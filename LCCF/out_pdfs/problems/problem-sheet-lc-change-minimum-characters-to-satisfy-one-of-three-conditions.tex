% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Change Minimum Characters to Satisfy One of Three Conditions}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given two strings ``a'' and ``b'' that consist of lowercase letters. In one operation, you can change any character in ``a'' or ``b'' to any lowercase letter.

Your goal is to satisfy one of the following three conditions:
\begin{bullets}
\item Every letter in ``a'' is strictly less than every letter in ``b'' in the alphabet.
\item Every letter in ``b'' is strictly less than every letter in ``a'' in the alphabet.
\item Both ``a'' and ``b'' consist of only one distinct letter.
\end{bullets}

Return the minimum number of operations needed to achieve your goal.

Example 1:

Input: a = ``aba'', b = ``caa''

Output: 2

Explanation: Consider the best way to make each condition true:
\begin{enumerate}[leftmargin=1.6em]
\item Change b to ``ccc'' in 2 operations, then every letter in a is less than every letter in b.
\item Change a to ``bbb'' and b to ``aaa'' in 3 operations, then every letter in b is less than every letter in a.
\item Change a to ``aaa'' and b to ``aaa'' in 2 operations, then a and b consist of one distinct letter.
\end{enumerate}
The best way was done in 2 operations (either condition 1 or condition 3).

Example 2:

Input: a = ``dabadd'', b = ``cda''

Output: 3

Explanation: The best way is to make condition 1 true by changing b to ``eee''.

Constraints:
\begin{bullets}
\item $1 \le |a|, |b| \le 10^5$.
\item ``a'' and ``b'' consist only of lowercase letters.
\end{bullets}}
\BREAKDOWN{Compute, over the alphabet, the cost to enforce each of the three conditions. Use frequency counts and prefix sums to evaluate costs quickly across all alphabet split points or target letters.}
\ELI{Count letters and try every split between letters or a common target letter; pick the cheapest plan.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two strings $a$, $b$ of lowercase English letters; on LeetCode, implement \texttt{minCharacters(self, a: str, b: str) -> int}. Valid sizes: $1 \le |a|, |b| \le 10^5$.}
\OUTPUTS{An integer: the minimum number of character changes needed so that one of the three conditions is satisfied.}
\SAMPLES{
Example 1: $a=\text{``aba''}$, $b=\text{``caa''}$ $\to 2$.

Example 2: $a=\text{``dabadd''}$, $b=\text{``cda''}$ $\to 3$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Map letters $\{a,\ldots,z\}$ to $\{0,\ldots,25\}$. Let $c_A[i]$ and $c_B[i]$ be the frequency of letter $i$ in $a$ and $b$. Let $n=|a|$, $m=|b|$.}
\varmapStart
\var{c_A[i]}{count of letter $i$ in $a$}
\var{c_B[i]}{count of letter $i$ in $b$}
\var{P_A[i]}{prefix sums $\sum_{k=0}^{i} c_A[k]$}
\var{P_B[i]}{prefix sums $\sum_{k=0}^{i} c_B[k]$}
\var{t}{alphabet split index, $0 \le t \le 24$}
\var{u}{target single letter for both strings, $0 \le u \le 25$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Cond1}(t) &= (n - P_A[t]) + P_B[t], \quad 0 \le t \le 24, \\
\text{Cond2}(t) &= (m - P_B[t]) + P_A[t], \quad 0 \le t \le 24, \\
\text{Cond3}(u) &= (n - c_A[u]) + (m - c_B[u]), \quad 0 \le u \le 25, \\
\text{Answer} &= \min\Big( \min_{t} \text{Cond1}(t),\ \min_{t} \text{Cond2}(t),\ \min_{u} \text{Cond3}(u) \Big).
\end{aligned}
\]
}
\ASSUMPTIONS{Alphabet size is 26. Strict inequality means maximum letter in $a$ is strictly less than minimum letter in $b$ (or vice versa) after edits. Edits can change any character to any letter.}
\INVARIANTS{
\begin{bullets}
\item For a fixed split $t$, the minimal edits for $a$ are exactly the letters $>t$; for $b$ are exactly the letters $\le t$.
\item For a fixed target $u$, the minimal edits are all non-$u$ letters in both strings.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly try every split $t$ for conditions 1 and 2, counting changes by scanning strings each time; and try every target letter $u$ for condition 3 by scanning.}
\ASSUMPTIONS{Alphabet size is constant (26), so trying all splits/targets is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $t \in [0,24]$, compute $\text{Cond1}(t)$ by counting letters in $a$ greater than $t$ and letters in $b$ less or equal to $t$ by scanning both strings.
\item For each $t \in [0,24]$, compute $\text{Cond2}(t)$ analogously (swap $a$ and $b$).
\item For each $u \in [0,25]$, compute $\text{Cond3}(u)$ by counting non-$u$ letters in $a$ and $b$.
\item Return the minimum of all computed costs.
\end{algosteps}
\COMPLEXITY{For each of $O(26)$ candidates we scan $O(n+m)$ characters.}
\[
\begin{aligned}
T(n) &= O\big(26\cdot(n+m)\big) = O(n+m), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{For fixed $t$, any letter in $a$ that is already $\le t$ need not change; any letter $> t$ must change to some $\le t$. Similarly, any letter in $b$ that is $\le t$ must change to some $\ge t+1$. Counting these is optimal per split. For condition 3, making both strings a single letter $u$ costs exactly the number of non-$u$ letters. Minimizing over all $t$ and $u$ yields the global minimum.}
\EDGECASES{Single-character strings; all letters identical; all letters at extremes (all 'a' or all 'z'); highly unbalanced lengths.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        n, m = len(a), len(b)

        def cost_cond1(t: int) -> int:
            # all a < all b => max(a) <= t < min(b)
            ca = sum(1 for ch in a if ord(ch) - 97 > t)
            cb = sum(1 for ch in b if ord(ch) - 97 <= t)
            return ca + cb

        def cost_cond2(t: int) -> int:
            # all b < all a => max(b) <= t < min(a)
            cb = sum(1 for ch in b if ord(ch) - 97 > t)
            ca = sum(1 for ch in a if ord(ch) - 97 <= t)
            return ca + cb

        def cost_cond3(u: int) -> int:
            ca = sum(1 for ch in a if ord(ch) - 97 != u)
            cb = sum(1 for ch in b if ord(ch) - 97 != u)
            return ca + cb

        ans = n + m
        for t in range(25):
            ans = min(ans, cost_cond1(t), cost_cond2(t))
        for u in range(26):
            ans = min(ans, cost_cond3(u))
        return ans

# Basic asserts (LC-style)
sol = Solution()
assert sol.minCharacters("aba", "caa") == 2
assert sol.minCharacters("dabadd", "cda") == 3
# Extra tiny checks
assert sol.minCharacters("a", "z") == 0  # already a < z
\end{minted}
\VALIDATION{Checked samples and a trivial case already satisfying condition 1.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Precompute frequency arrays and prefix sums once, then evaluate each candidate split/target in $O(1)$, avoiding repeated scans.}
\ASSUMPTIONS{Prefix sums over a constant alphabet yield $O(1)$ per candidate and improve constants in practice.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build counts $c_A[26]$ and $c_B[26]$.
\item Build prefix sums $P_A$ and $P_B$ where $P_X[i]=\sum_{k=0}^i c_X[k]$.
\item Evaluate $\text{Cond1}(t)$, $\text{Cond2}(t)$ for $t=0,\ldots,24$ and $\text{Cond3}(u)$ for $u=0,\ldots,25$ using the governing equations.
\item Return the minimum.
\end{algosteps}
\COMPLEXITY{One pass to count, one pass to prefix, constant work per candidate.}
\[
\begin{aligned}
T(n) &= O(n+m+26), \\
S(n) &= O(26).
\end{aligned}
\]
\CORRECTNESS{Directly follows from the equations derived in the model; prefix sums give exact counts of letters $\le t$ and $>t$ for each split.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        n, m = len(a), len(b)
        ca = [0]*26
        cb = [0]*26
        for ch in a:
            ca[ord(ch)-97] += 1
        for ch in b:
            cb[ord(ch)-97] += 1

        pa = [0]*26
        pb = [0]*26
        s = 0
        for i in range(26):
            s += ca[i]
            pa[i] = s
        s = 0
        for i in range(26):
            s += cb[i]
            pb[i] = s

        ans = n + m
        # Conditions 1 and 2: splits t in [0..24]
        for t in range(25):
            # Cond1: all a <= t, all b >= t+1
            cost1 = (n - pa[t]) + pb[t]
            # Cond2: all b <= t, all a >= t+1
            cost2 = (m - pb[t]) + pa[t]
            if cost1 < ans:
                ans = cost1
            if cost2 < ans:
                ans = cost2

        # Condition 3: both become single letter u
        for u in range(26):
            cost3 = (n - ca[u]) + (m - cb[u])
            if cost3 < ans:
                ans = cost3

        return ans

# Asserts (same behavior as baseline)
sol = Solution()
assert sol.minCharacters("aba", "caa") == 2
assert sol.minCharacters("dabadd", "cda") == 3
assert sol.minCharacters("a", "z") == 0
\end{minted}
\VALIDATION{Verified on samples and a trivial already-satisfied case; identical outputs to baseline on manual checks.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the frequency and prefix-sum formulation. This is optimal because each of the three conditions decomposes into independent per-character changes, and we try all constant-many split/target choices.}
\ASSUMPTIONS{Alphabet is fixed size; the optimal solution must correspond to some split $t$ or single target $u$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count $c_A$, $c_B$, then compute $P_A$, $P_B$.
\item Compute costs for all $t \in [0,24]$ and $u \in [0,25]$ via the closed forms.
\item Return the global minimum.
\end{algosteps}
\OPTIMALITY{Lower bound: any feasible solution for a split must change at least all offending letters ($>t$ in $a$, $\le t$ in $b$), which our formula matches; similarly for the reverse split and the single-letter target. Exhaustively minimizing over all $t$ and $u$ is therefore tight.}
\COMPLEXITY{$O(n+m+26)$ time and $O(26)$ space, which is asymptotically optimal up to constant factors because we must read all input.}
\[
\begin{aligned}
T(n) &= \Theta(n+m),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        n, m = len(a), len(b)
        ca = [0]*26
        cb = [0]*26
        for ch in a:
            ca[ord(ch)-97] += 1
        for ch in b:
            cb[ord(ch)-97] += 1

        pa = [0]*26
        pb = [0]*26
        acc = 0
        for i in range(26):
            acc += ca[i]
            pa[i] = acc
        acc = 0
        for i in range(26):
            acc += cb[i]
            pb[i] = acc

        ans = n + m
        for t in range(25):
            ans = min(ans, (n - pa[t]) + pb[t])  # a < b
            ans = min(ans, (m - pb[t]) + pa[t])  # b < a
        for u in range(26):
            ans = min(ans, (n - ca[u]) + (m - cb[u]))  # both same letter
        return ans

# Exactly 3 asserts (samples + one custom)
sol = Solution()
assert sol.minCharacters("aba", "caa") == 2
assert sol.minCharacters("dabadd", "cda") == 3
assert sol.minCharacters("zz", "aa") == 0  # already b < a
\end{minted}
\VALIDATION{Three asserts: both official samples and a case already satisfying condition 2.}
\RESULT{Returns the minimal number of edits across the three conditions; if multiple conditions tie, any minimum is acceptable since only the count is returned.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the function on samples, trivial extremes, and random small strings; compare multiple implementations for consistency.}
\LINE{CROSS-CHECKS}{Compare outputs of baseline-style scanning and prefix-sum implementations on many random cases to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate strings of length 1, all-same letters, and mixed extremes to stress split points at $t=0$ and $t=24$.}
\begin{minted}{python}
import random
from typing import Tuple

def baseline(a: str, b: str) -> int:
    n, m = len(a), len(b)

    def cost1(t: int) -> int:
        return sum(1 for ch in a if ord(ch)-97 > t) + sum(1 for ch in b if ord(ch)-97 <= t)

    def cost2(t: int) -> int:
        return sum(1 for ch in b if ord(ch)-97 > t) + sum(1 for ch in a if ord(ch)-97 <= t)

    def cost3(u: int) -> int:
        return sum(1 for ch in a if ord(ch)-97 != u) + sum(1 for ch in b if ord(ch)-97 != u)

    ans = n + m
    for t in range(25):
        ans = min(ans, cost1(t), cost2(t))
    for u in range(26):
        ans = min(ans, cost3(u))
    return ans

def prefix(a: str, b: str) -> int:
    n, m = len(a), len(b)
    ca = [0]*26
    cb = [0]*26
    for ch in a: ca[ord(ch)-97] += 1
    for ch in b: cb[ord(ch)-97] += 1
    pa = [0]*26
    pb = [0]*26
    s = 0
    for i in range(26):
        s += ca[i]; pa[i] = s
    s = 0
    for i in range(26):
        s += cb[i]; pb[i] = s
    ans = n + m
    for t in range(25):
        ans = min(ans, (n - pa[t]) + pb[t], (m - pb[t]) + pa[t])
    for u in range(26):
        ans = min(ans, (n - ca[u]) + (m - cb[u]))
    return ans

def rand_str(L: int) -> str:
    return "".join(chr(97 + random.randint(0,25)) for _ in range(L))

def run_cross_checks():
    random.seed(2025)
    # Samples and basics
    assert prefix("aba", "caa") == 2
    assert prefix("dabadd", "cda") == 3
    assert prefix("a", "z") == 0
    assert prefix("zz", "aa") == 0
    # Random cross-checks
    for _ in range(300):
        n = random.randint(1, 15)
        m = random.randint(1, 15)
        a = rand_str(n)
        b = rand_str(m)
        ba = baseline(a, b)
        pr = prefix(a, b)
        assert ba == pr, (a, b, ba, pr)

if __name__ == "__main__":
    run_cross_checks()
    print("All tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        n, m = len(a), len(b)
        ca = [0]*26
        cb = [0]*26
        for ch in a:
            ca[ord(ch)-97] += 1
        for ch in b:
            cb[ord(ch)-97] += 1

        pa = [0]*26
        pb = [0]*26
        s = 0
        for i in range(26):
            s += ca[i]
            pa[i] = s
        s = 0
        for i in range(26):
            s += cb[i]
            pb[i] = s

        ans = n + m
        for t in range(25):
            # Condition 1: all a < all b
            ans = min(ans, (n - pa[t]) + pb[t])
            # Condition 2: all b < all a
            ans = min(ans, (m - pb[t]) + pa[t])
        for u in range(26):
            # Condition 3: both a and b are the same letter u
            ans = min(ans, (n - ca[u]) + (m - cb[u]))
        return ans

# Simple sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.minCharacters("aba", "caa") == 2
    assert sol.minCharacters("dabadd", "cda") == 3
    assert sol.minCharacters("a", "a") == 0
    print("Reference solution OK.")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize edits to satisfy one of: $a$'s letters all less than $b$'s, or vice versa, or both strings become a single repeated letter.}
\WHY{Tests counting, prefix sums, and reasoning about strict inequalities across partitions of a fixed-size alphabet.}
\CHECKLIST{
\begin{bullets}
\item Build frequency arrays for $a$ and $b$.
\item Build prefix sums to get counts $\le t$ and $> t$ quickly.
\item Enumerate $t=0,\ldots,24$ for the two inequality conditions.
\item Enumerate $u=0,\ldots,25$ for the single-letter condition.
\item Take the global minimum.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $|a|=1$ or $|b|=1$.
\item All letters already satisfy $a<b$ or $b<a$ (answer $0$).
\item Both strings already single-letter and equal (answer $0$).
\item Highly skewed counts (e.g., many 'z' vs. many 'a').
\item Splits near ends: $t=0$ or $t=24$.
\item Very unbalanced lengths between $a$ and $b$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one on the split: $a \le t$ and $b \ge t+1$ enforces strict inequality.
\item Forgetting to try all $t$ up to $24$ (not $25$).
\item Miscomputing prefix sums or using them for the wrong string.
\item Mixing up condition 1 vs. condition 2 formulas.
\item Not handling both strings same-letter condition.
\item Assuming ASCII beyond lowercase; inputs are guaranteed lowercase only.
\end{bullets}}
\FAILMODES{A naive attempt to force concrete target letters for $a$ and $b$ (e.g., both to 'a' or 'z') can miss cheaper mixed edits. Enumerating all splits and the single-letter target guarantees the optimal.}
\ELI{Try every cut in the alphabet that would separate $a$ and $b$, and count how many letters violate that cut. Also try making both strings a single letter. Pick whichever costs the least changes.}
\NotePages{3}

\end{document}