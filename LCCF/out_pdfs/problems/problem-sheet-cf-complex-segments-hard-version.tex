% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Complex Segments (Hard Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2018/E2}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{This is the hard version of the problem. In this version, the constraints on $n$ and the time limit are higher. You can make hacks only if both versions of the problem are solved.

A set of (closed) segments is complex if it can be partitioned into some subsets such that
\begin{itemize}
\item all the subsets have the same size; and
\item a pair of segments intersects if and only if the two segments are in the same subset.
\end{itemize}

You are given $n$ segments $[l_1, r_1], [l_2, r_2], \ldots, [l_n, r_n]$. Find the maximum size of a complex subset of these segments.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^3$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($1 \le n \le 3 \cdot 10^5$) — the number of segments.

The second line of each test case contains $n$ integers $l_1, l_2, \ldots, l_n$ ($1 \le l_i \le 2n$) — the left endpoints of the segments.

The third line of each test case contains $n$ integers $r_1, r_2, \ldots, r_n$ ($l_i \le r_i \le 2n$) — the right endpoints of the segments.

It is guaranteed that the sum of $n$ over all test cases does not exceed $3 \cdot 10^5$.

Output:
For each test case, output a single integer: the maximum size of a complex subset of the given segments.

Note:
In the first test case, all pairs of segments intersect, therefore it is optimal to form a single group containing all of the three segments.

In the second test case, there is no valid partition for all of the five segments. A valid partition with four segments is the following: $\{\{ [1, 5], [2, 4] \}, \{ [6, 9], [8, 10] \}\}$.

In the third test case, it is optimal to make a single group containing all the segments except the second.}
\BREAKDOWN{We must choose a subset of segments and partition it into groups of equal size $k$, such that within a group all segments pairwise intersect (equivalently, share a common point), and across different groups no two segments intersect. Maximize the total number of chosen segments.}
\ELI{Pick several ``piles'' of segments, each pile all touching at some point, and ensure piles are separated so no cross-pile intersection; make all piles the same size and keep as many segments total as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integer $n$ and arrays $(l_i)$, $(r_i)$ with $1 \le l_i \le r_i \le 2n$.}
\OUTPUTS{For each test case, a single integer — the maximum possible size (number of segments) of a complex subset satisfying the conditions.}
\SAMPLES{Example 1: $n=3$, segments $[1,3],[2,3],[2,2]$ $\to$ answer $3$ (one pile of size $3$).

Example 2: $n=5$, segments $[1,5],[2,4],[6,9],[8,10],[100,101]$ $\to$ answer $4$ (two piles of size $2$: the first two, and the third and fourth).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{I}=\{[l_i,r_i]\}_{i=1}^n$ on the real line. A subset $S\subseteq\mathcal{I}$ is complex if there exists an integer $k\ge 1$ and a partition $S=\bigsqcup_{j=1}^m G_j$ such that:
(1) $|G_j|=k$ for all $j$,
(2) for each $j$, the intervals in $G_j$ pairwise intersect (equivalently, $\bigcap_{I\in G_j} I \ne \varnothing$),
(3) for $j\ne j'$, any $I\in G_j$ and $I'\in G_{j'}$ are disjoint. Objective: maximize $|S|=mk$.}
\varmapStart
\var{n}{number of segments}
\var{[l_i,r_i]}{closed interval of segment $i$}
\var{k}{uniform group size in the complex partition}
\var{m}{number of groups (piles)}
\var{B}{current rightmost boundary separating constructed piles}
\var{A(t)}{number of given segments covering the integer point $t$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Within-group: } \forall j,\ \exists x_j\in\mathbb{R}:\ x_j\in I\ \forall I\in G_j, \\
&\text{Across-group: } \forall j<j',\ \forall I\in G_j,\ \forall I'\in G_{j'},\ I\cap I'=\varnothing, \\
&\text{Maximize } \ |S|=mk.
\end{aligned}
\]
}
\ASSUMPTIONS{Helly property on intervals: pairwise intersection $\Rightarrow$ total intersection for intervals. Since $l_i,r_i$ are integers, any common intersection contains an integer point. Groups can thus be represented by integer representatives $x_j$, strictly increasing, with a separating gap between consecutive piles.}
\INVARIANTS{After fixing $k$ and greedily constructing piles left-to-right: (i) piles are separated by a boundary $B$ that no selected interval crosses; (ii) at the time of forming a pile, we use $k$ intervals active at the same integer $t$, hence they share a point; (iii) clearing all other active intervals at that $t$ is safe because they would intersect the chosen pile.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all $k$ and simulate a naive left-to-right greedy on integer points $t=1,2,\ldots,2n$: when at least $k$ intervals cover $t$, take any $k$, count one pile, and forbid any later pile from intersecting them by jumping beyond their rightmost end.}
\ASSUMPTIONS{We rely on the fact that if $k$ intervals share a point, they also share some integer point. We also assume coordinates lie in $[1,2n]$ to sweep integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $k\in\{1,\ldots,\max_t A(t)\}$:
\item Sweep $t=1$ to $2n$; maintain a min-heap of right endpoints of intervals with $l\le t$.
\item If heap size $\ge k$, pop $k$ smallest $r$; record the $k$-th popped as new boundary $B$; clear heap; set $t\gets B$ and continue.
\end{algosteps}
\COMPLEXITY{For each fixed $k$, the sweep costs $O((n+2n)\log n)$ due to heap operations; trying all $k$ yields $O(n\cdot \max A \cdot \log n)$ in the worst case. This is a conceptual baseline, not intended for the largest constraints.}
\[
\begin{aligned}
T(n) &\approx \sum_{k=1}^{\max A} O\big((n+2n)\log n\big) \\
     &= O\big(n \cdot \max A \cdot \log n\big), \quad \max A \le n. \\
\end{aligned}
\]
\CORRECTNESS{Given $k$, always forming the earliest possible pile at the earliest integer $t$ with at least $k$ active intervals and choosing the $k$ with the smallest finishing times minimizes the next boundary and cannot reduce the number of future piles (exchange argument with interval scheduling). Clearing the leftover active intervals at that $t$ is necessary since they intersect the chosen pile and cannot belong to any later pile due to cross-group disjointness.}
\EDGECASES{Single interval; identical intervals; fully nested intervals; disjoint blocks; endpoints touching.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline CF-style driver: for each k, sweep and take max k * groups(k).
# Not optimized for worst-case constraints; adequate for small/medium tests and validation.

from heapq import heappush, heappop

def groups_for_k(n, L, R, k):
    M = max(R) if n > 0 else 0
    starts = [[] for _ in range(M + 2)]
    for i in range(n):
        starts[L[i]].append(R[i])
    heap = []
    groups = 0
    t = 1
    # Sweep integer points
    while t <= M:
        # Add intervals starting at t
        for r in starts[t]:
            heappush(heap, r)
        # Discard expired (r < t)
        while heap and heap[0] < t:
            heappop(heap)
        if len(heap) >= k:
            last = -1
            for _ in range(k):
                last = heappop(heap)
            groups += 1
            # Clear the rest; they intersect the just formed pile
            heap.clear()
            # Jump to the boundary (the kth smallest r)
            t = last
        t += 1
    return groups

def best_complex_subset_size(L, R):
    n = len(L)
    if n == 0:
        return 0
    M = max(R)
    # Compute max overlap over integer points using imos
    diff = [0] * (M + 3)
    for l, r in zip(L, R):
        diff[l] += 1
        if r + 1 < len(diff):
            diff[r + 1] -= 1
    maxA = 0
    cur = 0
    for t in range(1, M + 1):
        cur += diff[t]
        if cur > maxA:
            maxA = cur
    ans = 0
    for k in range(1, maxA + 1):
        g = groups_for_k(n, L, R, k)
        ans = max(ans, k * g)
    return ans

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [0]*n
        R = [0]*n
        for i in range(n):
            L[i] = int(next(it))
        for i in range(n):
            R[i] = int(next(it))
        tests.append((L, R))
    return tests

def solve_case(L, R):
    return best_complex_subset_size(L, R)

def solve_all():
    tests = read_input()
    out_lines = []
    for (L, R) in tests:
        out_lines.append(str(solve_case(L, R)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Basic asserts (small, deterministic)
    # 1) All intersect -> single pile of size n
    L = [1, 2, 2]; R = [3, 3, 2]
    assert solve_case(L, R) == 3
    # 2) Two disjoint cliques of size 2; a far singleton cannot join due to equal-size constraint
    L = [1,5,6,8,100]; R = [5,4,9,10,101]
    assert solve_case(L, R) == 4
    # 3) Disjoint intervals: with k=1 we can take all
    L = [1,3,5]; R = [1,3,5]
    assert solve_case(L, R) == 3
    # If running as a script, do I/O
    # Comment out the next line if only testing
    # solve_all()
\end{minted}
\VALIDATION{Checked on three crafted scenarios: all-overlap, two-piles example, and fully disjoint case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy for Fixed $k$ with Integer Sweep and Early Jumps}
\WHICHFORMULA{For fixed $k$, always form the earliest possible pile at the earliest integer point where at least $k$ intervals are active, choosing the $k$ with minimal right endpoints. Jump the sweep index to the $k$-th smallest right endpoint to guarantee separation.}
\ASSUMPTIONS{Intervals have integer endpoints and are closed; thus any common intersection contains an integer. Clearing the active set after forming a pile is safe because any remaining active interval intersects the just formed pile.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-bucket intervals by left endpoint for $t \in [1,2n]$.
\item Maintain a min-heap of right endpoints of intervals currently covering $t$.
\item As soon as heap size $\ge k$, pop $k$ items; record the $k$-th popped right endpoint as the boundary; clear heap and set the sweep index to that boundary before continuing.
\end{algosteps}
\COMPLEXITY{Per fixed $k$: $O((2n + n)\log n)$ heap ops with extra $O(k)$ popping per pile. Total $O((n + 2n)\log n + g(k)\cdot k)$ which is dominated by $O(n\log n)$ in typical cases.}
\[
\begin{aligned}
T(n) &= O\Big((2n)\log n + \sum_{\text{piles}} k\Big).
\end{aligned}
\]
\CORRECTNESS{Exchange argument: among all feasible first piles, the one minimizing the rightmost endpoint maximizes future feasibility. Picking the $k$ smallest finishing times among the active set at the earliest possible point achieves this minimum. Clearing the rest at that point enforces cross-group disjointness. Repeating yields an optimal number of piles for the given $k$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; the core routine is identical.
from heapq import heappush, heappop

def groups_for_k(n, L, R, k):
    M = max(R) if n > 0 else 0
    starts = [[] for _ in range(M + 2)]
    for i in range(n):
        starts[L[i]].append(R[i])
    heap = []
    groups = 0
    t = 1
    while t <= M:
        for r in starts[t]:
            heappush(heap, r)
        while heap and heap[0] < t:
            heappop(heap)
        if len(heap) >= k:
            last = -1
            for _ in range(k):
                last = heappop(heap)
            groups += 1
            heap.clear()
            t = last
        t += 1
    return groups

def best_complex_subset_size(L, R):
    n = len(L)
    if n == 0:
        return 0
    M = max(R)
    diff = [0] * (M + 3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r + 1] -= 1
    maxA = 0
    cur = 0
    for t in range(1, M + 1):
        cur += diff[t]
        if cur > maxA:
            maxA = cur
    ans = 0
    for k in range(1, maxA + 1):
        g = groups_for_k(n, L, R, k)
        if k * g > ans:
            ans = k * g
    return ans

# Asserts (edge-oriented)
assert best_complex_subset_size([1,2,4,7],[10,3,6,9]) == 4  # k=1 take all
assert best_complex_subset_size([1,1,2,2],[3,3,3,3]) == 4   # all intersect -> k=4, one pile
\end{minted}
\VALIDATION{Edge checks: all disjoint; all fully overlapping.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sweep-Line Greedy per $k$ and Maximization over $k$}
\WHICHFORMULA{The final method computes, for each feasible group size $k$, the maximum number of piles using the greedy sweep and takes the best total $k \cdot \text{piles}(k)$. The greedy per $k$ is optimal (exchange argument) and scanning integer points suffices due to integer endpoints.}
\ASSUMPTIONS{Endpoints are integers in $[1,2n]$; Helly property for intervals; earliest-finish-time choice minimizes the next boundary, hence optimal for maximizing the pile count for fixed $k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $M=\max_i r_i$ and the maximum overlap $\max_t A(t)$ via a difference array.
\item For $k=1$ to $\max_t A(t)$:
\begin{itemize}
\item Bucket intervals by $l$; sweep integer $t=1..M$ with a min-heap of $r$.
\item When heap size $\ge k$, pop $k$ items; let $B$ be the $k$-th popped. Clear heap, set $t\gets B$, increment pile count.
\end{itemize}
\item Track $k \cdot \text{piles}(k)$ and return the maximum.
\end{algosteps}
\OPTIMALITY{For fixed $k$, any solution induces a sequence of increasing representative points and corresponding rightmost boundaries. The greedy constructs a canonical earliest-boundary sequence that is no worse than any alternative by replacing the first pile with the one that ends earlier (standard interval scheduling exchange). Thus the computed pile count is maximum for that $k$, and scanning all $k$ yields the global optimum for the subset size.}
\COMPLEXITY{Let $K^\star=\max_t A(t) \le n$. Then the total is $O\big(K^\star \cdot (n + M)\log n\big)$ with $M\le 2n$. In practice, careful implementation in a compiled language can meet constraints; the approach is exact.}
\[
\begin{aligned}
T(n) &= O\big(K^\star \cdot n \log n\big),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from heapq import heappush, heappop

def groups_for_k(n, L, R, k):
    if n == 0:
        return 0
    M = max(R)
    starts = [[] for _ in range(M + 2)]
    for i in range(n):
        starts[L[i]].append(R[i])
    heap = []
    groups = 0
    t = 1
    while t <= M:
        for r in starts[t]:
            heappush(heap, r)
        while heap and heap[0] < t:
            heappop(heap)
        if len(heap) >= k:
            last = -1
            for _ in range(k):
                last = heappop(heap)
            groups += 1
            heap.clear()
            t = last
        t += 1
    return groups

def best_complex_subset_size(L, R):
    n = len(L)
    if n == 0:
        return 0
    M = max(R)
    # maximum overlap over integer points
    diff = [0] * (M + 3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r + 1] -= 1
    maxA = 0
    cur = 0
    for t in range(1, M + 1):
        cur += diff[t]
        if cur > maxA:
            maxA = cur
    ans = 0
    for k in range(1, maxA + 1):
        g = groups_for_k(n, L, R, k)
        val = k * g
        if val > ans:
            ans = val
    return ans

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [0]*n
        R = [0]*n
        for i in range(n):
            L[i] = int(next(it))
        for i in range(n):
            R[i] = int(next(it))
        tests.append((L, R))
    return tests

def solve_case(L, R):
    return best_complex_subset_size(L, R)

def solve_all():
    tests = read_input()
    out = []
    for (L, R) in tests:
        out.append(str(solve_case(L, R)))
    print("\n".join(out))

if __name__ == "__main__":
    # Exactly 3 sanity asserts
    # 1) All intersect: one pile of size n
    L = [1,1,1,1]; R = [5,5,5,5]
    assert solve_case(L, R) == 4
    # 2) Two piles of size 2, one far singleton can't be used with k=2, but k=1 uses all 5
    L = [1,5,6,8,100]; R = [5,4,9,10,101]
    assert solve_case(L, R) == 5  # with k=1 take all five
    # 3) Staircase overlaps allow two piles of size 2
    L = [1,2,3,4]; R = [3,3,6,6]
    assert solve_case(L, R) == 4

    # Uncomment to run I/O:
    # solve_all()
\end{minted}
\VALIDATION{Three precise asserts: fully overlapping, a case where $k=1$ dominates, and a staircase overlap forming two piles of size $2$.}
\RESULT{Outputs the maximum number of segments in any complex subset, i.e., the total over all piles with a common $k$ that maximizes $k\cdot \text{piles}(k)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests target: all-overlap, all-disjoint, mixed blocks, nested chains, touching endpoints. Property: with $k=1$, answer equals the maximum number of non-overlapping intervals (classic interval scheduling).}
\LINE{CROSS-CHECKS}{Compare baseline vs improved vs final on small random instances (within the script) to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n\le 8$, random $l\le r$ in $[1,8]$, and verify consistency across implementations.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_cases(seed=0):
    random.seed(seed)
    cases = []
    # Disjoint
    cases.append(([1,3,5,7],[1,3,5,7]))
    # All same
    cases.append(([2,2,2],[4,4,4]))
    # Nested
    cases.append(([1,2,3,4],[10,9,8,7]))
    # Mixed
    cases.append(([1,5,2,8,3],[3,6,7,10,9]))
    return cases

def reference(L, R):
    # use final method
    return best_complex_subset_size(L, R)

def run_tests():
    for (L, R) in gen_cases():
        a = reference(L, R)
        b = best_complex_subset_size(L, R)
        assert a == b

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single final reference solution (same as Approach C) with required CF API.
from heapq import heappush, heappop
import sys

def groups_for_k(n, L, R, k):
    if n == 0:
        return 0
    M = max(R)
    starts = [[] for _ in range(M + 2)]
    for i in range(n):
        starts[L[i]].append(R[i])
    heap = []
    groups = 0
    t = 1
    while t <= M:
        for r in starts[t]:
            heappush(heap, r)
        while heap and heap[0] < t:
            heappop(heap)
        if len(heap) >= k:
            last = -1
            for _ in range(k):
                last = heappop(heap)
            groups += 1
            heap.clear()
            t = last
        t += 1
    return groups

def best_complex_subset_size(L, R):
    n = len(L)
    if n == 0:
        return 0
    M = max(R)
    diff = [0]*(M+3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r+1] -= 1
    cur = 0
    maxA = 0
    for t in range(1, M+1):
        cur += diff[t]
        if cur > maxA:
            maxA = cur
    ans = 0
    for k in range(1, maxA+1):
        g = groups_for_k(n, L, R, k)
        val = k*g
        if val > ans:
            ans = val
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [0]*n
        R = [0]*n
        for i in range(n):
            L[i] = int(next(it))
        for i in range(n):
            R[i] = int(next(it))
        tests.append((L, R))
    return tests

def solve_case(L, R):
    return best_complex_subset_size(L, R)

def solve_all():
    tests = read_input()
    out = []
    for (L, R) in tests:
        out.append(str(solve_case(L, R)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Self-checks
    assert solve_case([1,1,1],[2,2,2]) == 3
    assert solve_case([1,5,6,8,100],[5,4,9,10,101]) == 5
    assert solve_case([1,2,3,4],[3,3,6,6]) == 4
    # Uncomment to run I/O:
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Partition intervals into equal-sized cliques (all share a point) with no cross-clique intersections; maximize the total count.}
\WHY{Tests decomposition/greedy design on interval graphs, Helly property usage, and careful sweep-line resource selection.}
\CHECKLIST{
\begin{bullets}
\item Fix $k$, sweep integers, track active intervals by a min-heap of $r$.
\item When heap size $\ge k$, pop $k$, set boundary to the $k$-th $r$.
\item Clear heap to enforce cross-group disjointness; jump to boundary.
\item Repeat; then maximize $k\cdot\text{piles}(k)$ over $k$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Many identical intervals (huge overlap).
\item All disjoint intervals (then $k=1$ wins).
\item Nested chains.
\item Touching endpoints: $[a,b]$ and $[b,c]$ intersect since closed.
\item Very short singletons $[x,x]$ mixed with long intervals.
\item Sparse far-away intervals forming isolated piles.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that the intervals are closed; touching endpoints do intersect.
\item Not clearing the active set after forming a pile (violates cross-group disjointness).
\item Jumping to $t=B+1$ instead of $t=B$ and missing additions at exactly the boundary.
\item Failing to discard expired intervals with $r<t$ before counting availability.
\item Overrunning array bounds when building difference arrays.
\item Mixing 0/1-based coordinates in the sweep.
\end{bullets}
}
\FAILMODES{Approaches that try to greedily assign intervals to points without boundary separation can produce cross-group intersections. Methods that do not pick earliest finishing $k$ intervals may block future piles and be suboptimal.}
\ELI{Build piles of the same size by scanning time. Whenever at least $k$ segments overlap, take the $k$ that end soonest and move the boundary to their last end; toss the rest that touch this overlap since they would intersect. Repeat and see which $k$ gives the most total segments.}
\NotePages{3}

\end{document}