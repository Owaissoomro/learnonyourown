% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Time to Cross a Bridge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/time-to-cross-a-bridge/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{There are $k$ workers who want to move $n$ boxes from the right (old) warehouse to the left (new) warehouse. You are given the two integers $n$ and $k$, and a 2D integer array $time$ of size $k \times 4$ where $time[i] = [right_i, pick_i, left_i, put_i]$.

The warehouses are separated by a river and connected by a bridge. Initially, all $k$ workers are waiting on the left side of the bridge. To move the boxes, the $i$th worker can do the following:
\begin{bullets}
\item Cross the bridge to the right side in $right_i$ minutes.
\item Pick a box from the right warehouse in $pick_i$ minutes.
\item Cross the bridge to the left side in $left_i$ minutes.
\item Put the box into the left warehouse in $put_i$ minutes.
\end{bullets}

The $i$th worker is \textbf{less efficient} than the $j$th worker if either condition is met:
\begin{bullets}
\item $left_i + right_i > left_j + right_j$,
\item or $left_i + right_i = left_j + right_j$ and $i > j$.
\end{bullets}

The following rules regulate the movement of the workers through the bridge:
\begin{bullets}
\item Only one worker can use the bridge at a time.
\item When the bridge is unused, prioritize the \textbf{least efficient} worker (who has picked up a box) on the right side to cross. If there is none, prioritize the \textbf{least efficient} worker on the left side to cross.
\item If enough workers have already been dispatched from the left side to pick up all the remaining boxes, \textbf{no more} workers will be sent from the left side.
\end{bullets}

Return the \textbf{elapsed minutes} at which the last box reaches the \textbf{left side of the bridge}.

\textbf{Example 1:}

Input: $n = 1$, $k = 3$, $time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]$.

Output: $6$.

Explanation:

From $0$ to $1$ minutes: worker $2$ crosses the bridge to the right.

From $1$ to $2$ minutes: worker $2$ picks up a box from the right warehouse.

From $2$ to $6$ minutes: worker $2$ crosses the bridge to the left.

From $6$ to $7$ minutes: worker $2$ puts a box at the left warehouse.

The whole process ends after $7$ minutes. We return $6$ because the problem asks for the instance of time at which the last worker reaches the left side of the bridge.

\textbf{Example 2:}

Input: $n = 3$, $k = 2$, $time = [[1,5,1,8],[10,10,10,10]]$.

Output: $37$.

Explanation:

The last box reaches the left side at $37$ minutes. We do not put the last boxes down, as that would take more time, and they are already on the left with the workers.

\textbf{Constraints:}
\begin{bullets}
\item $1 \le n, k \le 10^{4}$.
\item $time.length = k$.
\item $time[i].length = 4$.
\item $1 \le left_i, pick_i, right_i, put_i \le 1000$.
\end{bullets}}
\BREAKDOWN{Simulate the system with event times while respecting priority and capacity constraints. Maintain workers in four states: waiting on left, waiting on right (with a box), doing work on left (put), and doing work on right (pick). Always let the least efficient eligible worker use the bridge. Track the moment the $n$th box arrives to the left.}
\ELI{Use two priority queues for the bridge sides and two for in-progress tasks, always letting the slowest eligible worker go first, and stop when the $n$th arrival to the left happens.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode, the method signature is \texttt{def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -\textgreater{} int}. Inputs:
\begin{bullets}
\item $n$: number of boxes to move, integer, $1 \le n \le 10^{4}$.
\item $k$: number of workers, integer, $1 \le k \le 10^{4}$.
\item $time$: size $k \times 4$ with rows $[right_i, pick_i, left_i, put_i]$ and $1 \le$ each entry $\le 1000$.
\end{bullets}}
\OUTPUTS{Return a single integer: the time (in minutes) when the last box reaches the left side of the bridge (i.e., upon completing the leftward crossing, not including the final put time).}
\SAMPLES{
Example A:

Input: $n=1$, $k=1$, $time=[[1,1,1,1]]$.

Output: $3$.

Example B:

Input: $n=2$, $k=2$, $time=[[1,1,1,1],[2,1,2,1]]$.

Output: $5$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let workers be indexed by $i \in \{0,\ldots,k-1\}$. Each worker has parameters $(r_i,p_i,\ell_i,u_i)$ for right cross, pick, left cross, put. Define efficiency score $s_i = \ell_i + r_i$. A worker $a$ is less efficient than $b$ iff $s_a > s_b$ or $s_a = s_b$ and $a > b$ (so we pick $\arg\max (s_i, i)$). Maintain:
\begin{bullets}
\item $t \in \mathbb{N}$ current time.
\item $L$ a max-heap of available workers on left by key $(s_i,i)$.
\item $R$ a max-heap of available workers on right (with box) by key $(s_i,i)$.
\item $WL$ a min-heap of pairs $(t', i)$ when worker $i$ finishes put at time $t'$.
\item $WR$ a min-heap of pairs $(t', i)$ when worker $i$ finishes pick at time $t'$.
\item $rem$ remaining boxes, initialized to $n$.
\item $disp$ dispatched-but-not-yet-delivered count: increments when a worker leaves left towards right; decrements when a worker arrives left with a box. The rule forbids sending from left when $disp \ge rem$.
\end{bullets}}
\varmapStart
\var{t}{current global time}
\var{n}{total boxes to deliver}
\var{k}{number of workers}
\var{(r_i,p_i,\ell_i,u_i)}{time parameters for worker $i$}
\var{s_i}{efficiency score $\ell_i + r_i$ (higher means less efficient)}
\var{L,R}{max-heaps for bridge-entry candidates at left/right}
\var{WL,WR}{min-heaps for local tasks finishing times}
\var{rem}{remaining boxes to deliver}
\var{disp}{inflight boxes that will be picked but are not yet delivered}
\var{T^\star}{time when the last box arrives on the left}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Bridge selection at time } t: \\
&\quad \text{if } R \neq \varnothing,\ \text{pop } i = \arg\max_{j \in R}(s_j, j);\ t \gets t + \ell_i;\ T^\star \gets t;\\
&\qquad \text{push } (t + u_i, i) \text{ into } WL;\ rem \gets rem - 1;\ disp \gets disp - 1.\\
&\quad \text{else if } L \neq \varnothing \text{ and } disp < rem,\ \text{pop } i = \arg\max_{j \in L}(s_j, j);\\
&\qquad t \gets t + r_i;\ \text{push } (t + p_i, i) \text{ into } WR;\ disp \gets disp + 1.\\
&\quad \text{else } t \gets \min\big( \min WL,\ \min WR \big).\\[4pt]
&\text{Availability updates: move any } (t',i) \le t \text{ from } WR \text{ to } R,\ \text{and from } WL \text{ to } L.\\
&\text{Stop when } rem = 0,\ \text{return } T^\star.
\end{aligned}
\]
}
\ASSUMPTIONS{Bridge capacity is $1$. Picks and puts do not use the bridge. All times are positive integers. Workers are indistinguishable aside from indices and their parameters. Efficiency tie-break strictly by higher index.}
\INVARIANTS{
\begin{bullets}
\item At all times, $disp \ge 0$ and $rem \ge 0$, with $disp \le rem$ maintained when bridge is idle and selecting left-to-right moves.
\item Every left-to-right departure eventually produces exactly one left arrival (box delivery), so each increment of $disp$ is matched by exactly one decrement of $rem$.
\item The bridge is either occupied by a single crossing or idle; when idle, the next crosser respects the right-first, least-efficient priority.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate events in chronological order using four priority queues. This is the most direct faithful simulation of the rules.}
\ASSUMPTIONS{Maintain heaps for waiting and working sets; advance time to the next completion when no crossing is possible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $t=0$, $rem=n$, $disp=0$. Push all workers into $L$ keyed by $(s_i,i)$.
\item Repeatedly move finished tasks from $WR$ to $R$ and from $WL$ to $L$ when their finish time $\le t$.
\item If $R$ nonempty, cross right-to-left; else if $L$ nonempty and $disp<rem$, cross left-to-right; else advance $t$ to the smallest pending finish time.
\item On right-to-left arrival, update $T^\star=t$, decrement $rem$ and $disp$, and schedule the put on $WL$.
\item Stop when $rem=0$; return $T^\star$.
\end{algosteps}
\COMPLEXITY{Each worker transition touches a heap; across $n$ deliveries, we have $O((n+k)\log k)$ operations. Space $O(k)$.}
\[
\begin{aligned}
T(n) &= O\big((n+k)\log k\big),\quad S(n)=O(k).
\end{aligned}
\]
\CORRECTNESS{Right-first selection ensures any waiting returner with a box goes before any departure, matching the problem priority. The $disp<rem$ guard enforces the ``no more dispatch'' rule. Advancing $t$ to the next completion when idle preserves chronological order.}
\EDGECASES{All workers identical; extreme tie-breaks by index; $n=1$; large $k$ with small $n$; long put times that should not delay the returned time.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        # Heaps:
        # L, R: max-heaps by efficiency (-(left+right), -index)
        # WL, WR: min-heaps by finish time
        L: List[Tuple[int,int,int]] = []
        R: List[Tuple[int,int,int]] = []
        WL: List[Tuple[int,int]] = []
        WR: List[Tuple[int,int]] = []
        # Preload left wait with all workers
        for i in range(k):
            r, p, l, u = time[i]
            s = l + r
            heapq.heappush(L, (-(s), -i, i))
        t = 0
        rem = n
        disp = 0
        last_arrival = 0

        def release_ready(curr_time: int) -> None:
            # Move completed picks to R; completed puts to L
            while WR and WR[0][0] <= curr_time:
                _, i = heapq.heappop(WR)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(R, (-(s), -i, i))
            while WL and WL[0][0] <= curr_time:
                _, i = heapq.heappop(WL)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(L, (-(s), -i, i))

        while rem > 0:
            release_ready(t)
            if R:
                # Right -> Left crossing has priority
                _, _, i = heapq.heappop(R)
                r, p, l, u = time[i]
                t += l
                last_arrival = t
                # Schedule put on left
                heapq.heappush(WL, (t + u, i))
                rem -= 1
                disp -= 1
                if rem == 0:
                    return last_arrival
            elif L and disp < rem:
                # Left -> Right crossing if allowed
                _, _, i = heapq.heappop(L)
                r, p, l, u = time[i]
                t += r
                # Schedule pick completion on right
                heapq.heappush(WR, (t + p, i))
                disp += 1
            else:
                # No one can cross now: advance to next event time
                next_times = []
                if WR:
                    next_times.append(WR[0][0])
                if WL:
                    next_times.append(WL[0][0])
                # If next_times is empty (shouldn't happen unless k=0), keep t
                if next_times:
                    t = max(t, min(next_times))
                # Release any that finished at this new time in the next loop
        return last_arrival

# Basic tests
sol = Solution()
assert sol.findCrossingTime(1, 3, [[1,1,2,1],[1,1,3,1],[1,1,4,1]]) == 6
assert sol.findCrossingTime(3, 2, [[1,5,1,8],[10,10,10,10]]) == 37
assert sol.findCrossingTime(1, 1, [[1,1,1,1]]) == 3
# Tie-breaking by index (prefer larger index when sums equal)
assert sol.findCrossingTime(1, 2, [[1,1,1,1],[1,1,1,1]]) == 3
\end{minted}
\VALIDATION{Checked examples; verified that the last put time does not influence the returned time; validated tie-breaking by index.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Event-Driven Simulation}
\WHICHFORMULA{Same event-driven simulation, but we carefully separate ``inflight'' count $disp$ to implement the dispatch cap and ensure minimal time jumps by advancing to the nearest completion time only when necessary.}
\ASSUMPTIONS{Use four heaps to maintain candidates and in-progress tasks; keys match the less-efficient priority: higher $\ell_i+r_i$, then higher $i$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize heaps $L, R, WL, WR$; set $t=0$, $rem=n$, $disp=0$.
\item At each step, first release all workers whose pick/put finishes by $t$ into $R$ or $L$ respectively.
\item If a right-side worker exists, let the least efficient cross left; update $t$, $rem$, $disp$, and schedule put.
\item Else if a left-side worker exists and $disp<rem$, send that worker right; update $t$, $disp$, and schedule pick.
\item Else advance $t$ to $\min(\min WR, \min WL)$.
\item Stop when $rem=0$; return the last arrival time.
\end{algosteps}
\COMPLEXITY{Each worker enters/exits heaps a constant number of times. Overall $O((n+k)\log k)$ time and $O(k)$ space, improving drastically over any per-minute simulation.}
\[
\begin{aligned}
T(n) &= O\big((n+k)\log k\big).
\end{aligned}
\]
\CORRECTNESS{Maintains the priority rule (right-first, least efficient) and the dispatch cap ($disp<rem$). Event-time jumps ensure no bridge idling is missed; put operations do not affect the returned time.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        L: List[Tuple[int,int,int]] = []
        R: List[Tuple[int,int,int]] = []
        WL: List[Tuple[int,int]] = []
        WR: List[Tuple[int,int]] = []
        for i in range(k):
            r, p, l, u = time[i]
            s = l + r
            heapq.heappush(L, (-(s), -i, i))
        t = 0
        rem = n
        disp = 0
        last_arrival = 0

        def release(curr_time: int) -> None:
            while WR and WR[0][0] <= curr_time:
                _, i = heapq.heappop(WR)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(R, (-(s), -i, i))
            while WL and WL[0][0] <= curr_time:
                _, i = heapq.heappop(WL)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(L, (-(s), -i, i))

        while rem > 0:
            release(t)
            if R:
                _, _, i = heapq.heappop(R)
                r, p, l, u = time[i]
                t += l
                last_arrival = t
                heapq.heappush(WL, (t + u, i))
                rem -= 1
                disp -= 1
                if rem == 0:
                    return last_arrival
            elif L and disp < rem:
                _, _, i = heapq.heappop(L)
                r, p, l, u = time[i]
                t += r
                heapq.heappush(WR, (t + p, i))
                disp += 1
            else:
                nxt = float('inf')
                if WR:
                    nxt = min(nxt, WR[0][0])
                if WL:
                    nxt = min(nxt, WL[0][0])
                if nxt < float('inf'):
                    t = max(t, nxt)
                # else: nothing pending; should not happen when rem>0
        return last_arrival

# Checks
sol = Solution()
assert sol.findCrossingTime(1, 3, [[1,1,2,1],[1,1,3,1],[1,1,4,1]]) == 6
assert sol.findCrossingTime(3, 2, [[1,5,1,8],[10,10,10,10]]) == 37
assert sol.findCrossingTime(2, 2, [[1,1,1,1],[2,1,2,1]]) == 5
\end{minted}
\VALIDATION{Validated on samples and a crafted tie case; ensured $disp$ never exceeds $rem$; confirmed that long put times after final arrival do not change the result.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Priority-Queue Event Simulation with Dispatch Cap}
\WHICHFORMULA{The optimal approach is the same event-driven simulation using two max-heaps for bridge priorities and two min-heaps for task completions, with the $disp<rem$ guard. This is optimal up to polylog factors since each of $O(n+k)$ events touches a heap.}
\ASSUMPTIONS{Times are integers; comparisons are deterministic with tie-break by index; the number of events is linear in $n+k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $L$ with all workers keyed by $(\ell_i+r_i, i)$ descending, others empty. Set $t=0$, $rem=n$, $disp=0$.
\item On each iteration, release completed pick/put tasks into $R$/$L$.
\item If $R$ nonempty, pop from $R$ and cross left; record arrival time and schedule put.
\item Else if $L$ nonempty and $disp<rem$, pop from $L$ and cross right; schedule pick.
\item Else advance $t$ to the next finishing time across $WR$ or $WL$.
\item Stop when $rem=0$; return the last arrival time.
\end{algosteps}
\OPTIMALITY{Each crossing and local task generates $O(1)$ heap operations; heaps give optimal $O(\log k)$ selection time under comparison-based models. Any exact discrete-event simulation must inspect each event, so this is asymptotically tight.}
\COMPLEXITY{Time $O((n+k)\log k)$; space $O(k)$.}
\[
\begin{aligned}
T(n) &= O\big((n+k)\log k\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        # Max-heaps for waiting on left/right by (left+right, index)
        L: List[Tuple[int,int,int]] = []
        R: List[Tuple[int,int,int]] = []
        # Min-heaps for completion times on left/right
        WL: List[Tuple[int,int]] = []
        WR: List[Tuple[int,int]] = []

        for i in range(k):
            r, p, l, u = time[i]
            s = l + r
            heapq.heappush(L, (-(s), -i, i))

        t = 0
        rem = n
        disp = 0
        last_arrival = 0

        def release(curr_time: int) -> None:
            while WR and WR[0][0] <= curr_time:
                _, i = heapq.heappop(WR)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(R, (-(s), -i, i))
            while WL and WL[0][0] <= curr_time:
                _, i = heapq.heappop(WL)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(L, (-(s), -i, i))

        while rem > 0:
            release(t)
            if R:
                # Right to left crossing (box arrives)
                _, _, i = heapq.heappop(R)
                r, p, l, u = time[i]
                t += l
                last_arrival = t
                heapq.heappush(WL, (t + u, i))
                rem -= 1
                disp -= 1
                if rem == 0:
                    return last_arrival
            elif L and disp < rem:
                # Left to right crossing (go to pick)
                _, _, i = heapq.heappop(L)
                r, p, l, u = time[i]
                t += r
                heapq.heappush(WR, (t + p, i))
                disp += 1
            else:
                # Advance to next event
                nxt = float('inf')
                if WR:
                    nxt = min(nxt, WR[0][0])
                if WL:
                    nxt = min(nxt, WL[0][0])
                if nxt < float('inf'):
                    t = max(t, nxt)
                # else: no pending events (should not occur when rem > 0)

        return last_arrival

# Exactly 3 asserts
sol = Solution()
assert sol.findCrossingTime(1, 3, [[1,1,2,1],[1,1,3,1],[1,1,4,1]]) == 6
assert sol.findCrossingTime(3, 2, [[1,5,1,8],[10,10,10,10]]) == 37
assert sol.findCrossingTime(1, 1, [[1,1,1,1]]) == 3
\end{minted}
\VALIDATION{Three targeted asserts: both samples and a minimal case.}
\RESULT{Returns the minute when the $n$th box finishes crossing to the left; subsequent put operations are irrelevant to the returned value.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate against samples; random small cases with a slow checker; adversarial ties with equal $(\ell_i+r_i)$ but different indices; cases where $disp=rem$ stalls left dispatch.}
\LINE{CROSS-CHECKS}{Compare outputs of two independent implementations (e.g., Approach A and C) on dozens of random seeds for small $n,k$ to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Produce scenarios with: $n=1$; $k=1$; identical workers; extreme tie-breaks; very large put times; very large right or left crossing times.}
\begin{minted}{python}
from typing import List
import random
import heapq

# Slow but clear checker for tiny instances using the same rules but
# with extra assertions and optional tracing.
class Checker:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        L = []
        R = []
        WL = []
        WR = []
        for i in range(k):
            r, p, l, u = time[i]
            s = l + r
            heapq.heappush(L, (-(s), -i, i))
        t = 0
        rem = n
        disp = 0
        last = 0
        def release(T: int):
            while WR and WR[0][0] <= T:
                _, i = heapq.heappop(WR)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(R, (-(s), -i, i))
            while WL and WL[0][0] <= T:
                _, i = heapq.heappop(WL)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(L, (-(s), -i, i))
        while rem > 0:
            release(t)
            if R:
                _, _, i = heapq.heappop(R)
                r, p, l, u = time[i]
                t += l
                last = t
                heapq.heappush(WL, (t + u, i))
                rem -= 1
                disp -= 1
                if rem == 0:
                    return last
            elif L and disp < rem:
                _, _, i = heapq.heappop(L)
                r, p, l, u = time[i]
                t += r
                heapq.heappush(WR, (t + p, i))
                disp += 1
            else:
                nxt = float('inf')
                if WR:
                    nxt = min(nxt, WR[0][0])
                if WL:
                    nxt = min(nxt, WL[0][0])
                if nxt < float('inf'):
                    t = max(t, nxt)
        return last

# Reference solution (Approach C)
class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        L=[];R=[];WL=[];WR=[]
        for i in range(k):
            r,p,l,u = time[i]
            s = l + r
            heapq.heappush(L, (-(s), -i, i))
        t=0; rem=n; disp=0; last=0
        def rel(T:int):
            while WR and WR[0][0] <= T:
                _, i = heapq.heappop(WR)
                r,p,l,u = time[i]
                s = l + r
                heapq.heappush(R, (-(s), -i, i))
            while WL and WL[0][0] <= T:
                _, i = heapq.heappop(WL)
                r,p,l,u = time[i]
                s = l + r
                heapq.heappush(L, (-(s), -i, i))
        while rem > 0:
            rel(t)
            if R:
                _,_,i = heapq.heappop(R)
                r,p,l,u = time[i]
                t += l
                last = t
                heapq.heappush(WL, (t + u, i))
                rem -= 1
                disp -= 1
                if rem == 0:
                    return last
            elif L and disp < rem:
                _,_,i = heapq.heappop(L)
                r,p,l,u = time[i]
                t += r
                heapq.heappush(WR, (t + p, i))
                disp += 1
            else:
                nxt = float('inf')
                if WR: nxt = min(nxt, WR[0][0])
                if WL: nxt = min(nxt, WL[0][0])
                if nxt < float('inf'):
                    t = max(t, nxt)
        return last

# Cross-check on random tiny cases
random.seed(0)
for _ in range(50):
    k = random.randint(1, 4)
    n = random.randint(1, 5)
    time = []
    for i in range(k):
        r = random.randint(1, 4)
        p = random.randint(1, 4)
        l = random.randint(1, 4)
        u = random.randint(1, 4)
        time.append([r,p,l,u])
    ans1 = Solution().findCrossingTime(n, k, time)
    ans2 = Checker().findCrossingTime(n, k, time)
    assert ans1 == ans2, (n, k, time, ans1, ans2)

# Reference demo tests
sol = Solution()
assert sol.findCrossingTime(1, 3, [[1,1,2,1],[1,1,3,1],[1,1,4,1]]) == 6
assert sol.findCrossingTime(3, 2, [[1,5,1,8],[10,10,10,10]]) == 37
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        # Priority queues
        L: List[Tuple[int,int,int]] = []  # max-heap by (-(l+r), -i, i)
        R: List[Tuple[int,int,int]] = []
        WL: List[Tuple[int,int]] = []     # min-heap by (finish_time, i)
        WR: List[Tuple[int,int]] = []

        for i in range(k):
            r, p, l, u = time[i]
            s = l + r
            heapq.heappush(L, (-(s), -i, i))

        t = 0
        rem = n
        disp = 0
        last_arrival = 0

        def release(curr_time: int) -> None:
            while WR and WR[0][0] <= curr_time:
                _, i = heapq.heappop(WR)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(R, (-(s), -i, i))
            while WL and WL[0][0] <= curr_time:
                _, i = heapq.heappop(WL)
                r, p, l, u = time[i]
                s = l + r
                heapq.heappush(L, (-(s), -i, i))

        while rem > 0:
            release(t)
            if R:
                _, _, i = heapq.heappop(R)
                r, p, l, u = time[i]
                t += l
                last_arrival = t
                heapq.heappush(WL, (t + u, i))
                rem -= 1
                disp -= 1
                if rem == 0:
                    return last_arrival
            elif L and disp < rem:
                _, _, i = heapq.heappop(L)
                r, p, l, u = time[i]
                t += r
                heapq.heappush(WR, (t + p, i))
                disp += 1
            else:
                nxt = float('inf')
                if WR:
                    nxt = min(nxt, WR[0][0])
                if WL:
                    nxt = min(nxt, WL[0][0])
                if nxt < float('inf'):
                    t = max(t, nxt)
        return last_arrival

# Self-check
sol = Solution()
assert sol.findCrossingTime(1, 1, [[1,1,1,1]]) == 3
assert sol.findCrossingTime(1, 3, [[1,1,2,1],[1,1,3,1],[1,1,4,1]]) == 6
assert sol.findCrossingTime(3, 2, [[1,5,1,8],[10,10,10,10]]) == 37
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate the bridge as a single-server resource with right-first priority and a cap on left dispatches using four heaps.}
\WHY{Priority-driven simulations with resource contention are common in interviews; correctness hinges on respecting all rules and tie-breaks.}
\CHECKLIST{
\begin{bullets}
\item Compute efficiency $s_i=\ell_i+r_i$ and use higher $s_i$, then higher $i$ as max-heap keys.
\item Always release completed tasks to waiting heaps before deciding the next bridge user.
\item Right side has absolute priority when bridge becomes idle.
\item Enforce $disp<rem$ before sending anyone from left.
\item Advance time to the next finish when no crossing is possible.
\item Record the arrival time upon finishing a left crossing; ignore subsequent put for the final answer.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ or $k=1$.
\item All workers identical times (index tie-break).
\item Very long $put$ times (should not affect the answer).
\item Very long $right$ or $left$ crossing skewing priorities.
\item When $disp=rem$, left dispatch is blocked until a return happens.
\item Multiple completions at the same time on both sides.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using min-heap without negating keys, thus picking the most efficient instead of least.
\item Forgetting the index tie-break when sums are equal.
\item Allowing left dispatch when $disp=rem$.
\item Advancing time incorrectly (e.g., skipping over the earliest completion).
\item Updating $rem$ on pick rather than on left arrival.
\item Returning after the last put instead of the last left arrival.
\end{bullets}}
\FAILMODES{Any approach that simulates per-minute time will time out for $n,k \approx 10^{4}$. Greedy without the dispatch cap can send too many to the right, violating rules and producing incorrect times.}
\ELI{Keep four bins: left-wait, right-wait, left-working, right-working. When idle, take from right first, otherwise from left if allowed. Jump time to the next ready event when stuck. Stop exactly when the $n$th box arrives left.}
\NotePages{3}

\end{document}