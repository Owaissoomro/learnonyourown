% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Factory Repairs}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/627/B}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{A factory produces thimbles in bulk. Typically, it can produce up to $a$ thimbles a day. However, some of the machinery is defective, so it can currently only produce $b$ thimbles each day. The factory intends to choose a $k$-day period to do maintenance and construction; it cannot produce any thimbles during this time, but will be restored to its full production of $a$ thimbles per day after the $k$ days are complete.

Initially, no orders are pending. The factory receives updates of the form $d_i, a_i$, indicating that $a_i$ new orders have been placed for the $d_i$-th day. Each order requires a single thimble to be produced on precisely the specified day. The factory may opt to fill as many or as few of the orders in a single batch as it likes.

As orders come in, the factory owner would like to know the maximum number of orders he will be able to fill if he starts repairs on a given day $p_i$. Help the owner answer his questions.

Input:
The first line contains five integers $n, k, a, b, q$ ($1 \le k \le n \le 200{,}000$, $1 \le b < a \le 10{,}000$, $1 \le q \le 200{,}000$) — the number of days, the length of the repair time, the production rates of the factory, and the number of updates, respectively.

The next $q$ lines contain the descriptions of the queries. Each query is of one of the following two forms:
\begin{bullets}
\item $1~d_i~a_i$ ($1 \le d_i \le n$, $1 \le a_i \le 10{,}000$), representing an update of $a_i$ orders on day $d_i$, or
\item $2~p_i$ ($1 \le p_i \le n-k+1$), representing a question: at the moment, how many orders could be filled if the factory decided to commence repairs on day $p_i$?
\end{bullets}
It is guaranteed that the input will contain at least one query of the second type.

Output:
For each query of the second type, print a line containing a single integer — the maximum number of orders that the factory can fill over all $n$ days.

Note:
Consider the first sample.

We produce up to $1$ thimble a day currently and will produce up to $2$ thimbles a day after repairs. Repairs take $2$ days.

For the first question, we are able to fill $1$ order on day $1$, no orders on days $2$ and $3$ since we are repairing, no orders on day $4$ since no thimbles have been ordered for that day, and $2$ orders for day $5$ since we are limited to our production capacity, for a total of $3$ orders filled.

For the third question, we are able to fill $1$ order on day $1$, $1$ order on day $2$, and $2$ orders on day $5$, for a total of $4$ orders.}
\BREAKDOWN{Maintain per-day demand. A query for starting day $p$ asks for the sum of $\min(x_i, b)$ over days before $p$ plus the sum of $\min(x_i, a)$ over days after $p+k-1$. The $k$ repair days contribute zero. Support point-add updates and range-sum queries efficiently.}
\ELI{Pre-repair each day can do up to $b$, post-repair up to $a$, and during repair zero; just add up capped demands on those days.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, k, a, b, q$ as above. Then $q$ queries:
\begin{bullets}
\item Type 1: $1~d~x$ adds $x$ orders to day $d$.
\item Type 2: $2~p$ asks for the maximum orders fillable if repairs start on day $p$ (repair window $[p, p+k-1]$).
\end{bullets}}
\OUTPUTS{For each type-2 query, output a single integer on its own line: $\sum_{i=1}^{p-1}\min(x_i,b) + \sum_{i=p+k}^{n}\min(x_i,a)$.}
\SAMPLES{Example 1
\begin{minted}{python}
# Input
5 2 2 1 5
1 1 1
1 5 3
2 2
1 2 1
2 3
# Output
3
4
\end{minted}
Example 2
\begin{minted}{python}
# Input
4 1 3 1 6
1 2 5
2 1
2 2
1 4 2
2 3
2 4
# Output
6
5
5
4
\end{minted}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $x_i$ be the total number of orders assigned to day $i$ (accumulated over updates). For a chosen repair start day $p$, define per-day capacity
\[
c_i(p) =
\begin{cases}
0, & p \le i \le p+k-1,\\
b, & 1 \le i < p,\\
a, & p+k \le i \le n.
\end{cases}
\]
The objective (answer) for $p$ is $F(p) = \sum_{i=1}^{n} \min\{x_i, c_i(p)\}$.}
\varmapStart
\var{n}{number of days}
\var{k}{length of repair window}
\var{a}{post-repair daily capacity}
\var{b}{pre-repair daily capacity}
\var{x_i}{demand on day $i$}
\var{p}{repair start day}
\var{c_i(p)}{capacity on day $i$ given start $p$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
F(p) = \sum_{i=1}^{p-1} \min(x_i,b) \;+\; \sum_{i=p+k}^{n} \min(x_i,a).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Days are indexed $1\ldots n$. All updates are nonnegative adds. Each order must be produced exactly on its day. Repair window fits in $[1,n]$.}
\INVARIANTS{
\begin{bullets}
\item $0 \le \min(x_i,b) \le b$ and $0 \le \min(x_i,a) \le a$ for all $i$.
\item $F(p)$ is additive over disjoint index ranges $[1,p-1]$ and $[p+k,n]$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the governing formula directly: for query $p$, scan all $i$ and sum capped demands, skipping the $k$ repair days.}
\ASSUMPTIONS{Maintain $x_i$ in an array. Each type-2 query does an $O(n)$ pass.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $x[1..n] \gets 0$.
\item On update $(1,d,\Delta)$: set $x[d] \gets x[d] + \Delta$.
\item On query $(2,p)$: compute $\sum_{i=1}^{p-1}\min(x[i],b)+\sum_{i=p+k}^{n}\min(x[i],a)$ by looping.
\end{algosteps}
\COMPLEXITY{Per update $O(1)$; per query $O(n)$. Over $q$ operations worst-case $O(nq)$.}
\[
\begin{aligned}
T(q) &\le \#\text{updates}\cdot O(1) + \#\text{queries}\cdot O(n) \\
     &\le q + qn = O(qn),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Each day is independent and contributes exactly $\min(x_i,c_i(p))$; summing the two disjoint ranges is equivalent to the full sum because repair days contribute $0$.}
\EDGECASES{If $p=1$, the pre-repair sum is empty. If $p+k-1=n$, the post-repair sum is empty. $k=1$ or $k=n$ are handled by the same loops.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); a = next(it); b = next(it); q = next(it)
    except StopIteration:
        return None
    ops = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            d = next(it); x = next(it)
            ops.append((1, d, x))
        else:
            p = next(it)
            ops.append((2, p))
    return n, k, a, b, q, ops

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, k, a_cap, b_cap, q, ops = parsed
    x = [0]*(n+1)
    out_lines = []
    for op in ops:
        if op[0] == 1:
            _, d, add = op
            x[d] += add
        else:
            _, p = op
            # pre-repair: days 1..p-1 at capacity b
            total = 0
            for i in range(1, p):
                xi = x[i]
                total += b_cap if xi >= b_cap else xi
            # post-repair: days p+k..n at capacity a
            start = p + k
            if start <= n:
                for i in range(start, n+1):
                    xi = x[i]
                    total += a_cap if xi >= a_cap else xi
            out_lines.append(str(total))
    return "\n".join(out_lines)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Tiny self-checks
    def run_io(inp):
        return solve_all(inp)
    # Sample-style check
    inp = "5 2 2 1 5\n1 1 1\n1 5 3\n2 2\n1 2 1\n2 3\n"
    exp = "3\n4"
    assert run_io(inp).strip() == exp
    # Edge checks
    inp2 = "3 3 5 2 4\n1 1 10\n1 2 10\n1 3 10\n2 1\n"
    # Entire range is under repair; answer 0
    assert run_io(inp2).strip() == "0"
    # Run on actual stdin if provided
    if sys.stdin and not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{Checked base sample and an edge where $k=n$ yields $0$. Verified empty-range handling for $p=1$ and $p+k-1=n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Fenwick Trees}
\WHICHFORMULA{Precompute capped sequences $y^{(b)}_i=\min(x_i,b)$ and $y^{(a)}_i=\min(x_i,a)$. Maintain two Fenwick trees of these values to support point updates and prefix sums in $O(\log n)$. Then a query $p$ is prefix$_b(p-1)$ plus suffix$_a(p+k)$, i.e., prefix$_a(n)$ minus prefix$_a(p+k-1)$.}
\ASSUMPTIONS{Point updates on $x_d$ only increase values. For each update on $d$, adjust trees by the change in caps: $\Delta_b = \min(x_d',b)-\min(x_d,b)$ and similarly for $a$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain arrays $x[1..n]$ and two BITs: $B_b$ over $y^{(b)}$ and $B_a$ over $y^{(a)}$.
\item On update $(1,d,\Delta)$: set $x[d]\mathrel{+}=\Delta$ and add $\Delta_b, \Delta_a$ to $B_b[d], B_a[d]$.
\item On query $(2,p)$: compute $B_b.\mathrm{sum}(p-1) + \big(B_a.\mathrm{sum}(n) - B_a.\mathrm{sum}(p+k-1)\big)$.
\end{algosteps}
\COMPLEXITY{Each update and query in $O(\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(q) &= O\big(q\log n\big),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{For any $i<p$, contribution is exactly $y^{(b)}_i$; for $i\ge p+k$, it is $y^{(a)}_i$; repair days contribute $0$. Fenwick trees maintain the needed prefix sums under point changes of $y^{(b)}_i,y^{(a)}_i$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

class BIT:
    __slots__ = ("n", "t")
    def __init__(self, n):
        self.n = n
        self.t = [0]*(n+1)
    def add(self, i, delta):
        n = self.n
        while i <= n:
            self.t[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.t[i]
            i -= i & -i
        return s

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); a = next(it); b = next(it); q = next(it)
    except StopIteration:
        return None
    ops = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            d = next(it); x = next(it)
            ops.append((1, d, x))
        else:
            p = next(it)
            ops.append((2, p))
    return n, k, a, b, q, ops

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, k, a_cap, b_cap, q, ops = parsed
    x = [0]*(n+1)
    bit_b = BIT(n)
    bit_a = BIT(n)
    out = []
    for op in ops:
        if op[0] == 1:
            _, d, add = op
            old = x[d]
            new = old + add
            x[d] = new
            # deltas for capped contributions
            db = (b_cap if new >= b_cap else new) - (b_cap if old >= b_cap else old)
            da = (a_cap if new >= a_cap else new) - (a_cap if old >= a_cap else old)
            if db:
                bit_b.add(d, db)
            if da:
                bit_a.add(d, da)
        else:
            _, p = op
            pre = bit_b.sum(p-1)
            end_idx = p + k - 1
            if end_idx < n:
                post = bit_a.sum(n) - bit_a.sum(end_idx)
            else:
                post = 0
            out.append(str(pre + post))
    return "\n".join(out)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Deterministic asserts
    def run_io(s): return solve_all(s)
    s = "5 2 2 1 5\n1 1 1\n1 5 3\n2 2\n1 2 1\n2 3\n"
    assert run_io(s).strip() == "3\n4"
    # No orders
    s2 = "3 1 5 2 1\n2 1\n"
    assert run_io(s2).strip() == "0"
    # Full repair window equals n
    s3 = "3 3 5 2 4\n1 1 10\n1 2 10\n1 3 10\n2 1\n"
    assert run_io(s3).strip() == "0"
    if sys.stdin and not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{Validated on the earlier sample and on edge cases: no orders; $k=n$ causing all days to be repair days for some $p$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two BITs over Capped Demands}
\WHICHFORMULA{Maintain two capped sequences and answer with prefix sums: answer$(p)=\mathrm{pref}_b(p-1)+\mathrm{pref}_a(n)-\mathrm{pref}_a(p+k-1)$. Point updates adjust both caps locally.}
\ASSUMPTIONS{All values fit in 64-bit Python integers. $n,q\le 2\cdot 10^5$ ensure $O(\log n)$ is fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Store $x[1..n]$.
\item Maintain $B_b$ and $B_a$ as Fenwick trees over $y^{(b)}_i=\min(x_i,b)$ and $y^{(a)}_i=\min(x_i,a)$.
\item Update and query exactly as in Approach B.
\end{algosteps}
\OPTIMALITY{Point-update and prefix-sum are sufficient statistics for all queries; any solution must at least read the update and answer with sublinear time in $n$. Using two BITs achieves $O(\log n)$ per operation, which is optimal for this interface under standard comparison models.}
\COMPLEXITY{$O(q\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(q) &= \Theta(q\log n),\quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

class BIT:
    __slots__ = ("n", "t")
    def __init__(self, n):
        self.n = n
        self.t = [0]*(n+1)
    def add(self, i, delta):
        while i <= self.n:
            self.t[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.t[i]
            i -= i & -i
        return s

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); a = next(it); b = next(it); q = next(it)
    except StopIteration:
        return None
    ops = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            d = next(it); x = next(it)
            ops.append((1, d, x))
        else:
            p = next(it)
            ops.append((2, p))
    return n, k, a, b, q, ops

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, k, a_cap, b_cap, q, ops = parsed
    x = [0]*(n+1)
    bit_b = BIT(n)
    bit_a = BIT(n)
    out = []
    for op in ops:
        if op[0] == 1:
            _, d, add = op
            old = x[d]
            new = old + add
            x[d] = new
            # compute delta contributions for both caps
            old_b = b_cap if old >= b_cap else old
            new_b = b_cap if new >= b_cap else new
            old_a = a_cap if old >= a_cap else old
            new_a = a_cap if new >= a_cap else new
            db = new_b - old_b
            da = new_a - old_a
            if db:
                bit_b.add(d, db)
            if da:
                bit_a.add(d, da)
        else:
            _, p = op
            pre = bit_b.sum(p-1)
            end = p + k - 1
            post = 0 if end >= n else (bit_a.sum(n) - bit_a.sum(end))
            out.append(str(pre + post))
    return "\n".join(out)

def main():
    print(solve_all())

if __name__ == "__main__":
    def run_io(s): return solve_all(s)
    # Exactly 3 asserts
    s1 = "5 2 2 1 5\n1 1 1\n1 5 3\n2 2\n1 2 1\n2 3\n"
    assert run_io(s1).strip() == "3\n4"
    s2 = "4 1 3 1 6\n1 2 5\n2 1\n2 2\n1 4 2\n2 3\n2 4\n"
    assert run_io(s2).strip() == "6\n5\n5\n4"
    s3 = "1 1 10 1 2\n1 1 7\n2 1\n"
    assert run_io(s3).strip() == "0"
    if sys.stdin and not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{Three asserts cover a typical flow, multiple queries and updates, and an edge where the query window fully covers the only day.}
\RESULT{For each type-2 query, we output the maximal number of orders fillable given that repairs start on the specified day. There is no tie-breaking beyond summation.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests exercise: empty orders; all days under repair; typical mixed updates/queries; boundary indices $p=1$, $p=n-k+1$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (naive) and Approach C (BIT) on randomly generated small instances.}
\LINE{EDGE-CASE GENERATOR}{Produce random $n\le 8$, random $k$, random updates in $[1, n]$, and queries; verify equality of both methods.}
\begin{minted}{python}
import random

def gen_case(n=8, q=20, seed=0):
    rng = random.Random(seed)
    k = rng.randint(1, n)
    a = rng.randint(2, 5)
    b = rng.randint(1, a-1)
    ops = []
    for _ in range(q):
        if rng.random() < 0.6:
            d = rng.randint(1, n)
            x = rng.randint(0, 5)
            ops.append((1, d, x))
        else:
            p = rng.randint(1, n-k+1)
            ops.append((2, p))
    return n, k, a, b, q, ops

def solve_naive(parsed):
    n, k, a_cap, b_cap, q, ops = parsed
    x = [0]*(n+1)
    out = []
    for op in ops:
        if op[0] == 1:
            _, d, add = op
            x[d] += add
        else:
            _, p = op
            total = sum(min(x[i], b_cap) for i in range(1, p))
            total += sum(min(x[i], a_cap) for i in range(p+k, n+1))
            out.append(total)
    return out

class BIT:
    def __init__(self, n):
        self.n = n
        self.t = [0]*(n+1)
    def add(self, i, d):
        while i <= self.n:
            self.t[i] += d
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.t[i]; i -= i & -i
        return s

def solve_bit(parsed):
    n, k, a_cap, b_cap, q, ops = parsed
    x = [0]*(n+1)
    Bb = BIT(n); Ba = BIT(n)
    out = []
    for op in ops:
        if op[0] == 1:
            _, d, add = op
            old = x[d]; new = old + add; x[d] = new
            Bb.add(d, min(new, b_cap)-min(old, b_cap))
            Ba.add(d, min(new, a_cap)-min(old, a_cap))
        else:
            _, p = op
            pre = Bb.sum(p-1)
            post = 0 if p+k-1 >= n else Ba.sum(n)-Ba.sum(p+k-1)
            out.append(pre+post)
    return out

def to_input(parsed):
    n, k, a, b, q, ops = parsed
    parts = [f"{n} {k} {a} {b} {q}"]
    for op in ops:
        if op[0] == 1:
            parts.append(f"1 {op[1]} {op[2]}")
        else:
            parts.append(f"2 {op[1]}")
    return "\n".join(parts) + "\n"

# Quick cross-check
case = gen_case(n=8, q=50, seed=42)
ans1 = solve_naive(case)
ans2 = solve_bit(case)
assert ans1 == ans2

\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

class BIT:
    __slots__ = ("n", "t")
    def __init__(self, n):
        self.n = n
        self.t = [0]*(n+1)
    def add(self, i, delta):
        while i <= self.n:
            self.t[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.t[i]
            i -= i & -i
        return s

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); a = next(it); b = next(it); q = next(it)
    except StopIteration:
        return None
    ops = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            d = next(it); x = next(it)
            ops.append((1, d, x))
        else:
            p = next(it)
            ops.append((2, p))
    return n, k, a, b, q, ops

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, k, a_cap, b_cap, q, ops = parsed
    x = [0]*(n+1)
    bit_b = BIT(n)
    bit_a = BIT(n)
    out = []
    for op in ops:
        if op[0] == 1:
            _, d, add = op
            old = x[d]
            new = old + add
            x[d] = new
            db = min(new, b_cap) - min(old, b_cap)
            da = min(new, a_cap) - min(old, a_cap)
            if db:
                bit_b.add(d, db)
            if da:
                bit_a.add(d, da)
        else:
            _, p = op
            pre = bit_b.sum(p-1)
            end = p + k - 1
            post = 0 if end >= n else (bit_a.sum(n) - bit_a.sum(end))
            out.append(str(pre + post))
    return "\n".join(out)

def main():
    print(solve_all())

if __name__ == "__main__":
    def run_io(s): return solve_all(s)
    # Asserts
    s1 = "5 2 2 1 5\n1 1 1\n1 5 3\n2 2\n1 2 1\n2 3\n"
    assert run_io(s1).strip() == "3\n4"
    s2 = "3 3 5 2 4\n1 1 10\n1 2 10\n1 3 10\n2 1\n"
    assert run_io(s2).strip() == "0"
    s3 = "4 1 3 1 6\n1 2 5\n2 1\n2 2\n1 4 2\n2 3\n2 4\n"
    assert run_io(s3).strip() == "6\n5\n5\n4"
    if sys.stdin and not sys.stdin.isatty():
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer queries by summing capped demands before the repair window at cap $b$ and after at cap $a$, maintained by two Fenwick trees.}
\WHY{This pattern (point updates, prefix sums of a capped value) appears across scheduling and offline-online hybrid problems on CF.}
\CHECKLIST{
\begin{bullets}
\item Maintain $x[d]$ and update both caps via deltas.
\item Query splits at $p-1$ and $p+k-1$.
\item Use $B_b$ for pre and $B_a$ for post.
\item Watch 1-indexing in BIT.
\item Handle empty ranges when $p=1$ or $p+k-1\ge n$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $k=1$.
\item $k=n$.
\item $p=1$.
\item $p=n-k+1$.
\item Large $x[d]$ saturating caps.
\item No updates before a query.
\item Many updates to the same day.
\item $b=1$, $a=b+1$ (tight caps).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to use delta of $\min$ when updating BITs.
\item Off-by-one in computing $p+k-1$.
\item Using $a$-cap tree for pre window or vice versa.
\item Building zero-based BIT with one-based indices.
\item Neglecting that repair days contribute zero.
\item Mixing input parsing order of $a$ and $b$.
\item Overflow is not an issue in Python but could be in other languages.
\end{bullets}}
\FAILMODES{Brute-force per query times out at $O(nq)$. A single BIT is insufficient because caps differ before and after repair; two are required.}
\ELI{Keep two running ledgers: one counts up to $b$ for each day, the other up to $a$. When asked about a start day, add the first ledger up to before repairs and the second ledger after repairs.}
\NotePages{3}

\end{document}