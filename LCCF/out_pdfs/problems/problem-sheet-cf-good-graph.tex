% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Good Graph}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1835/F}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{You are given a bipartite graph $G$ with the vertex set in the left part $L$, in the right part $R$, and $m$ edges connecting these two sets. We know that $|L| = |R| = n$.

For any subset $S \subseteq L$, let $N(S)$ denote the set of all neighbors of vertices in $S$. We say that a subset $S \subseteq L$ in graph $G$ is tight if $|S| = |N(S)|$. We say that graph $G$ is good if $\forall_{S \subseteq L},~|S| \le |N(S)|$.

Your task is to verify whether the graph is good and, if so, to optimize it. If the graph is not good, find a subset $S \subseteq L$ such that $|S| > |N(S)|$. However, if the graph is good, your task is to find a good bipartite graph $G'$ with the same set of vertices $L \cup R$, in which $\forall_{S \subseteq L}$, $S$ is tight in $G$ if and only if $S$ is tight in $G'$. If there are multiple such graphs, choose one with the smallest possible number of edges. If there are still multiple such graphs, print any.

Input:
The first line of the input contains two integers $n$ and $m$ ($1 \le n \le 10^3$, $0 \le m \le n^2$), separated by a single space. The number $n$ denotes the number of vertices in each of the sets $L$ and $R$, and the number $m$ denotes the number of edges between them.

The following $m$ lines describe the edges. Each of them contains two integers $l$ and $r$ ($1 \le l \le n$, $n+1 \le r \le 2 \cdot n$), separated by a single space, indicating that there is an edge from vertex $l \in L$ to vertex $r \in R$.

Output:
If the graph $G$ given in the input is not good, output one word ``NO'' in the first line of the output. In the second line of the output, output the number $k$, and in the third line, output $k$ numbers $l_1, l_2, \dots, l_k$, separated by single spaces. These numbers should indicate that for the set $S = \{l_1, l_2, \dots, l_k\}$, $|S| > |N(S)|$.

However, if the graph $G$ given in the input is good, output one word ``YES'' in the first line of the output. In the second line of the output, output the number $m'$, indicating the number of edges in the new, also good graph $G'$. Then, in the following $m'$ lines, output the edges of the graph $G'$ in the same format as given in the input.

Note:
In the first sample test, the graph $G$ is good; thus, we are looking for an equivalent graph with the same tight sets. The only tight set is $\{ 1, 2, 3 \}$, which remains tight in the resulting graph. Moreover, no other set is tight in the resulting graph. One can prove that no graph with less than $6$ edges and the same tight sets exists.

In the second sample test, the graph $G$ is not good. Set $\{ 2, 3 \}$ has only one neighbour — vertex $6$. Thus, $|\{ 2, 3 \}| > |\{ 6 \}|$, which is a proof that the input graph is not good.}
\BREAKDOWN{Check Hall's condition on the left side. If violated, construct a witness subset $S$. If satisfied, compute a minimal-edge graph $G'$ preserving exactly the same tight subsets of $L$.}
\ELI{Use maximum matching to detect goodness; if good, compress the alternating structure into a poset and keep only a transitive reduction plus minimal edges to keep strong components.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. First line: integers $n, m$. Next $m$ lines: edge endpoints $l \in \{1,\ldots,n\}$ and $r \in \{n+1,\ldots,2n\}$.}
\OUTPUTS{If not good: print NO, then $k$, then the $k$ indices of a violating subset $S \subseteq L$ with $|S| > |N(S)|$. If good: print YES, then $m'$ and then $m'$ edges of $G'$ in the same format; $G'$ must be good and have exactly the same tight subsets of $L$ as $G$; among such graphs, $m'$ must be minimal.}
\SAMPLES{Example 1 (good): $n=3$, edges forming a perfect matching plus some extras. Example 2 (not good): $n=2$, edges $(1,n+1)$ and $(2,n+1)$ yields witness $S=\{1,2\}$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(L \cup R, E)$ be bipartite with $|L|=|R|=n$. For $S \subseteq L$, define $N(S)\subseteq R$. Graph $G$ is good iff Hall's condition holds for all $S \subseteq L$, equivalently iff there exists a perfect matching $M$ of size $n$. For a fixed perfect matching $M$ (bijection $f:L\to R$), define a directed graph $D$ on $L$ with arcs $u\to v$ for each edge $(u,r)\in E$ where $v=f^{-1}(r)$.}
\varmapStart
\var{n}{number of vertices per side}
\var{m}{number of edges of $G$}
\var{M}{a perfect matching if it exists}
\var{f}{bijection $L\to R$ induced by $M$}
\var{D}{digraph on $L$; $u\to v$ iff $(u,f(v))\in E$}
\var{C}{SCC partition of $D$; condensation DAG $P$ on components}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{$G$ good} \iff \forall S\subseteq L:\ |S|\le |N(S)| \iff \text{$G$ has a perfect matching.}
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{For perfect $G$, the tight subsets of $L$ are exactly those $S$ that are forward-closed in $D$ (unions of SCCs closed under reachability).}
\end{BreakableEquation*}
}
\ASSUMPTIONS{Vertices are labeled $L=\{1,\ldots,n\}$ and $R=\{n+1,\ldots,2n\}$. Inputs may contain parallel edges; they are harmless and can be deduplicated.}
\INVARIANTS{If $G$ is good, every $r\in R$ is matched in any perfect matching. The SCC partition and condensation reachability of $D$ determine precisely the family of tight sets. Minimally preserving tight sets requires preserving the SCCs and the reachability partial order between them (the transitive reduction suffices).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Hall's theorem gives a characterization: check $|S|\le |N(S)|$ for all $S\subseteq L$.}
\ASSUMPTIONS{Small $n$ only; exponential enumeration.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For all subsets $S\subseteq L$, compute $|N(S)|$ and verify $|S|\le |N(S)|$.
\item If violated, return that $S$.
\item If satisfied, $G$ is good but this approach gives no $G'$ optimization.
\end{algosteps}
\COMPLEXITY{Exponential in $n$.}
\[
\begin{aligned}
T(n) &= \Theta(2^n \cdot n^2) \\
S(n) &= \Theta(n^2)
\end{aligned}
\]
\CORRECTNESS{Immediate from Hall's theorem.}
\EDGECASES{$S=\varnothing$ and $S=L$ must be included; handle isolated vertices.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline enumeration (illustrative; not for submission on large inputs)
from itertools import combinations

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        l = int(next(it)) - 1
        r = int(next(it)) - (n + 1)
        edges.append((l, r))
    return n, m, edges

def solve_case_bruteforce(n, m, edges):
    adj = [set() for _ in range(n)]
    for u, v in edges:
        adj[u].add(v)
    # Check Hall
    from itertools import combinations
    badS = None
    for k in range(1, n + 1):
        for comb in combinations(range(n), k):
            neigh = set()
            for u in comb:
                neigh |= adj[u]
            if len(comb) > len(neigh):
                badS = list(comb)
                break
        if badS is not None:
            break
    if badS is not None:
        return ("NO", [x + 1 for x in badS])
    else:
        return ("YES", [])  # placeholder; no optimization here

def main():
    n, m, edges = read_input()
    if n == 0 and m == 0 and not edges:
        return
    ans = solve_case_bruteforce(n, m, edges)
    if ans[0] == "NO":
        S = ans[1]
        print("NO")
        print(len(S))
        print(*S)
    else:
        print("YES")
        print(0)
        # no edges printed

if __name__ == "__main__":
    # Tiny asserts (do not run on CF)
    # n=2, edges: (1, n+1), (2, n+1) -> bad
    n=2; m=2; edges=[(0,0),(1,0)]
    res = solve_case_bruteforce(n,m,edges)
    assert res[0]=="NO"
    # Perfect matching trivial
    n=2; m=2; edges=[(0,0),(1,1)]
    res = solve_case_bruteforce(n,m,edges)
    assert res[0]=="YES"
    # Do not run main() in tests
    pass
\end{minted}
\VALIDATION{Confirmed detection of a simple Hall violation and acceptance of a trivial perfect matching instance.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Hopcroft–Karp for Goodness; Witness via Alternating BFS}
\WHICHFORMULA{Use Hopcroft–Karp to find a maximum matching in $O(m\sqrt{n})$. If its size is $n$, the graph is good; otherwise, obtain a Hall witness from the alternating graph.}
\ASSUMPTIONS{Standard HK alternating layer graph; deduplicate parallel edges for speed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency $L\to R$; deduplicate.
\item Run Hopcroft–Karp to compute a maximum matching $M$.
\item If $|M|<n$, perform BFS in the alternating graph starting from all free $L$ vertices, traversing unmatched edges $L\to R$ and matched edges $R\to L$, to get the reachable sets $Z_L, Z_R$.
\item Output $S=Z_L$; then $|S|>|N(S)|$ holds (standard Hall witness).
\end{algosteps}
\COMPLEXITY{Dominated by Hopcroft–Karp.}
\[
\begin{aligned}
T(n,m) &= O(m\sqrt{n}) \\
S(n,m) &= O(n+m)
\end{aligned}
\]
\CORRECTNESS{HK finds a maximum matching. If not perfect, the BFS from free $L$ yields $Z_L$ with all $R$ reached being matched, and $|Z_R|<|Z_L|$, hence $|Z_L|>|N(Z_L)|$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: Goodness check + witness if bad
from collections import deque

class HopcroftKarp:
    def __init__(self, n_left, n_right, adj):
        self.n = n_left
        self.m = n_right
        self.adj = adj
        self.NIL = self.n  # sentinel index for left side
        self.pairU = [-1] * (self.n)
        self.pairV = [-1] * (self.m)
        self.dist = [0] * (self.n + 1)

    def bfs(self):
        dq = deque()
        for u in range(self.n):
            if self.pairU[u] == -1:
                self.dist[u] = 0
                dq.append(u)
            else:
                self.dist[u] = 10**9
        found = False
        while dq:
            u = dq.popleft()
            for v in self.adj[u]:
                pu = self.pairV[v]
                if pu == -1:
                    found = True
                else:
                    if self.dist[pu] == 10**9:
                        self.dist[pu] = self.dist[u] + 1
                        dq.append(pu)
        return found

    def dfs(self, u):
        for v in self.adj[u]:
            pu = self.pairV[v]
            if pu == -1 or (self.dist[pu] == self.dist[u] + 1 and self.dfs(pu)):
                self.pairU[u] = v
                self.pairV[v] = u
                return True
        self.dist[u] = 10**9
        return False

    def max_matching(self):
        match = 0
        while self.bfs():
            for u in range(self.n):
                if self.pairU[u] == -1:
                    if self.dfs(u):
                        match += 1
        return match

def hall_witness_from_matching(n, adj, pairU, pairV):
    # Alternating BFS from all free left vertices; edges L->R are unmatched; R->L follow matching
    from collections import deque
    visL = [False] * n
    visR = [False] * n
    dq = deque()
    for u in range(n):
        if pairU[u] == -1:
            visL[u] = True
            dq.append(('L', u))
    while dq:
        side, x = dq.popleft()
        if side == 'L':
            u = x
            for v in adj[u]:
                if not visR[v] and pairU[u] != v:
                    visR[v] = True
                    dq.append(('R', v))
        else:
            v = x
            u2 = pairV[v]
            if u2 != -1 and not visL[u2]:
                visL[u2] = True
                dq.append(('L', u2))
    S = [i for i in range(n) if visL[i]]
    # Sanity: |S| > |N(S)|
    Nset = set()
    for u in S:
        Nset |= set(adj[u])
    assert len(S) > len(Nset)  # witness must violate Hall
    return S

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        l = int(next(it)) - 1
        r = int(next(it)) - (n + 1)
        edges.append((l, r))
    return n, m, edges

def solve_case_check(n, m, edges):
    adj = [set() for _ in range(n)]
    for u, v in edges:
        if 0 <= u < n and 0 <= v < n:
            adj[u].add(v)
    adj = [sorted(list(s)) for s in adj]
    hk = HopcroftKarp(n, n, adj)
    mm = hk.max_matching()
    if mm < n:
        S = hall_witness_from_matching(n, adj, hk.pairU, hk.pairV)
        return ("NO", [x + 1 for x in S])
    else:
        return ("YES", None)

def main():
    n, m, edges = read_input()
    if n == 0 and m == 0 and not edges:
        return
    kind, payload = solve_case_check(n, m, edges)
    if kind == "NO":
        S = payload
        print("NO")
        print(len(S))
        print(*S)
    else:
        # Placeholder for improved-only stage
        print("YES")
        print(0)

if __name__ == "__main__":
    # Basic asserts
    # Bad: two left to one right
    n=2; m=2; edges=[(0,0),(1,0)]
    kind, payload = solve_case_check(n,m,edges)
    assert kind=="NO"
    # Good: perfect matching
    n=2; m=2; edges=[(0,0),(1,1)]
    kind, payload = solve_case_check(n,m,edges)
    assert kind=="YES"
\end{minted}
\VALIDATION{Verified witness construction on a simple Hall-violating instance; acceptance on trivial perfect matching.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Tight-Set Preserving Minimization via SCCs and Transitive Reduction}
\WHICHFORMULA{If $G$ is good, fix a perfect matching $M$ (bijection $f$). Build the digraph $D$ on $L$ with arc $u\to v$ for each bipartite edge $(u,f(v))$. Tight subsets are exactly forward-closed unions of SCCs in $D$. Hence, any $G'$ with the same SCC partition and the same reachability partial order among SCCs induces exactly the same family of tight subsets. A minimal such $G'$ uses:
- within each SCC of size $s\ge 2$: a directed cycle of $s$ arcs,
- across SCCs: edges realizing the transitive reduction of the condensation DAG,
- plus one edge per $u\in L$ to ensure perfect matching (we keep $(u,f(u))$).}
\ASSUMPTIONS{$n\le 10^3$, $m\le n^2$. Bitset reachability over the condensation DAG is feasible in Python using integer bitmasks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run Hopcroft–Karp; if not perfect, output a Hall witness $S$ as in Approach B.
\item Build $D$ on $L$: for each $(u,r)\in E$, add arc $u\to v$ where $v=f^{-1}(r)$.
\item Compute SCCs of $D$ (Tarjan/Kosaraju). Build the condensation DAG $P$ (deduplicated).
\item Compute the transitive reduction of $P$ using bitset reachability in reverse topological order; remove any edge implied by another path.
\item Construct $G'$:
  - include all matching edges $(u,f(u))$ for all $u$,
  - for each SCC $C$ of size $s\ge 2$ with vertices $(u_1,\ldots,u_s)$, add edges $(u_i,f(u_{i+1}))$ (indices modulo $s$),
  - for each reduced DAG edge $A\to B$, pick any $u\in A$, $v\in B$ and add the edge $(u,f(v))$.
\item Output $G'$.
\end{algosteps}
\OPTIMALITY{Within an SCC of size $s$, any strongly connected digraph requires at least $s$ arcs; a directed cycle achieves this lower bound. Across SCCs, preserving exactly the same reachability requires at least the transitive reduction edges; any fewer would change the reachability relation and thus the family of forward-closed unions, altering tight sets. Adding the $n$ matching edges ensures goodness (existence of a perfect matching). Hence the construction is edge-minimal among graphs preserving the tight-set family.}
\COMPLEXITY{All steps are near-linear or low polynomial in $n$.}
\[
\begin{aligned}
\text{Matching: }& O(m\sqrt{n}),\\
\text{SCC on }D:& O(n + m),\\
\text{Transitive reduction: }& O(c^2 \cdot W) \text{ with } c\le n,~W\approx \lceil c/ \text{wordsize}\rceil \ (\text{fast via Python ints}),\\
\text{Total: }& O(m\sqrt{n}) \text{ dominated.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from collections import deque

class HopcroftKarp:
    def __init__(self, n_left, n_right, adj):
        self.n = n_left
        self.m = n_right
        self.adj = adj
        self.pairU = [-1] * self.n
        self.pairV = [-1] * self.m
        self.dist = [0] * self.n

    def bfs(self):
        q = deque()
        INF = 10**9
        for u in range(self.n):
            if self.pairU[u] == -1:
                self.dist[u] = 0
                q.append(u)
            else:
                self.dist[u] = INF
        found = False
        while q:
            u = q.popleft()
            for v in self.adj[u]:
                pu = self.pairV[v]
                if pu == -1:
                    found = True
                else:
                    if self.dist[pu] == 10**9:
                        self.dist[pu] = self.dist[u] + 1
                        q.append(pu)
        return found

    def dfs(self, u):
        for v in self.adj[u]:
            pu = self.pairV[v]
            if pu == -1 or (self.dist[pu] == self.dist[u] + 1 and self.dfs(pu)):
                self.pairU[u] = v
                self.pairV[v] = u
                return True
        self.dist[u] = 10**9
        return False

    def max_matching(self):
        res = 0
        while self.bfs():
            for u in range(self.n):
                if self.pairU[u] == -1 and self.dfs(u):
                    res += 1
        return res

def hall_witness_from_matching(n, adj, pairU, pairV):
    visL = [False] * n
    visR = [False] * n
    dq = deque()
    for u in range(n):
        if pairU[u] == -1:
            visL[u] = True
            dq.append(('L', u))
    while dq:
        side, x = dq.popleft()
        if side == 'L':
            u = x
            for v in adj[u]:
                if not visR[v] and pairU[u] != v:
                    visR[v] = True
                    dq.append(('R', v))
        else:
            v = x
            u2 = pairV[v]
            if u2 != -1 and not visL[u2]:
                visL[u2] = True
                dq.append(('L', u2))
    S = [i for i in range(n) if visL[i]]
    # Validate the witness property
    Nset = set()
    for u in S:
        Nset |= set(adj[u])
    assert len(S) > len(Nset)
    return S

def tarjan_scc(n, adj):
    # adj: list of lists for digraph on 0..n-1
    index = 0
    idx = [-1] * n
    low = [0] * n
    onst = [False] * n
    st = []
    comp_id = [-1] * n
    comp_cnt = 0

    def dfs(u):
        nonlocal index, comp_cnt
        idx[u] = low[u] = index
        index += 1
        st.append(u); onst[u] = True
        for v in adj[u]:
            if idx[v] == -1:
                dfs(v)
                low[u] = min(low[u], low[v])
            elif onst[v]:
                low[u] = min(low[u], idx[v])
        if low[u] == idx[u]:
            # root of SCC
            while True:
                w = st.pop()
                onst[w] = False
                comp_id[w] = comp_cnt
                if w == u:
                    break
            comp_cnt += 1

    for u in range(n):
        if idx[u] == -1:
            dfs(u)
    return comp_cnt, comp_id

def transitive_reduction(c, dag_adj):
    # dag_adj: list of sets (neighbors) for condensed DAG with nodes 0..c-1
    # returns list of sets with reduced edges
    # Topological order
    indeg = [0] * c
    for u in range(c):
        for v in dag_adj[u]:
            indeg[v] += 1
    q = deque([u for u in range(c) if indeg[u] == 0])
    topo = []
    while q:
        u = q.popleft()
        topo.append(u)
        for v in dag_adj[u]:
            indeg[v] -= 1
            if indeg[v] == 0:
                q.append(v)
    # Reachability bitsets in reverse topo
    reach = [0] * c  # bit i means reachable node i
    pos = {u:i for i,u in enumerate(topo)}
    for u in reversed(topo):
        mask = 0
        for v in dag_adj[u]:
            mask |= reach[v] | (1 << v)
        reach[u] = mask
    # Reduce edges: u->v is redundant if v is in union of reach[w]|{w} over w in out[u]\{v}
    red = [set() for _ in range(c)]
    for u in range(c):
        outs = list(dag_adj[u])
        if not outs:
            continue
        packs = [(reach[v] | (1 << v)) for v in outs]
        pref = [0] * (len(outs) + 1)
        for i in range(len(outs)):
            pref[i+1] = pref[i] | packs[i]
        suff = [0] * (len(outs) + 1)
        for i in range(len(outs)-1, -1, -1):
            suff[i] = suff[i+1] | packs[i]
        for i, v in enumerate(outs):
            union_wo = (pref[i] | suff[i+1])
            if ((union_wo >> v) & 1) == 0:
                red[u].add(v)
    return red

def build_min_graph(n, edges):
    # edges: list of (u in [0..n-1], v in [0..n-1]) with R mapped to 0..n-1
    # 1) dedup adjacency
    adjL = [set() for _ in range(n)]
    for u, v in edges:
        if 0 <= u < n and 0 <= v < n:
            adjL[u].add(v)
    adj = [sorted(list(s)) for s in adjL]
    # 2) HK
    hk = HopcroftKarp(n, n, adj)
    mm = hk.max_matching()
    if mm < n:
        S = hall_witness_from_matching(n, adj, hk.pairU, hk.pairV)
        return False, S, None
    pairU = hk.pairU
    pairV = hk.pairV
    # 3) Build D on L: u->v if (u, f(v)) is an edge; here f(v) is right of v = pairU[v]
    D = [[] for _ in range(n)]
    for u in range(n):
        for r in adj[u]:
            v = pairV[r]
            # if graph is good, every r is matched, so v != -1
            if v != -1:
                D[u].append(v)
    # 4) SCC
    c, cid = tarjan_scc(n, D)
    comp_vs = [[] for _ in range(c)]
    for u in range(n):
        comp_vs[cid[u]].append(u)
    # 5) Condensation DAG
    dag = [set() for _ in range(c)]
    for u in range(n):
        cu = cid[u]
        for v in D[u]:
            cv = cid[v]
            if cu != cv:
                dag[cu].add(cv)
    # 6) Transitive reduction
    dag_red = transitive_reduction(c, dag)
    # 7) Build G'
    out_edges = set()
    # Always include matching edges (u, pairU[u])
    for u in range(n):
        out_edges.add((u, pairU[u]))
    # Internal SCC cycles for size>=2
    for comp in range(c):
        vs = comp_vs[comp]
        s = len(vs)
        if s >= 2:
            for i in range(s):
                u = vs[i]
                w = vs[(i + 1) % s]
                out_edges.add((u, pairU[w]))
    # Cross-component edges for transitive reduction arcs
    for a in range(c):
        for b in dag_red[a]:
            u = comp_vs[a][0]
            v = comp_vs[b][0]
            out_edges.add((u, pairU[v]))
    # Prepare output in 1-based with R in [n+1..2n]
    out_list = sorted(list(out_edges))
    mprime = len(out_list)
    printable = [(u + 1, v + (n + 1)) for (u, v) in out_list]
    return True, mprime, printable

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        l = int(next(it)) - 1
        r = int(next(it)) - (n + 1)
        edges.append((l, r))
    return n, m, edges

def solve_all():
    n, m, edges = read_input()
    if n == 0 and m == 0 and not edges:
        return
    good, a, b = build_min_graph(n, edges)
    if not good:
        S = a
        print("NO")
        print(len(S))
        print(*[x + 1 for x in S])
    else:
        mprime = a; printable = b
        print("YES")
        print(mprime)
        for l, r in printable:
            print(l, r)

def main():
    solve_all()

if __name__ == "__main__":
    # Deterministic asserts on small cases
    # 1) Not good: S = {1,2} witnesses
    n=2; m=2; edges=[(0,0),(1,0)]
    ok, a, b = build_min_graph(n, edges)
    assert not ok
    S = a
    Nset = set()
    adj = [set() for _ in range(n)]
    for u,v in edges: adj[u].add(v)
    for u in S: Nset |= adj[u]
    assert len(S) > len(Nset)
    # 2) Good chain 1->1, 1->2, 2->2
    n=2; edges=[(0,0),(0,1),(1,1)]
    ok, mprime, pr = build_min_graph(n, edges)
    assert ok and mprime >= 2
    # 3) Good with three nodes forming chain of SCC DAG
    n=3; edges=[(0,0),(1,1),(2,2),(0,1),(1,2)]
    ok, mprime, pr = build_min_graph(n, edges)
    assert ok
    # Keep main for execution
    pass
\end{minted}
\VALIDATION{Exactly 3 asserts:
1) Hall witness truly violates $|S|\le |N(S)|$.
2) Simple good instance produces a nonzero minimal graph.
3) A chained good instance is accepted and minimized.}
\RESULT{If the input graph is not good, the algorithm outputs a Hall-violating subset $S \subseteq L$. If it is good, it outputs a minimal-edge $G'$ that preserves and only preserves the tight subsets of $L$ (same SCCs and reachability in the exchange digraph).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small graphs: isolated deficiency; trivial perfect matching; chains; multi-vertex SCCs; random small graphs compared between original and minimized via recomputed exchange digraphs.}
\LINE{CROSS-CHECKS}{For random small good graphs, verify that the SCC partition and condensation reachability of $D$ match between $G$ and $G'$.}
\LINE{EDGE-CASE GENERATOR}{Generate graphs with: empty edge set; full bipartite; stars; cycles; duplicated edges; disjoint SCCs and singletons.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_star_bad(n):
    # All left connect to only right 0
    edges = []
    for u in range(n):
        edges.append((u, 0))
    return n, len(edges), edges

def gen_perfect_matching(n):
    edges = [(i, i) for i in range(n)]
    return n, n, edges

def gen_chain_good(n):
    edges = [(i, i) for i in range(n)]
    for i in range(n - 1):
        edges.append((i, i + 1))
    return n, len(edges), edges

def run_quick_checks():
    # Bad star
    n, m, edges = gen_star_bad(4)
    ok, a, b = build_min_graph(n, edges)
    assert not ok
    # Perfect matching
    n, m, edges = gen_perfect_matching(5)
    ok, a, b = build_min_graph(n, edges)
    assert ok and a == 5
    # Chain good
    n, m, edges = gen_chain_good(5)
    ok, a, b = build_min_graph(n, edges)
    assert ok

if __name__ == "__main__":
    run_quick_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

class HopcroftKarp:
    def __init__(self, n_left, n_right, adj):
        self.n = n_left
        self.m = n_right
        self.adj = adj
        self.pairU = [-1] * self.n
        self.pairV = [-1] * self.m
        self.dist = [0] * self.n

    def bfs(self):
        q = deque()
        INF = 10**9
        for u in range(self.n):
            if self.pairU[u] == -1:
                self.dist[u] = 0
                q.append(u)
            else:
                self.dist[u] = INF
        found = False
        while q:
            u = q.popleft()
            for v in self.adj[u]:
                pu = self.pairV[v]
                if pu == -1:
                    found = True
                else:
                    if self.dist[pu] == 10**9:
                        self.dist[pu] = self.dist[u] + 1
                        q.append(pu)
        return found

    def dfs(self, u):
        for v in self.adj[u]:
            pu = self.pairV[v]
            if pu == -1 or (self.dist[pu] == self.dist[u] + 1 and self.dfs(pu)):
                self.pairU[u] = v
                self.pairV[v] = u
                return True
        self.dist[u] = 10**9
        return False

    def max_matching(self):
        res = 0
        while self.bfs():
            for u in range(self.n):
                if self.pairU[u] == -1 and self.dfs(u):
                    res += 1
        return res

def hall_witness_from_matching(n, adj, pairU, pairV):
    visL = [False] * n
    visR = [False] * n
    dq = deque()
    for u in range(n):
        if pairU[u] == -1:
            visL[u] = True
            dq.append(('L', u))
    while dq:
        side, x = dq.popleft()
        if side == 'L':
            u = x
            for v in adj[u]:
                if not visR[v] and pairU[u] != v:
                    visR[v] = True
                    dq.append(('R', v))
        else:
            v = x
            u2 = pairV[v]
            if u2 != -1 and not visL[u2]:
                visL[u2] = True
                dq.append(('L', u2))
    S = [i for i in range(n) if visL[i]]
    # Validate the witness property
    Nset = set()
    for u in S:
        Nset |= set(adj[u])
    assert len(S) > len(Nset)
    return S

def tarjan_scc(n, adj):
    index = 0
    idx = [-1] * n
    low = [0] * n
    onst = [False] * n
    st = []
    comp_id = [-1] * n
    comp_cnt = 0

    sys.setrecursionlimit(1000000)

    def dfs(u):
        nonlocal index, comp_cnt
        idx[u] = low[u] = index
        index += 1
        st.append(u); onst[u] = True
        for v in adj[u]:
            if idx[v] == -1:
                dfs(v)
                low[u] = min(low[u], low[v])
            elif onst[v]:
                low[u] = min(low[u], idx[v])
        if low[u] == idx[u]:
            while True:
                w = st.pop()
                onst[w] = False
                comp_id[w] = comp_cnt
                if w == u:
                    break
            comp_cnt += 1

    for u in range(n):
        if idx[u] == -1:
            dfs(u)
    return comp_cnt, comp_id

def transitive_reduction(c, dag_adj):
    indeg = [0] * c
    for u in range(c):
        for v in dag_adj[u]:
            indeg[v] += 1
    q = deque([u for u in range(c) if indeg[u] == 0])
    topo = []
    while q:
        u = q.popleft()
        topo.append(u)
        for v in dag_adj[u]:
            indeg[v] -= 1
            if indeg[v] == 0:
                q.append(v)
    reach = [0] * c
    for u in reversed(topo):
        mask = 0
        for v in dag_adj[u]:
            mask |= reach[v] | (1 << v)
        reach[u] = mask
    red = [set() for _ in range(c)]
    for u in range(c):
        outs = list(dag_adj[u])
        if not outs:
            continue
        packs = [(reach[v] | (1 << v)) for v in outs]
        pref = [0] * (len(outs) + 1)
        for i in range(len(outs)):
            pref[i+1] = pref[i] | packs[i]
        suff = [0] * (len(outs) + 1)
        for i in range(len(outs)-1, -1, -1):
            suff[i] = suff[i+1] | packs[i]
        for i, v in enumerate(outs):
            union_wo = (pref[i] | suff[i+1])
            if ((union_wo >> v) & 1) == 0:
                red[u].add(v)
    return red

def build_min_graph(n, edges):
    adjL = [set() for _ in range(n)]
    for u, v in edges:
        if 0 <= u < n and 0 <= v < n:
            adjL[u].add(v)
    adj = [sorted(list(s)) for s in adjL]
    hk = HopcroftKarp(n, n, adj)
    mm = hk.max_matching()
    if mm < n:
        S = hall_witness_from_matching(n, adj, hk.pairU, hk.pairV)
        return False, S, None
    pairU = hk.pairU
    pairV = hk.pairV
    D = [[] for _ in range(n)]
    for u in range(n):
        for r in adj[u]:
            v = pairV[r]
            if v != -1:
                D[u].append(v)
    c, cid = tarjan_scc(n, D)
    comp_vs = [[] for _ in range(c)]
    for u in range(n):
        comp_vs[cid[u]].append(u)
    dag = [set() for _ in range(c)]
    for u in range(n):
        cu = cid[u]
        for v in D[u]:
            cv = cid[v]
            if cu != cv:
                dag[cu].add(cv)
    dag_red = transitive_reduction(c, dag)
    out_edges = set()
    for u in range(n):
        out_edges.add((u, pairU[u]))
    for comp in range(c):
        vs = comp_vs[comp]
        s = len(vs)
        if s >= 2:
            for i in range(s):
                u = vs[i]
                w = vs[(i + 1) % s]
                out_edges.add((u, pairU[w]))
    for a in range(c):
        for b in dag_red[a]:
            u = comp_vs[a][0]
            v = comp_vs[b][0]
            out_edges.add((u, pairU[v]))
    out_list = sorted(list(out_edges))
    mprime = len(out_list)
    printable = [(u + 1, v + (n + 1)) for (u, v) in out_list]
    return True, mprime, printable

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        l = int(next(it)) - 1
        r = int(next(it)) - (n + 1)
        edges.append((l, r))
    return n, m, edges

def solve_all():
    n, m, edges = read_input()
    if n == 0 and m == 0 and not edges:
        return
    good, a, b = build_min_graph(n, edges)
    if not good:
        S = a
        print("NO")
        print(len(S))
        print(*[x + 1 for x in S])
    else:
        mprime = a; printable = b
        print("YES")
        print(mprime)
        for l, r in printable:
            print(l, r)

def main():
    solve_all()

if __name__ == "__main__":
    # Tests (not executed by CF judge unless run locally)
    # 1) Bad star
    n=3; edges=[(0,0),(1,0),(2,0)]
    ok, a, b = build_min_graph(n, edges)
    assert not ok
    # 2) Perfect matching minimal
    n=3; edges=[(0,0),(1,1),(2,2)]
    ok, mprime, pr = build_min_graph(n, edges)
    assert ok and mprime == 3
    # 3) Chain 1->2->3
    n=3; edges=[(0,0),(1,1),(2,2),(0,1),(1,2)]
    ok, mprime, pr = build_min_graph(n, edges)
    assert ok and mprime >= 5
    # Keep ready for submission
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check perfect matching; if not, output a Hall witness. If yes, compress alternating structure to $D$, keep SCCs and transitive reduction to minimize edges in $G'$.}
\WHY{This pattern appears in advanced matching/structure problems: preserve tight sets (flats) of a transversal matroid induced by a bipartite graph.}
\CHECKLIST{
- Deduplicate edges on input.
- Hopcroft–Karp to get perfect matching.
- If bad, BFS alternating graph to get $Z_L$ as witness $S$.
- Build exchange digraph $D$ via matching inverse.
- Compute SCCs and condensation DAG.
- Transitive reduction via bitset reachability.
- Emit $G'$: all matching edges, SCC cycles, reduced inter-component edges.}
\EDGECASES{
- Empty graph ($m=0$) $\Rightarrow$ not good unless $n=0$.
- Parallel edges; ignore duplicates.
- Single-vertex SCCs (no extra internal edges needed).
- Fully connected bipartite graph.
- Disconnected components on $L$ or $R$.}
\PITFALLS{
- Wrong mapping of right labels $r \mapsto r-(n+1)$.
- Forgetting to include matching edges in $G'$.
- Building $D$ with wrong direction; must use $(u,f(v))$.
- Tarjan recursion depth; but $n \le 10^3$ is safe.
- Transitive reduction mistakes; use bitset union excluding the edge under test.
- Duplicated output edges; use a set to deduplicate.}
\FAILMODES{Naive removal of edges may break SCCs or alter reachability, changing the tight-set family. The presented method preserves exactly the SCC partition and reachability closure, hence the family is unchanged.}
\ELI{Find a perfect matching. Then think of each right vertex as the ``name'' of its matched left. Turn each original edge into a directed edge between left vertices. Groups of left vertices mutually reachable form components; only the way these components can reach each other matters. Keep a simple cycle inside each group and just enough edges between groups to preserve who can reach whom.}
\NotePages{3}

\end{document}