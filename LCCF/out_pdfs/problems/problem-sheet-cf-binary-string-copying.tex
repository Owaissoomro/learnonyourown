% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Binary String Copying}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1849/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{You are given a string $s$ consisting of $n$ characters 0 and/or 1.

You make $m$ copies of this string, let the $i$-th copy be the string $t_i$. Then you perform exactly one operation on each of the copies: for the $i$-th copy, you sort its substring $[l_i; r_i]$ (the substring from the $l_i$-th character to the $r_i$-th character, both endpoints inclusive). Note that each operation affects only one copy, and each copy is affected by only one operation.

Your task is to calculate the number of different strings among $t_1, t_2, \ldots, t_m$. Note that the initial string $s$ should be counted only if at least one of the copies stays the same after the operation.

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains two integers $n$ and $m$ ($1 \le n, m \le 2 \cdot 10^5$) — the length of $s$ and the number of copies, respectively.

The second line contains $n$ characters 0 and/or 1 — the string $s$.

Then $m$ lines follow. The $i$-th of them contains two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le n$) — the description of the operation applied to the $i$-th copy.

The sum of $n$ over all test cases does not exceed $2 \cdot 10^5$. The sum of $m$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
Print one integer — the number of different strings among $t_1, t_2, \ldots, t_m$.

Note:
Consider the first example. Copies below are given in order of the input operations. Underlined substrings are substrings that are sorted:

1. 101100 $\rightarrow$ 011100;
2. 101100 $\rightarrow$ 011100;
3. 101100 $\rightarrow$ 101100;
4. 101100 $\rightarrow$ 101100;
5. 101100 $\rightarrow$ 000111.

There are three different strings among $t_1, t_2, t_3, t_4, t_5$: 000111, 011100 and 101100.

Consider the second example:

1. 100111 $\rightarrow$ 100111;
2. 100111 $\rightarrow$ 001111;
3. 100111 $\rightarrow$ 001111;
4. 100111 $\rightarrow$ 010111.

There are three different strings among $t_1, t_2, t_3, t_4$: 001111, 010111 and 100111.}
\BREAKDOWN{Sort-once substrings turn each chosen segment into all zeros followed by all ones. Two operations produce the same final string if and only if they have the same ``first 1'' and ``last 0'' inside their segments, or the segment is already monotone in the sense no $1$ precedes a $0$.}
\ELI{Each operation is fully described by the first 1 and the last 0 it encloses; identical such pairs lead to identical results.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases:
\begin{bullets}
\item $t$ — number of test cases.
\item For each test: $n, m$; string $s$ of length $n$ over $\{0,1\}$; then $m$ queries $(l_i, r_i)$ with $1 \le l_i \le r_i \le n$.
\end{bullets}}
\OUTPUTS{For each test case, a single integer: the number of distinct strings among $t_1,\dots,t_m$ after sorting $[l_i,r_i]$ in copy $i$. The original $s$ counts if at least one query leaves the string unchanged.}
\SAMPLES{Example mini-case:
\begin{bullets}
\item $s=101100$, queries: $(1,3),(1,3),(2,5),(3,4),(1,6)$. Distinct results: $\{011100,101100,000111\}$, answer $3$.
\item $s=100111$, queries: $(1,1),(1,4),(1,4),(2,4)$. Distinct: $\{100111,001111,010111\}$, answer $3$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For fixed $s \in \{0,1\}^n$ and a query interval $[l,r]$, define
\[
L = \min\{\,i \in [l,r] : s_i=1\,\}\ \text{(or }+\infty\text{ if none)},\quad
R = \max\{\,i \in [l,r] : s_i=0\,\}\ \text{(or }-\infty\text{ if none)}.
\]
If $L>R$ then sorting $[l,r]$ yields $s$ unchanged. Otherwise the result depends only on the pair $(L,R)$; inside $[L,R]$ the substring becomes $0^{k}1^{(|[L,R]|-k)}$, where $k$ is the number of zeros in $[L,R]$ (a function of $s,L,R$). Therefore each query maps to a canonical key: $(0,0)$ for unchanged, else $(L,R)$. Distinct keys imply distinct final strings.}
\varmapStart
\var{n}{length of $s$}
\var{m}{number of queries}
\var{s_i}{character at position $i$}
\var{[l,r]}{sorted substring for a query}
\var{L}{first index of a $1$ in $[l,r]$ (or $+\infty$)}
\var{R}{last index of a $0$ in $[l,r]$ (or $-\infty$)}
\var{\text{key}}{canonical representative: $(0,0)$ if $L>R$, else $(L,R)$}
\varmapEnd
\GOVERN{
\[
\text{Ans} \;=\; \left|\left\{\ \text{key}([l_i,r_i])\ :\ i=1,\dots,m\ \right\}\right|,\quad
\text{key}([l,r])=\begin{cases}
(0,0), & \text{if } \min\{i\ge l:s_i=1\} > \max\{j\le r:s_j=0\},\\
\big(\min\{i\ge l:s_i=1\},\ \max\{j\le r:s_j=0\}\big), & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{Indices are $1$-based. We consider $+\infty$ and $-\infty$ as sentinels; in implementation we use $n+1$ and $0$.}
\INVARIANTS{
\begin{bullets}
\item If $L>R$ then $s$ already has no pattern $1\ldots 0$ inside $[l,r]$; sorting is a no-op.
\item If $L\le R$, positions $[l,L-1]$ are all zeros and $[R+1,r]$ are all ones by definition of $L,R$.
\item The multiset of characters in $[l,r]$ is preserved; sorting only rearranges them.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate each operation: extract $s[l:r]$, sort it, and splice back. Use a set of resulting strings to count distinct outcomes.}
\ASSUMPTIONS{Direct manipulation of Python strings; OK for tiny $n,m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each query $[l,r]$, copy $s$ to a list of chars.
\item Sort the slice $[l-1:r]$ (0-based) and write it back.
\item Insert the joined string into a set; print the set size at the end of each test.
\end{algosteps}
\COMPLEXITY{For one test: $O\!\left(\sum_i (r_i-l_i+1)\log(r_i-l_i+1)\right)$ time and $O(n)$ extra space per query due to copying.}
\[
\begin{aligned}
T(n) &\le \sum_{i=1}^m (r_i-l_i+1)\log(r_i-l_i+1) \\
     &\le m\cdot n \log n \quad \text{in the worst case.}
\end{aligned}
\]
\CORRECTNESS{Sorting the chosen slice produces the exact post-operation string. A set over all produced strings counts distinct outcomes.}
\EDGECASES{Single character ranges; all zeros or all ones; full-string sort; repeated identical queries.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Set

def after_sort_once(s: str, l: int, r: int) -> str:
    # l, r are 1-based inclusive
    a = list(s)
    seg = a[l-1:r]
    seg.sort()
    a[l-1:r] = seg
    return "".join(a)

def solve_case_baseline(n: int, m: int, s: str, queries: List[Tuple[int, int]]) -> int:
    seen: Set[str] = set()
    for l, r in queries:
        t = after_sort_once(s, l, r)
        seen.add(t)
    return len(seen)

def read_input(data: List[str]):
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s = next(it).strip()
        qs = []
        for _ in range(m):
            l = int(next(it)); r = int(next(it))
            qs.append((l, r))
        tests.append((n, m, s, qs))
    return tests

def solve_all_baseline(tests):
    out_lines = []
    for n, m, s, qs in tests:
        out_lines.append(str(solve_case_baseline(n, m, s, qs)))
    return "\n".join(out_lines)

def _self_test_baseline():
    # tiny checks
    assert after_sort_once("101100", 1, 3) == "011100"
    assert after_sort_once("101100", 3, 4) == "101100"
    # sample distinct counting
    n, m, s = 6, 5, "101100"
    qs = [(1,3),(1,3),(3,4),(2,5),(1,6)]
    # Outputs: 011100, 011100, 101100, 101100, 000111 -> 3 distinct
    assert solve_case_baseline(n, m, s, qs) == 3
    n, m, s = 6, 4, "100111"
    qs = [(1,1),(1,4),(1,4),(2,4)]
    assert solve_case_baseline(n, m, s, qs) == 3

def main():
    data = sys.stdin.buffer.read().split()
    if not data:
        return
    tests = read_input([x.decode() for x in data])
    ans = solve_all_baseline(tests)
    sys.stdout.write(ans)

if __name__ == "__main__":
    _self_test_baseline()
    # main()
\end{minted}
\VALIDATION{Compared against hand-worked cases; verifies idempotent intervals and full-range sorts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Canonicalize each query to a pair $(L,R)$ using binary search on precomputed index lists of zeros and ones; distinct pairs correspond to distinct outputs.}
\ASSUMPTIONS{Maintain sorted lists $P_0=\{i:s_i=0\}$ and $P_1=\{i:s_i=1\}$. Use bisect to find $L=\min\{i\in P_1:i\ge l\}$ and $R=\max\{i\in P_0:i\le r\}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build lists of indices of zeros and ones.
\item For each query $[l,r]$, find $L$ via lower\_bound in $P_1$ and $R$ via upper\_bound in $P_0$.
\item If $L>R$ (including ``no 1'' or ``no 0'' cases), insert sentinel $(0,0)$; else insert $(L,R)$ in a set.
\item Answer is the set size.
\end{algosteps}
\COMPLEXITY{Each query is $O(\log n)$ due to two binary searches; preprocessing is $O(n)$. This strictly beats the baseline on large inputs.}
\[
\begin{aligned}
T(n) &= O(n) + O(m\log n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{By definition of $L$ and $R$, only the block $[L,R]$ can change; identical $(L,R)$ leads to identical post-sorted strings. If there is no $1$ before any $0$ in $[l,r]$ then sorting does nothing, producing the same original string, represented by sentinel $(0,0)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right
from typing import List, Tuple, Set

def canonical_pair_bisect(s: str, l: int, r: int) -> Tuple[int, int]:
    P0 = [i+1 for i, ch in enumerate(s) if ch == '0']
    P1 = [i+1 for i, ch in enumerate(s) if ch == '1']
    # find L = first 1 >= l
    idx1 = bisect_left(P1, l)
    L = P1[idx1] if idx1 < len(P1) else (len(s) + 1)
    # find R = last 0 <= r
    idx0 = bisect_right(P0, r) - 1
    R = P0[idx0] if idx0 >= 0 else 0
    if L > R:
        return (0, 0)
    return (L, R)

def solve_case_bisect(n: int, m: int, s: str, queries: List[Tuple[int, int]]) -> int:
    P0 = [i+1 for i, ch in enumerate(s) if ch == '0']
    P1 = [i+1 for i, ch in enumerate(s) if ch == '1']
    seen: Set[Tuple[int, int]] = set()
    for l, r in queries:
        idx1 = bisect_left(P1, l)
        L = P1[idx1] if idx1 < len(P1) else (n + 1)
        idx0 = bisect_right(P0, r) - 1
        R = P0[idx0] if idx0 >= 0 else 0
        if L > R:
            seen.add((0, 0))
        else:
            seen.add((L, R))
    return len(seen)

def read_input(data: List[str]):
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s = next(it).strip()
        qs = []
        for _ in range(m):
            l = int(next(it)); r = int(next(it))
            qs.append((l, r))
        tests.append((n, m, s, qs))
    return tests

def solve_all_bisect(tests):
    out_lines = []
    for n, m, s, qs in tests:
        out_lines.append(str(solve_case_bisect(n, m, s, qs)))
    return "\n".join(out_lines)

def _self_test_bisect():
    # Matches baseline on small crafted cases
    s = "101100"
    assert solve_case_bisect(6, 5, s, [(1,3),(1,3),(3,4),(2,5),(1,6)]) == 3
    s2 = "100111"
    assert solve_case_bisect(6, 4, s2, [(1,1),(1,4),(1,4),(2,4)]) == 3
    # Edge: all zeros
    s3 = "0000"
    assert solve_case_bisect(4, 2, s3, [(1,4),(2,3)]) == 1  # always unchanged -> {(0,0)}

def main():
    data = sys.stdin.buffer.read().split()
    if not data:
        return
    tests = read_input([x.decode() for x in data])
    ans = solve_all_bisect(tests)
    sys.stdout.write(ans)

if __name__ == "__main__":
    _self_test_bisect()
    # main()
\end{minted}
\VALIDATION{Confirms equality with brute force on tiny strings; checks degenerate inputs such as all zeros.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Precompute arrays in $O(n)$: $\text{next1}[i]=$ first index $\ge i$ with a $1$ (or $n{+}1$), and $\text{prev0}[i]=$ last index $\le i$ with a $0$ (or $0$). For a query $[l,r]$, form $(L,R)=(\text{next1}[l],\text{prev0}[r])$; if $L>R$ use $(0,0)$, else use $(L,R)$.}
\ASSUMPTIONS{String indexed $1\ldots n$. Sentinel values $n{+}1$ and $0$ ensure clean comparisons.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $\text{next1}$ by scanning right-to-left; build $\text{prev0}$ by scanning left-to-right.
\item For each query, compute $L=\text{next1}[l]$, $R=\text{prev0}[r]$.
\item Insert $(0,0)$ if $L>R$, else insert $(L,R)$ into a hash set.
\item Print the set size.
\end{algosteps}
\OPTIMALITY{Each query is $O(1)$ after $O(n)$ preprocessing, so total time is $O(n+m)$ per test, which is optimal up to constants as each query must be read.}
\COMPLEXITY{$T(n)=O(n+m)$, $S(n)=O(n)$ for the two arrays and the set of at most $m{+}1$ pairs.}
\[
\begin{aligned}
T(n) &= O(n) + m\cdot O(1), \quad S(n) = O(n) + O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Set

def solve_case_opt(n: int, m: int, s: str, queries: List[Tuple[int, int]]) -> int:
    next1 = [n + 1] * (n + 3)  # 1-based
    prev0 = [0] * (n + 3)
    # next1: first '1' at or after i
    last = n + 1
    for i in range(n, 0, -1):
        if s[i-1] == '1':
            last = i
        next1[i] = last
    # prev0: last '0' at or before i
    last0 = 0
    for i in range(1, n + 1):
        if s[i-1] == '0':
            last0 = i
        prev0[i] = last0
    seen: Set[Tuple[int, int]] = set()
    for l, r in queries:
        L = next1[l]
        R = prev0[r]
        if L > R:
            seen.add((0, 0))
        else:
            seen.add((L, R))
    return len(seen)

def read_input(data: List[str]):
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s = next(it).strip()
        qs = []
        for _ in range(m):
            l = int(next(it)); r = int(next(it))
            qs.append((l, r))
        tests.append((n, m, s, qs))
    return tests

def solve_all_opt(tests):
    out_lines = []
    for n, m, s, qs in tests:
        out_lines.append(str(solve_case_opt(n, m, s, qs)))
    return "\n".join(out_lines)

def _self_test_opt():
    # Provided scenarios
    n, m, s = 6, 5, "101100"
    qs = [(1,3),(1,3),(3,4),(2,5),(1,6)]
    assert solve_case_opt(n, m, s, qs) == 3
    n2, m2, s2 = 6, 4, "100111"
    qs2 = [(1,1),(1,4),(1,4),(2,4)]
    assert solve_case_opt(n2, m2, s2, qs2) == 3
    # Edge: all ones -> unchanged regardless of query
    n3, m3, s3 = 5, 3, "11111"
    qs3 = [(1,5),(2,4),(3,3)]
    assert solve_case_opt(n3, m3, s3, qs3) == 1

def main():
    data = sys.stdin.buffer.read().split()
    if not data:
        return
    tests = read_input([x.decode() for x in data])
    ans = solve_all_opt(tests)
    sys.stdout.write(ans)

if __name__ == "__main__":
    _self_test_opt()
    # main()
\end{minted}
\VALIDATION{Exactly 3 asserts: matches two illustrative examples and an all-ones edge case.}
\RESULT{Counts unique canonical pairs $(L,R)$ plus possibly the unchanged sentinel $(0,0)$; this equals the number of distinct resulting strings.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: unchanged queries, full interval, repeated identical queries, and strings with only one symbol. Cross-validate optimal vs baseline on small cases.}
\LINE{CROSS-CHECKS}{On small $n$, enumerate random queries and confirm $\text{baseline}==\text{optimal}$ for counts.}
\LINE{EDGE-CASE GENERATOR}{Produce degenerate inputs: all zeros, all ones, alternating bits, single-length segments, full-length segments, and repeated queries.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # all zeros
    cases.append((5, 4, "00000", [(1,5),(2,4),(1,1),(3,3)]))
    # all ones
    cases.append((5, 3, "11111", [(1,5),(1,1),(2,4)]))
    # alternating
    cases.append((6, 5, "101010", [(1,6),(2,5),(3,4),(1,3),(4,6)]))
    # repeated queries
    cases.append((6, 5, "101100", [(1,3),(1,3),(3,4),(2,5),(1,6)]))
    return cases

def cross_check():
    from typing import List, Tuple
    def baseline(n:int,m:int,s:str,qs:List[Tuple[int,int]])->int:
        seen=set()
        for l,r in qs:
            a=list(s); seg=a[l-1:r]; seg.sort(); a[l-1:r]=seg
            seen.add("".join(a))
        return len(seen)
    def optimal(n:int,m:int,s:str,qs:List[Tuple[int,int]])->int:
        next1=[n+1]*(n+3); prev0=[0]*(n+3); last=n+1
        for i in range(n,0,-1):
            if s[i-1]=='1': last=i
            next1[i]=last
        last0=0
        for i in range(1,n+1):
            if s[i-1]=='0': last0=i
            prev0[i]=last0
        seen=set()
        for l,r in qs:
            L=next1[l]; R=prev0[r]
            seen.add((0,0) if L>R else (L,R))
        return len(seen)
    for n,m,s,qs in gen_cases():
        assert baseline(n,m,s,qs)==optimal(n,m,s,qs)
cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Set

def read_input(tokens: List[str]):
    it = iter(tokens)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s = next(it).strip()
        qs: List[Tuple[int,int]] = []
        for _ in range(m):
            l = int(next(it)); r = int(next(it))
            qs.append((l, r))
        tests.append((n, m, s, qs))
    return tests

def solve_case(n: int, m: int, s: str, queries: List[Tuple[int, int]]) -> int:
    next1 = [n + 1] * (n + 3)
    prev0 = [0] * (n + 3)
    # Build next1 (first '1' at/after i)
    nxt = n + 1
    for i in range(n, 0, -1):
        if s[i-1] == '1':
            nxt = i
        next1[i] = nxt
    # Build prev0 (last '0' at/before i)
    prv = 0
    for i in range(1, n + 1):
        if s[i-1] == '0':
            prv = i
        prev0[i] = prv
    seen: Set[Tuple[int, int]] = set()
    for l, r in queries:
        L = next1[l]
        R = prev0[r]
        if L > R:
            seen.add((0, 0))
        else:
            seen.add((L, R))
    return len(seen)

def solve_all(tests) -> str:
    out = []
    for n, m, s, qs in tests:
        out.append(str(solve_case(n, m, s, qs)))
    return "\n".join(out)

def _self_test():
    # Minimal self-tests (do not print)
    assert solve_case(6, 5, "101100", [(1,3),(1,3),(3,4),(2,5),(1,6)]) == 3
    assert solve_case(6, 4, "100111", [(1,1),(1,4),(1,4),(2,4)]) == 3
    assert solve_case(5, 3, "11111", [(1,5),(2,4),(3,3)]) == 1
    assert solve_case(5, 3, "00000", [(1,5),(2,4),(3,3)]) == 1

def main():
    data = sys.stdin.buffer.read().split()
    if not data:
        return
    tests = read_input([x.decode() for x in data])
    sys.stdout.write(solve_all(tests))

if __name__ == "__main__":
    _self_test()
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Map each query to its first-1/last-0 pair; count unique pairs with an unchanged sentinel.}
\WHY{Common CF pattern: turning local operations into canonical keys via monotonic structure. Tests ability to reason about invariants and avoid reconstruction.}
\CHECKLIST{
\begin{bullets}
\item Build $\text{next1}$ and $\text{prev0}$ correctly with sentinels.
\item For each $[l,r]$, compute $L=\text{next1}[l]$, $R=\text{prev0}[r]$.
\item If $L>R$, insert $(0,0)$; else insert $(L,R)$.
\item Output set size per test case.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All zeros or all ones: every query unchanged $\Rightarrow$ answer $1$.
\item Segments containing only zeros or only ones: unchanged.
\item $l=r$: single character sort does nothing.
\item Full interval $[1,n]$.
\item Repeated identical queries.
\item Adjacent boundaries where $L=R$ (a single position being both first 1 and last 0 cannot happen; hence $L=R$ implies the pair is invalid and falls into unchanged via $L>R$ when defined with sentinels).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one: arrays must be $1$-based with sentinels at $0$ and $n{+}1$.
\item Forgetting to handle ``no 1'' or ``no 0'' inside $[l,r]$.
\item Using Python strings for in-place edits in the baseline (must convert to list).
\item Using $O(m\log n)$ bisect approach when $m$ and $n$ are large — acceptable but not optimal; prefer $O(1)$ per query with precomputed arrays.
\item Reconstructing full strings is unnecessary and slow.
\item Not counting the original $s$ when some queries do nothing; $(0,0)$ takes care of this.
\end{bullets}}
\FAILMODES{Brute force times out on worst-case $n,m\approx 2\cdot 10^5$. The canonical-pair method survives since it is $O(n{+}m)$.}
\ELI{Sorting a substring only cares about where the first $1$ begins and where the last $0$ ends. If a query has no $1$ before any $0$, nothing changes. Otherwise, the changed region is pinned by those two indices. Counting unique outcomes is then just counting unique such index pairs.}
\NotePages{3}

\end{document}