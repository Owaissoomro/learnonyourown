% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Matrix Cells in Distance Order}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/matrix-cells-in-distance-order/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given four integers $rows$, $cols$, $rCenter$, and $cCenter$. There is a $rows \times cols$ matrix and you are on the cell with the coordinates $(rCenter, cCenter)$. Return the coordinates of all cells in the matrix, sorted by their \emph{distance} from $(rCenter, cCenter)$ from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition.

The distance between two cells $(r_1, c_1)$ and $(r_2, c_2)$ is $|r_1 - r_2| + |c_1 - c_2|$.

Example 1:

Input: $rows = 1$, $cols = 2$, $rCenter = 0$, $cCenter = 0$.

Output: $[[0,0],[0,1]]$.

Explanation: The distances from $(0,0)$ to other cells are $[0,1]$.

Example 2:

Input: $rows = 2$, $cols = 2$, $rCenter = 0$, $cCenter = 1$.

Output: $[[0,1],[0,0],[1,1],[1,0]]$.

Explanation: The distances from $(0,1)$ to other cells are $[0,1,1,2]$. The answer $[[0,1],[1,1],[0,0],[1,0]]$ would also be accepted as correct.

Example 3:

Input: $rows = 2$, $cols = 3$, $rCenter = 1$, $cCenter = 2$.

Output: $[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]$.

Explanation: The distances from $(1,2)$ to other cells are $[0,1,1,2,2,3]$. There are other answers that would also be accepted as correct, such as $[[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]$.

Constraints:
\begin{bullets}
\item $1 \le rows, cols \le 100$.
\item $0 \le rCenter < rows$.
\item $0 \le cCenter < cols$.
\end{bullets}
}
\BREAKDOWN{Compute Manhattan distances from the given center to all grid cells and return all coordinates in nondecreasing distance order. Any tie-breaking is acceptable.}
\ELI{List all grid cells starting from the center and moving outward by Manhattan distance.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $rows$, $cols$, $rCenter$, $cCenter$ with $1 \le rows, cols \le 100$ and $0 \le rCenter < rows$, $0 \le cCenter < cols$.}
\OUTPUTS{A list of $rows \times cols$ pairs $[r,c]$ containing every cell in the grid exactly once, ordered such that the sequence of distances $|r - rCenter| + |c - cCenter|$ is nondecreasing.}
\SAMPLES{
Example A: $rows=1$, $cols=2$, $rCenter=0$, $cCenter=0$ $\to$ $[[0,0],[0,1]]$.

Example B: $rows=2$, $cols=3$, $rCenter=1$, $cCenter=1$ $\to$ one valid answer is $[[1,1],[0,1],[1,0],[1,2],[0,0],[0,2]]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the grid be the set $G = \{0,\ldots,rows-1\} \times \{0,\ldots,cols-1\}$. Fix center $(r_0,c_0)=(rCenter,cCenter)$. Define the Manhattan distance $d((r,c),(r_0,c_0)) = |r-r_0|+|c-c_0|$. The task is to output a permutation of $G$ that is nondecreasing with respect to $d(\cdot,(r_0,c_0))$.}
\varmapStart
\var{rows}{number of rows}
\var{cols}{number of columns}
\var{(r_0,c_0)}{center cell $(rCenter,cCenter)$}
\var{d(r,c)}{Manhattan distance to $(r_0,c_0)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Output } \pi = \bigl[(r_1,c_1),\ldots,(r_{N},c_{N})\bigr],\; N=rows\cdot cols,\;\text{such that}
\end{BreakableEquation*}
\begin{BreakableEquation*}
\{(r_i,c_i)\}_{i=1}^{N}=G\quad\text{and}\quad d(r_i,c_i) \le d(r_{i+1},c_{i+1})\ \text{for all } i\in\{1,\ldots,N-1\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are zero-based; grid is rectangular; all inputs satisfy the constraints ensuring feasibility.}
\INVARIANTS{
\begin{bullets}
\item Distances are nonnegative integers; maximum possible distance is $(rows-1)+(cols-1)$.
\item Each cell appears exactly once in the output.
\item Any two cells at the same distance may appear in any relative order.
\end{bullets}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $rows \times cols$ coordinates and sort them by key $d(r,c)=|r-rCenter|+|c-cCenter|$.}
\ASSUMPTIONS{Python's Timsort is $O(n\log n)$ and stable; any consistent tie-breaking is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate list $L$ of all pairs $(r,c)$ for $r\in[0,rows)$ and $c\in[0,cols)$.
\item Sort $L$ by key $|r-rCenter|+|c-cCenter|$.
\item Return the sorted list.
\end{algosteps}
\COMPLEXITY{Let $N=rows\cdot cols$. Generating $L$ is $O(N)$; sorting dominates.}
\[
\begin{aligned}
T(N) &= O(N \log N),\\
S(N) &= O(N).
\end{aligned}
\]
\CORRECTNESS{Sorting by the Manhattan distance yields a nondecreasing sequence by definition; enumeration covers all cells exactly once.}
\EDGECASES{Single cell grids; single row or single column; center at a corner or in the middle.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import collections

class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:
        def dist(r: int, c: int) -> int:
            return abs(r - rCenter) + abs(c - cCenter)
        cells = [[r, c] for r in range(rows) for c in range(cols)]
        cells.sort(key=lambda rc: abs(rc[0] - rCenter) + abs(rc[1] - cCenter))
        return cells

# Helpers for validation
def _is_valid(rows: int, cols: int, r0: int, c0: int, ans: List[List[int]]) -> bool:
    if len(ans) != rows * cols:
        return False
    seen = set()
    prev = -1
    for rc in ans:
        if not isinstance(rc, list) or len(rc) != 2:
            return False
        r, c = rc
        if not (0 <= r < rows and 0 <= c < cols):
            return False
        if (r, c) in seen:
            return False
        seen.add((r, c))
        d = abs(r - r0) + abs(c - c0)
        if d < prev:
            return False
        prev = d
    return len(seen) == rows * cols

# Asserts
if __name__ == "__main__":
    sol = Solution()
    out1 = sol.allCellsDistOrder(1, 2, 0, 0)
    assert _is_valid(1, 2, 0, 0, out1)
    out2 = sol.allCellsDistOrder(2, 2, 0, 1)
    assert _is_valid(2, 2, 0, 1, out2)
    out3 = sol.allCellsDistOrder(2, 3, 1, 2)
    assert _is_valid(2, 3, 1, 2, out3)
\end{minted}
\VALIDATION{Checked length equals $rows\cdot cols$, all cells present and unique, distances nondecreasing.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Counting by Distance (Bucket Sort)}
\WHICHFORMULA{Instead of $O(N\log N)$ sorting, bucket cells by their distance $d\in[0,D_{\max}]$ where $D_{\max}=(rows-1)+(cols-1)$, then concatenate buckets.}
\ASSUMPTIONS{Distances are small integers bounded by $D_{\max}$; allocating $D_{\max}+1$ buckets is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $B[0\dots D_{\max}]$ as empty lists.
\item For each cell $(r,c)$, compute $d=|r-rCenter|+|c-cCenter|$ and append to $B[d]$.
\item Concatenate $B[0],B[1],\ldots,B[D_{\max}]$ to form the answer.
\end{algosteps}
\COMPLEXITY{Linear time in the number of cells; no comparison sort.}
\[
\begin{aligned}
T(N) &= O(N + D_{\max}) = O(N),\\
S(N) &= O(N + D_{\max}) = O(N).
\end{aligned}
\]
\CORRECTNESS{All cells with the same distance share a bucket; iterating buckets in increasing $d$ ensures nondecreasing distance while preserving completeness and uniqueness.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:
        Dmax = (rows - 1) + (cols - 1)
        buckets: List[List[List[int]]] = [[] for _ in range(Dmax + 1)]
        for r in range(rows):
            for c in range(cols):
                d = abs(r - rCenter) + abs(c - cCenter)
                buckets[d].append([r, c])
        ans: List[List[int]] = []
        for d in range(Dmax + 1):
            if buckets[d]:
                ans.extend(buckets[d])
        return ans

def _is_valid(rows: int, cols: int, r0: int, c0: int, ans: List[List[int]]) -> bool:
    if len(ans) != rows * cols:
        return False
    seen = set()
    prev = -1
    for rc in ans:
        if not isinstance(rc, list) or len(rc) != 2:
            return False
        r, c = rc
        if not (0 <= r < rows and 0 <= c < cols):
            return False
        if (r, c) in seen:
            return False
        seen.add((r, c))
        d = abs(r - r0) + abs(c - c0)
        if d < prev:
            return False
        prev = d
    return True

if __name__ == "__main__":
    sol = Solution()
    assert _is_valid(1, 1, 0, 0, sol.allCellsDistOrder(1, 1, 0, 0))
    assert _is_valid(2, 3, 0, 0, sol.allCellsDistOrder(2, 3, 0, 0))
    assert _is_valid(3, 3, 1, 1, sol.allCellsDistOrder(3, 3, 1, 1))
\end{minted}
\VALIDATION{Validated on center at corner, edges, and middle; ensures nondecreasing distances and coverage.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Breadth-First Search (BFS) From Center}
\WHICHFORMULA{BFS in a 4-neighbor grid explores nodes in order of shortest-path length from the source; in a grid, shortest-path length equals Manhattan distance.}
\ASSUMPTIONS{Use a queue and a visited boolean grid; neighbor order is fixed for determinism.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize queue with $(rCenter,cCenter)$; mark visited.
\item While queue nonempty, pop front $(r,c)$, append to answer.
\item For each neighbor $(r\pm 1,c)$ and $(r,c\pm 1)$ within bounds and not visited, mark and push.
\end{algosteps}
\OPTIMALITY{BFS generates cells in nondecreasing graph distance, which equals Manhattan distance in a 4-neighbor grid; each cell processed once. Time and space are $O(N)$.}
\COMPLEXITY{
\[
\begin{aligned}
T(N) &= O(N),\quad S(N)=O(N).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:
        vis = [[False] * cols for _ in range(rows)]
        q = deque()
        q.append((rCenter, cCenter))
        vis[rCenter][cCenter] = True
        ans: List[List[int]] = []
        # Fixed neighbor order for determinism: up, right, down, left
        for_r = (-1, 0, 1, 0)
        for_c = (0, 1, 0, -1)
        while q:
            r, c = q.popleft()
            ans.append([r, c])
            for k in range(4):
                nr, nc = r + for_r[k], c + for_c[k]
                if 0 <= nr < rows and 0 <= nc < cols and not vis[nr][nc]:
                    vis[nr][nc] = True
                    q.append((nr, nc))
        return ans

def _is_valid(rows: int, cols: int, r0: int, c0: int, ans: List[List[int]]) -> bool:
    if len(ans) != rows * cols:
        return False
    seen = set()
    prev = -1
    for rc in ans:
        if not isinstance(rc, list) or len(rc) != 2:
            return False
        r, c = rc
        if not (0 <= r < rows and 0 <= c < cols):
            return False
        if (r, c) in seen:
            return False
        seen.add((r, c))
        d = abs(r - r0) + abs(c - c0)
        if d < prev:
            return False
        prev = d
    return True

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 validation asserts
    assert _is_valid(1, 2, 0, 0, sol.allCellsDistOrder(1, 2, 0, 0))
    assert _is_valid(2, 2, 0, 1, sol.allCellsDistOrder(2, 2, 0, 1))
    assert _is_valid(2, 3, 1, 2, sol.allCellsDistOrder(2, 3, 1, 2))
\end{minted}
\VALIDATION{Three asserts corresponding to the problem's examples validate nondecreasing distance and full coverage.}
\RESULT{Returns a list of all grid coordinates ordered by nondecreasing Manhattan distance from the center; ties can be in any order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check the properties: length equals $rows\cdot cols$, all cells unique and inside bounds, distances nondecreasing. Test centers at corners, edges, and interior with varied shapes (tall, wide, square).}
\LINE{CROSS-CHECKS}{Compare outputs from Baseline (sort), Improved (buckets), and Optimal (BFS) on small grids by verifying that each is valid and all produce identical multisets of coordinates. Optionally check that the sorted-by-distance list equals the Baseline's canonical order.}
\LINE{EDGE-CASE GENERATOR}{Generate random small $rows,cols\in[1,6]$ and random centers to fuzz the solution; validate via the property-checker.}
\begin{minted}{python}
from typing import List, Tuple
from random import seed, randint

def baseline(rows: int, cols: int, r0: int, c0: int) -> List[List[int]]:
    cells = [[r, c] for r in range(rows) for c in range(cols)]
    cells.sort(key=lambda rc: abs(rc[0]-r0)+abs(rc[1]-c0))
    return cells

def buckets(rows: int, cols: int, r0: int, c0: int) -> List[List[int]]:
    D = (rows-1)+(cols-1)
    B: List[List[List[int]]] = [[] for _ in range(D+1)]
    for r in range(rows):
        for c in range(cols):
            B[abs(r-r0)+abs(c-c0)].append([r,c])
    ans: List[List[int]] = []
    for d in range(D+1):
        ans.extend(B[d])
    return ans

def bfs(rows: int, cols: int, r0: int, c0: int) -> List[List[int]]:
    from collections import deque
    vis = [[False]*cols for _ in range(rows)]
    q = deque([(r0,c0)])
    vis[r0][c0] = True
    ans: List[List[int]] = []
    for_r, for_c = (-1,0,1,0), (0,1,0,-1)
    while q:
        r,c = q.popleft()
        ans.append([r,c])
        for k in range(4):
            nr, nc = r+for_r[k], c+for_c[k]
            if 0 <= nr < rows and 0 <= nc < cols and not vis[nr][nc]:
                vis[nr][nc] = True
                q.append((nr,nc))
    return ans

def is_valid(rows: int, cols: int, r0: int, c0: int, ans: List[List[int]]) -> bool:
    if len(ans) != rows*cols:
        return False
    seen = set()
    prev = -1
    for r,c in ans:
        if not (0 <= r < rows and 0 <= c < cols):
            return False
        if (r,c) in seen:
            return False
        seen.add((r,c))
        d = abs(r-r0)+abs(c-c0)
        if d < prev: return False
        prev = d
    return True

if __name__ == "__main__":
    # Cross-check on small randoms
    seed(0)
    for _ in range(200):
        R = randint(1, 6)
        C = randint(1, 6)
        r0 = randint(0, R-1)
        c0 = randint(0, C-1)
        a, b, c = baseline(R,C,r0,c0), buckets(R,C,r0,c0), bfs(R,C,r0,c0)
        assert is_valid(R,C,r0,c0,a)
        assert is_valid(R,C,r0,c0,b)
        assert is_valid(R,C,r0,c0,c)
        assert sorted(a) == sorted(b) == sorted(c)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:
        vis = [[False] * cols for _ in range(rows)]
        q = deque([(rCenter, cCenter)])
        vis[rCenter][cCenter] = True
        ans: List[List[int]] = []
        # Neighbor order fixed for determinism
        dr = (-1, 0, 1, 0)
        dc = (0, 1, 0, -1)
        while q:
            r, c = q.popleft()
            ans.append([r, c])
            for k in range(4):
                nr, nc = r + dr[k], c + dc[k]
                if 0 <= nr < rows and 0 <= nc < cols and not vis[nr][nc]:
                    vis[nr][nc] = True
                    q.append((nr, nc))
        return ans

# Self-checks
if __name__ == "__main__":
    def _is_valid(rows: int, cols: int, r0: int, c0: int, ans: List[List[int]]) -> bool:
        if len(ans) != rows * cols:
            return False
        seen = set()
        prev = -1
        for r, c in ans:
            if not (0 <= r < rows and 0 <= c < cols):
                return False
            if (r, c) in seen:
                return False
            seen.add((r, c))
            d = abs(r - r0) + abs(c - c0)
            if d < prev:
                return False
            prev = d
        return True

    sol = Solution()
    assert _is_valid(1, 2, 0, 0, sol.allCellsDistOrder(1, 2, 0, 0))
    assert _is_valid(2, 2, 0, 1, sol.allCellsDistOrder(2, 2, 0, 1))
    assert _is_valid(3, 4, 2, 3, sol.allCellsDistOrder(3, 4, 2, 3))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Order all grid cells by nondecreasing Manhattan distance from a given center.}
\WHY{Common test of sorting by computed keys, using counting/buckets, or applying BFS layering on grids.}
\CHECKLIST{
\begin{bullets}
\item Define Manhattan distance correctly.
\item Cover every cell exactly once.
\item Ensure nondecreasing distance order.
\item Respect bounds when exploring neighbors.
\item Choose deterministic neighbor order if needed.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $rows=1$ or $cols=1$ (single line).
\item $rows=1, cols=1$ (single cell).
\item Center at each of the four corners.
\item Center on edge but not corner.
\item Tall vs. wide rectangles (e.g., $1\times 100$, $100\times 1$).
\item Max size $100\times 100$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using Euclidean distance instead of Manhattan.
\item Forgetting to include the center cell.
\item Off-by-one in bounds checks.
\item Not marking visited before enqueue in BFS (can enqueue duplicates).
\item Sorting by string of coordinates instead of numeric distance.
\item Excess memory from prebuilding large intermediate structures unnecessarily.
\end{bullets}
}
\FAILMODES{Brute-force sort is correct but slower; custom tie-breaking is unnecessary. BFS without visited checks may revisit nodes; wrong neighbor order does not break correctness but can change output determinism.}
\ELI{Start at the center, then list cells one step away, then two steps away, and so on. You can do this by either sorting all cells by their step count or by exploring the grid outward in waves.}
\NotePages{3}

\end{document}