% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — AquaMoon and Chess}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1545/B}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Cirno gave AquaMoon a chessboard of size $1 \times n$. Its cells are numbered with integers from $1$ to $n$ from left to right. In the beginning, some of the cells are occupied with at most one pawn, and other cells are unoccupied.

In each operation, AquaMoon can choose a cell $i$ with a pawn, and do either of the following (if possible):
\begin{bullets}
\item Move pawn from it to the $(i+2)$-th cell, if $i+2 \le n$ and the $(i+1)$-th cell is occupied and the $(i+2)$-th cell is unoccupied.
\item Move pawn from it to the $(i-2)$-th cell, if $i-2 \ge 1$ and the $(i-1)$-th cell is occupied and the $(i-2)$-th cell is unoccupied.
\end{bullets}

You are given an initial state of the chessboard. AquaMoon wants to count the number of states reachable from the initial state with some sequence of operations. As the answer can be large, find it modulo $998{,}244{,}353$.

Input: The input consists of multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 10{,}000$) — the number of test cases.

For each test case, the first line contains a single integer $n$ ($1 \le n \le 10^5$) — the size of the chessboard. The second line contains a string of $n$ characters, consisting of characters ``0'' and ``1''. If the $i$-th character is ``1'', the $i$-th cell is initially occupied; otherwise, the $i$-th cell is initially unoccupied. It is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.

Output: For each test case, print the number of states that are reachable from the initial state with some sequence of operations modulo $998{,}244{,}353$.

Note: In the first test case the strings ``1100'', ``0110'' and ``0011'' are reachable from the initial state with some sequence of operations.}
\BREAKDOWN{Identify invariant structures under the local move $110 \leftrightarrow 011$. Reduce the system to counting placements of composite tokens over zeros with singles acting as separators. Compute the count via a closed-form combinatorial formula.}
\ELI{Pairs of adjacent ones behave like sliding dominoes that move through zeros; the number of ways to place these dominoes among zeros gives the number of reachable states.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 10^5$).
\item Binary string $s$ of length $n$.
\end{bullets}
The total $\sum n \le 10^5$.}
\OUTPUTS{For each test case, output a single integer: the number of distinct strings reachable from $s$ via any sequence of moves, modulo $998{,}244{,}353$.}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input: $n=4$, $s=\texttt{1100}$. Zeros $z=2$, pairs $k=1$. Answer $=\binom{z+k}{k}=\binom{3}{1}=3$. The reachable strings are \texttt{1100}, \texttt{0110}, \texttt{0011}.
\end{bullets}
Example 2:
\begin{bullets}
\item Input: $n=4$, $s=\texttt{1010}$. $z=2$, $k=0$. Answer $=\binom{2}{0}=1$ (no move is possible).
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s \in \{0,1\}^n$. A move is a local rewrite of a length-3 window:
\begin{BreakableEquation*}
110 \leftrightarrow 011.
\end{BreakableEquation*}
Let $z$ be the number of zeros in $s$. Decompose each maximal run of ones; a run of length $\ell$ contributes $\left\lfloor \tfrac{\ell}{2} \right\rfloor$ disjoint adjacent pairs (``dominoes'') and $\ell \bmod 2$ lonely ones. Define
\begin{BreakableEquation*}
k \coloneqq \sum_{\text{runs of ones }R} \left\lfloor \frac{|R|}{2} \right\rfloor.
\end{BreakableEquation*}
}
\varmapStart
\var{n}{board length}
\var{s}{initial binary string}
\var{z}{count of zeros in $s$}
\var{k}{total count of disjoint adjacent-1 pairs across all runs}
\var{\mathbb{F}}{finite field of integers modulo $998{,}244{,}353$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Number of reachable states from } s \;=\; \binom{z + k}{k} \pmod{998{,}244{,}353}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Pawns are indistinguishable; moves are applied until no change. The $110 \leftrightarrow 011$ operation preserves $z$ and $k$. Singles (lonely ones) act as separators that dominoes cannot cross.}
\INVARIANTS{
\begin{bullets}
\item Parity positions of ones are preserved in aggregate: each domino always occupies one even and one odd index.
\item $z$ is preserved since only $110 \leftrightarrow 011$ occurs.
\item $k=\sum \lfloor \ell/2 \rfloor$ is preserved: moves slide dominoes through zeros without creating or destroying dominoes.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Breadth-first search over all states reachable from the starting string using the local rewrites $110 \to 011$ and $011 \to 110$.}
\ASSUMPTIONS{Feasible only for small $n$ (e.g., $n \le 18$) due to state space size.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Use a queue starting from the initial string.
\item For each dequeued string, generate neighbors by applying all $110 \leftrightarrow 011$ rewrites at all positions.
\item Track visited states in a set; the answer is the size of the visited set.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in the worst case; space also exponential.}
\[
\begin{aligned}
T(n) &= O(\text{number of reachable states}) \\
S(n) &= O(\text{number of reachable states})
\end{aligned}
\]
\CORRECTNESS{BFS explores all strings reachable by any sequence of valid moves exactly once.}
\EDGECASES{All zeros, all ones, alternating patterns (no moves), and short strings $n<3$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

MOD = 998244353

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        # No stdin provided; return a tiny baseline suite
        cases = ["1100", "1010", "1", "0", "111", "0110"]
        return cases
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        assert len(s) == n
        cases.append(s)
    return cases

def neighbors(s):
    """Generate all neighbors by 110<->011 at every position."""
    n = len(s)
    res = []
    a = list(s)
    for i in range(n - 2):
        tri = s[i:i+3]
        if tri == "110":
            b = a[:]
            b[i], b[i+1], b[i+2] = '0', '1', '1'
            res.append("".join(b))
        if tri == "011":
            b = a[:]
            b[i], b[i+1], b[i+2] = '1', '1', '0'
            res.append("".join(b))
    return res

def brute_reachable_count(s):
    """BFS to count reachable states; intended for small n."""
    seen = set([s])
    q = deque([s])
    while q:
        cur = q.popleft()
        for nxt in neighbors(cur):
            if nxt not in seen:
                seen.add(nxt)
                q.append(nxt)
    return len(seen) % MOD

def solve_case_brutal(s):
    # Fallback to brute only for tiny n; otherwise use formula to keep runtime sane.
    if len(s) <= 16:
        return brute_reachable_count(s)
    else:
        return solve_case_formula(s)

def runs_of_ones_k(s):
    k = 0
    i = 0
    n = len(s)
    while i < n:
        if s[i] == '1':
            j = i
            while j < n and s[j] == '1':
                j += 1
            L = j - i
            k += L // 2
            i = j
        else:
            i += 1
    return k

def precompute_binom(max_n):
    fac = [1] * (max_n + 1)
    ifac = [1] * (max_n + 1)
    for i in range(1, max_n + 1):
        fac[i] = fac[i - 1] * i % MOD
    ifac[max_n] = pow(fac[max_n], MOD - 2, MOD)
    for i in range(max_n, 0, -1):
        ifac[i - 1] = ifac[i] * i % MOD
    return fac, ifac

def nCk(n, k, fac, ifac):
    if k < 0 or k > n:
        return 0
    return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD

def solve_case_formula(s):
    z = s.count('0')
    k = runs_of_ones_k(s)
    fac, ifac = precompute_binom(len(s))
    return nCk(z + k, k, fac, ifac)

def solve_all(cases):
    # Use formula universally here for speed; baseline BFS is available for tiny strings.
    maxn = max(len(s) for s in cases) if cases else 0
    fac, ifac = precompute_binom(maxn)
    out = []
    for s in cases:
        z = s.count('0')
        k = runs_of_ones_k(s)
        out.append(str(nCk(z + k, k, fac, ifac)))
    return "\n".join(out)

def main():
    cases = read_input()
    # Tiny self-checks (only when no stdin)
    if sys.stdin.isatty():
        assert brute_reachable_count("1100") == 3
        assert brute_reachable_count("1010") == 1
        # Cross-check formula vs brute for a few small cases
        small = ["", "0", "1", "11", "010", "0110", "0011", "111", "1011", "0101"]
        for s in small:
            f = solve_case_formula(s)
            b = brute_reachable_count(s) if len(s) <= 12 else f
            assert f == b
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-check brute-force and formula on small strings; verify sample-like cases match expected counts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Compression + Stars-and-Bars DP}
\WHICHFORMULA{Compress each maximal run of ones by extracting disjoint adjacent pairs (dominoes). The total number of dominoes $k$ is invariant. Lonely ones ($\ell \bmod 2$ per run) are separators that dominoes cannot cross. Dominoes slide through zeros and among themselves without changing order, producing a stars-and-bars count.}
\ASSUMPTIONS{Dominoes are indistinguishable; their relative order is preserved under local moves; singles cannot be overtaken by dominoes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan $s$ to count zeros $z$ and compute $k=\sum \lfloor \ell/2 \rfloor$ over all one-runs.
\item Precompute factorials and inverse factorials up to $n$ modulo $998{,}244{,}353$.
\item Return $\binom{z+k}{k}$.
\end{algosteps}
\COMPLEXITY{Linear pass to compute $z$ and $k$; precomputation up to $\max n$ amortized across test cases.}
\[
\begin{aligned}
T(n) &= O(n) \text{ per test}, \\
S(n) &= O(n) \text{ for precomputed tables shared across tests}.
\end{aligned}
\]
\CORRECTNESS{Each move $110 \leftrightarrow 011$ slides a domino across a zero; singles remain as separators. Thus every reachable state corresponds to an interleaving of $k$ dominoes with $z$ zeros, counted by $\binom{z+k}{k}$. No other states are possible due to invariants and separators.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

MOD = 998244353

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return ["1100", "1010", "111000", "01011"]
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        cases.append(s)
    return cases

def runs_pairs_k(s):
    k = 0
    i = 0
    n = len(s)
    while i < n:
        if s[i] == '1':
            j = i
            while j < n and s[j] == '1':
                j += 1
            k += (j - i) // 2
            i = j
        else:
            i += 1
    return k

def precompute(maxn):
    fac = [1] * (maxn + 1)
    ifac = [1] * (maxn + 1)
    for i in range(1, maxn + 1):
        fac[i] = fac[i - 1] * i % MOD
    ifac[maxn] = pow(fac[maxn], MOD - 2, MOD)
    for i in range(maxn, 0, -1):
        ifac[i - 1] = ifac[i] * i % MOD
    return fac, ifac

def nCk(n, k, fac, ifac):
    if k < 0 or k > n:
        return 0
    return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD

def solve_all():
    cases = read_input()
    maxn = max((len(s) for s in cases), default=0)
    fac, ifac = precompute(maxn)
    out = []
    for s in cases:
        z = s.count('0')
        k = runs_pairs_k(s)
        out.append(str(nCk(z + k, k, fac, ifac)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Quick correctness checks
    def ans(s):
        z = s.count('0'); k = runs_pairs_k(s)
        f, g = precompute(len(s))
        return nCk(z + k, k, f, g)
    assert ans("1100") == 3
    assert ans("1010") == 1
    assert ans("1111") == 1  # z=0,k=2 -> C(2,2)=1
    solve_all()
\end{minted}
\VALIDATION{Validated on small crafted cases and degenerate strings; parity and separator behavior match the model.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Domino Compression + Closed-Form Binomial}
\WHICHFORMULA{Final method: compute $z$ and $k$ via a single scan and output $\binom{z+k}{k} \bmod 998{,}244{,}353$.}
\ASSUMPTIONS{Valid for all inputs. Precompute factorials once up to $\max n$ across test cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $z=\#\{i:s_i=0\}$ and $k=\sum \lfloor \ell/2 \rfloor$ over one-runs.
\item Precompute factorials and inverse factorials up to $\max n$.
\item Output $\binom{z+k}{k} \bmod 998{,}244{,}353$.
\end{algosteps}
\OPTIMALITY{Any method must at least inspect the input; $\Omega(n)$ is a lower bound. This achieves $O(n)$ per test with small constant factors and optimal asymptotics.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n)\ \text{per test},\\
S(n) &= O(n)\ \text{shared precomputation across tests}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys

MOD = 998244353

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        # Fallback tiny suite if no stdin (for local verification)
        return ["1100", "1010", "111000", "01011"]
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        _n = int(next(it))
        s = next(it).strip()
        cases.append(s)
    return cases

def count_pairs_k(s: str) -> int:
    k = 0
    i = 0
    n = len(s)
    while i < n:
        if s[i] == '1':
            j = i
            while j < n and s[j] == '1':
                j += 1
            k += (j - i) // 2
            i = j
        else:
            i += 1
    return k

def precompute_fact_ifact(maxn: int):
    fac = [1] * (maxn + 1)
    ifac = [1] * (maxn + 1)
    for i in range(1, maxn + 1):
        fac[i] = fac[i - 1] * i % MOD
    if maxn >= 0:
        ifac[maxn] = pow(fac[maxn], MOD - 2, MOD)
        for i in range(maxn, 0, -1):
            ifac[i - 1] = ifac[i] * i % MOD
    return fac, ifac

def nCk(n, k, fac, ifac):
    if k < 0 or k > n:
        return 0
    return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD

def solve_case(s: str, fac, ifac) -> int:
    z = s.count('0')
    k = count_pairs_k(s)
    return nCk(z + k, k, fac, ifac)

def solve_all():
    cases = read_input()
    maxn = max((len(s) for s in cases), default=0)
    fac, ifac = precompute_fact_ifact(maxn)
    out = []
    for s in cases:
        out.append(str(solve_case(s, fac, ifac)))
    sys.stdout.write("\n".join(out))

def main():
    # Minimal asserts (deterministic)
    if sys.stdin.isatty():
        fac, ifac = precompute_fact_ifact(10)
        assert nCk(3, 1, fac, ifac) == 3
        assert solve_case("1100", fac, ifac) == 3
        assert solve_case("1010", fac, ifac) == 1
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 checks: $\binom{3}{1}=3$, case \texttt{1100} gives $3$, and \texttt{1010} gives $1$.}
\RESULT{For each test, print $\binom{z+k}{k} \bmod 998{,}244{,}353$, where $z$ is the number of zeros and $k$ is the total number of disjoint adjacent-one pairs across all runs.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the combinatorial core $k$-extraction and $n \choose k$ function. Cross-check against brute-force BFS on strings up to length 10. Include degenerate cases: all zeros, all ones, alternating, single run.}
\LINE{CROSS-CHECKS}{Compare the optimal method against brute-force for hand-picked small cases to confirm the stars-and-bars model.}
\LINE{EDGE-CASE GENERATOR}{Generate short patterns such as $0^a1^b0^c$, alternating \texttt{01} repeats, and mixed runs to hit different run-parity scenarios.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases_small():
    cases = set()
    for n in range(0, 9):
        # simple families
        cases.add("0" * n)
        cases.add("1" * n)
        cases.add(("01" * ((n + 1)//2))[:n])
        cases.add(("10" * ((n + 1)//2))[:n])
    # hand-crafted
    cases |= {"1100", "0110", "0011", "1110", "0111", "1011", "1101", "1010", "0101"}
    return sorted(cases)

def brute_bfs_count(s):
    from collections import deque
    n = len(s)
    q = deque([s])
    vis = set([s])
    while q:
        cur = q.popleft()
        a = list(cur)
        for i in range(n - 2):
            tri = cur[i:i+3]
            if tri == "110":
                b = a[:]
                b[i], b[i+1], b[i+2] = '0', '1', '1'
                nxt = "".join(b)
                if nxt not in vis:
                    vis.add(nxt); q.append(nxt)
            if tri == "011":
                b = a[:]
                b[i], b[i+1], b[i+2] = '1', '1', '0'
                nxt = "".join(b)
                if nxt not in vis:
                    vis.add(nxt); q.append(nxt)
    return len(vis)

def ref_answer(s, fac, ifac):
    z = s.count('0')
    # compute k = sum floor(run_length/2)
    k = 0; i = 0
    while i < len(s):
        if s[i] == '1':
            j = i
            while j < len(s) and s[j] == '1':
                j += 1
            k += (j - i) // 2
            i = j
        else:
            i += 1
    return (fac[z + k] * ifac[k] * ifac[z] ) % 998244353

def self_check():
    # precompute up to 20
    MOD = 998244353
    maxn = 20
    fac = [1]*(maxn+1); ifac = [1]*(maxn+1)
    for i in range(1, maxn+1): fac[i] = fac[i-1]*i % MOD
    ifac[maxn] = pow(fac[maxn], MOD-2, MOD)
    for i in range(maxn, 0, -1): ifac[i-1] = ifac[i]*i % MOD
    for s in gen_cases_small():
        f = ref_answer(s, fac, ifac)
        b = brute_bfs_count(s)
        assert f == b, (s, f, b)
    print("All small cross-checks passed.")

if __name__ == "__main__":
    self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys

MOD = 998244353

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return ["1100", "1010", "111000", "01011"]
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        _n = int(next(it))
        s = next(it).strip()
        cases.append(s)
    return cases

def count_pairs_k(s: str) -> int:
    k = 0
    i = 0
    n = len(s)
    while i < n:
        if s[i] == '1':
            j = i
            while j < n and s[j] == '1':
                j += 1
            k += (j - i) // 2
            i = j
        else:
            i += 1
    return k

def precompute_fact_ifact(maxn: int):
    fac = [1] * (maxn + 1)
    ifac = [1] * (maxn + 1)
    for i in range(1, maxn + 1):
        fac[i] = fac[i - 1] * i % MOD
    ifac[maxn] = pow(fac[maxn], MOD - 2, MOD)
    for i in range(maxn, 0, -1):
        ifac[i - 1] = ifac[i] * i % MOD
    return fac, ifac

def nCk(n, k, fac, ifac):
    if k < 0 or k > n:
        return 0
    return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD

def solve_case(s: str, fac, ifac) -> int:
    z = s.count('0')
    k = count_pairs_k(s)
    return nCk(z + k, k, fac, ifac)

def solve_all():
    cases = read_input()
    maxn = max((len(s) for s in cases), default=0)
    fac, ifac = precompute_fact_ifact(maxn)
    out = []
    for s in cases:
        out.append(str(solve_case(s, fac, ifac)))
    sys.stdout.write("\n".join(out))

def main():
    # Asserts for sanity when run locally without stdin
    if sys.stdin.isatty():
        fac, ifac = precompute_fact_ifact(10)
        assert nCk(0, 0, fac, ifac) == 1
        assert solve_case("1100", fac, ifac) == 3
        assert solve_case("1010", fac, ifac) == 1
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count reachable states under $110 \leftrightarrow 011$ by compressing adjacent ones into dominoes and using a binomial formula $\binom{z+k}{k}$.}
\WHY{Appears in interviews to test modeling local rewrites as combinatorial objects and deriving counts via invariants and stars-and-bars.}
\CHECKLIST{
\begin{bullets}
\item Scan runs of ones; sum $\lfloor \ell/2 \rfloor$ to get $k$.
\item Count zeros $z$.
\item Precompute factorials and inverse factorials modulo $998{,}244{,}353$.
\item Output $\binom{z+k}{k}$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All zeros: $k=0$, answer $1$.
\item All ones: $z=0$, answer $1$.
\item Alternating strings: $k=0$, answer $1$.
\item Single-character strings: answer $1$.
\item One long run with odd length: one separator single remains.
\item Multiple small runs separated by zeros: sum pairs independently.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Miscounting $k$ by pairing across zeros (illegal).
\item Forgetting that dominoes are indistinguishable; use combinations, not permutations.
\item Precomputing factorials only up to $z+k$ but not up to $n$; ensure bounds cover $z+k \le n$.
\item Modulo inverse mistakes; use Fermat’s little theorem with correct exponent.
\item Off-by-one when scanning run endpoints.
\item Using slow big-integer binomials without precomputation.
\end{bullets}
}
\FAILMODES{Brute-force explodes exponentially; greedy local moves without global modeling miss states or double-count. The invariant-based compression avoids both.}
\ELI{Think of each ``11'' as a domino that can slide through zeros. Singles are pegs stuck in place. The number of ways to interleave $k$ dominoes with $z$ zeros is simply a binomial coefficient.}
\NotePages{3}

\end{document}