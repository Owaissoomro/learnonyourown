% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximize Consecutive Elements in an Array After Modification}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximize-consecutive-elements-in-an-array-after-modification/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed array \texttt{nums} consisting of positive integers.\\
Initially, you can increase the value of any element in the array by at most 1 (independently per element; you may also choose not to increase an element). After that, you need to select one or more elements from the final array such that those elements are consecutive when sorted in increasing order. For example, the elements \([3, 4, 5]\) are consecutive while \([3, 4, 6]\) and \([1, 1, 2, 3]\) are not (no duplicates allowed within the selected set).\\
Return the maximum number of elements that you can select.\\[4pt]
Example 1:\\
Input: \(\texttt{nums} = [2, 1, 5, 1, 1]\)\\
Output: \(3\)\\
Explanation: Increase the elements at indices 0 and 3. The resulting array is \(\texttt{nums} = [3, 1, 5, 2, 1]\). Select the elements \([3, 1, 2]\) and sort them to obtain \([1, 2, 3]\), which are consecutive. It can be shown that we cannot select more than 3 consecutive elements.\\[4pt]
Example 2:\\
Input: \(\texttt{nums} = [1, 4, 7, 10]\)\\
Output: \(1\)\\
Explanation: The maximum consecutive elements that we can select is 1.\\[4pt]
Constraints:\\
\(\,1 \le \texttt{nums.length} \le 10^5\)\\
\(\,1 \le \texttt{nums[i]} \le 10^6\)}
\BREAKDOWN{We may add 0 or 1 to each element, then choose a subset that forms a strictly consecutive set. Reformulate as assigning each chosen element to either its value or value+1, with all assigned targets distinct and consecutive. We must maximize the length of such an interval.}
\ELI{Sort the array and find the longest window where each element can be shifted by at most 1 to fit perfectly into consecutive slots.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode, a single method \texttt{maxSelectedElements(self, nums: List[int]) -\textgreater{} int}.\\
\(\texttt{nums}\): list of integers, \(1 \le \lvert \texttt{nums} \rvert \le 10^5\), \(1 \le \texttt{nums[i]} \le 10^6\).}
\OUTPUTS{A single integer: the maximum size of a subset that can become consecutive after increasing any elements by at most 1 each.}
\SAMPLES{Example 1:\\
Input: \([2, 1, 5, 1, 1]\) \(\rightarrow\) Output: \(3\).\\
Example 2:\\
Input: \([1, 4, 7, 10]\) \(\rightarrow\) Output: \(1\).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the sorted array be \(a_0 \le a_1 \le \ldots \le a_{n-1}\). After modification, each \(a_i\) can become either \(a_i\) or \(a_i + 1\). We seek the largest \(m\) and indices \(l \le r\) with \(r-l+1=m\) such that there exists an integer \(L\) with
\[
a_{l+i} \le L+i \le a_{l+i}+1 \quad \text{for all } i=0,\ldots,m-1,
\]
ensuring the selected modified values are the consecutive integers \(L, L+1, \ldots, L+m-1\).}
\varmapStart
\var{a_i}{sorted input values}
\var{m}{length of the selected consecutive set}
\var{L}{starting value of the consecutive set after modification}
\var{l,r}{window endpoints in the sorted array with \(m=r-l+1\)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\exists\, L \ \text{s.t.}\ \forall i\in[0,m-1]:\quad
a_{l+i} \le L+i \le a_{l+i}+1
\ \Longleftrightarrow\
\max_{k\in[l,r]} \bigl(a_k - (k-l)\bigr) \le \min_{k\in[l,r]} \bigl(a_k + 1 - (k-l)\bigr).
\end{aligned}
\]
Equivalently, since the shift by \(l\) cancels,
\begin{BreakableEquation*}
\max_{k\in[l,r]} (a_k - k)\ \le\ \min_{k\in[l,r]} (a_k + 1 - k).
\end{BreakableEquation*}
}
\ASSUMPTIONS{We may pick any subset of indices; elements are independent for the \(\{0,1\}\) increment choice. Selected final values must be distinct and consecutive (no duplicates allowed).}
\INVARIANTS{Within any fixed window \([l,r]\), feasibility is monotone in window growth: extending the window can only increase \(\max(a_k-k)\) and decrease \(\min(a_k+1-k)\). Hence once infeasible for a fixed \(l\), further increasing \(r\) remains infeasible.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the intersection condition \(\max(a_k-k)\le \min(a_k+1-k)\) over a window. Try all left endpoints \(l\) and expand \(r\) while the condition holds, tracking the best length.}
\ASSUMPTIONS{Array sorted ascending. Maintain running window extrema for \((a_k-k)\) and \((a_k+1-k)\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \(\texttt{nums}\) to obtain \(a\).
\item For each \(l\) from \(0\) to \(n-1\): initialize \(M_{\max}=-\infty\), \(M_{\min}=+\infty\).
\item Increment \(r\) from \(l\) to \(n-1\), updating \(M_{\max}=\max(M_{\max}, a_r-r)\), \(M_{\min}=\min(M_{\min}, a_r+1-r)\). If \(M_{\max}\le M_{\min}\), update answer; else break and continue with next \(l\).
\end{algosteps}
\COMPLEXITY{For each \(l\), \(r\) advances at most \(n\) steps and stops once infeasible. Worst-case \(O(n^2)\) time, \(O(1)\) extra space (besides the sorted array).}
\[
\begin{aligned}
T(n) &= \sum_{l=0}^{n-1} O(n-l) = O(n^2), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Directly enforces the necessary and sufficient feasibility condition for each window. Monotonicity guarantees that breaking on first infeasibility for a fixed \(l\) does not miss any longer valid window starting at \(l\).}
\EDGECASES{All elements equal; strictly increasing; large gaps; \(n=1\).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        # Baseline O(n^2): expanding windows using the max/min intersection check.
        nums.sort()
        n = len(nums)
        ans = 0
        for l in range(n):
            mmax = float('-inf')
            mmin = float('inf')
            for r in range(l, n):
                val1 = nums[r] - r
                val2 = nums[r] + 1 - r
                if val1 > mmax:
                    mmax = val1
                if val2 < mmin:
                    mmin = val2
                if mmax <= mmin:
                    ans = max(ans, r - l + 1)
                else:
                    break
        return ans

# Basic asserts (small inputs)
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxSelectedElements([2,1,5,1,1]) == 3
    assert sol.maxSelectedElements([1,4,7,10]) == 1
    assert sol.maxSelectedElements([1,3,3]) == 3
    assert sol.maxSelectedElements([1,1,1,1]) == 2
    assert sol.maxSelectedElements([1]) == 1
\end{minted}
\VALIDATION{Validated on the provided examples; added cases: bridging a single gap \([1,3,3]\to 3\); duplicates only \([1,1,1,1]\to 2\); singleton.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Length with Sliding Max/Min}
\WHICHFORMULA{For a fixed window length \(m\), the window is feasible iff \(\max(a_k-k)\le \min(a_k+1-k)\) over that window. We can test all windows of size \(m\) in \(O(n)\) with monotonic deques. Binary search \(m\) from \(1\) to \(n\).}
\ASSUMPTIONS{Sorted array; deques maintain range maximum of \((a_k-k)\) and range minimum of \((a_k+1-k)\) for a fixed-size sliding window.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \(\texttt{nums}\), precompute arrays \(x_k=a_k-k\) and \(y_k=a_k+1-k\).
\item For a candidate \(m\), slide a window of length \(m\) over \(x\) and \(y\) using deques to get \(\max x\) and \(\min y\) in \(O(1)\).
\item If any window satisfies \(\max x \le \min y\), \(m\) is feasible. Binary search the maximum feasible \(m\).
\end{algosteps}
\COMPLEXITY{Each feasibility check is \(O(n)\); binary search over \(m\) adds a \(\log n\) factor.}
\[
\begin{aligned}
T(n) &= O(n \log n) \text{ (sorting)} + O(n \log n) \text{ (binary search checks)} = O(n \log n), \\
S(n) &= O(n) \text{ for arrays and deques}.
\end{aligned}
\]
\CORRECTNESS{For fixed-length windows, the intersection condition is necessary and sufficient. Monotone deques compute exact range extrema. Binary search over a monotone predicate (feasibility in \(m\)) is valid.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        x = [nums[i] - i for i in range(n)]
        y = [nums[i] + 1 - i for i in range(n)]

        def ok(m: int) -> bool:
            if m == 0:
                return True
            dmax = deque()  # indices for max over x
            dmin = deque()  # indices for min over y
            for i in range(n):
                # push for x max
                while dmax and x[dmax[-1]] <= x[i]:
                    dmax.pop()
                dmax.append(i)
                # push for y min
                while dmin and y[dmin[-1]] >= y[i]:
                    dmin.pop()
                dmin.append(i)
                # pop out-of-window
                if dmax[0] <= i - m:
                    dmax.popleft()
                if dmin[0] <= i - m:
                    dmin.popleft()
                # when we have a full window [i-m+1, i]
                if i >= m - 1:
                    if x[dmax[0]] <= y[dmin[0]]:
                        return True
            return False

        lo, hi = 1, n
        ans = 1
        while lo <= hi:
            mid = (lo + hi) // 2
            if ok(mid):
                ans = mid
                lo = mid + 1
            else:
                hi = mid - 1
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.maxSelectedElements([2,1,5,1,1]) == 3
    assert sol.maxSelectedElements([1,4,7,10]) == 1
    assert sol.maxSelectedElements([1,3,3]) == 3
    assert sol.maxSelectedElements([1,1,1,1]) == 2
\end{minted}
\VALIDATION{Checked against examples and tricky bridging case \([1,3,3]\).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Sliding Window with Monotone Deques}
\WHICHFORMULA{Maintain a variable-length sliding window \([l,r]\) over the sorted array such that \(\max_{k\in[l,r]} (a_k-k) \le \min_{k\in[l,r]} (a_k+1-k)\). Grow \(r\); while infeasible, advance \(l\). Range extrema are maintained by deques in \(O(1)\) amortized per step.}
\ASSUMPTIONS{Sorted input; deques store indices and are pruned on both ends to maintain current window extrema.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \(\texttt{nums}\); compute \(x_k=a_k-k\), \(y_k=a_k+1-k\).
\item Initialize \(l=0\), empty deques \(D_{\max}\) for \(x\) (decreasing) and \(D_{\min}\) for \(y\) (increasing), answer \(ans=0\).
\item For each \(r=0\ldots n-1\): push \(r\) into both deques with monotone maintenance. While \(x[D_{\max}[0]] > y[D_{\min}[0]]\), increment \(l\) and evict indices \(< l\) from fronts.
\item Update \(ans = \max(ans, r-l+1)\). Return \(ans\).
\end{algosteps}
\OPTIMALITY{Each element index enters and leaves each deque at most once, yielding linear time. The sliding window maintains exactly the necessary and sufficient feasibility condition at all times.}
\COMPLEXITY{Sorting dominates: \(O(n \log n)\) time; the sliding window pass is \(O(n)\). Space \(O(n)\) for arrays and deques.}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(n), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        # Sort and apply a variable-length sliding window using the
        # intersection condition max(a_k - k) <= min(a_k + 1 - k)
        nums.sort()
        n = len(nums)
        x = [nums[i] - i for i in range(n)]
        y = [nums[i] + 1 - i for i in range(n)]
        dmax = deque()  # indices for decreasing x
        dmin = deque()  # indices for increasing y
        ans = 0
        l = 0
        for r in range(n):
            # maintain x max deque
            while dmax and x[dmax[-1]] <= x[r]:
                dmax.pop()
            dmax.append(r)
            # maintain y min deque
            while dmin and y[dmin[-1]] >= y[r]:
                dmin.pop()
            dmin.append(r)
            # shrink left while infeasible
            while dmax and dmin and x[dmax[0]] > y[dmin[0]]:
                if dmax[0] == l:
                    dmax.popleft()
                if dmin[0] == l:
                    dmin.popleft()
                l += 1
                while dmax and dmax[0] < l:
                    dmax.popleft()
                while dmin and dmin[0] < l:
                    dmin.popleft()
            ans = max(ans, r - l + 1)
        return ans

if __name__ == "__main__":
    sol = Solution()
    # Provided examples
    assert sol.maxSelectedElements([2,1,5,1,1]) == 3
    assert sol.maxSelectedElements([1,4,7,10]) == 1
    # Additional checks
    assert sol.maxSelectedElements([1,3,3]) == 3
    assert sol.maxSelectedElements([1,1,1,1]) == 2
    assert sol.maxSelectedElements([1,2,2,3,3]) == 4
\end{minted}
\VALIDATION{Three asserts included: the two samples and a bridging case.}
\RESULT{Return the maximum number of elements that can be selected to form a strictly consecutive set after increasing any element by at most 1. No tie-breaking beyond the maximum cardinality is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: all-equal arrays; strictly increasing arrays; arrays with single gaps (bridgeable); arrays with larger gaps (non-bridgeable); random small arrays compared between approaches.}
\LINE{CROSS-CHECKS}{For small \(n\), compare Baseline \(O(n^2)\) and Optimal \(O(n)\) outputs on randomized cases to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of size \(1\), arrays with all identical values, arrays with alternating pairs to stress deques, and arrays with spaced values to test gap handling.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_equal(n: int, val: int) -> List[int]:
    return [val] * n

def gen_strict_inc(n: int, start: int = 1) -> List[int]:
    return [start + i for i in range(n)]

def gen_single_gap_block() -> List[int]:
    # Bridgeable gap example
    return [1, 3, 3]

def gen_large_gaps(n: int, start: int = 1, gap: int = 3) -> List[int]:
    return [start + i * gap for i in range(n)]

def cross_check():
    from collections import deque

    class Opt:
        def maxSelectedElements(self, nums: List[int]) -> int:
            nums.sort()
            n = len(nums)
            x = [nums[i] - i for i in range(n)]
            y = [nums[i] + 1 - i for i in range(n)]
            dmax, dmin = deque(), deque()
            ans, l = 0, 0
            for r in range(n):
                while dmax and x[dmax[-1]] <= x[r]:
                    dmax.pop()
                dmax.append(r)
                while dmin and y[dmin[-1]] >= y[r]:
                    dmin.pop()
                dmin.append(r)
                while dmax and dmin and x[dmax[0]] > y[dmin[0]]:
                    if dmax[0] == l:
                        dmax.popleft()
                    if dmin[0] == l:
                        dmin.popleft()
                    l += 1
                    while dmax and dmax[0] < l:
                        dmax.popleft()
                    while dmin and dmin[0] < l:
                        dmin.popleft()
                ans = max(ans, r - l + 1)
            return ans

    class Baseline:
        def maxSelectedElements(self, nums: List[int]) -> int:
            nums = sorted(nums)
            n = len(nums)
            ans = 0
            for l in range(n):
                mmax = float('-inf')
                mmin = float('inf')
                for r in range(l, n):
                    val1 = nums[r] - r
                    val2 = nums[r] + 1 - r
                    if val1 > mmax:
                        mmax = val1
                    if val2 < mmin:
                        mmin = val2
                    if mmax <= mmin:
                        ans = max(ans, r - l + 1)
                    else:
                        break
            return ans

    opt = Opt()
    base = Baseline()

    # Deterministic cases
    cases = []
    cases.append([2,1,5,1,1])
    cases.append([1,4,7,10])
    cases.append(gen_all_equal(6, 5))
    cases.append(gen_strict_inc(6, 1))
    cases.append(gen_single_gap_block())
    cases.append(gen_large_gaps(5, 1, 3))  # unbridgeable gaps

    # Random small cases
    random.seed(0)
    for _ in range(50):
        n = random.randint(1, 12)
        arr = [random.randint(1, 12) for _ in range(n)]
        cases.append(arr)

    for arr in cases:
        assert opt.maxSelectedElements(arr[:]) == base.maxSelectedElements(arr[:])

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        # Final O(n log n) overall (due to sort) and O(n) window pass
        nums.sort()
        n = len(nums)
        x = [nums[i] - i for i in range(n)]
        y = [nums[i] + 1 - i for i in range(n)]
        dmax = deque()
        dmin = deque()
        ans = 0
        l = 0
        for r in range(n):
            # Update deques with r
            while dmax and x[dmax[-1]] <= x[r]:
                dmax.pop()
            dmax.append(r)
            while dmin and y[dmin[-1]] >= y[r]:
                dmin.pop()
            dmin.append(r)
            # Shrink from left until feasible
            while dmax and dmin and x[dmax[0]] > y[dmin[0]]:
                if dmax[0] == l:
                    dmax.popleft()
                if dmin[0] == l:
                    dmin.popleft()
                l += 1
                while dmax and dmax[0] < l:
                    dmax.popleft()
                while dmin and dmin[0] < l:
                    dmin.popleft()
            ans = max(ans, r - l + 1)
        return ans

if __name__ == "__main__":
    sol = Solution()
    # Sanity tests
    assert sol.maxSelectedElements([2,1,5,1,1]) == 3
    assert sol.maxSelectedElements([1,4,7,10]) == 1
    assert sol.maxSelectedElements([1,3,3]) == 3
    assert sol.maxSelectedElements([1,1,1,1]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Longest window \([l,r]\) in sorted \(\texttt{nums}\) where \(\max(a_k-k)\le \min(a_k+1-k)\).}
\WHY{This pattern (assigning to consecutive slots with limited per-item slack) appears in scheduling and greedy matching problems; it tests your ability to turn feasibility into a sliding window with range extrema.}
\CHECKLIST{
\begin{bullets}
\item Sort the array.
\item Build \(x_i = a_i - i\), \(y_i = a_i + 1 - i\).
\item Maintain deques for \(\max x\) and \(\min y\) over \([l,r]\).
\item While infeasible, increment \(l\), evicting old indices.
\item Track the best window length.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All values equal: answer is \(\min(2, n)\).
\item Single-element array: answer \(1\).
\item One missing integer between clusters (e.g., \([1,3,3]\)): bridgeable.
\item Two or more missing integers between clusters: not bridgeable.
\item Large ranges and duplicates near boundaries.
\item Arrays where optimal window starts in a gap rather than at an element value.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to add \(+1\) in \(a_i+1-i\) for the upper interval bound.
\item Off-by-one in window maintenance when popping indices \(\le i-m\) (fixed-size) or \(< l\) (variable-size).
\item Not updating both deques when advancing \(l\).
\item Assuming the run must start at an existing element value (it may start in a gap).
\item Using naive greedy that commits too early (fails on \([1,3,3]\)).
\item Mishandling duplicates (selected set must be strictly consecutive, no repeats).
\end{bullets}
}
\FAILMODES{Greedy that always places \(a_i\) at \(\max(\text{need}, a_i)\) misses cases where delaying use (placing \(a_i\) at \(a_i+1\)) yields a longer chain. Sliding window with range extrema avoids such local traps.}
\ELI{Think of laying your numbers on a number line and each number can stretch one step to the right. You want the longest solid block of integers you can fill. Sorting and tracking how far left and right each element can push lets you slide a window and keep only those ranges where everyone fits.}
\NotePages{3}

\end{document}