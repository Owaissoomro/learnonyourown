% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Unimodal Array}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/831/A}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{Array of integers is unimodal, if:
\begin{itemize}
\item it is strictly increasing in the beginning;
\item after that it is constant;
\item after that it is strictly decreasing.
\end{itemize}
The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5, 7, 11, 11, 2, 1], [4, 4, 2], [7], but the following three are not unimodal: [5, 5, 6, 6, 1], [1, 2, 1, 2], [4, 5, 5, 6].

Write a program that checks if an array is unimodal.

Input:
The first line contains integer $n$ ($1 \le n \le 100$) — the number of elements in the array.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 1{,}000$) — the elements of the array.

Output:
Print ``YES'' if the given array is unimodal. Otherwise, print ``NO''.

You can output each letter in any case (upper or lower).

Note:
In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), then it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).}
\BREAKDOWN{We must detect whether the sequence can be partitioned into up to three consecutive phases: strictly increasing, then constant, then strictly decreasing. A single linear scan with a small state machine suffices.}
\ELI{Walk once from left to right: go up while you can, then flat while you can, then down while you can; if you ever go the wrong way for your current phase, it is not unimodal.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case:
\begin{itemize}
\item Integer $n$ ($1 \le n \le 100$).
\item Sequence of $n$ integers $a_1, \ldots, a_n$ ($1 \le a_i \le 1{,}000$).
\end{itemize}}
\OUTPUTS{Print ``YES'' if the array is unimodal under the definition; otherwise print ``NO''. A trailing newline is acceptable.}
\SAMPLES{Examples (Codeforces style):
\begin{itemize}
\item Input:\quad 6; array: 5 7 11 11 2 1.\quad Output: YES.
\item Input:\quad 4; array: 4 5 5 6.\quad Output: NO.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite sequence $(a_k)_{k=1}^n$ with $n \ge 1$, decide if there exist indices $1 \le i \le j \le n$ such that:
\[
\begin{aligned}
&\text{(Inc)} && a_1 < a_2 < \cdots < a_i, \\
&\text{(Const)} && a_i = a_{i+1} = \cdots = a_j, \\
&\text{(Dec)} && a_j > a_{j+1} > \cdots > a_n,
\end{aligned}
\]
where any of the strict segments may be empty by taking $i=1$ (no increasing) or $j=n$ (no decreasing). The constant segment is at least length 1 (possibly a single element).}
\varmapStart
\var{n}{length of the sequence}
\var{a_k}{the $k$-th element of the sequence}
\var{i}{last index of the strictly increasing prefix (can be 1)}
\var{j}{last index of the constant block, $i \le j \le n$}
\varmapEnd
\GOVERN{
\[
\exists\, i,j \text{ with } 1 \le i \le j \le n \text{ s.t. }
\bigwedge_{k=2}^{i} (a_{k-1} < a_k)\ \wedge\
\bigwedge_{k=i+1}^{j} (a_{k-1} = a_k)\ \wedge\
\bigwedge_{k=j+1}^{n} (a_{k-1} > a_k).
\]
}
\ASSUMPTIONS{Indices are 1-based in the definition; comparisons are over integers; no further structure is assumed.}
\INVARIANTS{
\begin{itemize}
\item Once a non-increasing step ($a_k \le a_{k-1}$) occurs, the increasing phase is over.
\item Once a strictly decreasing step occurs, the constant phase is over.
\item In the decreasing phase, no non-decreasing step is permitted.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all valid splits $(i,j)$ and check the three conditions directly.}
\ASSUMPTIONS{Small $n$ permits a cubic scan; $n \le 100$ so $O(n^3)$ is fine.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For every $i \in \{1,\ldots,n\}$ and $j \in \{i,\ldots,n\}$:
\item Check $a_{1} < a_{2} < \cdots < a_{i}$; then $a_{i} = \cdots = a_{j}$; then $a_{j} > \cdots > a_{n}$.
\item If any pair $(i,j)$ passes, answer YES; otherwise NO.
\end{algosteps}
\COMPLEXITY{Triple loop worst case with inner linear checks: $T(n)=\Theta(n^3)$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} \sum_{j=i}^{n} O(n) \\
     &= O\!\left(n \cdot \frac{n(n+1)}{2}\right) = O(n^3).
\end{aligned}
\]
\CORRECTNESS{Exhaustive over all legal $(i,j)$ boundaries; if a valid unimodal decomposition exists, it will be found. Each check enforces the strict/constant relations by construction.}
\EDGECASES{All equal; strictly increasing; strictly decreasing; immediate decrease; single element.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import io
import contextlib

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return n, arr

def is_unimodal_bruteforce(a: List[int]) -> bool:
    n = len(a)
    if n == 0:
        return False
    # Use 1-based friendly indices in logic
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            ok = True
            # Increasing: positions 1..i strictly increasing
            for k in range(2, i + 1):
                if not (a[k - 2] < a[k - 1]):
                    ok = False
                    break
            if not ok:
                continue
            # Constant: positions i..j equal
            for k in range(i + 1, j + 1):
                if not (a[k - 2] == a[k - 1]):
                    ok = False
                    break
            if not ok:
                continue
            # Decreasing: positions j..n strictly decreasing
            for k in range(j + 1, n + 1):
                if not (a[k - 2] > a[k - 1]):
                    ok = False
                    break
            if ok:
                return True
    return False

def solve_case(n: int, a: List[int]) -> str:
    return "YES" if is_unimodal_bruteforce(a) else "NO"

def solve_all() -> None:
    n, a = read_input()
    if n == 0 and not a:
        return
    print(solve_case(n, a))

def main() -> None:
    solve_all()

# --- Tests (baseline) ---
if __name__ == "__main__":
    # Direct helper asserts
    assert is_unimodal_bruteforce([5,7,11,11,2,1]) is True
    assert is_unimodal_bruteforce([4,4,2]) is True
    assert is_unimodal_bruteforce([7]) is True
    assert is_unimodal_bruteforce([5,5,6,6,1]) is False
    assert is_unimodal_bruteforce([1,2,1,2]) is False
    assert is_unimodal_bruteforce([4,5,5,6]) is False
    # End-to-end I/O mini-tests
    sample_in = "6\n5 7 11 11 2 1\n"
    with contextlib.redirect_stdout(io.StringIO()) as buf:
        sys.stdin = io.StringIO(sample_in)
        solve_all()
        out = buf.getvalue().strip()
    assert out == "YES"
    sample_in = "4\n4 5 5 6\n"
    with contextlib.redirect_stdout(io.StringIO()) as buf:
        sys.stdin = io.StringIO(sample_in)
        solve_all()
        out = buf.getvalue().strip()
    assert out == "NO"
\end{minted}
\VALIDATION{Covered provided examples and several edge patterns; end-to-end checks confirm the printout.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Linear-time single scan with a 3-state finite automaton: states for increasing, constant, and decreasing.}
\ASSUMPTIONS{One left-to-right pass; transitions only in the order Inc $\to$ Const $\to$ Dec; no reversals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize state = Inc.
\item For each adjacent pair $(a_{k-1}, a_k)$:
\begin{itemize}
\item If $a_k > a_{k-1}$: allowed only in Inc; if in Const or Dec, reject; stay in Inc.
\item If $a_k = a_{k-1}$: allowed in Inc or Const; move to Const.
\item If $a_k < a_{k-1}$: allowed in Inc or Const; move to Dec; in Dec, any non-decrease rejects.
\end{itemize}
\item If the scan finishes without violation, answer YES.
\end{algosteps}
\COMPLEXITY{Single pass, constant memory.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{By the invariant that transitions are monotone Inc $\to$ Const $\to$ Dec and each state's relation is enforced on every step, the accepted sequences are exactly those admitting indices $(i,j)$ satisfying the unimodal definition.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import io, contextlib

INC, CONST, DEC = 0, 1, 2

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return n, arr

def is_unimodal_linear(a: List[int]) -> bool:
    n = len(a)
    if n == 0:
        return False
    state = INC
    for k in range(1, n):
        if a[k] > a[k - 1]:
            if state == CONST:
                # Increasing after plateau is not allowed
                return False
            if state == DEC:
                # Increasing after decrease is not allowed
                return False
            state = INC
        elif a[k] == a[k - 1]:
            if state == DEC:
                # Flat after decrease is not allowed
                return False
            state = CONST
        else:  # a[k] < a[k - 1]
            state = DEC
    return True

def solve_case(n: int, a: List[int]) -> str:
    return "YES" if is_unimodal_linear(a) else "NO"

def solve_all() -> None:
    n, a = read_input()
    if n == 0 and not a:
        return
    print(solve_case(n, a))

def main() -> None:
    solve_all()

# Tests for improved approach
if __name__ == "__main__":
    # Helper asserts
    assert is_unimodal_linear([5,7,11,11,2,1]) is True
    assert is_unimodal_linear([4,4,2]) is True
    assert is_unimodal_linear([7]) is True
    assert is_unimodal_linear([5,5,6,6,1]) is False
    assert is_unimodal_linear([1,2,1,2]) is False
    assert is_unimodal_linear([4,5,5,6]) is False
    # Cross-check against brute for small spaces
    def brute(a):  # local brute for cross-check
        n = len(a)
        if n == 0: return False
        for i in range(1, n + 1):
            for j in range(i, n + 1):
                ok = True
                for k in range(2, i + 1):
                    if not (a[k - 2] < a[k - 1]): ok = False; break
                if not ok: continue
                for k in range(i + 1, j + 1):
                    if not (a[k - 2] == a[k - 1]): ok = False; break
                if not ok: continue
                for k in range(j + 1, n + 1):
                    if not (a[k - 2] > a[k - 1]): ok = False; break
                if ok: return True
        return False
    for arr in ([1],[2,1],[1,2],[2,2],[1,2,2,1],[3,2,1],[1,1,1],[1,3,2,2]):
        assert is_unimodal_linear(arr) == brute(arr)
    # I/O test
    sample_in = "6\n5 7 11 11 2 1\n"
    with contextlib.redirect_stdout(io.StringIO()) as buf:
        sys.stdin = io.StringIO(sample_in)
        solve_all()
        out = buf.getvalue().strip()
    assert out == "YES"
\end{minted}
\VALIDATION{Unit asserts mirror the statement examples; brute-force cross-check over small arrays confirms equivalence.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same one-pass finite automaton; this is asymptotically optimal since every element must be read.}
\ASSUMPTIONS{Input length $n$ unknown a priori; reading all $n$ elements is necessary.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize state to Inc.
\item For each next element, compare to previous and enforce allowed transitions Inc $\to$ Const $\to$ Dec.
\item Reject if any forbidden transition occurs; otherwise accept at end.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect all inputs in the worst case; this method is $O(n)$ time and $O(1)$ space, hence optimal up to constant factors.}
\COMPLEXITY{$T(n)=\Theta(n)$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n) &= n-1 \text{ comparisons } \in \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import io, contextlib

INC, CONST, DEC = 0, 1, 2

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def is_unimodal(a: List[int]) -> bool:
    n = len(a)
    if n == 0:
        return False
    state = INC
    for i in range(1, n):
        if a[i] > a[i - 1]:
            if state != INC:
                return False
        elif a[i] == a[i - 1]:
            if state == DEC:
                return False
            state = CONST
        else:  # a[i] < a[i - 1]
            state = DEC
    return True

def solve_case(n: int, a: List[int]) -> str:
    return "YES" if is_unimodal(a) else "NO"

def solve_all() -> None:
    n, a = read_input()
    if n == 0 and not a:
        return
    print(solve_case(n, a))

def main() -> None:
    solve_all()

if __name__ == "__main__":
    # 3 exact asserts or I/O mini-tests
    assert is_unimodal([5,7,11,11,2,1]) is True
    assert is_unimodal([4,5,5,6]) is False
    sample_in = "3\n3 2 1\n"
    with contextlib.redirect_stdout(io.StringIO()) as buf:
        sys.stdin = io.StringIO(sample_in)
        solve_all()
        out = buf.getvalue().strip()
    assert out == "YES"
\end{minted}
\VALIDATION{Three checks: two direct helper asserts and one end-to-end I/O run.}
\RESULT{Print ``YES'' if the array is unimodal under the Inc-Const-Dec definition; otherwise ``NO''. Case-insensitive output is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on helper is\_unimodal; end-to-end I/O tests; exhaustive cross-check on small domains ($n \le 4$, values in $\{1,2,3\}$).}
\LINE{CROSS-CHECKS}{Compare the brute-force baseline and the linear method on many tiny arrays to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays that are all equal, strictly increasing, strictly decreasing, and with single transitions at ends.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Iterable
def gen_all_small(n_max: int = 4, vmax: int = 3) -> Iterable[List[int]]:
    def rec(n: int, cur: List[int]):
        if len(cur) == n:
            yield cur[:]
            return
        for v in range(1, vmax + 1):
            cur.append(v)
            yield from rec(n, cur)
            cur.pop()
    for n in range(1, n_max + 1):
        yield from rec(n, [])

def is_unimodal_bruteforce(a: List[int]) -> bool:
    n = len(a)
    if n == 0: return False
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            ok = True
            for k in range(2, i + 1):
                if not (a[k - 2] < a[k - 1]): ok = False; break
            if not ok: continue
            for k in range(i + 1, j + 1):
                if not (a[k - 2] == a[k - 1]): ok = False; break
            if not ok: continue
            for k in range(j + 1, n + 1):
                if not (a[k - 2] > a[k - 1]): ok = False; break
            if ok: return True
    return False

def is_unimodal_linear(a: List[int]) -> bool:
    if not a: return False
    INC, CONST, DEC = 0, 1, 2
    state = INC
    for i in range(1, len(a)):
        if a[i] > a[i-1]:
            if state != INC: return False
        elif a[i] == a[i-1]:
            if state == DEC: return False
            state = CONST
        else:
            state = DEC
    return True

# Cross-check
for arr in gen_all_small(4, 3):
    assert is_unimodal_bruteforce(arr) == is_unimodal_linear(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys
from typing import List, Tuple

INC, CONST, DEC = 0, 1, 2

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def is_unimodal(a: List[int]) -> bool:
    n = len(a)
    if n == 0:
        return False
    state = INC
    for i in range(1, n):
        if a[i] > a[i - 1]:
            if state != INC:
                return False
        elif a[i] == a[i - 1]:
            if state == DEC:
                return False
            state = CONST
        else:
            state = DEC
    return True

def solve_case(n: int, a: List[int]) -> str:
    return "YES" if is_unimodal(a) else "NO"

def solve_all() -> None:
    n, a = read_input()
    if n == 0 and not a:
        return
    print(solve_case(n, a))

def main() -> None:
    solve_all()

if __name__ == "__main__":
    # Minimal sanity asserts
    assert is_unimodal([1,2,3]) is True
    assert is_unimodal([3,2,1]) is True
    assert is_unimodal([1,2,1,2]) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decide if a sequence is increasing, then flat, then decreasing with no violations.}
\WHY{Patterns like ``mountain with plateau'' appear in array invariants and scanning proofs; mastering small state machines is a common interview theme.}
\CHECKLIST{
\begin{itemize}
\item Initialize state to Inc.
\item For each step, compare with previous.
\item Disallow increase after Const or Dec.
\item Disallow flat after Dec.
\item Accept at end if no violations.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Single element (YES).
\item All equal (YES).
\item Strictly increasing (YES).
\item Strictly decreasing (YES).
\item Increase after plateau (NO), e.g., [1,1,2].
\item Flat after starting to decrease (NO), e.g., [3,2,2].
\item Up-down-up (NO), e.g., [1,3,2,3].
\item Multiple plateaus separated by increases (NO).
\item Immediate decrease at start (YES).
\item Plateau length 1 (allowed).
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Accidentally allowing an increase after the constant phase.
\item Treating an empty array as unimodal (it is not in this problem).
\item Mishandling boundaries at transitions $i$ and $j$.
\item Using non-strict comparisons in the wrong phase.
\item Forgetting that the constant block can be length 1.
\item Misreading that decreasing-only arrays are allowed (they are, with a length-1 constant block at the top).
\item Not resetting or tracking state consistently.
\item Off-by-one in adjacency comparisons.
\end{itemize}}
\FAILMODES{Brute force with wrong inequality directions; two-pass methods that mis-handle equal elements at the peak; approaches allowing Inc $\leftrightarrow$ Const $\leftrightarrow$ Dec back-and-forth. The one-pass FSM forbids backward transitions.}
\ELI{Scan once: first go up, then go flat, then go down. If you ever try to go up after flattening or go flat after going down, it is not unimodal. Otherwise, it is.}
\NotePages{3}

\end{document}