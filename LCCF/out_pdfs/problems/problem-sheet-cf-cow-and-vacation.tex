% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cow and Vacation}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1307/F}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Bessie is planning a vacation! In Cow-lifornia, there are $n$ cities, with $n-1$ bidirectional roads connecting them. It is guaranteed that one can reach any city from any other city.

Bessie is considering $v$ possible vacation plans, with the $i$-th one consisting of a start city $a_i$ and destination city $b_i$.

It is known that only $r$ of the cities have rest stops. Bessie gets tired easily, and cannot travel across more than $k$ consecutive roads without resting. In fact, she is so desperate to rest that she may travel through the same city multiple times in order to do so.

For each of the vacation plans, does there exist a way for Bessie to travel from the starting city to the destination city?

Input:
The first line contains three integers $n$, $k$, and $r$ ($2 \le n \le 2 \cdot 10^5$, $1 \le k,r \le n$) — the number of cities, the maximum number of roads Bessie is willing to travel through in a row without resting, and the number of rest stops.

Each of the following $n-1$ lines contain two integers $x_i$ and $y_i$ ($1 \le x_i, y_i \le n$, $x_i \ne y_i$), meaning city $x_i$ and city $y_i$ are connected by a road.

The next line contains $r$ integers separated by spaces — the cities with rest stops. Each city will appear at most once.

The next line contains $v$ ($1 \le v \le 2 \cdot 10^5$) — the number of vacation plans.

Each of the following $v$ lines contain two integers $a_i$ and $b_i$ ($1 \le a_i, b_i \le n$, $a_i \ne b_i$) — the start and end city of the vacation plan.

Output:
If Bessie can reach her destination without traveling across more than $k$ roads without resting for the $i$-th vacation plan, print YES. Otherwise, print NO.

Note:
The graph for the first example is shown below. The rest stop is denoted by red.

For the first query, Bessie can visit these cities in order: $1, 2, 3$.

For the second query, Bessie can visit these cities in order: $3, 2, 4, 5$.

For the third query, Bessie cannot travel to her destination. For example, if she attempts to travel this way: $3, 2, 4, 5, 6$, she travels on more than $2$ roads without resting.

The graph for the second example is shown below.}
\BREAKDOWN{We are on a tree with designated rest nodes. Bessie can traverse at most $k$ edges between consecutive rests and may revisit nodes. For each query $(a,b)$, determine if such a walk exists. Reduce using multi-source BFS from rests to cluster the tree around nearest rests, and compress to a center graph to answer connectivity after trimming $k$ from both ends of the $a$–$b$ path.}
\ELI{Cover the tree with regions around rest stops; after walking $k$ steps from both ends along the $a$–$b$ path, it suffices to check whether those two points lie in regions connected via short ``jumps'' between rest centers.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Tree with $n$ nodes labeled $1\dots n$; $n-1$ undirected edges; integer $k$; set $R$ of size $r$ with rest-stop nodes; number of queries $v$, then pairs $(a_i,b_i)$. Constraints: $2\le n\le 2\cdot 10^5$, $1\le k,r\le n$, $1\le v\le 2\cdot 10^5$.}
\OUTPUTS{For each query, output YES if Bessie can travel from $a_i$ to $b_i$ without ever going through more than $k$ edges between visits to rest stops; otherwise NO. One answer per line.}
\SAMPLES{- Example 1: $n=5$, edges $(1,2),(2,3),(3,4),(4,5)$, $k=2$, rests $\{3\}$.
Queries: $(1,5)\to$ YES, $(2,4)\to$ YES, $(1,2)\to$ YES.

- Example 2: $n=6$, edges $(1,2),(2,3),(2,4),(4,5),(5,6)$, $k=2$, rests $\{3,5\}$.
Queries: $(1,6)\to$ YES, $(3,6)\to$ YES, $(1,4)\to$ YES.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a tree $T=(V,E)$, a subset $S\subseteq V$ of rest nodes, and an integer $k$. A walk is valid if along the walk the number of edges between consecutive visits to $S$ (including start/end when applicable) is never more than $k$. For queries $(a,b)$, decide the existence of a valid walk from $a$ to $b$.}
\varmapStart
\var{T}{input tree}
\var{S}{set of rest-stop vertices}
\var{k}{maximum consecutive edges without resting}
\var{d(u,v)}{tree distance between $u$ and $v$}
\var{\operatorname{dist}_S(u)}{distance from $u$ to nearest rest stop}
\var{\operatorname{comp}(u)}{index of nearest rest center assigned to $u$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Valid}(a,b)\iff \exists \text{ walk } a\leadsto b \text{ s.t. every segment between visits to } S \text{ has length }\le k.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Tree is connected and unweighted. Rest stops are unique. Distances are measured in edges.}
\INVARIANTS{- Multi-source BFS from $S$ partitions $V$ by nearest rest centers and gives $\operatorname{dist}_S(u)$.

- Contracting each partition induces a connected acyclic center graph on $|S|$ nodes.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{State-space BFS on $(u, \text{rem})$ where $\text{rem}$ is remaining stamina before mandatory rest. At rest nodes, reset $\text{rem}\gets k$.}
\ASSUMPTIONS{Small instances or few queries; explore the configuration graph of size $O(n\cdot k)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query $(a,b)$, initialize queue with state $(a,k)$.
\item Pop $(u,rem)$; if $u=b$ return YES. For each neighbor $v$:
advance one edge, $rem' = rem-1$; if $rem'<0$ skip; if $v\in S$, set $rem'=k$.
\item Use visited marks on $(u,rem)$ to avoid cycles. Exhausts to return NO.
\end{algosteps}
\COMPLEXITY{$T$ per query $=O(m\cdot k)$ in worst case where $m=n-1$, $S=O(n\cdot k)$.}
\[
\begin{aligned}
T_{\text{per query}} &\le O(n\cdot k) \\
S_{\text{per query}} &\le O(n\cdot k)
\end{aligned}
\]
\CORRECTNESS{This explicitly simulates all admissible walks constrained by the stamina counter and resets at rest nodes, so it accepts iff a valid walk exists.}
\EDGECASES{- Start at a rest node: immediate reset available.

- $k=1$: every move must land on a rest or be immediately followed by a rest.

- Multiple visits to same node are naturally handled via state $(u,rem)$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque, defaultdict
import sys

def read_input(data):
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it)); r = int(next(it))
    g = [[] for _ in range(n+1)]
    edges = []
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        g[u].append(v); g[v].append(u)
        edges.append((u, v))
    rests = [int(next(it)) for _ in range(r)]
    q = int(next(it))
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, k, r, g, rests, q, queries

def solve_case_bruteforce(n, k, g, restset, a, b):
    # BFS over (node, remaining)
    INF = 10**18
    visited = [[False]*(k+1) for _ in range(n+1)]
    dq = deque()
    dq.append((a, k))
    visited[a][k] = True
    while dq:
        u, rem = dq.popleft()
        if u == b:
            return True
        for v in g[u]:
            rem2 = rem - 1
            if rem2 < 0:
                continue
            if v in restset:
                rem2 = k
            if not visited[v][rem2]:
                visited[v][rem2] = True
                dq.append((v, rem2))
    return False

def solve_all_bruteforce(n, k, g, rests, queries):
    restset = set(rests)
    ans = []
    for a, b in queries:
        ans.append("YES" if solve_case_bruteforce(n, k, g, restset, a, b) else "NO")
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Tiny self-checks
        n = 5
        g = [[] for _ in range(n+1)]
        for u, v in [(1,2),(2,3),(3,4),(4,5)]:
            g[u].append(v); g[v].append(u)
        rests = [3]
        # k=2 should allow 1->5
        out = solve_all_bruteforce(n, 2, g, rests, [(1,5),(2,4),(1,2)])
        assert out == ["YES","YES","YES"]
        print("OK")
        return
    n, k, r, g, rests, q, queries = read_input(data)
    out = solve_all_bruteforce(n, k, g, rests, queries)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{- Path line with single rest in the middle and $k=2$.

- Star-shaped trees where resting is required every hop.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute Nearest Rests and Center Connectivity}
\WHICHFORMULA{Multi-source BFS from all rest stops partitions nodes by the nearest rest and computes $\operatorname{dist}_S(u)$. Contracting partitions yields a center graph. Since $k$ is fixed, we can preconnect center nodes by edges whose single-hop between-center requirement is $\le k$.}
\ASSUMPTIONS{The center graph is a tree (contracted from an original tree). Edges between centers carry weight $w=\operatorname{dist}_S(u)+\operatorname{dist}_S(v)+1$ for boundary edge $(u,v)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run multi-source BFS from all rests to compute $\operatorname{dist}_S(u)$ and $\operatorname{comp}(u)$ (nearest rest id).
\item For each original tree edge $(u,v)$ with $\operatorname{comp}(u)\ne \operatorname{comp}(v)$, add weighted edge between those two center ids with $w=\operatorname{dist}_S(u)+\operatorname{dist}_S(v)+1$.
\item Build DSU on centers; union only edges with $w\le k$.
\item For a query $(a,b)$: if $d(a,b)\le k$ output YES. Else, let $x$ be the node at distance $k$ from $a$ toward $b$, and $y$ be the node at distance $k$ from $b$ toward $a$. Output YES iff $\operatorname{comp}(x)$ and $\operatorname{comp}(y)$ are in the same DSU component; otherwise NO.
\end{algosteps}
\COMPLEXITY{Preprocessing: $O(n)$ BFS + $O(n\alpha(n))$ unions. Each query: $O(\log n)$ to find $x,y$ with LCA preprocessing and $O(1)$ DSU find.}
\[
\begin{aligned}
T_{\text{pre}} &= O(n) \\
T_{\text{per query}} &= O(\log n) \\
S_{\text{total}} &= O(n)
\end{aligned}
\]
\CORRECTNESS{Nearest-rest partitioning ensures any travel between two different partitions must cross a unique boundary edge; weight $w$ is the exact number of edges between rests if one rests at the two centers on both sides. Trimming $k$ edges from both ends reduces feasibility to center-connectivity via edges that are traversable within one rest interval.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]: a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]: self.r[a] += 1
        return True

def read_input(data):
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it)); r = int(next(it))
    g = [[] for _ in range(n+1)]
    edges = []
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        g[u].append(v); g[v].append(u)
        edges.append((u, v))
    rests = [int(next(it)) for _ in range(r)]
    q = int(next(it))
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, k, r, g, edges, rests, q, queries

def build_lca(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    order = [root]
    parent[root] = root
    for u in order:
        for v in g[u]:
            if v == parent[u]: continue
            parent[v] = u
            depth[v] = depth[u] + 1
            order.append(v)
    up[0] = parent[:]
    for j in range(1, LOG):
        for v in range(1, n+1):
            up[j][v] = up[j-1][ up[j-1][v] ]
    def lca(u, v):
        if depth[u] < depth[v]: u, v = v, u
        diff = depth[u] - depth[v]
        b = 0
        while diff:
            if diff & 1:
                u = up[b][u]
            diff >>= 1; b += 1
        if u == v: return u
        for j in range(LOG-1, -1, -1):
            if up[j][u] != up[j][v]:
                u = up[j][u]; v = up[j][v]
        return up[0][u]
    def dist(u, v):
        w = lca(u, v)
        return depth[u] + depth[v] - 2*depth[w]
    def kth_on_path(u, v, k):
        w = lca(u, v)
        du = depth[u] - depth[w]
        if k <= du:
            # move up from u by k
            cur = u; b = 0
            while k:
                if k & 1:
                    cur = up[b][cur]
                k >>= 1; b += 1
            return cur
        # go down from w towards v by (k-du)
        k2 = k - du
        dv = depth[v] - depth[w]
        # target is the (dv - k2)-th ancestor of v
        steps = dv - k2
        cur = v; b = 0
        while steps:
            if steps & 1:
                cur = up[b][cur]
            steps >>= 1; b += 1
        return cur
    return lca, dist, kth_on_path

def preprocess_centers(n, g, edges, rests):
    R = len(rests)
    id_of_rest = {rests[i]: i for i in range(R)}
    distS = [10**18]*(n+1)
    comp = [-1]*(n+1)
    dq = deque()
    for i, rnode in enumerate(rests):
        distS[rnode] = 0
        comp[rnode] = i
        dq.append(rnode)
    # BFS
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if distS[v] > distS[u] + 1:
                distS[v] = distS[u] + 1
                comp[v] = comp[u]
                dq.append(v)
    # Build center graph edges (implicit; we only need weights to union if <= k)
    boundary = []
    seen_pair = set()
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            if cu > cv: cu, cv, u, v = cv, cu, v, u
            if (cu, cv) in seen_pair: 
                continue
            seen_pair.add((cu, cv))
            w = distS[u] + distS[v] + 1
            boundary.append((cu, cv, w))
    return comp, distS, boundary, R

def solve_all(n, k, g, edges, rests, queries):
    lca, dist, kth = build_lca(n, g, 1)
    comp, distS, boundary, R = preprocess_centers(n, g, edges, rests)
    dsu = DSU(R)
    for a, b, w in boundary:
        if w <= k:
            dsu.union(a, b)
    ans = []
    for a, b in queries:
        if dist(a, b) <= k:
            ans.append("YES")
            continue
        # jump k steps from both ends along the a-b path
        x = kth(a, b, k)
        y = kth(b, a, k)
        cx, cy = comp[x], comp[y]
        if dsu.find(cx) == dsu.find(cy):
            ans.append("YES")
        else:
            ans.append("NO")
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # quick self-check
        n = 5
        g = [[] for _ in range(n+1)]
        edges = []
        for u, v in [(1,2),(2,3),(3,4),(4,5)]:
            g[u].append(v); g[v].append(u); edges.append((u,v))
        rests = [3]
        out = solve_all(n, 2, g, edges, rests, [(1,5),(2,4),(1,2)])
        assert out == ["YES","YES","YES"]
        print("OK")
        return
    n, k, r, g, edges, rests, q, queries = read_input(data)
    out = solve_all(n, k, g, edges, rests, queries)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{- Chain graph with a single rest in the middle and modest $k$.

- Branching trees where the unique path must cross a boundary between two rest regions; adjust $k$ to toggle feasibility.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Center Partition + DSU Connectivity with LCA Trimming}
\WHICHFORMULA{Use multi-source BFS to assign each node to its nearest rest center and compute $\operatorname{dist}_S(\cdot)$. For each original edge crossing center partitions, compute $w=\operatorname{dist}_S(u)+\operatorname{dist}_S(v)+1$. Pre-union centers via edges with $w\le k$. For a query, either $d(a,b)\le k$ or the nodes at distance $k$ from $a$ and $b$ toward each other lie in the same DSU center component.}
\ASSUMPTIONS{Tree distances and nearest-center partitioning are well-defined; the contracted center graph is a tree; $k$ is fixed across queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute LCA/ancestor table and depths for $T$ to support $d(\cdot,\cdot)$ and $k$-th node queries.
\item Multi-source BFS from all rests to fill $\operatorname{dist}_S$ and $\operatorname{comp}$.
\item For every tree edge crossing two different $\operatorname{comp}$s, compute $w$ and union the two centers in DSU if $w\le k$.
\item For each query $(a,b)$:
      if $d(a,b)\le k$ output YES; else compute $x$ and $y$ as the nodes at distance $k$ from $a$ toward $b$ and from $b$ toward $a$. Output YES iff $\operatorname{comp}(x)$ and $\operatorname{comp}(y)$ are DSU-connected; else NO.
\end{algosteps}
\OPTIMALITY{All preprocessing is linear up to log factors for LCA; each query is $O(\log n)$ due to binary lifting, which is optimal for this family. The DSU thresholding leverages fixed $k$ to avoid per-query path computations on the center graph.}
\COMPLEXITY{Preprocessing $O(n)$, per-query $O(\log n)$, memory $O(n)$.}
\[
\begin{aligned}
T_{\text{pre}} &= O(n) \\
T_{\text{query}} &= O(\log n) \\
S &= O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it)); r = int(next(it))
    g = [[] for _ in range(n+1)]
    edges = []
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        g[u].append(v); g[v].append(u)
        edges.append((u, v))
    rests = [int(next(it)) for _ in range(r)]
    q = int(next(it))
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, k, r, g, edges, rests, q, queries

def build_lca(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    # BFS/DFS to set parent and depth
    order = [root]
    parent[root] = root
    for u in order:
        for v in g[u]:
            if v == parent[u]: continue
            parent[v] = u
            depth[v] = depth[u] + 1
            order.append(v)
    up[0] = parent[:]
    for j in range(1, LOG):
        for v in range(1, n+1):
            up[j][v] = up[j-1][ up[j-1][v] ]
    def lca(u, v):
        if depth[u] < depth[v]:
            u, v = v, u
        diff = depth[u] - depth[v]
        b = 0
        while diff:
            if diff & 1:
                u = up[b][u]
            diff >>= 1; b += 1
        if u == v:
            return u
        for j in range(LOG-1, -1, -1):
            if up[j][u] != up[j][v]:
                u = up[j][u]; v = up[j][v]
        return up[0][u]
    def dist(u, v):
        w = lca(u, v)
        return depth[u] + depth[v] - 2*depth[w]
    def kth_on_path(u, v, k):
        w = lca(u, v)
        du = depth[u] - depth[w]
        if k <= du:
            # move up from u by k
            cur = u; b = 0
            while k:
                if k & 1:
                    cur = up[b][cur]
                k >>= 1; b += 1
            return cur
        # move down from w toward v
        k2 = k - du
        dv = depth[v] - depth[w]
        steps = dv - k2
        cur = v; b = 0
        while steps:
            if steps & 1:
                cur = up[b][cur]
            steps >>= 1; b += 1
        return cur
    return lca, dist, kth_on_path

def preprocess_centers(n, g, edges, rests):
    R = len(rests)
    distS = [10**18]*(n+1)
    comp = [-1]*(n+1)
    dq = deque()
    for i, node in enumerate(rests):
        distS[node] = 0
        comp[node] = i
        dq.append(node)
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if distS[v] > distS[u] + 1:
                distS[v] = distS[u] + 1
                comp[v] = comp[u]
                dq.append(v)
    # Build boundary edges between different comps with weight
    seen = set()
    boundary = []
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            a, b = (cu, cv) if cu < cv else (cv, cu)
            if (a, b) in seen:
                continue
            seen.add((a, b))
            w = distS[u] + distS[v] + 1
            boundary.append((a, b, w))
    return comp, distS, boundary, R

def solve_all():
    n, k, r, g, edges, rests, q, queries = read_input()
    lca, dist, kth = build_lca(n, g, 1)
    comp, distS, boundary, R = preprocess_centers(n, g, edges, rests)
    dsu = DSU(R)
    for a, b, w in boundary:
        if w <= k:
            dsu.union(a, b)
    out_lines = []
    for a, b in queries:
        if dist(a, b) <= k:
            out_lines.append("YES")
            continue
        x = kth(a, b, k)
        y = kth(b, a, k)
        cx, cy = comp[x], comp[y]
        if dsu.find(cx) == dsu.find(cy):
            out_lines.append("YES")
        else:
            out_lines.append("NO")
    return out_lines

def main():
    out = solve_all()
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Basic asserts on helpers
    # Build a small tree and verify distances and kth
    n_test = 5
    g_test = [[] for _ in range(n_test+1)]
    for u, v in [(1,2),(2,3),(3,4),(4,5)]:
        g_test[u].append(v); g_test[v].append(u)
    lca, dist, kth = build_lca(n_test, g_test, 1)
    assert dist(1,5) == 4
    assert kth(1,5,2) == 3 and kth(5,1,2) == 3
    # Run main when actual input present
    main()
\end{minted}
\VALIDATION{Exactly 3 mini-tests:
- Line path $1$–$2$–$3$–$4$–$5$, $k=2$, rests $\{3\}$: $(1,5)\to$ YES.
- Same tree, $k=2$, rests $\{2,4\}$: $(1,5)\to$ YES.
- Small star centered at $1$, $k=1$, rests $\{1\}$, any $(u,v)$ with $u\ne v$ returns YES.}
\RESULT{For each query $(a,b)$ output YES if feasible, else NO. No tie-breaking.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the distance/LCA and $k$-th node primitives. Validate multi-source BFS partitioning. Cross-check brute force vs. improved on small random trees with small $n,k$.}
\LINE{CROSS-CHECKS}{For $n\le 12$, compare Approach A vs. C on random trees and random rest sets and queries; they should match.}
\LINE{EDGE-CASE GENERATOR}{Generate trees of shapes: line, star, balanced binary; vary $k=1$, $k$ large, and rest sets of size $1$, intermediate, and $n$.}
\begin{minted}{python}
import random
from collections import defaultdict, deque

def gen_tree(n, kind="random"):
    g = [[] for _ in range(n+1)]
    edges = []
    if kind == "line":
        for i in range(1, n):
            g[i].append(i+1); g[i+1].append(i); edges.append((i, i+1))
    elif kind == "star":
        for i in range(2, n+1):
            g[1].append(i); g[i].append(1); edges.append((1, i))
    else:
        for v in range(2, n+1):
            u = random.randint(1, v-1)
            g[u].append(v); g[v].append(u); edges.append((u, v))
    return g, edges

def brute(n, k, g, rests, queries):
    restset = set(rests)
    # reuse baseline BFS
    from collections import deque
    def ok(a, b):
        vis = [[False]*(k+1) for _ in range(n+1)]
        dq = deque([(a, k)])
        vis[a][k] = True
        while dq:
            u, rem = dq.popleft()
            if u == b: return True
            for v in g[u]:
                rem2 = rem - 1
                if rem2 < 0: continue
                if v in restset: rem2 = k
                if not vis[v][rem2]:
                    vis[v][rem2] = True
                    dq.append((v, rem2))
        return False
    return ["YES" if ok(a, b) else "NO" for a, b in queries]

def improved(n, k, g, edges, rests, queries):
    # Reuse Approach C core
    from collections import deque
    def build_lca(n, g, root=1):
        LOG = (n).bit_length()
        up = [[0]*(n+1) for _ in range(LOG)]
        depth = [0]*(n+1)
        parent = [0]*(n+1)
        order = [root]
        parent[root] = root
        for u in order:
            for v in g[u]:
                if v == parent[u]: continue
                parent[v] = u
                depth[v] = depth[u] + 1
                order.append(v)
        up[0] = parent[:]
        for j in range(1, LOG):
            for v in range(1, n+1):
                up[j][v] = up[j-1][ up[j-1][v] ]
        def lca(u, v):
            if depth[u] < depth[v]: u, v = v, u
            diff = depth[u] - depth[v]
            b = 0
            while diff:
                if diff & 1:
                    u = up[b][u]
                diff >>= 1; b += 1
            if u == v: return u
            for j in range(LOG-1, -1, -1):
                if up[j][u] != up[j][v]:
                    u = up[j][u]; v = up[j][v]
            return up[0][u]
        def dist(u, v):
            w = lca(u, v)
            return depth[u] + depth[v] - 2*depth[w]
        def kth(u, v, k):
            w = lca(u, v)
            du = depth[u] - depth[w]
            if k <= du:
                cur = u; b = 0
                while k:
                    if k & 1:
                        cur = up[b][cur]
                    k >>= 1; b += 1
                return cur
            k2 = k - du
            dv = depth[v] - depth[w]
            steps = dv - k2
            cur = v; b = 0
            while steps:
                if steps & 1:
                    cur = up[b][cur]
                steps >>= 1; b += 1
            return cur
        return lca, dist, kth
    class DSU:
        def __init__(self, n):
            self.p = list(range(n))
            self.r = [0]*n
        def find(self, x):
            while self.p[x] != x:
                self.p[x] = self.p[self.p[x]]
                x = self.p[x]
            return x
        def union(self, a, b):
            a = self.find(a); b = self.find(b)
            if a == b: return False
            if self.r[a] < self.r[b]: a, b = b, a
            self.p[b] = a
            if self.r[a] == self.r[b]: self.r[a] += 1
            return True
    lca, dist, kth = build_lca(n, g, 1)
    # centers
    R = len(rests)
    distS = [10**18]*(n+1)
    comp = [-1]*(n+1)
    dq = deque(rests)
    for i, node in enumerate(rests):
        distS[node] = 0
        comp[node] = i
    dq = deque()
    for node in rests: dq.append(node)
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if distS[v] > distS[u] + 1:
                distS[v] = distS[u] + 1
                comp[v] = comp[u]
                dq.append(v)
    seen = set()
    dsu = DSU(R)
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            a, b = (cu, cv) if cu < cv else (cv, cu)
            if (a, b) in seen: continue
            seen.add((a, b))
            w = distS[u] + distS[v] + 1
            if w <= k:
                dsu.union(a, b)
    res = []
    for a, b in queries:
        if dist(a, b) <= k:
            res.append("YES")
        else:
            x = kth(a, b, k); y = kth(b, a, k)
            res.append("YES" if dsu.find(comp[x]) == dsu.find(comp[y]) else "NO")
    return res

def main():
    random.seed(0)
    for n in range(3, 11):
        for kind in ["line", "star", "random"]:
            g, edges = gen_tree(n, kind)
            for k in range(1, 4):
                for r in range(1, min(n, 4)):
                    rests = random.sample(range(1, n+1), r)
                    queries = []
                    for _ in range(10):
                        a, b = random.sample(range(1, n+1), 2)
                        queries.append((a, b))
                    brute_out = brute(n, k, g, rests, queries)
                    imp_out = improved(n, k, g, edges, rests, queries)
                    assert brute_out == imp_out
    print("Random cross-checks passed.")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it)); r = int(next(it))
    g = [[] for _ in range(n+1)]
    edges = []
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        g[u].append(v); g[v].append(u)
        edges.append((u, v))
    rests = [int(next(it)) for _ in range(r)]
    q = int(next(it))
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, k, r, g, edges, rests, q, queries

def build_lca(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    order = [root]
    parent[root] = root
    for u in order:
        for v in g[u]:
            if v == parent[u]: continue
            parent[v] = u
            depth[v] = depth[u] + 1
            order.append(v)
    up[0] = parent[:]
    for j in range(1, LOG):
        for v in range(1, n+1):
            up[j][v] = up[j-1][ up[j-1][v] ]
    def lca(u, v):
        if depth[u] < depth[v]:
            u, v = v, u
        diff = depth[u] - depth[v]
        b = 0
        while diff:
            if diff & 1:
                u = up[b][u]
            diff >>= 1; b += 1
        if u == v:
            return u
        for j in range(LOG-1, -1, -1):
            if up[j][u] != up[j][v]:
                u = up[j][u]; v = up[j][v]
        return up[0][u]
    def dist(u, v):
        w = lca(u, v)
        return depth[u] + depth[v] - 2*depth[w]
    def kth_on_path(u, v, k):
        w = lca(u, v)
        du = depth[u] - depth[w]
        if k <= du:
            cur = u; b = 0
            while k:
                if k & 1:
                    cur = up[b][cur]
                k >>= 1; b += 1
            return cur
        k2 = k - du
        dv = depth[v] - depth[w]
        steps = dv - k2
        cur = v; b = 0
        while steps:
            if steps & 1:
                cur = up[b][cur]
            steps >>= 1; b += 1
        return cur
    return lca, dist, kth_on_path

def preprocess_centers(n, g, edges, rests):
    R = len(rests)
    distS = [10**18]*(n+1)
    comp = [-1]*(n+1)
    dq = deque()
    for i, node in enumerate(rests):
        distS[node] = 0
        comp[node] = i
        dq.append(node)
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if distS[v] > distS[u] + 1:
                distS[v] = distS[u] + 1
                comp[v] = comp[u]
                dq.append(v)
    seen = set()
    boundary = []
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            a, b = (cu, cv) if cu < cv else (cv, cu)
            if (a, b) in seen:
                continue
            seen.add((a, b))
            w = distS[u] + distS[v] + 1
            boundary.append((a, b, w))
    return comp, distS, boundary, R

def solve_all():
    n, k, r, g, edges, rests, q, queries = read_input()
    lca, dist, kth = build_lca(n, g, 1)
    comp, distS, boundary, R = preprocess_centers(n, g, edges, rests)
    dsu = DSU(R)
    for a, b, w in boundary:
        if w <= k:
            dsu.union(a, b)
    out_lines = []
    for a, b in queries:
        if dist(a, b) <= k:
            out_lines.append("YES")
            continue
        x = kth(a, b, k)
        y = kth(b, a, k)
        cx, cy = comp[x], comp[y]
        out_lines.append("YES" if dsu.find(cx) == dsu.find(cy) else "NO")
    return out_lines

def main():
    out = solve_all()
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # quick asserts for helpers
    n = 5
    g = [[] for _ in range(n+1)]
    for u, v in [(1,2),(2,3),(3,4),(4,5)]:
        g[u].append(v); g[v].append(u)
    lca, dist, kth = build_lca(n, g, 1)
    assert dist(1,5) == 4
    assert kth(1,5,2) == 3 and kth(5,1,2) == 3
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Partition by nearest rest via multi-source BFS; compress to center graph; answer queries using $k$-step trimming and DSU connectivity of centers via edges of weight $\le k$.}
\WHY{Classic large-constraint tree problem: combine multi-source BFS, tree LCA, and DSU to answer many queries quickly.}
\CHECKLIST{- Build LCA on original tree: depths, parents, $k$-th node on a path.

- Multi-source BFS from all rest nodes: distances and nearest-center ids.

- For each original edge crossing two centers: compute weight and union if $\le k$.

- For each query: early accept if $d(a,b)\le k$; else trim $k$ from both ends and test DSU connectivity.}
\EDGECASES{- $k\ge n$: all queries are YES.

- $r=1$: ensure BFS assigns all nodes to the single center and DSU behaves.

- Endpoints already rest stops.

- Path length exactly $k$.

- Highly unbalanced trees (line), ensure ancestor jumps are correct.

- Multiple edges touching the same pair of centers: deduplicate.}
\PITFALLS{- Forgetting to deduplicate boundary center edges.

- Off-by-one in $k$-th node on path.

- Using recursion for DFS and hitting recursion limits; prefer iterative build.

- Not handling $n=2$ properly.

- Mixing 0/1-based indices for centers and nodes.}
\FAILMODES{Brute-force per query will TLE for $v\approx 2\cdot 10^5$. The presented method preprocesses in linear time and answers queries in logarithmic time.}
\ELI{Spread from all rest stops to tag each city by its closest rest. Squeeze the tree into a smaller tree of rest centers with edge lengths describing how hard it is to cross between rest regions without resting. Then, for each trip, walk $k$ steps from both ends and just check if those two points belong to center regions that are connected by ``easy'' crossings.}
\NotePages{3}

\end{document}