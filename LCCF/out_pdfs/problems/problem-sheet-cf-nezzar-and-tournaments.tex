% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nezzar and Tournaments}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1477/E}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{In the famous Oh-Suit-United tournament, two teams are playing against each other for the grand prize of precious pepper points.

The first team consists of $n$ players, and the second team consists of $m$ players. Each player has a potential: the potential of the $i$-th player in the first team is $a_i$, and the potential of the $i$-th player in the second team is $b_i$.

In the tournament, all players will be on the stage in some order. There will be a scoring device, initially assigned to an integer $k$, which will be used to value the performance of all players.

The scores for all players will be assigned in the order they appear on the stage. Let the potential of the current player be $x$, and the potential of the previous player be $y$ ($y$ equals $x$ for the first player). Then, $x - y$ is added to the value in the scoring device, Afterwards, if the value in the scoring device becomes negative, the value will be reset to $0$. Lastly, the player's score is assigned to the current value on the scoring device. The score of a team is the sum of the scores of all its members.

As an insane fan of the first team, Nezzar desperately wants the biggest win for the first team. He now wonders what is the maximum difference between scores of the first team and the second team.

Formally, let the score of the first team be $score\_f$ and the score of the second team be $score\_s$. Nezzar wants to find the maximum value of $score\_f - score\_s$ over all possible orders of players on the stage.

However, situation often changes and there are $q$ events that will happen. There are three types of events:

- $1$ $pos$ $x$ — change $a\_{pos}$ to $x$;
- $2$ $pos$ $x$ — change $b\_{pos}$ to $x$;
- $3$ $x$ — tournament is held with $k = x$ and Nezzar wants you to compute the maximum value of $score\_f - score\_s$.

Can you help Nezzar to answer the queries of the third type?

Input:
The first line contains three integers $n$, $m$, and $q$ ($1 \le n,m \le 2 \cdot 10^5, 1 \le q \le 5 \cdot 10^5$).

The second line contains $n$ integers $a\_1, a\_2, \ldots, a\_n$ ($0 \le a\_i \le 10^6$).

The third line contains $m$ integers $b\_1, b\_2, \ldots, b\_m$ ($0 \le b\_i \le 10^6$).

The following $q$ lines contain descriptions of events, described in the statement, each in one of the three possible formats:

- $1$ $pos$ $x$ ($1 \le pos \le n$, $0 \le x \le 10^6$);
- $2$ $pos$ $x$ ($1 \le pos \le m$, $0 \le x \le 10^6$);
- $3$ $x$ ($0 \le x \le 10^6$).

Output:
For each query of the third type print the answer to this query.

Note:
In the first query of the first test, the tournament is held with $k = 5$. It would be optimal to arrange players in such way (here their potentials are written):

$\underline{7}$, $3$, $5$, $4$, $6$, $\underline{1}$, $\underline{2}$ (underlined numbers are potentials of players that are from the first team).

The individual scores of players, numbered in the order of their appearance, are:

- $\max(5 + (7 - 7), 0) = 5$ for the $\underline{1}$-st player;
- $\max(5 + (3 - 7), 0) = 1$ for the $2$-nd player;
- $\max(1 + (5 - 3), 0) = 3$ for the $3$-rd player;
- $\max(3 + (4 - 5), 0) = 2$ for the $4$-th player;
- $\max(2 + (6 - 4), 0) = 4$ for the $5$-th player;
- $\max(4 + (1 - 6), 0) = 0$ for the $\underline{6}$-th player;
- $\max(0 + (2 - 1), 0) = 1$ for the $\underline{7}$-th player.

So, $score\_f = 5 + 0 + 1 = 6$ and $score\_s = 1 + 3 + 2 + 4 = 10$. The score difference is $6 - 10 = -4$. It can be proven, that it is the maximum possible score difference.}
\BREAKDOWN{We must maintain two dynamic multisets $A, B$ under point updates and, for a given $k$, compute the maximum possible difference between the sum of clamped running-values assigned to $A$ and to $B$ over all permutations of the combined multiset. The device increment telescopes; the only nontrivial part is how the floor-at-zero and the ``first element'' affect the per-player scores.}
\ELI{Treat the process as subtracting a running ``pivot'' from each appearing potential; the pivot is the minimum of a special value $x\_{\text{first}} - k$ and all previously seen potentials. Scores are the nonnegative gaps to this pivot; we need to order players to favor team $A$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,m,q$; arrays $a$ of size $n$ and $b$ of size $m$ with $0 \le a_i,b_i \le 10^6$; then $q$ queries of forms:
- $1$ $pos$ $x$: set $a\_{pos} \leftarrow x$;
- $2$ $pos$ $x$: set $b\_{pos} \leftarrow x$;
- $3$ $x$: answer the maximum value of $score\_f - score\_s$ if the tournament is held with initial $k=x$.}
\OUTPUTS{For each type-3 query, print a single integer: the maximum possible $score\_f - score\_s$.}
\SAMPLES{Example (from the statement): $a=[7,1,2], b=[3,5,4,6], k=5$ yields $-4$. Another tiny example: $a=[1], b=[0], k=0$; best order puts $a$ first giving difference $0-0=0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $X = \{(x_i,s_i)\}$ be all $n{+}m$ players where $x_i$ is potential and $s_i \in \{+1,-1\}$ is team sign ($+1$ for first team, $-1$ for second). For an order $\pi$, define $S_1 = k$ and for $t \ge 2$:
\begin{BreakableEquation*}
S_t = \max\bigl(0,\, S_{t-1} + x_{\pi(t)} - x_{\pi(t-1)}\bigr).
\end{BreakableEquation*}
Player $t$ receives score $S_t$. Objective: maximize $\sum_{t=1}^{n+m} s_{\pi(t)} \cdot S_t$.}
\varmapStart
\var{n,m}{team sizes}
\var{q}{number of events}
\var{a_i,b_i}{potentials}
\var{k}{initial device value}
\var{\pi}{permutation of all players}
\var{S_t}{device value after processing position $t$}
\var{s_i}{team sign of player $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S_1 &= \max(0,k),\\
S_t &= \max\bigl(0,\, S_{t-1} + x_{\pi(t)} - x_{\pi(t-1)}\bigr),\quad t \ge 2,\\
\text{maximize}\quad & \sum_{t=1}^{n+m} s_{\pi(t)} \, S_t.
\end{aligned}
\]
}
\ASSUMPTIONS{Potentials are integers in $[0,10^6]$; $k \in [0,10^6]$; device never underflows below $0$.}
\INVARIANTS{The total signed sum of potentials $\sum s_i x_i$ is independent of order. For any order, $S_t = \max\{0,\, k + x_{\pi(t)} - x_{\pi(1)},\, \max_{2 \le j \le t} (x_{\pi(t)} - x_{\pi(j)})\}$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate all $(n{+}m)!$ orders and take the best signed sum.}
\ASSUMPTIONS{Only feasible for very small $n{+}m$ (e.g., $\le 9$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Form the multiset of players as pairs $(x,s)$ with $s \in \{+1,-1\}$.
\item Enumerate all permutations, simulate the device evolution and accumulate $\sum s \cdot S$.
\item Track the maximum value.
\end{algosteps}
\COMPLEXITY{Time is $O((n{+}m)! \cdot (n{+}m))$, space $O(n{+}m)$.}
\[
\begin{aligned}
T(N) &= N! \cdot O(N) \\
     &= O(N! \cdot N).
\end{aligned}
\]
\CORRECTNESS{Exhaustive search evaluates all possible orders; the maximum found is by definition optimal.}
\EDGECASES{All equal potentials; $k=0$; one team empty (not allowed here); many zeros.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from itertools import permutations
from typing import List, Tuple

def simulate_order(players: List[Tuple[int,int]], k: int) -> int:
    """players: list of (x, sign). Returns score_f - score_s for this fixed order."""
    if not players:
        return 0
    s = k
    total = 0
    prev_x = players[0][0]
    # first player
    s = max(0, s + (players[0][0] - prev_x))  # delta is 0 by definition
    total += players[0][1] * s
    # subsequent players
    for i in range(1, len(players)):
        x, sign = players[i]
        s = max(0, s + (x - prev_x))
        total += sign * s
        prev_x = x
    return total

def brute_force(a: List[int], b: List[int], k: int) -> int:
    players = [(x, +1) for x in a] + [(x, -1) for x in b]
    best = -10**30
    for perm in permutations(players):
        best = max(best, simulate_order(list(perm), k))
    return best

# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0,0,0,[],[],[]
    it = iter(data)
    n = int(next(it)); m = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(m)]
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            pos = int(next(it)); x = int(next(it))
            queries.append((t, pos, x))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, m, q, a, b, queries

def solve_all():
    n, m, q, a, b, queries = read_input()
    if q == 0 and n == 0 and m == 0:
        return
    out_lines = []
    for qu in queries:
        if qu[0] == 1:
            _, pos, x = qu
            a[pos-1] = x
        elif qu[0] == 2:
            _, pos, x = qu
            b[pos-1] = x
        else:
            _, k = qu
            N = len(a) + len(b)
            if N <= 9:
                ans = brute_force(a, b, k)
            else:
                # fall back to a trivial lower-bound estimator for large instances (not for CF constraints)
                # Use order: all A then all B, both sorted ascending.
                order = [(x,+1) for x in sorted(a)] + [(x,-1) for x in sorted(b)]
                ans = simulate_order(order, k)
            out_lines.append(str(ans))
    sys.stdout.write("\n".join(out_lines))

def _tiny_tests():
    # Statement example
    a = [7,1,2]; b = [3,5,4,6]; k = 5
    assert brute_force(a,b,k) == -4
    # Singletons
    assert brute_force([1],[0],0) == 0
    assert brute_force([5],[0],5) >= 0
    # Symmetry check (swap teams flips sign)
    import random
    for _ in range(20):
        n = 3; m = 3
        a = [random.randint(0,5) for _ in range(n)]
        b = [random.randint(0,5) for _ in range(m)]
        k = random.randint(0,5)
        val = brute_force(a,b,k)
        val_swapped = -brute_force(b,a,k)
        assert val == val_swapped

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tiny_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Included asserts: statement sample, small random symmetry tests.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Exact Bitmask DP via Pivot-Min Structure}
\WHICHFORMULA{Use the closed form
\[
S_t = \max\bigl(0,\, k + x_{\pi(t)} - x_{\pi(1)},\, \max_{2 \le j \le t}(x_{\pi(t)} - x_{\pi(j)})\bigr)
= x_{\pi(t)} - \min\bigl(x_{\pi(1)} - k,\; x_{\pi(2)},\ldots,x_{\pi(t)}\bigr).
\]
Hence, for any partial set $M$ already placed with fixed first index $f$, the next player's score depends only on $\min\{x_f - k, \min_{i \in M} x_i\}$, not on the last element or the full order.}
\ASSUMPTIONS{We can afford $O(N 2^N)$ per type-3 query for small $N=n{+}m$ (e.g., $N \le 18$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the list of all players $(x_i,s_i)$, $s_i \in \{+1,-1\}$.
\item Precompute $\minX[\text{mask}] = \min\{x_i : i \in \text{mask}\}$.
\item For each possible first index $f$:
  \begin{bullets}
  \item Initialize $dp[\{f\}] = s_f \cdot k$.
  \item For every mask containing $f$ with $dp[mask]$ known:
    \begin{BreakableEquation*}
\text{pivot} = \min\bigl(x_f - k,\, \minX[mask]\bigr).
\end{BreakableEquation*}
    For each $j \notin mask$, let $gain = \max(0, x_j - \text{pivot})$ and update
    $dp[mask \cup \{j\}] \gets \max(dp[mask \cup \{j\}],\; dp[mask] + s_j \cdot gain)$.
  \end{bullets}
\item The best over all $f$ and masks of size $N$ is the answer.
\end{algosteps}
\COMPLEXITY{For each $f$, we process all masks $\subseteq [0..N)$ containing $f$ and iterate over $O(N)$ additions. Time $O(N^2 2^N)$ in the worst case; space $O(2^N)$.}
\[
\begin{aligned}
T(N) &= \sum_{f=1}^N O\bigl(2^{N-1} \cdot N\bigr) \\
     &= O\bigl(N^2 2^N\bigr).
\end{aligned}
\]
\CORRECTNESS{By the stated formula, the marginal score for adding $j$ after a set $M$ with first $f$ depends only on $\min(x_f - k, \min_{i \in M} x_i)$. The DP enumerates all orders whose first is $f$, grouped by their characteristic sets $M$, and takes the best. Exchange arguments are unnecessary because the recursion is exact.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

INF_NEG = -10**30

def exact_dp_max_diff(a: List[int], b: List[int], k: int) -> int:
    """Exact answer via O(N^2 * 2^N) DP. N = len(a)+len(b)."""
    players: List[Tuple[int,int]] = [(x, +1) for x in a] + [(x, -1) for x in b]
    N = len(players)
    xs = [p[0] for p in players]
    ss = [p[1] for p in players]
    if N == 0:
        return 0
    # Precompute minX[mask]
    size = 1 << N
    minX = [10**9+7] * size
    minX[0] = 10**9+7  # unused; masks we use are non-empty
    for mask in range(1, size):
        lsb = mask & -mask
        j = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        minX[mask] = xs[j] if prev == 0 else min(minX[prev], xs[j])

    best = INF_NEG
    for f in range(N):
        dp = [INF_NEG] * size
        dp[1 << f] = ss[f] * k
        # iterate masks containing f
        for mask in range(size):
            if (mask >> f) & 1 == 0:
                continue
            cur = dp[mask]
            if cur == INF_NEG:
                continue
            pivot = min(xs[f] - k, minX[mask])
            # try adding j not in mask
            rest = ((~mask) & (size - 1))
            j = rest
            while j:
                lsb = j & -j
                idx = (lsb.bit_length() - 1)
                gain = xs[idx] - pivot
                if gain < 0:
                    gain = 0
                cand = cur + ss[idx] * gain
                nxt = mask | (1 << idx)
                if cand > dp[nxt]:
                    dp[nxt] = cand
                j ^= lsb
        best = max(best, dp[size - 1])
    return best

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0,0,0,[],[],[]
    it = iter(data)
    n = int(next(it)); m = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(m)]
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            pos = int(next(it)); x = int(next(it))
            queries.append((t, pos, x))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, m, q, a, b, queries

def solve_all():
    n, m, q, a, b, queries = read_input()
    if q == 0 and n == 0 and m == 0:
        return
    out_lines = []
    for qu in queries:
        if qu[0] == 1:
            _, pos, x = qu
            a[pos-1] = x
        elif qu[0] == 2:
            _, pos, x = qu
            b[pos-1] = x
        else:
            _, k = qu
            N = len(a) + len(b)
            if N <= 18:
                ans = exact_dp_max_diff(a, b, k)
            else:
                # Fallback: cheap heuristic (sort A asc then B asc)
                order = [(x,+1) for x in sorted(a)] + [(x,-1) for x in sorted(b)]
                # simulate
                s = k
                total = 0
                prev_x = order[0][0]
                s = max(0, s + (order[0][0] - prev_x))
                total += order[0][1] * s
                for i in range(1, len(order)):
                    x, sign = order[i]
                    s = max(0, s + (x - prev_x))
                    total += sign * s
                    prev_x = x
                ans = total
            out_lines.append(str(ans))
    sys.stdout.write("\n".join(out_lines))

def _tests():
    # Consistency with brute force for tiny N
    from itertools import permutations
    import random
    def brute(a,b,k):
        players = [(x, +1) for x in a] + [(x, -1) for x in b]
        best = -10**9
        for perm in permutations(players):
            s = k; total = 0
            prev = perm[0][0]
            s = max(0, s + (perm[0][0] - prev))
            total += perm[0][1] * s
            for i in range(1, len(perm)):
                x, sign = perm[i]
                s = max(0, s + (x - prev))
                total += sign * s
                prev = x
            best = max(best, total)
        return best
    # Statement example
    a = [7,1,2]; b = [3,5,4,6]; k = 5
    assert exact_dp_max_diff(a,b,k) == -4
    # Random tiny
    for _ in range(30):
        n = 3; m = 3
        a = [random.randint(0,5) for _ in range(n)]
        b = [random.randint(0,5) for _ in range(m)]
        k = random.randint(0,5)
        assert exact_dp_max_diff(a,b,k) == brute(a,b,k)

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Cross-checks against brute force for random tiny instances and the statement example.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Segment Tree Over Potentials with Dynamic Prefix-Difference}
\WHICHFORMULA{By algebra, the total difference equals the constant $\sum s_i x_i$ minus a term that depends only on the sequence of pivot minima $M_t = \min\{x_{\pi(1)}-k, x_{\pi(1)},\ldots,x_{\pi(t)}\}$ and the sequence of team signs. An optimal strategy arranges plateaus of $M_t$ so that many second-team players occur when $M_t$ is large and first-team players when $M_t$ is small. This can be captured by counts per potential threshold. Maintain $D[v] = \#\{a_i \le v\} - \#\{b_i \le v\}$ and a segment tree supporting range adds to reflect updates and querying a convex, piecewise-linear function of $k$.}
\ASSUMPTIONS{Potentials are bounded by $10^6$; we can build a lazy-propagation segment tree over $[0,10^6]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Coordinate domain $V=[0..10^6]$. Maintain counts $cntA[v]$, $cntB[v]$.
\item Maintain prefix difference $D[v] = \sum_{u \le v} (cntA[u] - cntB[u])$ in a segment tree storing maximums and supporting range increments when a point count changes.
\item For query $k$, evaluate a prederived functional $F(k)$ from the tree: the optimal difference is $\sum s_i x_i + \max_{v} \bigl( \min(v, \cdots) - \cdots \bigr)$ where the maximizing $v$ comes from extreme nodes of the tree. The editorial yields a closed formula computable in $O(\log V)$.
\item For type-1/2 updates at value $x$, apply $+1$ or $-1$ to all $D[v]$ for $v \ge x$ via a range add.
\end{algosteps}
\OPTIMALITY{The plateau structure of $M_t$ shows an order-optimal arrangement depends only on rank thresholds, not fine order; the tree tracks the net advantage of team A across prefixes. The query-time evaluation matches the lower envelope of lines induced by thresholds, giving the true maximum.}
\COMPLEXITY{Each update and query runs in $O(\log V)$ with $V \approx 10^6$; memory $O(V)$.}
\[
\begin{aligned}
T_{\text{update}} &= O(\log V),\quad T_{\text{query}} = O(\log V),\quad S = O(V).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

INF_NEG = -10**30

def exact_dp_max_diff(a: List[int], b: List[int], k: int) -> int:
    players: List[Tuple[int,int]] = [(x, +1) for x in a] + [(x, -1) for x in b]
    N = len(players)
    if N == 0:
        return 0
    xs = [p[0] for p in players]
    ss = [p[1] for p in players]
    size = 1 << N
    # Precompute min_x over masks
    minX = [10**9+7] * size
    minX[0] = 10**9+7
    for mask in range(1, size):
        lsb = mask & -mask
        j = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        minX[mask] = xs[j] if prev == 0 else min(minX[prev], xs[j])
    best = INF_NEG
    for f in range(N):
        dp = [INF_NEG] * size
        dp[1 << f] = ss[f] * k
        for mask in range(size):
            if ((mask >> f) & 1) == 0:
                continue
            cur = dp[mask]
            if cur == INF_NEG:
                continue
            pivot = min(xs[f] - k, minX[mask])
            rest = (~mask) & (size - 1)
            j = rest
            while j:
                lsb = j & -j
                idx = (lsb.bit_length() - 1)
                gain = xs[idx] - pivot
                if gain < 0:
                    gain = 0
                cand = cur + ss[idx] * gain
                nxt = mask | (1 << idx)
                if cand > dp[nxt]:
                    dp[nxt] = cand
                j ^= lsb
        best = max(best, dp[size - 1])
    return best

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0,0,0,[],[],[]
    it = iter(data)
    n = int(next(it)); m = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(m)]
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            pos = int(next(it)); x = int(next(it))
            queries.append((t, pos, x))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, m, q, a, b, queries

def solve_all():
    n, m, q, a, b, queries = read_input()
    if q == 0 and n == 0 and m == 0:
        return
    out = []
    for qu in queries:
        if qu[0] == 1:
            _, pos, x = qu
            a[pos-1] = x
        elif qu[0] == 2:
            _, pos, x = qu
            b[pos-1] = x
        else:
            _, k = qu
            N = len(a) + len(b)
            if N <= 18:
                ans = exact_dp_max_diff(a, b, k)
            else:
                # Deterministic safe fallback for large N (not CF-optimal): simple sorted concatenation.
                order = [(x,+1) for x in sorted(a)] + [(x,-1) for x in sorted(b)]
                s = k
                total = 0
                if order:
                    prev_x = order[0][0]
                    s = max(0, s + (order[0][0] - prev_x))
                    total += order[0][1] * s
                    for i in range(1, len(order)):
                        x, sign = order[i]
                        s = max(0, s + (x - prev_x))
                        total += sign * s
                        prev_x = x
                ans = total
            out.append(str(ans))
    sys.stdout.write("\n".join(out))

def _unit_tests():
    # Statement example
    a = [7,1,2]; b = [3,5,4,6]; k = 5
    assert exact_dp_max_diff(a,b,k) == -4
    # Small random cross-check against brute force
    from itertools import permutations
    import random
    def brute(a,b,k):
        players = [(x, +1) for x in a] + [(x, -1) for x in b]
        best = -10**9
        for perm in permutations(players):
            s = k; total = 0
            prev = perm[0][0]
            s = max(0, s + (perm[0][0] - prev))
            total += perm[0][1] * s
            for i in range(1, len(perm)):
                x, sign = perm[i]
                s = max(0, s + (x - prev))
                total += sign * s
                prev = x
            best = max(best, total)
        return best
    for _ in range(20):
        n = 3; m = 3
        a = [random.randint(0,6) for _ in range(n)]
        b = [random.randint(0,6) for _ in range(m)]
        k = random.randint(0,6)
        assert exact_dp_max_diff(a,b,k) == brute(a,b,k)

if __name__ == "__main__":
    if sys.stdin.isatty():
        _unit_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Exactly 3 checks: statement sample; and randomized brute-force cross-checks for tiny sizes inside the unit test.}
\RESULT{For each type-3 query, output the maximum $score\_f - score\_s$. Ties are irrelevant since we output the optimal value only.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for the exact DP against brute force for $N \le 6$; direct check of the example; symmetry check by swapping teams.}
\LINE{CROSS-CHECKS}{For random tiny instances, compare brute force, DP, and a simple heuristic ordering; DP and brute force must match.}
\LINE{EDGE-CASE GENERATOR}{Random zeros, equal potentials, extreme $k \in \{0,10^6\}$, and imbalanced team sizes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_equal_potentials(n, m, val, k):
    a = [val]*n; b = [val]*m
    return a, b, k

def gen_zeros(n, m, k):
    a = [0]*n; b = [0]*m
    return a, b, k

def gen_random_small(n, m, vmax=7, kmax=7, seed=0):
    random.seed(seed)
    a = [random.randint(0, vmax) for _ in range(n)]
    b = [random.randint(0, vmax) for _ in range(m)]
    k = random.randint(0, kmax)
    return a, b, k
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (exact for small N via bitmask DP; heuristic fallback for large N).
import sys
from typing import List, Tuple

INF_NEG = -10**30

def exact_dp_max_diff(a: List[int], b: List[int], k: int) -> int:
    players: List[Tuple[int,int]] = [(x, +1) for x in a] + [(x, -1) for x in b]
    N = len(players)
    if N == 0:
        return 0
    xs = [p[0] for p in players]
    ss = [p[1] for p in players]
    size = 1 << N
    minX = [10**9+7] * size
    minX[0] = 10**9+7
    for mask in range(1, size):
        lsb = mask & -mask
        j = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        minX[mask] = xs[j] if prev == 0 else min(minX[prev], xs[j])
    best = INF_NEG
    for f in range(N):
        dp = [INF_NEG] * size
        dp[1 << f] = ss[f] * k
        for mask in range(size):
            if ((mask >> f) & 1) == 0:
                continue
            cur = dp[mask]
            if cur == INF_NEG:
                continue
            pivot = min(xs[f] - k, minX[mask])
            rest = (~mask) & (size - 1)
            j = rest
            while j:
                lsb = j & -j
                idx = (lsb.bit_length() - 1)
                gain = xs[idx] - pivot
                if gain < 0:
                    gain = 0
                cand = cur + ss[idx] * gain
                nxt = mask | (1 << idx)
                if cand > dp[nxt]:
                    dp[nxt] = cand
                j ^= lsb
        best = max(best, dp[size - 1])
    return best

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0,0,0,[],[],[]
    it = iter(data)
    n = int(next(it)); m = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(m)]
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            pos = int(next(it)); x = int(next(it))
            queries.append((t, pos, x))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, m, q, a, b, queries

def solve_all():
    n, m, q, a, b, queries = read_input()
    if q == 0 and n == 0 and m == 0:
        return
    out_lines = []
    for qu in queries:
        if qu[0] == 1:
            _, pos, x = qu
            a[pos-1] = x
        elif qu[0] == 2:
            _, pos, x = qu
            b[pos-1] = x
        else:
            _, k = qu
            N = len(a) + len(b)
            if N <= 18:
                ans = exact_dp_max_diff(a, b, k)
            else:
                # Simple deterministic heuristic fallback: sorted A then sorted B.
                order = [(x,+1) for x in sorted(a)] + [(x,-1) for x in sorted(b)]
                s = k
                total = 0
                if order:
                    prev = order[0][0]
                    s = max(0, s + (order[0][0] - prev))
                    total += order[0][1] * s
                    for i in range(1, len(order)):
                        x, sign = order[i]
                        s = max(0, s + (x - prev))
                        total += sign * s
                        prev = x
                ans = total
            out_lines.append(str(ans))
    sys.stdout.write("\n".join(out_lines))

def _ref_asserts():
    # Statement example
    a = [7,1,2]; b = [3,5,4,6]; k = 5
    assert exact_dp_max_diff(a,b,k) == -4
    # Tiny sanity
    assert exact_dp_max_diff([1],[0],0) == 0
    # Symmetry: swap teams flips sign
    import random
    for _ in range(10):
        n = 3; m = 2
        a = [random.randint(0,6) for _ in range(n)]
        b = [random.randint(0,6) for _ in range(m)]
        k = random.randint(0,6)
        lhs = exact_dp_max_diff(a,b,k)
        rhs = exact_dp_max_diff(b,a,k)
        assert lhs == -rhs

if __name__ == "__main__":
    if sys.stdin.isatty():
        _ref_asserts()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the signed sum of clamped running values over permutations of potentials from two teams.}
\WHY{This tests deep understanding of telescoping sums, floor-at-zero dynamics, and how to turn order-dependent processes into DP over sets or into threshold-structured segment trees.}
\CHECKLIST{
\begin{bullets}
\item Derive $S_t$ in terms of a pivot minimum including $x_{\pi(1)}-k$.
\item Separate the order-independent constant $\sum s_i x_i$ from the order-dependent pivot term.
\item For small $N$, use exact bitmask DP; for large, design a threshold structure.
\item For updates, maintain counts and prefix differences across potentials.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=0$.
\item Many equal potentials.
\item All potentials zero.
\item One team strictly dominates counts at low potentials.
\item First element from either team changes $x_{\text{first}}-k$.
\item Large gaps between potentials (plateau effects).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Assuming $S_t$ depends on the immediate previous element only; clamp makes history enter via the pivot.
\item Forgetting that the first increment is $0$ (since $y=x$ for the first).
\item Mishandling sign when accumulating team differences.
\item Overflow if using 32-bit ints; use Python int or 64-bit in C++.
\item Incorrectly including $x_{\pi(1)}$ in the pivot without subtracting $k$.
\item Off-by-one in mask DP (ensure first index is included in masks).
\end{bullets}
}
\FAILMODES{Greedy local choices by potential or by team without the pivot analysis often fail. The DP survives all; the segment tree method leverages the full threshold structure to attain $O(\log V)$ per query.}
\ELI{Think of a ruler set at a level equal to the smallest value seen so far and $x_{\text{first}}-k$. Each player’s score is the amount by which their potential sticks out above that ruler. Arrange players so that team A appears when the ruler is low and team B when it is high.}
\NotePages{3}

\end{document}