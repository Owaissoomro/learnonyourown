% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Not a Cheap String}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1702/D}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{Let $s$ be a string of lowercase Latin letters. Its price is the sum of the indices of letters (an integer between 1 and 26) that are included in it. For example, the price of the string abca is $1+2+3+1=7$.

The string $w$ and the integer $p$ are given. Remove the minimal number of letters from $w$ so that its price becomes less than or equal to $p$ and print the resulting string. Note that the resulting string may be empty. You can delete arbitrary letters, they do not have to go in a row. If the price of a given string $w$ is less than or equal to $p$, then nothing needs to be deleted and $w$ must be output.

Note that when you delete a letter from $w$, the order of the remaining letters is preserved. For example, if you delete the letter e from the string test, you get tst.

Input:
The first line of input contains an integer $t$ ($1 \le t \le 10^4$) — the number of test cases in the test. The following are descriptions of $t$ test cases.

Each case consists of two lines.

The first of them is the string $w$, it is non-empty and consists of lowercase Latin letters. Its length does not exceed $2\cdot 10^5$.

The second line contains an integer $p$ ($1 \le p \le 5{,}200{,}000$).

It is guaranteed that the sum of string lengths $w$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
Output exactly $t$ rows, the $i$-th of them should contain the answer to the $i$-th set of input data. Print the longest string that is obtained from $w$ by deleting letters such that its price is less or equal to $p$. If there are several answers, then output any of them.

Note that the empty string — is one of the possible answers. In this case, just output an empty string.}
\BREAKDOWN{Compute the total price of $w$. If it exceeds $p$, delete as few letters as possible, always preferring to remove letters with larger indices first, while preserving the original order of the remaining letters.}
\ELI{Keep as many cheap letters as possible within budget $p$, deleting expensive ones first, and keep the original order.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases:
\begin{bullets}
\item Integer $t$ ($1 \le t \le 10^4$).
\item For each test: string $w$ (lowercase letters, $1 \le |w| \le 2\cdot 10^5$), and integer $p$ ($1 \le p \le 5{,}200{,}000$).
\end{bullets}
It is guaranteed $\sum |w| \le 2\cdot 10^5$.}
\OUTPUTS{For each test, output a string obtained by deleting some letters from $w$ such that:
\begin{bullets}
\item Its price (sum of letter indices a=1, b=2, \ldots, z=26) is $\le p$.
\item The number of deletions is minimal; equivalently, the output length is maximal.
\item Among multiple valid answers, any is acceptable. Order of remaining letters must match their order in $w$.
\end{bullets}}
\SAMPLES{Example 1 (single test):
\begin{bullets}
\item Input:
\[
\begin{aligned}
&1\\
&\texttt{abca}\\
&7
\end{aligned}
\]
\item Output:
\begin{BreakableEquation*}
\texttt{abca}
\end{BreakableEquation*}
\end{bullets}
Example 2 (single test):
\begin{bullets}
\item Input:
\[
\begin{aligned}
&1\\
&\texttt{zzazz}\\
&52
\end{aligned}
\]
\item One possible output:
\begin{BreakableEquation*}
\texttt{zz}
\end{BreakableEquation*}
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $w=w_1w_2\cdots w_n$, with cost function $c(\text{a})=1,\ldots,c(\text{z})=26$. Choose an index subset $S\subseteq \{1,\ldots,n\}$ to keep, preserving order, such that $\sum_{i\in S} c(w_i)\le p$ and $|S|$ is maximized.}
\varmapStart
\var{n}{length of $w$}
\var{w_i}{the $i$-th character of $w$}
\var{c(\cdot)}{letter cost in $\{1,\ldots,26\}$}
\var{p}{budget}
\var{S}{kept indices (in increasing order)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{maximize } &|S|\\
\text{subject to } &\sum_{i\in S} c(w_i)\le p,\\
&S\subseteq \{1,\ldots,n\},\quad i<j\in S \Rightarrow i \text{ precedes } j \text{ in output.}
\end{aligned}
\]
}
\ASSUMPTIONS{Alphabet is fixed lowercase Latin letters; costs are positive integers; feasibility is guaranteed by the empty set $S=\varnothing$.}
\INVARIANTS{
\begin{bullets}
\item Replacing a kept expensive letter by a cheaper one cannot decrease $|S|$ under the same budget.
\item For fixed multiset of kept letters, preserving index order yields a unique subsequence.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy deletions one-by-one: while the total price exceeds $p$, delete one occurrence of the currently most expensive remaining letter. This reduces the price fastest per deletion and preserves minimal deletions.}
\ASSUMPTIONS{We directly manipulate the current string as a list and repeatedly scan it to remove one maximal-cost letter.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute total price of $w$. If $\le p$, return $w$.
\item While total price $>$ $p$:
\begin{bullets}
\item Find the maximum letter value present in the current string.
\item Delete one occurrence (e.g., the leftmost) of such a letter; subtract its value from total.
\end{bullets}
\item Return the remaining letters in order.
\end{algosteps}
\COMPLEXITY{Let $K$ be the number of deletions. Each iteration scans $O(n)$ to find and delete the next target, so $T(n)=O(nK)$ in the worst case; $S(n)=O(n)$ to store a mutable list.}
\[
\begin{aligned}
T(n) &= O\bigl(n + K\cdot n\bigr) = O(nK),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Each deletion reduces total price by the maximal possible per single deletion, so for any target reduction, no strategy uses fewer deletions; preserving order is ensured by deleting characters in place without reordering.}
\EDGECASES{Already within budget; all letters identical; budget $p=1$; budget so small that output becomes empty.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Codeforces 1702D - Baseline O(n*K) greedy-delete
from typing import List, Tuple

def letter_value(ch: str) -> int:
    return ord(ch) - 96  # 'a'->1 ... 'z'->26

def price(s: str) -> int:
    return sum(letter_value(c) for c in s)

def solve_case_baseline(w: str, p: int) -> str:
    cur_sum = price(w)
    if cur_sum <= p:
        return w
    s = list(w)
    # Repeatedly delete one occurrence of the currently most expensive letter
    while cur_sum > p and s:
        # Find maximum letter value present
        max_val = 0
        for ch in s:
            v = ord(ch) - 96
            if v > max_val:
                max_val = v
        # Delete one occurrence (leftmost) of a letter with this max value
        for i, ch in enumerate(s):
            if ord(ch) - 96 == max_val:
                del s[i]
                cur_sum -= max_val
                break
    return "".join(s)

def read_input() -> List[Tuple[str, int]]:
    import sys
    data = sys.stdin.read().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases: List[Tuple[str, int]] = []
    for _ in range(t):
        w = next(it)
        p = int(next(it))
        cases.append((w, p))
    return cases

def solve_all_baseline(cases: List[Tuple[str, int]]) -> List[str]:
    return [solve_case_baseline(w, p) for (w, p) in cases]

def _self_test_baseline() -> None:
    assert solve_case_baseline("abca", 7) == "abca"
    assert solve_case_baseline("abca", 6) == "aba"  # delete 'c'
    assert solve_case_baseline("test", 40) == "es"  # delete both 't'
    # Budget too small -> empty
    assert solve_case_baseline("b", 1) == "" or solve_case_baseline("b", 1) == "b"  # depends; here deletes 'b' -> ""

def main() -> None:
    cases = read_input()
    if not cases:
        _self_test_baseline()
        return
    ans = solve_all_baseline(cases)
    import sys
    sys.stdout.write("\n".join(ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Quick checks:
\begin{bullets}
\item For $w=\texttt{zz}$, $p=26$, output length is 1.
\item For $w=\texttt{a}$, $p=1$, output is $\texttt{a}$.
\item For $w=\texttt{abc}$, $p=3$, one valid output is $\texttt{ac}$ or $\texttt{ba}$; baseline may output $\texttt{ab}$ or $\texttt{ac}$, all valid by constraints.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sort by Cost, Keep as Many as Budget Allows}
\WHICHFORMULA{Pick the longest subsequence by selecting the cheapest letters first: sort letters by cost (ties arbitrary), keep greedily while tracking spent budget, then output kept indices in original order.}
\ASSUMPTIONS{We sort the multiset of positions by letter value ascending and keep while cumulative cost $\le p$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pair each index $i$ with $(c(w_i), i)$ and sort ascending by $c(w_i)$ then by $i$.
\item Traverse the sorted list, keep index $i$ if adding $c(w_i)$ does not exceed $p$.
\item Let $K$ be the set of kept indices; sort $K$ (or traverse $w$ and check membership) to emit characters in original order.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $T(n)=O(n\log n)$, $S(n)=O(n)$ for indices.}
\[
\begin{aligned}
T(n) &= O(n\log n) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{Greedy-by-cost maximizes the number of items kept under a knapsack with unit weights and positive costs, independent of order; preserving the original order at the end yields a valid subsequence.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Codeforces 1702D - Improved O(n log n) sort-keep
from typing import List, Tuple

def letter_value(ch: str) -> int:
    return ord(ch) - 96

def solve_case_sorted_keep(w: str, p: int) -> str:
    n = len(w)
    pairs = [(letter_value(w[i]), i) for i in range(n)]
    pairs.sort()  # increasing by cost, then index
    budget = 0
    keep = [False] * n
    for val, i in pairs:
        if budget + val <= p:
            budget += val
            keep[i] = True
    # Output in original order
    out = []
    for i in range(n):
        if keep[i]:
            out.append(w[i])
    return "".join(out)

def read_input() -> List[Tuple[str, int]]:
    import sys
    data = sys.stdin.read().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases: List[Tuple[str, int]] = []
    for _ in range(t):
        w = next(it)
        p = int(next(it))
        cases.append((w, p))
    return cases

def solve_all(cases: List[Tuple[str, int]]) -> List[str]:
    return [solve_case_sorted_keep(w, p) for (w, p) in cases]

def _self_test_sorted() -> None:
    assert solve_case_sorted_keep("abca", 7) == "abca"
    # May keep any 3 letters whose total <= 6; sorted-keep retains 'a','a','b' -> "abaa" filtered to original order "aaba"? No, indices preserved -> "abaa" impossible. Actual function keeps indices of two 'a' and 'b' -> "aaba"? But original is "abca": kept i=0('a'),1('b'),3('a') -> "aba".
    assert solve_case_sorted_keep("abca", 6) == "aba"
    assert solve_case_sorted_keep("test", 40) == "es"
    assert solve_case_sorted_keep("zzazz", 52) in ("zz",)

def main() -> None:
    cases = read_input()
    if not cases:
        _self_test_sorted()
        return
    ans = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item Tiny: $w=\texttt{a}$, $p=1$ $\Rightarrow$ \texttt{a}.
\item Tight: $w=\texttt{zz}$, $p=26$ $\Rightarrow$ one \texttt{z}.
\item Mixed: $w=\texttt{bzaa}$, $p=3$ $\Rightarrow$ \texttt{aa}.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Linear Counting and Stable Reconstruction}
\WHICHFORMULA{Count how many of each letter to remove by traversing from $\text{z}\to\text{a}$ until the total price fits the budget, then reconstruct by skipping exactly those many occurrences while scanning $w$ left-to-right.}
\ASSUMPTIONS{Alphabet size is constant (26). We can compute frequency and removal counts in $O(26)$ passes; reconstruction is a single linear pass.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute total price $S=\sum_i c(w_i)$. If $S\le p$, return $w$.
\item Let $\text{cnt}[1..26]$ be letter frequencies. For $v=26$ down to $1$, while $S>p$ and $\text{cnt}[v]>0$, decrement $\text{cnt}[v]$, increment $\text{rem}[v]$, and set $S\mathrel{-}=v$.
\item Scan $w$ left-to-right: for letter value $v$, if $\text{rem}[v]>0$ then decrement $\text{rem}[v]$ and skip; otherwise append to output.
\end{algosteps}
\OPTIMALITY{Deleting from largest value down achieves the minimal number of deletions to reach any feasible total price because each deletion reduces the sum by the maximum possible amount. Stable reconstruction preserves original order; any solution with fewer deletions would exceed budget, and any solution with the same number of deletions cannot be longer.}
\COMPLEXITY{$T(n)=O(n+26)$ and $S(n)=O(26)$ besides the output.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Codeforces 1702D - Optimal O(n) counting solution
from typing import List, Tuple

def letter_value(ch: str) -> int:
    return ord(ch) - 96

def solve_case(w: str, p: int) -> str:
    total = sum(letter_value(c) for c in w)
    if total <= p:
        return w
    freq = [0] * 27
    for ch in w:
        freq[letter_value(ch)] += 1
    # Determine how many of each letter to remove
    remove = [0] * 27
    cur = total
    for v in range(26, 0, -1):
        while cur > p and freq[v] > 0:
            freq[v] -= 1
            remove[v] += 1
            cur -= v
        if cur <= p:
            break
    # Reconstruct by skipping exactly remove[v] occurrences
    out = []
    for ch in w:
        v = letter_value(ch)
        if remove[v] > 0:
            remove[v] -= 1
            continue
        out.append(ch)
    return "".join(out)

def read_input() -> List[Tuple[str, int]]:
    import sys
    data = sys.stdin.read().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases: List[Tuple[str, int]] = []
    for _ in range(t):
        w = next(it)
        p = int(next(it))
        cases.append((w, p))
    return cases

def solve_all(cases: List[Tuple[str, int]]) -> List[str]:
    return [solve_case(w, p) for (w, p) in cases]

def _self_tests() -> None:
    assert solve_case("abca", 7) == "abca"
    assert solve_case("abca", 6) == "aba"
    assert solve_case("zzazz", 52) == "zz"

def main() -> None:
    cases = read_input()
    if not cases:
        _self_tests()
        return
    ans = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts:
\begin{bullets}
\item $\texttt{abca},~p=7\Rightarrow\texttt{abca}$.
\item $\texttt{abca},~p=6\Rightarrow\texttt{aba}$.
\item $\texttt{zzazz},~p=52\Rightarrow\texttt{zz}$.
\end{bullets}}
\RESULT{For each test case, outputs a longest subsequence of $w$ with total letter price $\le p$, preserving order; ties are broken implicitly by skipping earliest expensive letters until the budget fits.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted cases covering: within budget, single deletion, multiple deletions across different letters, all deleted, and random mixes.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Optimal on tiny random cases to ensure identical lengths and valid subsequences under budget.}
\LINE{EDGE-CASE GENERATOR}{Generate strings of identical letters, alternating expensive/cheap letters, and budgets at thresholds (just below/above total).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_identical(ch: str, n: int, p: int) -> Tuple[str, int]:
    return ch * n, p

def gen_alternating(n: int, p: int) -> Tuple[str, int]:
    s = "".join("az"[i % 2] for i in range(n))
    return s, p

def is_subsequence(x: str, y: str) -> bool:
    # is x subsequence of y?
    it = iter(y)
    return all(c in it for c in x)

def check_solution(w: str, p: int, sol: str) -> None:
    def val(ch: str) -> int: return ord(ch) - 96
    assert is_subsequence(sol, w)
    assert sum(val(c) for c in sol) <= p

def quick_cross_check():
    from random import seed
    seed(0)
    def baseline(w: str, p: int) -> str:
        # Simple re-import-free baseline (max-delete loop)
        s = list(w)
        total = sum(ord(c)-96 for c in s)
        if total <= p:
            return w
        while total > p and s:
            maxv = max(ord(c)-96 for c in s)
            for i, ch in enumerate(s):
                if ord(ch)-96 == maxv:
                    total -= maxv
                    del s[i]
                    break
        return "".join(s)

    def optimal(w: str, p: int) -> str:
        total = sum(ord(c)-96 for c in w)
        if total <= p:
            return w
        freq = [0]*27
        for ch in w:
            freq[ord(ch)-96] += 1
        rem = [0]*27
        cur = total
        for v in range(26, 0, -1):
            while cur > p and freq[v] > 0:
                freq[v] -= 1
                rem[v] += 1
                cur -= v
            if cur <= p:
                break
        out = []
        for ch in w:
            v = ord(ch)-96
            if rem[v] > 0:
                rem[v] -= 1
                continue
            out.append(ch)
        return "".join(out)

    # Fixed cases
    for w, p in [("abca", 7), ("abca", 6), ("zzazz", 52), ("test", 40), ("b", 1), ("a", 1)]:
        b = baseline(w, p)
        o = optimal(w, p)
        check_solution(w, p, b)
        check_solution(w, p, o)
        assert len(b) == len(o)

    # Random small cases
    for n in range(1, 12):
        for _ in range(50):
            w = "".join(random.choice("abcxyz") for _ in range(n))
            p = random.randint(1, 26*n)
            b = baseline(w, p)
            o = optimal(w, p)
            check_solution(w, p, b)
            check_solution(w, p, o)
            assert len(b) == len(o)

if __name__ == "__main__":
    quick_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 1702D - Not a Cheap String (Final Reference)
from typing import List, Tuple

def letter_value(ch: str) -> int:
    return ord(ch) - 96  # 'a'->1 ... 'z'->26

def solve_case(w: str, p: int) -> str:
    total = sum(letter_value(c) for c in w)
    if total <= p:
        return w
    freq = [0] * 27
    for ch in w:
        freq[letter_value(ch)] += 1
    remove = [0] * 27
    cur = total
    for v in range(26, 0, -1):
        while cur > p and freq[v] > 0:
            freq[v] -= 1
            remove[v] += 1
            cur -= v
        if cur <= p:
            break
    out = []
    for ch in w:
        v = letter_value(ch)
        if remove[v] > 0:
            remove[v] -= 1
            continue
        out.append(ch)
    return "".join(out)

def read_input() -> List[Tuple[str, int]]:
    import sys
    data = sys.stdin.read().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases: List[Tuple[str, int]] = []
    for _ in range(t):
        w = next(it)
        p = int(next(it))
        cases.append((w, p))
    return cases

def solve_all(cases: List[Tuple[str, int]]) -> List[str]:
    return [solve_case(w, p) for (w, p) in cases]

def _self_tests() -> None:
    assert solve_case("abca", 7) == "abca"
    assert solve_case("abca", 6) == "aba"
    assert solve_case("zzazz", 52) == "zz"

def main() -> None:
    cases = read_input()
    if not cases:
        _self_tests()
        return
    ans = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(ans))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Delete the fewest (longest keep) letters so the total letter index sum is within budget, preserving order.}
\WHY{Greedy knapsack with unit weights and fixed small alphabet is common; recognizing to remove highest-cost items first and reconstruct stably is a frequent interview test.}
\CHECKLIST{
\begin{bullets}
\item Compute total price.
\item If within budget, return $w$.
\item Count frequencies and compute removals from z to a until budget fits.
\item Reconstruct by skipping exactly the planned removals.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Already within budget.
\item Budget allows only some of many identical high-cost letters.
\item Budget just one less than total (forces removal of at least a letter of cost 1).
\item Single-character string.
\item Output becomes empty.
\item Multiple optimal answers; any is valid.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Reordering kept letters (invalid) instead of preserving original order.
\item Removing too many of a letter due to not tracking per-letter removal counts.
\item Integer parsing and whitespace handling over multiple test cases.
\item Using $O(n\log n)$ unnecessarily when $O(n)$ counting suffices.
\item Forgetting that alphabet is lowercase only.
\item Accumulating budget with wrong letter-to-value mapping (off-by-one).
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Baseline that rescans the whole string per deletion may TLE on worst cases; the linear counting method avoids this.
\item Greedy by left-to-right acceptance without planning removals can violate minimal-deletion optimality.
\end{bullets}}
\ELI{Think of letters having prices. You have a budget and want to buy as many letters as possible from the given order. First decide how many of the most expensive letters to skip, then read the string and skip exactly those, keeping the rest in order.}
\NotePages{3}

\end{document}