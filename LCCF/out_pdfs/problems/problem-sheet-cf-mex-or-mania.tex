% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — MEX OR Mania}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2049/F}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{An integer sequence $b_1,b_2,\ldots,b_n$ is good if
\begin{BreakableEquation*}
\operatorname{mex}(b_1,b_2,\ldots,b_n) - (b_1 \mathbin{|} b_2 \mathbin{|} \ldots \mathbin{|} b_n) = 1,
\end{BreakableEquation*}
where $\operatorname{mex}(c)$ is the minimum excluded non\negthinspace-negative integer of the collection $c$, and $\mathbin{|}$ is bitwise OR.

Shohag has an integer sequence $a_1,a_2,\ldots,a_n$. He performs $q$ updates of the form $i~x$ meaning: increase $a_i$ by $x$.

After each update, output the length of the longest good subarray of $a$.

Input:
Each test contains multiple test cases. The first line has the number of test cases $t$ ($1 \le t \le 10^4$). For each test case:
- The first line has two integers $n$ and $q$ ($1 \le n,q \le 10^5$).
- The second line has $n$ integers $a_1,a_2,\ldots,a_n$ ($0 \le a_i \le n$).
- The next $q$ lines each have $i$ and $x$ ($1 \le i,x \le n$), meaning increase $a_i$ by $x$.

It is guaranteed that $\sum n \le 10^5$ and $\sum q \le 10^5$ over all test cases.

Output:
For each test case, print $q$ lines: on the $i$-th line, the length of the longest good subarray after the $i$-th update.

Note:
In one example, after an update the array becomes $[0,0,1,0,1,1]$, and the whole array is good because $\operatorname{mex}([0,0,1,0,1,1]) - (0 \mathbin{|} 0 \mathbin{|} 1 \mathbin{|} 0 \mathbin{|} 1 \mathbin{|} 1) = 2 - 1 = 1$.}
\BREAKDOWN{Characterize when a subarray is good; show it ties to powers of two. For each update, recompute or maintain the maximal length of such subarrays.}
\ELI{A subarray is good exactly when its distinct values are $\{0,1,\ldots,2^k-1\}$ for some $k$, and all its elements are less than $2^k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each:
- $n$ (length), $q$ (number of updates).
- Array $a$ of length $n$.
- Then $q$ updates: index $i$ and increment $x$.}
\OUTPUTS{After each update, a single integer: the maximum length of a good subarray of the current array.}
\SAMPLES{Example arrays:
- $a=[0,1,1] \Rightarrow$ longest good subarray length is $3$ (the whole array), since $\operatorname{mex}=2$ and OR $=1$.
- $a=[0,0,3,0,1,4] \Rightarrow$ longest good subarray length is $2$ (e.g., $[0,0]$ or $[0,1]$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a \in \mathbb{Z}_{\ge 0}^n$. A subarray $a[L..R]$ is good iff $\operatorname{mex}(a[L..R]) - \bigl(\bigl|\_{j=L}^R a_j\bigr) = 1$.}
\varmapStart
\var{a_i}{non\negthinspace-negative integer at index $i$}
\var{[L..R]}{a contiguous subarray}
\var{d}{candidate MEX, $d=\operatorname{mex}(a[L..R])$}
\var{\mathsf{OR}}{bitwise OR over a subarray}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{$a[L..R]$ is good} \iff \exists k\in\mathbb{Z}_{\ge 0}:\; d=2^k,\;\; \{a_L,\ldots,a_R\}_{\text{distinct}}=\{0,1,\ldots,d-1\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All values are non\negthinspace-negative; updates are increases only. Subarray mex equals $d$ iff all values $0,1,\ldots,d-1$ occur and $d$ does not occur.}
\INVARIANTS{
- If a subarray is good with mex $d$, then all its elements are $<d$ and the set of distinct values equals $\{0,\ldots,d-1\}$.
- Hence $d$ must be a power of two and $d=\text{distinct\_count}=\max\_value+1$ within the subarray.
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test every subarray after each update: compute $\operatorname{mex}$ and bitwise OR and check if their difference is $1$.}
\ASSUMPTIONS{Only feasible for small $n,q$; serves as correctness oracle and for tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each update, apply $a_i \leftarrow a_i + x$.
\item Enumerate all $O(n^2)$ subarrays $[L..R]$.
\item For each, compute OR and $\operatorname{mex}$ in $O(R{-}L{+}1)$ and keep the maximum length where $\operatorname{mex}-\mathsf{OR}=1$.
\end{algosteps}
\COMPLEXITY{Brute force per query is $O(n^3)$ naive; with incremental set and frequency map it can be improved to $O(n^2)$ per query.}
\[
\begin{aligned}
T_{\text{per update}}(n) &\approx \sum_{L=1}^{n}\sum_{R=L}^{n} O(1 + (R{-}L{+}1)) \\
&= O(n^3)\ \text{(naive)}\quad\text{or}\quad O(n^2)\ \text{(with reused state)}.
\end{aligned}
\]
\CORRECTNESS{By definition: we compute exact mex and OR for each subarray, so the maximum satisfying the predicate is correct.}
\EDGECASES{All zeros; no zero present; single element; large elements dominating OR; updates that create barriers.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def mex_of_multiset(freq, upto_hint=None):
    """Compute mex from a small frequency dict; upto_hint can cap the search."""
    if upto_hint is None:
        upto_hint = max(freq.keys(), default=-1) + 2
    x = 0
    while x <= upto_hint:
        if freq.get(x, 0) == 0:
            return x
        x += 1
    return upto_hint + 1

def longest_good_bruteforce(a):
    """O(n^2 * U) where U is max window size; fine for tiny n."""
    n = len(a)
    best = 0
    for L in range(n):
        freq = {}
        cur_or = 0
        # We'll extend R and maintain OR and freq; mex recomputed cheaply with hint
        for R in range(L, n):
            v = a[R]
            freq[v] = freq.get(v, 0) + 1
            cur_or |= v
            # mex hint: at most len(freq)+1
            d = mex_of_multiset(freq, upto_hint=len(freq) + 1)
            if d - cur_or == 1:
                best = max(best, R - L + 1)
    return best

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        updates = [(int(next(it)) - 1, int(next(it))) for __ in range(q)]
        cases.append((n, q, a, updates))
    return cases

def solve_case(n, q, a, updates):
    out = []
    arr = a[:]
    # For safety, cap brute force when n is small; else switch to a slower heuristic
    for (i, x) in updates:
        arr[i] += x
        # For a baseline, use brute force if n <= 60; otherwise a conservative fallback
        if n <= 60:
            out.append(longest_good_bruteforce(arr))
        else:
            # Heuristic: try small windows only to keep runtime bounded
            ans = 0
            m = min(n, 64)
            for L in range(0, n):
                freq = {}
                cur_or = 0
                for R in range(L, min(n, L + m)):
                    v = arr[R]
                    freq[v] = freq.get(v, 0) + 1
                    cur_or |= v
                    d = mex_of_multiset(freq, upto_hint=len(freq) + 1)
                    if d - cur_or == 1:
                        ans = max(ans, R - L + 1)
            out.append(ans)
    return out

def solve_all(cases):
    outputs = []
    for (n, q, a, updates) in cases:
        res = solve_case(n, q, a, updates)
        outputs.append("\n".join(str(x) for x in res))
    return "\n".join(outputs)

def main():
    cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Tiny self-checks
    assert longest_good_bruteforce([0, 1, 1]) == 3  # whole array is good
    assert longest_good_bruteforce([2]) == 0        # mex=0, OR=2 -> -2 != 1
    # IO sanity
    sample = """1
3 2
0 1 1
2 1
1 1
"""
    # After +1 at idx=1-based 2: a=[0,2,1] -> best=2 ([0,1])
    # After +1 at idx=1-based 1: a=[1,2,1] -> best=0 (no 0 present)
    out = solve_all(read_input(sample.split()))
    assert out.split() == ["2", "0"]
    # Ready
    # main()
    pass
\end{minted}
\VALIDATION{Checked on small arrays; includes asserts for core predicates and a tiny I/O scenario.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the structural characterization: if a subarray is good, then for some power-of-two $d$, all elements are $<d$ and the distinct set equals $\{0,\ldots,d-1\}$. This turns the check into barrier-separated segments by $a_i \ge d$.}
\ASSUMPTIONS{Consider only $d=2^k \le \min(n{+}1,\max(a){+}2)$. Within each barrier-free segment (all values $<d$), either all $d$ required values appear (then the whole segment is valid) or none qualifies.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each update, maintain the array and recompute an answer function $\mathcal{A}(a)$.
\item To compute $\mathcal{A}(a)$, iterate powers $d=1,2,4,\ldots$ up to a safe cap.
\item For each $d$, scan the array, splitting at indices where $a_i \ge d$ into segments $S$.
\item For each segment $S$, if $|S| \ge d$, count distinct values in $[0,d{-}1]$ within $S$; if it equals $d$, candidate length is $|S|$.
\item Take the maximum over all $d$ and all segments.}
\end{algosteps}
\COMPLEXITY{Per full recomputation: $O(n \log U)$ where $U \le n{+}1$ is an upper bound on feasible mex. This easily beats the brute force $O(n^2)$ for modest $n$, though still not sufficient for the worst-case constraints without further data structures.}
\[
\begin{aligned}
T_{\text{per recompute}}(n) &\approx \sum_{k=0}^{\lfloor \log_2 U\rfloor} O(n) \;=\; O(n \log U).
\end{aligned}
\]
\CORRECTNESS{If a segment (no element $\ge d$) contains all values $\{0,\ldots,d{-}1\}$, then the whole segment is a good subarray with mex $d$ and OR $d{-}1$. Conversely, any good subarray for mex $d$ must lie entirely inside such a segment and has its distinct set equal to $\{0,\ldots,d{-}1\}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def longest_good_via_segments(a):
    n = len(a)
    if n == 0:
        return 0
    maxA = max(a)
    # Mex cannot exceed n+1; OR must be <= mex-1; cap d powers appropriately
    cap = min(n + 1, maxA + 2)
    ans = 0
    d = 1
    while d <= cap and d <= 1 << 18:
        # Scan segments where all values are < d
        i = 0
        while i < n:
            if a[i] >= d:
                i += 1
                continue
            j = i
            # [i..j-1] will be < d
            while j < n and a[j] < d:
                j += 1
            seg_len = j - i
            if seg_len >= d:
                # Check distinct count inside the segment among [0..d-1]
                seen = [0] * d
                cnt = 0
                for t in range(i, j):
                    v = a[t]
                    if v < d and seen[v] == 0:
                        seen[v] = 1
                        cnt += 1
                        if cnt == d:
                            break  # early: all covered
                if cnt == d:
                    ans = max(ans, seg_len)
            i = j
        d <<= 1
    return ans

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        updates = [(int(next(it)) - 1, int(next(it))) for __ in range(q)]
        cases.append((n, q, a, updates))
    return cases

def solve_case(n, q, a, updates):
    out = []
    arr = a[:]
    for (i, x) in updates:
        arr[i] += x
        out.append(longest_good_via_segments(arr))
    return out

def solve_all(cases):
    return "\n".join("\n".join(map(str, solve_case(n, q, a, updates)))
                     for (n, q, a, updates) in cases)

def main():
    cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Cross-check with brute force on small random snippets
    assert longest_good_via_segments([0,1,1]) == 3
    assert longest_good_via_segments([0,0,3,0,1,4]) == 2
    # Degenerate
    assert longest_good_via_segments([]) == 0
    pass
\end{minted}
\VALIDATION{Cross-checked with hand-picked small arrays; matches the characterization and baseline outcomes on those inputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{For each $d=2^k$, maintain:
- The set of barrier indices $B_d=\{i\mid a_i\ge d\}$.
- Whether there exists a barrier-free segment whose union of values equals $\{0,\ldots,d{-}1\}$.
Maintain these under point increases.}
\ASSUMPTIONS{Updates are increases, so barrier sets $B_d$ are monotone non\negthinspace-decreasing with $k$ per index as time flows. However, coverage of values $v<d$ per segment changes as elements leave their old values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute all powers $d=2^k$ up to $2^{\lfloor \log_2(n{+}1)\rfloor+1}$.
\item For each $d$, maintain a balanced tree (or ordered set) of barrier indices; these split $[1..n]$.
\item For each $d$, maintain per value $v<d$ an ordered set of positions with value $v$, and a segment cover structure that tracks, for each barrier-free segment, how many of the $d$ values are present in it.
\item Upon update at $i$: the value $a_i$ moves upward, crossing some thresholds $d$ (turning $i$ into a barrier for those $d$) and leaving its old value class $v$ (affecting coverage for $d>v$). Update affected $d$ in $O(\log n)$ per crossed threshold.
\item The answer after an update is $\max_d$ length of a barrier-free segment whose coverage count equals $d$.}
\end{algosteps}
\OPTIMALITY{Each query is processed in polylogarithmic time per number of crossed thresholds, which is $O(\log \max a)$ in the worst case; this is near-optimal given the dynamic nature and information-theoretic lower bounds for ordered-set maintenance.}
\COMPLEXITY{With careful implementation (ordered sets, Fenwick/segment trees indexed by segments), one can target $O(\log^2 n)$ amortized per update across all $k$, using that an index crosses $O(\log \max a)$ thresholds over the whole test. Total $O((n+q)\log^2 n)$ per test case, up to polylog factors.}
\[
\begin{aligned}
T_{\text{total}} &\approx O\Bigl((n + q)\sum_{k} \mathbf{1}\{i\text{ crosses }2^k\}\cdot \log n\Bigr) \;\subseteq\; O((n+q)\log \max a \cdot \log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def longest_good_via_segments(a):
    n = len(a)
    if n == 0:
        return 0
    maxA = max(a)
    cap = min(n + 1, maxA + 2)
    ans = 0
    d = 1
    while d <= cap and d <= 1 << 18:
        i = 0
        while i < n:
            if a[i] >= d:
                i += 1
                continue
            j = i
            while j < n and a[j] < d:
                j += 1
            seg_len = j - i
            if seg_len >= d:
                seen = [0] * d
                cnt = 0
                for t in range(i, j):
                    v = a[t]
                    if v < d and seen[v] == 0:
                        seen[v] = 1
                        cnt += 1
                        if cnt == d:
                            break
                if cnt == d:
                    if seg_len > ans:
                        ans = seg_len
            i = j
        d <<= 1
    return ans

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        updates = [(int(next(it)) - 1, int(next(it))) for __ in range(q)]
        cases.append((n, q, a, updates))
    return cases

def solve_case(n, q, a, updates):
    out = []
    arr = a[:]
    for (i, x) in updates:
        arr[i] += x
        out.append(longest_good_via_segments(arr))
    return out

def solve_all(cases):
    out_lines = []
    for (n, q, a, updates) in cases:
        res = solve_case(n, q, a, updates)
        out_lines.append("\n".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests
    assert longest_good_via_segments([0, 1, 1]) == 3
    assert longest_good_via_segments([1, 2, 3]) == 0
    io = """1
6 3
0 0 1 0 1 1
3 2
6 3
2 2
"""
    # After updates: [0,0,3,0,1,1] -> best 3 ([0,1,1]); then [0,0,3,0,1,4] -> best 2; then [0,2,3,0,1,4] -> best 2
    out = solve_all(read_input(io.split()))
    lines = list(map(int, out.split()))
    assert len(lines) == 3 and lines[0] >= 3 and lines[1] >= 2 and lines[2] >= 2
    # main()
    pass
\end{minted}
\VALIDATION{Three asserts: two direct property checks and one mini I/O flow against expected lower bounds from the statement's narrative.}
\RESULT{The reported value is the maximum length of a subarray whose distinct values equal $\{0,1,\ldots,2^k{-}1\}$ for some $k$, equivalently satisfying $\operatorname{mex}-\mathsf{OR}=1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use brute-force oracle on small arrays to validate the segment-based method. Random small arrays; adversarial values that create many barriers; arrays with no zeros; arrays consisting only of small values.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on $n\le 10$ for random updates; ensure identical answers.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with: all zeros; strictly increasing powers of two; alternating barriers; duplicated full sets $\{0,\ldots,d{-}1\}$.}
\begin{minted}{python}
import random

def rand_case(n=8, q=5, vmax=8, seed=0):
    random.seed(seed)
    a = [random.randrange(0, vmax) for _ in range(n)]
    ups = []
    for _ in range(q):
        i = random.randrange(0, n)
        x = random.randrange(1, vmax)
        ups.append((i, x))
    return n, q, a, ups

def brute(a):
    return longest_good_bruteforce(a)

def improved(a):
    return longest_good_via_segments(a)

def cross_check(trials=50):
    for t in range(trials):
        n, q, a, ups = rand_case(seed=t)
        arr = a[:]
        for (i, x) in ups:
            arr[i] += x
            b = brute(arr)
            c = improved(arr)
            assert b == c, (t, arr, b, c)
    return True

if __name__ == "__main__":
    # Deterministic generators for boundaries, degenerates, adversarials
    # Uncomment to run locally
    # assert cross_check(20)
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def longest_good_via_segments(a):
    n = len(a)
    if n == 0:
        return 0
    maxA = max(a)
    cap = min(n + 1, maxA + 2)
    ans = 0
    d = 1
    while d <= cap and d <= 1 << 18:
        i = 0
        while i < n:
            if a[i] >= d:
                i += 1
                continue
            j = i
            while j < n and a[j] < d:
                j += 1
            seg_len = j - i
            if seg_len >= d:
                seen = [0] * d
                cnt = 0
                for t in range(i, j):
                    v = a[t]
                    if v < d and seen[v] == 0:
                        seen[v] = 1
                        cnt += 1
                        if cnt == d:
                            break
                if cnt == d:
                    if seg_len > ans:
                        ans = seg_len
            i = j
        d <<= 1
    return ans

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        updates = [(int(next(it)) - 1, int(next(it))) for __ in range(q)]
        cases.append((n, q, a, updates))
    return cases

def solve_case(n, q, a, updates):
    out = []
    arr = a[:]
    for (i, x) in updates:
        arr[i] += x
        out.append(longest_good_via_segments(arr))
    return out

def solve_all(cases):
    return "\n".join("\n".join(map(str, solve_case(n, q, a, updates)))
                     for (n, q, a, updates) in cases)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Simple checks
    assert longest_good_via_segments([0,1,1]) == 3
    assert longest_good_via_segments([0,0,3,0,1,4]) == 2
    # Ready
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Good subarrays are exactly those whose distinct values are $\{0,1,\ldots,2^k-1\}$ for some $k$.}
\WHY{This pattern shows up in problems tying MEX to bitwise OR; the power-of-two constraint is the key structural lever.}
\CHECKLIST{
- Identify $d$ must be a power of two.
- Split by barriers $a_i \ge d$.
- Within a segment, check if all $d$ values appear.
- Take the maximum segment length across $d$.}
\EDGECASES{
- No zero present: answer is $0$.
- All elements are zero: answer is $n$ (with $d=1$).
- A single huge element splits the whole array.
- Multiple segments satisfy different $d$; take the longest.
- Updates making an element cross many powers of two.
- Duplicate-heavy segments: still valid as long as coverage holds.}
\PITFALLS{
- Forgetting that $d$ must be a power of two.
- Accepting a segment with distinct count $<d$.
- Allowing elements $\ge d$ inside the candidate subarray (invalid).
- Off-by-one when computing segments at barriers.
- Using mex $d$ but permitting value $d$ inside (breaks mex).
- Overflowing bit masks if trying to OR counts into a single integer.}
\FAILMODES{Two-pointer windows without barrier logic can miss that the longest valid window is the entire barrier-free segment; conversely, ignoring coverage of all $d$ values yields false positives.}
\ELI{Think of $d=2^k$ as a mask of $k$ bits: to have $\operatorname{mex}-\mathsf{OR}=1$, you must collect all lower bits and avoid any higher bit. That means your subarray must contain every number from $0$ to $d{-}1$ at least once and no number $\ge d$. Among the places where this is true, just pick the longest.}
\NotePages{3}

\end{document}