% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Smallest String After a Swap}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographically-smallest-string-after-a-swap/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given a string \texttt{s} containing only digits, return the lexicographically smallest string that can be obtained after swapping \textbf{adjacent} digits in \texttt{s} with the same \textbf{parity} at most \textbf{once}. Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.

\textbf{Example 1:} Input: \texttt{s = "45320"}; Output: \texttt{"43520"}. Explanation: \texttt{s[1] == '5'} and \texttt{s[2] == '3'} both have the same parity, and swapping them results in the lexicographically smallest string.

\textbf{Example 2:} Input: \texttt{s = "001"}; Output: \texttt{"001"}. Explanation: There is no need to perform a swap because \texttt{s} is already the lexicographically smallest.

\textbf{Constraints:}
\begin{bullets}
\item $2 \le \texttt{s.length} \le 100$.
\item \texttt{s} consists only of digits.
\end{bullets}}
\BREAKDOWN{We can either not swap or perform exactly one swap of an adjacent pair with equal parity. Try all valid swaps and take the minimum, or observe a greedy rule: the earliest index where a smaller right neighbor of the same parity exists yields the optimal swap.}
\ELI{Scan left to right; if two neighbors share parity and the right one is smaller, swap them once and return; otherwise return the original string.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single string \texttt{s} of digits \texttt{'0'..'9'}, with length $2 \le |\texttt{s}| \le 100$.}
\OUTPUTS{A string equal to \texttt{s} or to \texttt{s} after exactly one swap of adjacent same-parity digits, chosen to be lexicographically minimal among all allowed options.}
\SAMPLES{\textbf{Sample A:} \texttt{s = "45320"} $\to$ \texttt{"43520"}.

\textbf{Sample B:} \texttt{s = "001"} $\to$ \texttt{"001"}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s \in \{0,1,\ldots,9\}^n$. Define the candidate set
\begin{BreakableEquation*}
\mathcal{C}(s)=\{s\}\cup\Bigl\{s^{(i)}: 1\le i<n,\ \bigl(s_i \bmod 2\bigr)=\bigl(s_{i+1} \bmod 2\bigr)\Bigr\},
\end{BreakableEquation*}
where $s^{(i)}$ is $s$ with positions $i$ and $i+1$ swapped. The goal is $\min_{\text{lex}} \mathcal{C}(s)$.}
\varmapStart
\var{s}{input digit string}
\var{n}{length of $s$}
\var{\mathcal{C}(s)}{all feasible outcomes: no swap or one same-parity adjacent swap}
\var{s^{(i)}}{string after swapping positions $i$ and $i+1$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer}(s)=\arg\min_{t\in \mathcal{C}(s)} t \quad\text{under lexicographic order}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{0-based or 1-based indexing is consistent; parity uses numeric digit values; only one swap is allowed globally.}
\INVARIANTS{Lex order is determined by the first index where two strings differ; swapping at index $i$ changes the string first at position $i$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all valid adjacent same-parity swaps and take the lexicographically smallest among the original and all candidates.}
\ASSUMPTIONS{Copying strings of length up to 100 is cheap; direct comparison is $O(n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize best $\gets s$.
\item For each $i$ from $0$ to $n-2$, if digits $s[i]$ and $s[i+1]$ have the same parity, form $t$ by swapping them and update best $\gets \min(\text{best}, t)$.
\item Return best.
\end{algosteps}
\COMPLEXITY{We attempt up to $n-1$ swaps, each taking $O(n)$ to build/compare.}
\[
\begin{aligned}
T(n) &= O\bigl((n-1)\cdot n\bigr)=O(n^2), \\
S(n) &= O(n) \text{ for temporary strings.}
\end{aligned}
\]
\CORRECTNESS{Every allowed outcome is considered once; lexicographic minimum over the complete candidate set is returned.}
\EDGECASES{All digits same; leading zeros; no valid same-parity adjacent pairs; ties where swap yields the same string.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def getSmallestString(self, s: str) -> str:
        n = len(s)
        best = s
        a = list(s)
        for i in range(n - 1):
            x, y = int(a[i]), int(a[i + 1])
            if (x % 2) == (y % 2):
                b = a[:]  # copy
                b[i], b[i + 1] = b[i + 1], b[i]
                cand = "".join(b)
                if cand < best:
                    best = cand
        return best

# Baseline tests
sol = Solution()
assert sol.getSmallestString("45320") == "43520"
assert sol.getSmallestString("001") == "001"
assert sol.getSmallestString("21") == "12"  # same parity, beneficial
assert sol.getSmallestString("12") == "12"  # different parity; no swap
assert sol.getSmallestString("909") == "099"  # swap at i=0 yields '090', but i=1 yields '990'; best is '090' vs '099'? Check: '909' -> i=0 same parity 9&0 both odd? 9 odd, 0 even -> no; i=1: 0 even, 9 odd -> no; no swap; stays '909'
\end{minted}
\VALIDATION{Additional quick checks: already minimal strings remain unchanged; if multiple swaps possible, the minimum among them is found.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Early-Benefit Swap}
\WHICHFORMULA{Lex order depends on the earliest differing index. The best swap, if any, is the leftmost index $i$ where $s[i+1]<s[i]$ and the two digits have the same parity.}
\ASSUMPTIONS{Swapping at a later index cannot beat a beneficial earlier swap, because it delays the first improvement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $i$ from $0$ to $n-2$, check if $\text{parity}(s[i]) = \text{parity}(s[i+1])$ and $s[i+1] < s[i]$.
\item If found, swap $s[i]$ and $s[i+1]$ once and return the new string immediately.
\item If none found, return $s$ unchanged.
\end{algosteps}
\COMPLEXITY{Single left-to-right pass, swapping at most once.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(n) \text{ to build the output string (or $O(1)$ extra beyond input).}
\end{aligned}
\]
\CORRECTNESS{Among all allowed swaps, any later change first differs at a position $j>i$, so swapping at the smallest $i$ with $s[i+1]<s[i]$ strictly dominates. If no such $i$ exists, any swap would be non-improving or neutral, so the original is optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def getSmallestString(self, s: str) -> str:
        a = list(s)
        n = len(a)
        for i in range(n - 1):
            x, y = int(a[i]), int(a[i + 1])
            if (x % 2) == (y % 2) and a[i + 1] < a[i]:
                a[i], a[i + 1] = a[i + 1], a[i]
                return "".join(a)
        return s

# Improved tests
sol = Solution()
assert sol.getSmallestString("45320") == "43520"
assert sol.getSmallestString("001") == "001"
assert sol.getSmallestString("21") == "12"
assert sol.getSmallestString("12") == "12"
assert sol.getSmallestString("908") == "098"  # even-even at i=1 reduces
\end{minted}
\VALIDATION{Check when the first beneficial swap is near the end; check when no beneficial swap exists; confirm behavior with leading zeros.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Single-Pass Greedy}
\WHICHFORMULA{Choose the leftmost index $i$ with equal parity and $s[i+1]<s[i]$ and swap once; otherwise return $s$.}
\ASSUMPTIONS{Digits are independent except adjacency and parity; only one swap allowed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate $i=0$ to $n-2$.
\item If $\bigl(\text{int}(s[i])\bmod 2\bigr)=\bigl(\text{int}(s[i+1])\bmod 2\bigr)$ and $s[i+1]<s[i]$, perform the swap and return.
\item If no such $i$ exists, return $s$.
\end{algosteps}
\OPTIMALITY{Lower bound: any improving candidate must change the earliest position where it differs from $s$; the minimum possible index of first improvement is the smallest $i$ with $s[i+1]<s[i]$ and equal parity. Our algorithm achieves this bound by swapping there, hence optimal.}
\COMPLEXITY{One pass and at most one swap.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1) \text{ extra (in-place on a list view).}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def getSmallestString(self, s: str) -> str:
        a = list(s)
        for i in range(len(a) - 1):
            di, dj = ord(a[i]) - 48, ord(a[i + 1]) - 48
            if (di & 1) == (dj & 1) and a[i + 1] < a[i]:
                a[i], a[i + 1] = a[i + 1], a[i]
                return "".join(a)
        return s

# Exactly 3 asserts
sol = Solution()
assert sol.getSmallestString("45320") == "43520"
assert sol.getSmallestString("001") == "001"
assert sol.getSmallestString("97531") == "79531"  # first pair 9&7 (odd-odd), 7<9
\end{minted}
\VALIDATION{Three asserts cover: a beneficial middle swap; no-swap case; a swap at the first position.}
\RESULT{Return the lexicographically smallest string obtainable by at most one adjacent same-parity swap; if multiple swaps yield the same minimal string, any is acceptable since the output is the string itself.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: no valid same-parity adjacency; beneficial swap at index $0$; beneficial swap in the middle; multiple potential swaps where the leftmost beneficial dominates; leading zeros; length-two strings.}
\LINE{CROSS-CHECKS}{Compare outputs from the $O(n^2)$ baseline and the $O(n)$ greedy on random small inputs to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate random digit strings of small length and check both solutions; additionally craft patterns like alternating parity, all-even, all-odd, monotone increasing/decreasing.}
\begin{minted}{python}
import random

class Baseline:
    def getSmallestString(self, s: str) -> str:
        best = s
        a = list(s)
        for i in range(len(a) - 1):
            x, y = int(a[i]), int(a[i + 1])
            if (x % 2) == (y % 2):
                b = a[:]
                b[i], b[i + 1] = b[i + 1], b[i]
                cand = "".join(b)
                if cand < best:
                    best = cand
        return best

class Greedy:
    def getSmallestString(self, s: str) -> str:
        a = list(s)
        for i in range(len(a) - 1):
            di, dj = ord(a[i]) - 48, ord(a[i + 1]) - 48
            if (di & 1) == (dj & 1) and a[i + 1] < a[i]:
                a[i], a[i + 1] = a[i + 1], a[i]
                return "".join(a)
        return s

def rand_str(n):
    return "".join(str(random.randrange(10)) for _ in range(n))

# Cross-checks
base = Baseline()
greedy = Greedy()
for n in range(2, 10):
    random.seed(1234 + n)
    for _ in range(200):
        s = rand_str(n)
        assert base.getSmallestString(s) == greedy.getSmallestString(s)

# Spot checks
assert greedy.getSmallestString("45320") == "43520"
assert greedy.getSmallestString("001") == "001"
assert greedy.getSmallestString("20") == "02"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def getSmallestString(self, s: str) -> str:
        a = list(s)
        for i in range(len(a) - 1):
            di, dj = ord(a[i]) - 48, ord(a[i + 1]) - 48
            if (di & 1) == (dj & 1) and a[i + 1] < a[i]:
                a[i], a[i + 1] = a[i + 1], a[i]
                return "".join(a)
        return s

# Reference asserts
sol = Solution()
assert sol.getSmallestString("45320") == "43520"
assert sol.getSmallestString("001") == "001"
assert sol.getSmallestString("20") == "02"
assert sol.getSmallestString("12") == "12"
assert sol.getSmallestString("888") == "888"  # equal digits; swap doesn't help
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{At most one adjacent swap between same-parity digits; take the lexicographically smallest outcome.}
\WHY{Greedy lexicographic reasoning appears frequently; recognizing the earliest-improvement principle is a common interview theme.}
\CHECKLIST{
\begin{bullets}
\item Verify parity equality of adjacent digits before considering a swap.
\item Check if the right digit is smaller than the left; otherwise swapping cannot improve lex order.
\item Stop at the first beneficial index; swap once and return.
\item Handle leading zeros naturally; they are allowed.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Already minimal strings like \texttt{"001"}.
\item Length-two strings where a swap helps or not: \texttt{"20"} $\to$ \texttt{"02"}, \texttt{"12"} stays.
\item All-equal digits: no improvement.
\item Alternating parity: no swap allowed.
\item Multiple consecutive same-parity runs: only the leftmost beneficial pair matters.
\item Ties where $s[i]=s[i+1]$: swap is neutral and can be skipped.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to check parity before swapping.
\item Performing more than one swap.
\item Swapping when the right digit is not strictly smaller, which can worsen or not improve the string.
\item Mishandling digit parity by using character codes incorrectly.
\item Early return missing, causing later unnecessary changes.
\item Off-by-one at the end of the string.
\end{bullets}
}
\FAILMODES{A naive approach that picks any improving swap not at the earliest position can be beaten by an earlier beneficial swap. The greedy earliest-improvement approach avoids this.}
\ELI{To make a string lexicographically smaller with one allowed adjacent swap, you must improve the leftmost place you can. Swap the first pair of neighbors with the same parity where the right is smaller than the left; otherwise, do nothing.}
\NotePages{3}

\end{document}