% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Counting Bits}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/counting-bits/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given an integer $n$, return an array $ans$ of length $n+1$ such that for each $i$ ($0 \le i \le n$), $ans[i]$ is the number of $1$'s in the binary representation of $i$.\\
Examples.\\
Input: $n = 2$; Output: $[0,1,1]$; Explanation: $0 \to 0$, $1 \to 1$, $2 \to 10$.\\
Input: $n = 5$; Output: $[0,1,1,2,1,2]$; Explanation: $0 \to 0$, $1 \to 1$, $2 \to 10$, $3 \to 11$, $4 \to 100$, $5 \to 101$.\\
Constraints: $0 \le n \le 10^5$.\\
Follow up: It is easy to get $O(n \log n)$; can you do $O(n)$ in one pass and without built-in popcount?}
\BREAKDOWN{We need to compute popcount for all integers from $0$ to $n$. A naive per-number bit count is $O(\log i)$, while dynamic programming can reuse previous results to achieve $O(1)$ amortized per $i$.}
\ELI{Reuse that shifting right drops the last bit: the number of ones in $i$ equals those in $\lfloor i/2 \rfloor$ plus the last bit.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $0 \le n \le 10^5$.}
\OUTPUTS{A list $ans$ of length $n+1$ where $ans[i]$ equals the count of set bits in the binary expansion of $i$.}
\SAMPLES{Example 1: Input $n=2$; Output $[0,1,1]$. Example 2: Input $n=5$; Output $[0,1,1,2,1,2]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S=\{0,1,\ldots,n\}$. Define $dp:S\to\mathbb{N}$ with $dp(i)=\text{popcount}(i)$. We seek the vector $(dp(0),dp(1),\ldots,dp(n))$.}
\varmapStart
\var{n}{upper bound integer}
\var{i}{index in $[0,n]$}
\var{dp[i]}{number of ones in binary of $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
dp[0] &= 0,\\
dp[i] &= dp\!\left[\left\lfloor \dfrac{i}{2}\right\rfloor\right] + (i \bmod 2) = dp[i \mathbin{\gg} 1] + (i \mathbin{\&} 1), \quad 1 \le i \le n,\\
\text{equivalently}\quad dp[i] &= dp[i \mathbin{\&} (i-1)] + 1,\quad i\ge 1.
\end{aligned}
\]
}
\ASSUMPTIONS{Zero-based indexing; standard integer bitwise operators; all arithmetic fits in typical 32-bit signed integers for the given range.}
\INVARIANTS{For all $i$, $0 \le dp[i] \le \lfloor \log_2 i \rfloor + 1$ for $i \ge 1$; $dp[i] = dp[i \mathbin{\&} (i-1)] + 1$ removes exactly one lowest set bit.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Count bits of each $i$ independently by repeated right shifts and masking the least significant bit.}
\ASSUMPTIONS{No specialized instructions; per-number loop terminates in $O(\log i)$ iterations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans$ as an array of zeros of length $n+1$.
\item For each $i$ from $1$ to $n$, set $x=i$ and count $c=0$ while $x>0$: add $(x \mathbin{\&} 1)$ to $c$ and shift $x$ right by one.
\item Assign $ans[i]=c$ and return $ans$ at the end.
\end{algosteps}
\COMPLEXITY{Let $L(i)=\lfloor \log_2 i \rfloor + 1$ for $i \ge 1$.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} L(i) = \Theta\!\bigl(n \log n\bigr),\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Each right shift removes the last bit; summing the last bits over all positions equals the popcount.}
\EDGECASES{$n=0$ yields $[0]$; powers of two produce $1$ at those positions; large $n$ within bounds.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    # Baseline O(n log n): per-number bit counting via shifts
    def countBits(self, n: int) -> List[int]:
        ans = [0] * (n + 1)
        for i in range(1, n + 1):
            x = i
            c = 0
            while x:
                c += (x & 1)
                x >>= 1
            ans[i] = c
        return ans

# Basic asserts
assert Solution().countBits(0) == [0]
assert Solution().countBits(2) == [0, 1, 1]
assert Solution().countBits(5) == [0, 1, 1, 2, 1, 2]
\end{minted}
\VALIDATION{Checked $n \in \{0,2,5\}$ against known outputs.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized DP via removing lowest set bit}
\WHICHFORMULA{Use $dp[i] = dp[i \mathbin{\&} (i-1)] + 1$; the operation $i \mathbin{\&} (i-1)$ drops the lowest set bit, guaranteeing progress.}
\ASSUMPTIONS{Integer bitwise operations are $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[0]=0$.
\item For $i$ from $1$ to $n$, compute $j=i \mathbin{\&} (i-1)$ and set $dp[i]=dp[j]+1$.
\item Return the filled array.
\end{algosteps}
\COMPLEXITY{One constant-time recurrence per $i$, so linear time.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Each $i$ has a unique decomposition into $(i \mathbin{\&} (i-1))$ plus the lowest set bit; induction on the number of set bits proves correctness.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    # DP with lowest-set-bit removal: dp[i] = dp[i & (i-1)] + 1
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i & (i - 1)] + 1
        return dp

# Cross-checks
assert Solution().countBits(1) == [0, 1]
assert Solution().countBits(4) == [0, 1, 1, 2, 1]
assert Solution().countBits(5) == [0, 1, 1, 2, 1, 2]
\end{minted}
\VALIDATION{Validated on small ranges and boundaries near powers of two.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DP via right shift: parity plus half}
\WHICHFORMULA{Use $dp[i] = dp[i \mathbin{\gg} 1] + (i \mathbin{\&} 1)$, which reuses the count for $\lfloor i/2 \rfloor$ and adds the parity of $i$.}
\ASSUMPTIONS{Bit shifts and bitwise-and are constant time; array writes are $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[0]=0$.
\item For $i=1$ to $n$, compute $dp[i]=dp[i \mathbin{\gg} 1] + (i \mathbin{\&} 1)$.
\item Return $dp$.
\end{algosteps}
\OPTIMALITY{Every $i$ uses exactly one prior value and constant-time arithmetic, achieving $\Theta(n)$ time and $\Theta(n)$ space, which is optimal to output $n+1$ values.}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    # Final LC-ready solution: dp[i] = dp[i >> 1] + (i & 1)
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp

# Exactly 3 asserts
assert Solution().countBits(0) == [0]
assert Solution().countBits(2) == [0, 1, 1]
assert Solution().countBits(8) == [0, 1, 1, 2, 1, 2, 2, 3, 1]
\end{minted}
\VALIDATION{Three direct asserts including a power-of-two boundary at $8$.}
\RESULT{Returns the array of popcounts for all integers from $0$ to $n$ inclusive; order is ascending by index with no tie-breaking needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Check base cases ($n=0,1$), powers of two, ranges crossing powers of two, and random values under the constraint. Compare different approaches for consistency.}
\LINE{CROSS-CHECKS}{For small $n$, compare Baseline, Improved, and Final outputs element-wise.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic random $n$ in a safe range and verify equal results across implementations.}
\begin{minted}{python}
import random
from typing import List

class Baseline:
    def countBits(self, n: int) -> List[int]:
        ans = [0] * (n + 1)
        for i in range(1, n + 1):
            x = i
            c = 0
            while x:
                c += (x & 1)
                x >>= 1
            ans[i] = c
        return ans

class DPDropLSB:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i & (i - 1)] + 1
        return dp

class DPRightShift:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp

# Deterministic cross-checks
random.seed(0)
B, LSB, RS = Baseline(), DPDropLSB(), DPRightShift()
for n in [0, 1, 2, 5, 8, 16, 31, 32, 50]:
    a, b, c = B.countBits(n), LSB.countBits(n), RS.countBits(n)
    assert a == b == c

for _ in range(20):
    n = random.randint(0, 1000)
    a, b, c = B.countBits(n), LSB.countBits(n), RS.countBits(n)
    assert a == b == c
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    # Reference LC solution using dp[i] = dp[i >> 1] + (i & 1)
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp

# Sanity asserts
assert Solution().countBits(3) == [0, 1, 1, 2]
assert Solution().countBits(10) == [0,1,1,2,1,2,2,3,1,2,2]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute popcounts for all $i \in [0,n]$ efficiently using a simple DP recurrence.}
\WHY{Common bit DP; tests understanding of bit operations and linear-time preprocessing used in many problems.}
\CHECKLIST{%
\begin{bullets}
\item State the recurrence: either drop lowest set bit or use right shift plus parity.
\item Initialize $dp[0]=0$.
\item Iterate $i$ from $1$ to $n$, fill $dp[i]$ in $O(1)$.
\item Return the full array of length $n+1$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=0$ must return $[0]$.
\item $n=1$ produces $[0,1]$.
\item Powers of two: exactly one set bit.
\item Numbers just below powers of two (e.g., $2^k-1$) have all lower bits set.
\item Large $n$ near $10^5$.
\item Alternating bit patterns (e.g., $10\_2, 101\_2, 1010\_2$).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to include index $0$ in the output.
\item Off-by-one in array size ($n$ vs $n+1$).
\item Using slow string conversions instead of $O(1)$ DP.
\item Misusing operator precedence; always parenthesize $(i \mathbin{\&} 1)$.
\item Accidentally using built-in popcount when constrained not to.
\item Negative shifts or wrong direction of shift.
\end{bullets}
}
\FAILMODES{Naive $O(n \log n)$ may still pass but is not optimal; string-based popcount can be slower. The DP solutions remain linear and robust.}
\ELI{Shift right to reuse the count for half the number, and add one if the last bit is $1$. Doing this for each $i$ builds the whole answer in one pass.}
\NotePages{3}

\end{document}