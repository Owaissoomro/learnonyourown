% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Preimage Size of Factorial Zeroes Function}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Let \texttt{f(x)} be the number of zeroes at the end of \texttt{x!}. Recall that \texttt{x! = 1 * 2 * 3 * ... * x} and by convention, \texttt{0! = 1}.\\
\quad For example, \texttt{f(3) = 0} because \texttt{3! = 6} has no zeroes at the end, while \texttt{f(11) = 2} because \texttt{11! = 39916800} has two zeroes at the end.

Given an integer \texttt{k}, return the number of non-negative integers \texttt{x} have the property that \texttt{f(x) = k}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{k = 0}

\quad \textbf{Output:} \texttt{5}

\quad \textbf{Explanation:} \texttt{0!}, \texttt{1!}, \texttt{2!}, \texttt{3!}, and \texttt{4!} end with \texttt{k = 0} zeroes.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{k = 5}

\quad \textbf{Output:} \texttt{0}

\quad \textbf{Explanation:} There is no \texttt{x} such that \texttt{x!} ends in \texttt{k = 5} zeroes.

\textbf{Example 3:}

\quad \textbf{Input:} \texttt{k = 3}

\quad \textbf{Output:} \texttt{5}

\textbf{Constraints:}
\quad \texttt{0 <= k <= 10^9}}
\BREAKDOWN{Trailing zeroes of \texttt{x!} equal the number of factors of 5 in \texttt{x!}, given by \(\sum_{i\ge 1}\big\lfloor \tfrac{x}{5^i}\big\rfloor\). We must count how many \texttt{x} satisfy this equals \texttt{k}. The key known fact is that this count is either \(0\) or \(5\).}
\ELI{The function that counts trailing zeroes grows in steps and sometimes ``plateaus'' across runs of five numbers; each \texttt{k} either occurs for exactly five consecutive \texttt{x} or not at all.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer \(k\) with \(0 \le k \le 10^9\).}
\OUTPUTS{Return the integer \(\#\{x \in \mathbb{Z}_{\ge 0} : f(x)=k\}\), which is either \(0\) or \(5\).}
\SAMPLES{
- Input: \(k=0\) \(\to\) Output: \(5\).\\
- Input: \(k=5\) \(\to\) Output: \(0\).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Define \(f:\mathbb{Z}_{\ge 0}\to\mathbb{Z}_{\ge 0}\) by
\begin{BreakableEquation*}
f(x)=\sum_{i=1}^{\infty}\left\lfloor \frac{x}{5^i}\right\rfloor,
\end{BreakableEquation*}
finite because \(\left\lfloor \tfrac{x}{5^i}\right\rfloor=0\) for \(i>\log_5 x\). Given \(k\), compute \(S_k=\#\{x\ge 0: f(x)=k\}.\)}
\varmapStart
\var{x}{non-negative integer input to \(f\)}
\var{k}{target trailing-zero count}
\var{S_k}{preimage size at \(k\)}
\var{z(x)}{alias for \(f(x)\) for brevity}
\varmapEnd
\GOVERN{
\[
  z(x)=\sum_{i\ge 1}\left\lfloor \frac{x}{5^i}\right\rfloor,\qquad
  S_k=\#\{x\in\mathbb{Z}_{\ge 0}\mid z(x)=k\}.
\]
}
\ASSUMPTIONS{We work over 64-bit integers; bounds ensure binary search ranges like \(0\) to \(5(k+1)\) are safe.}
\INVARIANTS{
- \(z(x)\) is non-decreasing in \(x\).\\
- \(z(5n)=n+z(n)\), hence \(z(5(k+1))\ge k+1\).\\
- Differences satisfy \(z(x+1)-z(x)\in\{0,1\}\), with increments when \(x+1\) is a multiple of \(5\).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use \(z(x)=\sum_{i\ge 1}\lfloor x/5^i\rfloor\). Count solutions by finding the smallest \(x\) with \(z(x)\ge k\) and the smallest \(y\) with \(z(y)\ge k+1\); if \(z(\text{left})\ne k\) then \(S_k=0\), else \(S_k=(\text{left}(k+1)-\text{left}(k))\).}
\ASSUMPTIONS{Binary search over \(x\in[0,5(k+1)]\) suffices since \(z(5(k+1))\ge k+1\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Implement \(z(x)\) by repeated division by \(5\).
\item Binary search \(\text{left}(k)=\min\{x:z(x)\ge k\}\).
\item Binary search \(\text{left}(k{+}1)\). If \(z(\text{left}(k))\ne k\), return \(0\); else return \(\text{left}(k{+}1)-\text{left}(k)\).
\end{algosteps}
\COMPLEXITY{Each \(z(x)\) costs \(O(\log_5 x)\). Each binary search costs \(O(\log x)\) iterations. Two searches total \(O(\log x\cdot \log_5 x)\) time, with \(x=O(k)\); space \(O(1)\).}
\[
\begin{aligned}
T(k) &\in O\big((\log k)\cdot(\log_5 k)\big),\quad S(k)\in O(1).
\end{aligned}
\]
\CORRECTNESS{By monotonicity of \(z\), standard lower-bound binary search finds the minimal \(x\) reaching a threshold. The count of \(x\) with \(z(x)=k\) is exactly the length of the interval \([\text{left}(k),\text{left}(k{+}1))\) if non-empty.}
\EDGECASES{\(k=0\), very large \(k\) up to \(10^9\), and values \(k\) that have no preimage (e.g., \(k=5\)).}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        def zeta(x: int) -> int:
            s = 0
            while x:
                x //= 5
                s += x
            return s

        def left_bound(t: int) -> int:
            # smallest x with zeta(x) >= t
            lo, hi = 0, 5 * (t + 1)
            while lo < hi:
                mid = (lo + hi) // 2
                if zeta(mid) < t:
                    lo = mid + 1
                else:
                    hi = mid
            return lo

        l = left_bound(k)
        if zeta(l) != k:
            return 0
        r = left_bound(k + 1) - 1
        return r - l + 1

# Basic asserts
S = Solution()
assert S.preimageSizeFZF(0) == 5
assert S.preimageSizeFZF(5) == 0
assert S.preimageSizeFZF(3) == 5

# Cross-check small k by brute force mapping
def brute_preimage_size(k: int, X: int = 2000) -> int:
    def z(x: int) -> int:
        s = 0
        while x:
            x //= 5
            s += x
        return s
    return sum(1 for x in range(X) if z(x) == k)

for kk in range(0, 25):
    ans = S.preimageSizeFZF(kk)
    b = brute_preimage_size(kk, 5000)
    assert ans == b or (ans in (0, 5) and b in (0, 5) and ans == b)
\end{minted}
\VALIDATION{Checked samples and a sweep for \(k\le 24\) with brute force.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the identity \(S_k=\text{left}(k{+}1)-\text{left}(k)\) directly. This avoids recomputing right endpoints explicitly and leverages that the preimage size is either \(0\) or \(5\).}
\ASSUMPTIONS{Same search bounds; arithmetic property ensures the difference is exactly \(0\) or \(5\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Implement \(z(x)\) and \(\text{left}(k)\) as before.
\item Return \(\text{left}(k{+}1)-\text{left}(k)\) without extra checks.
\item The result is in \(\{0,5\}\) by theory below.
\end{algosteps}
\COMPLEXITY{Two lower-bound searches; still \(O(\log k\cdot \log_5 k)\) time, \(O(1)\) space, but simpler constant factors.}
\[
\begin{aligned}
T(k) &\in O\big((\log k)\cdot(\log_5 k)\big).
\end{aligned}
\]
\CORRECTNESS{If \(z(\text{left}(k))>k\), then \(\text{left}(k{+}1)=\text{left}(k)\) and the difference is \(0\). If \(z(\text{left}(k))=k\), then all \(x\in[\text{left}(k),\text{left}(k{+}1))\) map to \(k\); the interval length is the answer.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        def zeta(x: int) -> int:
            s = 0
            while x:
                x //= 5
                s += x
            return s

        def left_bound(t: int) -> int:
            lo, hi = 0, 5 * (t + 1)
            while lo < hi:
                mid = (lo + hi) // 2
                if zeta(mid) < t:
                    lo = mid + 1
                else:
                    hi = mid
            return lo

        return left_bound(k + 1) - left_bound(k)

# Tests
S = Solution()
assert S.preimageSizeFZF(0) == 5
assert S.preimageSizeFZF(5) == 0
assert S.preimageSizeFZF(3) == 5

# Spot-check a few more values
for kk, expect in [(1, 5), (2, 5), (4, 5), (6, 0), (10, 5), (11, 0)]:
    assert S.preimageSizeFZF(kk) == expect
\end{minted}
\VALIDATION{Validated on samples and some known positions where gaps occur (e.g., \(k=5,6,11,\ldots\)).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Known fact: \(S_k\in\{0,5\}\). It suffices to test existence of any \(x\) with \(z(x)=k\), then return \(5\) if found else \(0\). Implement existence by a single lower-bound search and a check.}
\ASSUMPTIONS{Monotonicity of \(z\) enables binary search; the five-fold preimage size when it exists comes from base-5 carry structure.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Binary search \(l=\text{left}(k)\).
\item If \(z(l)=k\), return \(5\); else return \(0\).
\item Proof sketch: when \(z(l)=k\), the solutions are exactly \(l,l+1,\ldots,l+4\).
\end{algosteps}
\OPTIMALITY{This uses one search and one evaluation, which is asymptotically optimal for comparison-based access to \(z\).}
\COMPLEXITY{Same asymptotics; slightly fewer calls to \(z\).}
\[
\begin{aligned}
T(k) &\in O\big((\log k)\cdot(\log_5 k)\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        def zeta(x: int) -> int:
            s = 0
            while x:
                x //= 5
                s += x
            return s

        # Find smallest x with zeta(x) >= k
        lo, hi = 0, 5 * (k + 1)
        while lo < hi:
            mid = (lo + hi) // 2
            if zeta(mid) < k:
                lo = mid + 1
            else:
                hi = mid
        # If exact match exists, there are exactly 5 solutions; else 0.
        return 5 if zeta(lo) == k else 0

# Exactly 3 asserts
S = Solution()
assert S.preimageSizeFZF(0) == 5
assert S.preimageSizeFZF(5) == 0
assert S.preimageSizeFZF(3) == 5
\end{minted}
\VALIDATION{Three asserts on canonical examples from the statement.}
\RESULT{Return \(5\) if a preimage exists for \(k\); otherwise return \(0\). There are no tie-breakers.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on sample cases; property test for small \(k\) that the result is in \(\{0,5\}\) and matches brute force; random spot checks.}
\LINE{CROSS-CHECKS}{Compare Approach A/B/C on small \(k\) and ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate \(k\in\{0,1,2,3,4,5,6,10,11,10^2,10^3,10^9\}\) to probe transitions and size.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def zeta(x: int) -> int:
    s = 0
    while x:
        x //= 5
        s += x
    return s

def brute_preimage(k: int, X: int = 20000) -> int:
    return sum(1 for x in range(X) if zeta(x) == k)

class A:
    def preimageSizeFZF(self, k: int) -> int:
        def left(t: int) -> int:
            lo, hi = 0, 5 * (t + 1)
            while lo < hi:
                mid = (lo + hi) // 2
                if zeta(mid) < t:
                    lo = mid + 1
                else:
                    hi = mid
            return lo
        l = left(k)
        if zeta(l) != k:
            return 0
        return left(k + 1) - l

class B:
    def preimageSizeFZF(self, k: int) -> int:
        def left(t: int) -> int:
            lo, hi = 0, 5 * (t + 1)
            while lo < hi:
                mid = (lo + hi) // 2
                if zeta(mid) < t:
                    lo = mid + 1
                else:
                    hi = mid
            return lo
        return left(k + 1) - left(k)

class C:
    def preimageSizeFZF(self, k: int) -> int:
        lo, hi = 0, 5 * (k + 1)
        while lo < hi:
            mid = (lo + hi) // 2
            if zeta(mid) < k:
                lo = mid + 1
            else:
                hi = mid
        return 5 if zeta(lo) == k else 0

# Cross-validate small k
for kk in range(0, 200):
    a = A().preimageSizeFZF(kk)
    b = B().preimageSizeFZF(kk)
    c = C().preimageSizeFZF(kk)
    assert a == b == c
    # Optional brute check for small kk
    bb = brute_preimage(kk, 20000)
    assert bb in (0, 5) and bb == a

# Probe edges
for kk in [0, 1, 2, 3, 4, 5, 6, 10, 11, 25, 26, 10**4, 10**5, 10**6]:
    assert A().preimageSizeFZF(kk) in (0, 5)
    assert B().preimageSizeFZF(kk) in (0, 5)
    assert C().preimageSizeFZF(kk) in (0, 5)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        def zeta(x: int) -> int:
            s = 0
            while x:
                x //= 5
                s += x
            return s

        def left_bound(t: int) -> int:
            lo, hi = 0, 5 * (t + 1)
            while lo < hi:
                mid = (lo + hi) // 2
                if zeta(mid) < t:
                    lo = mid + 1
                else:
                    hi = mid
            return lo

        return left_bound(k + 1) - left_bound(k)

# Quick self-checks
S = Solution()
assert S.preimageSizeFZF(0) == 5
assert S.preimageSizeFZF(5) == 0
assert S.preimageSizeFZF(3) == 5
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count how many \(x\) yield exactly \(k\) trailing zeroes in \(x!\) using the monotone function \(z(x)=\sum_{i\ge 1}\lfloor x/5^i\rfloor\).}
\WHY{A canonical hard LC problem assessing monotone binary search, number-theory insight on trailing zeroes, and proof that the preimage size is \(0\) or \(5\).}
\CHECKLIST{
- Write \(z(x)=\sum \lfloor x/5^i\rfloor\).\\
- Prove monotonicity and choose safe search bounds.\\
- Implement lower-bound search for \(k\) and \(k{+}1\).\\
- Answer is \(\text{left}(k{+}1)-\text{left}(k)\in\{0,5\}\).}
\EDGECASES{
- \(k=0\).\\
- Large \(k\) near \(10^9\).\\
- Values like \(k=5,6,11\) with no preimage.\\
- Off-by-one around multiples of \(5\).\\
- Ensure search upper bound sufficient for all \(k\).\\
- Verify no overflow in intermediate arithmetic.}
\PITFALLS{
- Using factorial directly (overflow, too slow).\\
- Forgetting to sum all powers of \(5\).\\
- Incorrect binary search loop (infinite loop on ties).\\
- Choosing too small a high bound.\\
- Assuming the answer could be values other than \(0\) or \(5\).\\
- Miscomputing mid updates when \(z(mid)=k\).}
\FAILMODES{Naive scanning over \(x\) is infeasible for \(k\approx 10^9\). The presented method survives due to logarithmic search and \(O(1)\) space.}
\ELI{Trailing zeroes count how many fives divide \(x!\). As \(x\) grows, this count increases in a step-like way. Either a step lands exactly on \(k\) for a run of five consecutive \(x\), or it skips \(k\) entirely. Binary search finds the run, and we return \(5\) or \(0\).}
\NotePages{3}

\end{document}