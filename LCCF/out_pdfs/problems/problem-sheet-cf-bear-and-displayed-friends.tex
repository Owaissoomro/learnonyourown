% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Bear and Displayed Friends}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/639/A}}
\LINE{DIFFICULTY / RATING}{1200}
\STATEMENT{Limak is a little polar bear. He loves connecting with other bears via social networks. He has $n$ friends and his relation with the $i$-th of them is described by a unique integer $t_i$. The bigger this value is, the better the friendship is. No two friends have the same value $t_i$.

Spring is starting and the Winter sleep is over for bears. Limak has just woken up and logged in. All his friends still sleep and thus none of them is online. Some (maybe all) of them will appear online in the next hours, one at a time.

The system displays friends who are online. On the screen there is space to display at most $k$ friends. If there are more than $k$ friends online then the system displays only $k$ best of them — those with biggest $t_i$.

Your task is to handle queries of two types:
\begin{bullets}
\item ``1 id'' — Friend $id$ becomes online. It is guaranteed that he was not online before.
\item ``2 id'' — Check whether friend $id$ is displayed by the system. Print ``YES'' or ``NO'' in a separate line.
\end{bullets}
Are you able to help Limak and answer all queries of the second type?

Input:
The first line contains three integers $n$, $k$ and $q$ ($1 \le n, q \le 150{,}000$, $1 \le k \le \min(6, n)$) — the number of friends, the maximum number of displayed online friends and the number of queries, respectively.

The second line contains $n$ integers $t_1, t_2, \ldots, t_n$ ($1 \le t_i \le 10^9$) where $t_i$ describes how good is Limak's relation with the $i$-th friend.

The $i$-th of the following $q$ lines contains two integers $\text{type}_i$ and $\text{id}_i$ ($1 \le \text{type}_i \le 2$, $1 \le \text{id}_i \le n$) — the $i$-th query. If $\text{type}_i = 1$ then a friend $\text{id}_i$ becomes online. If $\text{type}_i = 2$ then you should check whether a friend $\text{id}_i$ is displayed.

It is guaranteed that no two queries of the first type will have the same $\text{id}_i$ because one friend cannot become online twice. Also, it is guaranteed that at least one query will be of the second type ($\text{type}_i = 2$) so the output will not be empty.

Output:
For each query of the second type print one line with the answer — ``YES'' (without quotes) if the given friend is displayed and ``NO'' (without quotes) otherwise.

Note:
In the first sample, Limak has 4 friends who all sleep initially. At first, the system displays nobody because nobody is online. There are the following 8 queries:
\begin{enumerate}[leftmargin=1.6em]
\item ``1 3'' — Friend $3$ becomes online.
\item ``2 4'' — We should check if friend $4$ is displayed. He is not even online and thus we print ``NO''.
\item ``2 3'' — We should check if friend $3$ is displayed. Right now he is the only friend online and the system displays him. We should print ``YES''.
\item ``1 1'' — Friend $1$ becomes online. The system now displays both friend $1$ and friend $3$.
\item ``1 2'' — Friend $2$ becomes online. There are $3$ friends online now but we were given $k=2$ so only two friends can be displayed. Limak has worse relation with friend $1$ than with other two online friends ($t_1 < t_2, t_3$) so friend $1$ will not be displayed.
\item ``2 1'' — Print ``NO''.
\item ``2 2'' — Print ``YES''.
\item ``2 3'' — Print ``YES''.
\end{enumerate}}
\BREAKDOWN{Maintain, under online additions only, the set of currently displayed friends: the top $k$ by $t_i$ among all online users. For each query of type $2$, answer whether the given $id$ is in that displayed set.}
\ELI{Keep the best up to $k$ online friends; when someone better comes, kick out the current worst shown.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
- Integers $n, k, q$ with $1 \le n, q \le 150{,}000$ and $1 \le k \le \min(6, n)$.\\
- Array $t[1..n]$ with $1 \le t_i \le 10^9$, all $t_i$ distinct.\\
- $q$ queries, each is a pair $(\text{type}, \text{id})$ with $\text{type} \in \{1,2\}$ and $1 \le \text{id} \le n$. For $\text{type}=1$, that $\text{id}$ never repeats across type-1 queries.}
\OUTPUTS{For each query with $\text{type}=2$, print a line ``YES'' if friend $\text{id}$ is currently displayed (among top $k$ by $t$ among online), otherwise ``NO''.}
\SAMPLES{
Example 1:\\
Input
\begin{verbatim}
4 2 8
5 3 4 2
1 3
2 4
2 3
1 1
1 2
2 1
2 2
2 3
\end{verbatim}
Output
\begin{verbatim}
NO
YES
YES
NO
YES
\end{verbatim}
Example 2:\\
Input
\begin{verbatim}
3 1 5
10 20 30
2 1
1 2
2 2
1 3
2 2
\end{verbatim}
Output
\begin{verbatim}
NO
YES
NO
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $U=\{1,\ldots,n\}$ be friends. Let $t:U\to\mathbb{Z}$ be distinct scores. Maintain $O\subseteq U$ (online) and $D \subseteq O$ (displayed) with $\lvert D\rvert \le k$ and $D$ equals the $k$ highest-scored elements of $O$ (or all of $O$ if $\lvert O\rvert<k$). Type-1 query adds an element to $O$. Type-2 query asks whether $id \in D$.}
\varmapStart
\var{n}{number of friends}
\var{k}{display capacity}
\var{q}{number of queries}
\var{t_i}{friendship score of friend $i$}
\var{O}{set of online friends}
\var{D}{set of currently displayed friends (top $k$ in $O$ by $t$)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
& O \gets O \cup \{x\} \quad \text{on type-1 with } x, \\
& D \gets \arg\max_{S \subseteq O,\ \lvert S\rvert \le k} \sum_{i \in S} t_i \quad \text{(ties impossible since $t_i$ distinct)}, \\
& \text{Answer YES to type-2 $(\_, x)$ iff } x \in D.
\end{aligned}
\]
}
\ASSUMPTIONS{Scores $t_i$ are distinct. Only additions to $O$ occur (no deletions). $k \le 6$, a very small constant.}
\INVARIANTS{
- $D \subseteq O$ and $\lvert D\rvert \le k$.\\
- If $\lvert O\rvert \le k$ then $D=O$. If $\lvert O\rvert>k$, then $\min_{i\in D} t_i > \max_{j\in O\setminus D} t_j$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{On a type-2 query for $id$, check if $id \in O$ and whether fewer than $k$ online friends have strictly larger $t$ than $t_{id}$.}
\ASSUMPTIONS{Maintain only the set $O$ of online friends. Recompute ranking as needed for each type-2 query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a boolean array $online[1..n]$, all initially false.
\item For type-1 $(1, x)$: set $online[x] \gets \text{true}$.
\item For type-2 $(2, x)$: if $online[x]=\text{false}$ print NO. Else count $c=\lvert\{j: online[j]\ \land\ t_j>t_x\}\rvert$. Print YES iff $c<k$.
\end{algosteps}
\COMPLEXITY{For $q$ queries and $n$ friends, type-1 is $O(1)$, type-2 is $O(n)$. Worst-case $O(nq)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= \Theta(\#\text{type-1})\cdot O(1) + \Theta(\#\text{type-2})\cdot O(n) \\
     &= O(nq) \text{ worst-case.}
\end{aligned}
\]
\CORRECTNESS{Directly tests the definition: a friend is displayed iff fewer than $k$ online friends have strictly higher $t$.}
\EDGECASES{Friend not online; $k=1$; $k\ge \lvert O\rvert$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); q = next(it)
    except StopIteration:
        return None
    t = [0]*(n+1)
    for i in range(1, n+1):
        t[i] = next(it)
    queries = []
    for _ in range(q):
        typ = next(it); idx = next(it)
        queries.append((typ, idx))
    return n, k, q, t, queries

def solve_all(n, k, q, t, queries):
    online = [False]*(n+1)
    out = []
    for typ, idx in queries:
        if typ == 1:
            online[idx] = True
        else:
            if not online[idx]:
                out.append("NO")
                continue
            tx = t[idx]
            higher = 0
            # Count how many online have strictly higher t
            for j in range(1, n+1):
                if online[j] and t[j] > tx:
                    higher += 1
                    if higher >= k:  # early stop
                        break
            out.append("YES" if higher < k else "NO")
    return out

def main():
    data = sys.stdin.buffer.read().decode()
    parsed = read_input(data)
    if parsed is None:
        return
    n, k, q, t, queries = parsed
    ans = solve_all(n, k, q, t, queries)
    sys.stdout.write("\n".join(ans))

# --- simple asserts (do not print) ---
def _test():
    n, k, q = 4, 2, 8
    t = [0, 5, 3, 4, 2]
    queries = [(1,3),(2,4),(2,3),(1,1),(1,2),(2,1),(2,2),(2,3)]
    expect = ["NO","YES","YES","NO","YES"]
    got = solve_all(n,k,q,t,queries)
    assert got == expect
    n2, k2, q2 = 3, 1, 5
    t2 = [0, 10, 20, 30]
    queries2 = [(2,1),(1,2),(2,2),(1,3),(2,2)]
    expect2 = ["NO","YES","NO"]
    assert solve_all(n2,k2,q2,t2,queries2) == expect2

_test()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked against two tiny examples and early-stop when $k$ higher-$t$ friends are found.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Min-Heap of Displayed (Top-$k$) + Membership Set}
\WHICHFORMULA{Maintain $D$ directly. With $\lvert D\rvert \le k$, the worst displayed is the heap-min by $t$. On a new online friend $x$, if $\lvert D\rvert<k$ put $x$ into $D$; else, if $t_x > \min(D)$, evict the current min and insert $x$. Query in $O(1)$ by set membership.}
\ASSUMPTIONS{Keep a min-heap of pairs $(t_i, i)$ for $D$ and a set $in\_disp$ for $O(1)$ membership. Use lazy-deletion on the heap to skip stale entries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $in\_disp=\emptyset$, heap $H=\emptyset$, boolean $online[1..n]=\text{false}$.
\item Type-1 $(1,x)$:
  \begin{bullets}
  \item Set $online[x]\gets\text{true}$.
  \item If $\lvert in\_disp\rvert<k$, push $(t_x,x)$ to $H$ and add $x$ to $in\_disp$.
  \item Else clean $H$'s top until it references an id in $in\_disp$. Let $(t_{\min},i_{\min})$ be the top.
  \item If $t_x>t_{\min}$: pop top, remove $i_{\min}$ from $in\_disp$, then push $(t_x,x)$ and add $x$.
  \end{bullets}
\item Type-2 $(2,x)$: print YES iff $x\in in\_disp$, else NO.
\end{algosteps}
\COMPLEXITY{Type-1 is $O(\log k)$ amortized due to heap ops and occasional lazy pops; type-2 is $O(1)$. Since $k\le 6$, this is effectively constant-time.}
\[
\begin{aligned}
T(n) &= O(q \log k),\quad S(n)=O(k+n).
\end{aligned}
\]
\CORRECTNESS{Invariant: $in\_disp$ always stores exactly the current top-$k$ online friends by $t$. Insertion either fills capacity or swaps with the current worst displayed iff newcomer is strictly better, which is necessary and sufficient for top-$k$ maintenance.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, heapq

def read_input(data):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); q = next(it)
    except StopIteration:
        return None
    t = [0]*(n+1)
    for i in range(1, n+1):
        t[i] = next(it)
    queries = []
    for _ in range(q):
        typ = next(it); idx = next(it)
        queries.append((typ, idx))
    return n, k, q, t, queries

def solve_all(n, k, q, t, queries):
    in_disp = set()
    heap = []  # min-heap of (t_i, i) for displayed
    online = [False]*(n+1)
    out = []
    def clean_top():
        while heap and heap[0][1] not in in_disp:
            heapq.heappop(heap)
    for typ, idx in queries:
        if typ == 1:
            online[idx] = True
            if len(in_disp) < k:
                in_disp.add(idx)
                heapq.heappush(heap, (t[idx], idx))
            else:
                clean_top()
                if not heap:
                    # Shouldn't happen if k>0 and in_disp synced, but guard anyway
                    in_disp.add(idx)
                    heapq.heappush(heap, (t[idx], idx))
                else:
                    tmin, imin = heap[0]
                    if t[idx] > tmin:
                        heapq.heappop(heap)
                        if imin in in_disp:
                            in_disp.remove(imin)
                        in_disp.add(idx)
                        heapq.heappush(heap, (t[idx], idx))
        else:
            out.append("YES" if idx in in_disp else "NO")
    return out

def main():
    data = sys.stdin.buffer.read().decode()
    parsed = read_input(data)
    if parsed is None:
        return
    n, k, q, t, queries = parsed
    ans = solve_all(n, k, q, t, queries)
    sys.stdout.write("\n".join(ans))

# --- asserts ---
def _test():
    n, k, q = 4, 2, 8
    t = [0, 5, 3, 4, 2]
    queries = [(1,3),(2,4),(2,3),(1,1),(1,2),(2,1),(2,2),(2,3)]
    expect = ["NO","YES","YES","NO","YES"]
    assert solve_all(n,k,q,t,queries) == expect
    n2, k2, q2 = 3, 1, 5
    t2 = [0, 10, 20, 30]
    queries2 = [(2,1),(1,2),(2,2),(1,3),(2,2)]
    expect2 = ["NO","YES","NO"]
    assert solve_all(n2,k2,q2,t2,queries2) == expect2

_test()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-checked against baseline outputs on tiny cases; heap top is lazily cleaned to avoid stale minima.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Exploit $k \le 6$: Tiny Top-$k$ Set with Linear-in-$k$ Maintenance}
\WHICHFORMULA{Maintain only the displayed set $D$ as a Python set plus a tiny array/list. On insertion, if $\lvert D\rvert<k$ insert; else scan $D$ to find the current minimum by $t$ in $O(k)$ and replace if the newcomer is better. Type-2 is $O(1)$.}
\ASSUMPTIONS{Because $k \le 6$, scanning and updating $D$ in $O(k)$ is effectively constant time and has lower constant factors than a heap or tree.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep $in\_disp$ (set of displayed ids).
\item On type-1 $(1,x)$:
  \begin{bullets}
  \item If $\lvert in\_disp\rvert<k$, add $x$.
  \item Else find $i_{\min} \in in\_disp$ minimizing $t_{i_{\min}}$. If $t_x>t_{i_{\min}}$, replace $i_{\min}$ with $x$.
  \end{bullets}
\item On type-2 $(2,x)$: print YES iff $x\in in\_disp$.
\end{algosteps}
\OPTIMALITY{With only additions and $k$ bounded by a small constant, any solution must at least inspect whether the newcomer beats the current worst displayed friend. This needs identifying the minimum in $D$, which can be done in $O(k)$. Since $k$ is constant, this achieves optimal $O(1)$ amortized time per query and is simpler than a heap.}
\COMPLEXITY{$T(q)=O(q\cdot k)=O(q)$ since $k\le 6$. Space $O(n)$ for scores and online bookkeeping, $O(k)$ for the displayed set.}
\[
\begin{aligned}
T(n) &= O(q \cdot k) = O(q), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); q = next(it)
    except StopIteration:
        return None
    t = [0]*(n+1)
    for i in range(1, n+1):
        t[i] = next(it)
    queries = []
    for _ in range(q):
        typ = next(it); idx = next(it)
        queries.append((typ, idx))
    return n, k, q, t, queries

def solve_all(n, k, q, t, queries):
    in_disp = set()
    online = [False]*(n+1)
    out = []
    for typ, idx in queries:
        if typ == 1:
            online[idx] = True
            if len(in_disp) < k:
                in_disp.add(idx)
            else:
                # Find current min in displayed by t
                imin = None
                tmin = None
                for i in in_disp:
                    if imin is None or t[i] < tmin:
                        imin = i
                        tmin = t[i]
                if t[idx] > tmin:
                    in_disp.remove(imin)
                    in_disp.add(idx)
        else:
            out.append("YES" if idx in in_disp else "NO")
    return out

def main():
    data = sys.stdin.buffer.read().decode()
    parsed = read_input(data)
    if parsed is None:
        return
    n, k, q, t, queries = parsed
    ans = solve_all(n, k, q, t, queries)
    sys.stdout.write("\n".join(ans))

# --- asserts / mini-tests ---
def _test():
    # Example 1
    n, k, q = 4, 2, 8
    t = [0, 5, 3, 4, 2]
    queries = [(1,3),(2,4),(2,3),(1,1),(1,2),(2,1),(2,2),(2,3)]
    expect = ["NO","YES","YES","NO","YES"]
    assert solve_all(n,k,q,t,queries) == expect
    # Example 2
    n2, k2, q2 = 3, 1, 5
    t2 = [0, 10, 20, 30]
    queries2 = [(2,1),(1,2),(2,2),(1,3),(2,2)]
    expect2 = ["NO","YES","NO"]
    assert solve_all(n2,k2,q2,t2,queries2) == expect2
    # Random cross-check vs baseline logic on small n
    import random
    random.seed(0)
    for _ in range(50):
        n = 6
        k = random.randint(1, min(6, n))
        vals = list(range(1, n+1))
        random.shuffle(vals)
        t = [0]+vals
        q = 30
        online_seen = set()
        queries = []
        for __ in range(q):
            if random.random() < 0.5 and len(online_seen) < n:
                # add a new online friend
                choices = [i for i in range(1, n+1) if i not in online_seen]
                x = random.choice(choices)
                online_seen.add(x)
                queries.append((1, x))
            else:
                queries.append((2, random.randint(1, n)))
        # Baseline checker
        def baseline(n,k,q,t,queries):
            online = [False]*(n+1)
            out = []
            for typ, idx in queries:
                if typ == 1:
                    online[idx] = True
                else:
                    if not online[idx]:
                        out.append("NO")
                    else:
                        higher = sum(1 for j in range(1, n+1) if online[j] and t[j] > t[idx])
                        out.append("YES" if higher < k else "NO")
            return out
        ref = baseline(n,k,q,t,queries)
        got = solve_all(n,k,q,t,queries)
        assert got == ref
_test()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts were included above: two fixed cases and a randomized cross-check against the baseline on small inputs.}
\RESULT{For each type-2 query, output ``YES'' if the friend is among the currently displayed top-$k$ online friends by $t$, otherwise ``NO''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for simple scenarios; randomized differential tests vs a baseline on small $n$; edge cases $k=1$, $k=n$, querying offline ids.}
\LINE{CROSS-CHECKS}{Compare Approach A vs Approach C on many random sequences to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generates sequences with only type-2 queries first, then bursts of type-1, and interleavings that push/replace the displayed minimum frequently.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case(n=6, k=3, q=20, seed=1):
    random.seed(seed)
    tvals = list(range(1, n+1))
    random.shuffle(tvals)
    t = [0]+tvals
    online = set()
    queries = []
    for _ in range(q):
        if not online or (random.random() < 0.6 and len(online) < n):
            # Favor type-1 early while not all online
            choices = [i for i in range(1, n+1) if i not in online]
            x = random.choice(choices)
            online.add(x)
            queries.append((1, x))
        else:
            x = random.randint(1, n)
            queries.append((2, x))
    return n, k, q, t, queries

def ref_baseline(n,k,q,t,queries):
    online = [False]*(n+1)
    out = []
    for typ, idx in queries:
        if typ == 1:
            online[idx] = True
        else:
            if not online[idx]:
                out.append("NO")
            else:
                higher = sum(1 for j in range(1, n+1) if online[j] and t[j] > t[idx])
                out.append("YES" if higher < k else "NO")
    return out

def final_solution(n,k,q,t,queries):
    in_disp = set()
    online = [False]*(n+1)
    out = []
    for typ, idx in queries:
        if typ == 1:
            online[idx] = True
            if len(in_disp) < k:
                in_disp.add(idx)
            else:
                # find min in displayed
                imin = None; tmin = None
                for i in in_disp:
                    if imin is None or t[i] < tmin:
                        imin, tmin = i, t[i]
                if t[idx] > tmin:
                    in_disp.remove(imin)
                    in_disp.add(idx)
        else:
            out.append("YES" if idx in in_disp else "NO")
    return out

# Cross-check
n,k,q,t,queries = gen_case()
assert final_solution(n,k,q,t,queries) == ref_baseline(n,k,q,t,queries)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 639A — Bear and Displayed Friends
# Final solution exploiting k <= 6

import sys

def read_input(data):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); k = next(it); q = next(it)
    except StopIteration:
        return None
    t = [0]*(n+1)
    for i in range(1, n+1):
        t[i] = next(it)
    queries = []
    for _ in range(q):
        typ = next(it); idx = next(it)
        queries.append((typ, idx))
    return n, k, q, t, queries

def solve_all(n, k, q, t, queries):
    in_disp = set()
    online = [False]*(n+1)
    out = []
    for typ, idx in queries:
        if typ == 1:
            online[idx] = True
            if len(in_disp) < k:
                in_disp.add(idx)
            else:
                # Find the currently worst displayed by t
                imin = None
                tmin = None
                for i in in_disp:
                    if imin is None or t[i] < tmin:
                        imin = i
                        tmin = t[i]
                if t[idx] > tmin:
                    in_disp.remove(imin)
                    in_disp.add(idx)
        else:
            out.append("YES" if idx in in_disp else "NO")
    return out

def main():
    data = sys.stdin.buffer.read().decode()
    parsed = read_input(data)
    if parsed is None:
        return
    n, k, q, t, queries = parsed
    ans = solve_all(n, k, q, t, queries)
    sys.stdout.write("\n".join(ans))

# Minimal asserts (do not print)
def _test():
    n, k, q = 4, 2, 8
    t = [0, 5, 3, 4, 2]
    queries = [(1,3),(2,4),(2,3),(1,1),(1,2),(2,1),(2,2),(2,3)]
    expect = ["NO","YES","YES","NO","YES"]
    assert solve_all(n,k,q,t,queries) == expect
    n2, k2, q2 = 3, 1, 5
    t2 = [0, 10, 20, 30]
    queries2 = [(2,1),(1,2),(2,2),(1,3),(2,2)]
    expect2 = ["NO","YES","NO"]
    assert solve_all(n2,k2,q2,t2,queries2) == expect2

_test()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain the top $k$ scores among online friends under only insertions; answer membership queries for a given $id$.}
\WHY{A staple of streaming/online data-structure problems: maintain a dynamic top-$k$ set with fast queries.}
\CHECKLIST{
- Are $t_i$ distinct and read correctly?\\
- On type-1: if $|D|<k$ then insert; else compare against current minimum in $D$.\\
- On type-2: just membership in $D$.\\
- No off-by-one in indexing ($1\ldots n$).}
\EDGECASES{
- $k=1$ (only max online is displayed).\\
- $k=n$ (everyone online is displayed).\\
- Querying offline ids (always NO).\\
- First queries are all type-2 (outputs all NO).\\
- Last online addition does not beat current minimum.\\
- Scores extremely large but fit in 32-bit; Python int is unbounded.}
\PITFALLS{
- Forgetting that only additions occur; no need to remove unless replacing the minimum in displayed.\\
- Using sorting per query (too slow).\\
- Mis-handling ties (but scores are guaranteed distinct).\\
- Not updating membership set consistently on replace.\\
- Mixing $0$- and $1$-based indices.\\
- Printing extra spaces or missing newlines.}
\FAILMODES{The naive baseline times out due to $O(n)$ per type-2. Heap-based and $O(k)$-scan approaches both pass; with $k \le 6$, the $O(k)$ scan is simplest and fastest in practice.}
\ELI{We can keep a tiny shelf of up to $k$ best friends on the screen. When someone comes online, if the shelf is not full, put them on it; if it is full, only put them there if they are better than the current worst on the shelf. To answer a check, see if they are on the shelf.}
\NotePages{3}

\end{document}