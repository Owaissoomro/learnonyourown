% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Reshape the Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/reshape-the-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{In MATLAB, there is a handy function called \texttt{reshape} which can reshape an $m \times n$ matrix into a new one with a different size $r \times c$ keeping its original data. You are given an $m \times n$ matrix \texttt{mat} and two integers $r$ and $c$ representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the \texttt{reshape} operation with given parameters is possible and legal, output the new reshaped matrix; otherwise, output the original matrix.

Example 1:

Input: \texttt{mat = [[1,2],[3,4]]}, \texttt{r = 1}, \texttt{c = 4}. Output: \texttt{[[1,2,3,4]]}.

Example 2:

Input: \texttt{mat = [[1,2],[3,4]]}, \texttt{r = 2}, \texttt{c = 4}. Output: \texttt{[[1,2],[3,4]]}.

Constraints:
\begin{bullets}
\item $m = \texttt{len(mat)}$.
\item $n = \texttt{len(mat[i])}$.
\item $1 \le m, n \le 100$.
\item $-1000 \le \texttt{mat[i][j]} \le 1000$.
\item $1 \le r, c \le 300$.
\end{bullets}}
\BREAKDOWN{Check feasibility via size equality $m \times n = r \times c$. If infeasible, return the original matrix. If feasible, preserve row-major order by mapping each element's linear index to its new row and column.}
\ELI{Flatten in reading order and refill to the requested shape if the total number of elements matches; otherwise keep it as is.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A 2D list \texttt{mat} of size $m \times n$ with integers, and two integers $r$ and $c$. Valid ranges: $1 \le m, n \le 100$, $-1000 \le \texttt{mat[i][j]} \le 1000$, $1 \le r, c \le 300$.}
\OUTPUTS{A 2D list of integers. If $m \times n \ne r \times c$, return \texttt{mat} unchanged; else return the reshaped matrix of size $r \times c$ in the same row-major order.}
\SAMPLES{Example A: \texttt{mat = [[1,2],[3,4]]}, \texttt{r = 1}, \texttt{c = 4} yields \texttt{[[1,2,3,4]]}. Example B: \texttt{mat = [[1,2],[3,4]]}, \texttt{r = 2}, \texttt{c = 4} yields \texttt{[[1,2],[3,4]]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $M \in \mathbb{Z}^{m \times n}$ and integers $r, c \in \mathbb{Z}_{>0}$ with $m \times n = r \times c$, define a bijection between positions by linearizing row-major order. Let $k \in \{0,\ldots,mn-1\}$ index the elements in row-major order.}
\varmapStart
\var{M}{original matrix in $\mathbb{Z}^{m \times n}$}
\var{m, n}{original number of rows and columns}
\var{r, c}{target number of rows and columns}
\var{k}{zero-based linear index in row-major order}
\var{(i,j)}{original coordinates with $0 \le i < m$, $0 \le j < n$}
\var{(u,v)}{target coordinates with $0 \le u < r$, $0 \le v < c$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
k &= i \cdot n + j, \quad 0 \le i < m,\; 0 \le j < n, \\
u &= \left\lfloor \dfrac{k}{c} \right\rfloor, \\
v &= k \bmod c, \\
\text{and}\quad M'[u,v] &= M[i,j], \quad \text{provided } m \times n = r \times c.
\end{aligned}
\]
}
\ASSUMPTIONS{Row-major traversal; zero-based indices; reshaping only if total size matches; if not, $M'$ is defined to be $M$.}
\INVARIANTS{
\begin{bullets}
\item Element order is preserved: for any $k_1 < k_2$, the image positions $(u_1,v_1)$ and $(u_2,v_2)$ maintain the same relative order in row-major traversal.
\item No data loss or duplication when $m \times n = r \times c$: the mapping $k \mapsto (u,v)$ is bijective on $\{0,\ldots,mn-1\}$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Flatten the matrix in row-major order, then slice into chunks of length $c$ if and only if $m \times n = r \times c$.}
\ASSUMPTIONS{Use an intermediate flat list to simplify implementation; preserve order by iterating rows then columns.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $m = \texttt{len(mat)}$, $n = \texttt{len(mat[0])}$. If $m \times n \ne r \times c$, return \texttt{mat}.
\item Build a flat list \texttt{vals} by iterating row by row through \texttt{mat}.
\item Create the result as consecutive slices: \texttt{res[t] = vals[t*c : (t+1)*c]} for $t = 0,\ldots,r-1$.
\end{algosteps}
\COMPLEXITY{Time and space are both linear in the element count $N = m \times n$.}
\[
\begin{aligned}
T(n) &= \Theta(mn) = \Theta(N), \\
S(n) &= \Theta(N) \text{ for the temporary flat list}.
\end{aligned}
\]
\CORRECTNESS{Since flattening in row-major order enumerates elements by increasing $k$, chunking into consecutive groups of size $c$ maps $k$ to $(\lfloor k/c \rfloor, k \bmod c)$, preserving order with no loss or duplication.}
\EDGECASES{Single row or column; $r=c=1$; negative values; infeasible reshape where $m \times n \ne r \times c$; maximum sizes.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0:
            return mat
        if m * n != r * c:
            return mat
        flat = [mat[i][j] for i in range(m) for j in range(n)]
        res = [flat[t * c:(t + 1) * c] for t in range(r)]
        return res

# tests
sol = Solution()
assert sol.matrixReshape([[1,2],[3,4]], 1, 4) == [[1,2,3,4]]
assert sol.matrixReshape([[1,2],[3,4]], 2, 4) == [[1,2],[3,4]]
assert sol.matrixReshape([[1]], 1, 1) == [[1]]
assert sol.matrixReshape([[1,2,3,4]], 2, 2) == [[1,2],[3,4]]
\end{minted}
\VALIDATION{Validated on two provided examples, identity reshape, and a reshape from $1 \times 4$ to $2 \times 2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid the extra flat buffer by filling the target matrix directly using index arithmetic $k = i \cdot n + j$, $u = \lfloor k/c \rfloor$, $v = k \bmod c$.}
\ASSUMPTIONS{Preallocate the result matrix and write each element exactly once; early return when sizes mismatch.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $m = \texttt{len(mat)}$, $n = \texttt{len(mat[0])}$. If $m \times n \ne r \times c$, return \texttt{mat}.
\item Initialize \texttt{res} as a list of $r$ rows each of length $c$.
\item For each $(i,j)$, compute $k = i \cdot n + j$, then $(u,v) = (\lfloor k/c \rfloor, k \bmod c)$ and set \texttt{res[u][v] = mat[i][j]}.
\end{algosteps}
\COMPLEXITY{Same asymptotic time but reduced auxiliary memory.}
\[
\begin{aligned}
T(n) &= \Theta(mn), \\
S(n) &= \Theta(1) \text{ auxiliary beyond the output matrix}.
\end{aligned}
\]
\CORRECTNESS{The bijection from linear index $k$ to $(u,v)$ preserves order and covers all positions exactly once; thus the filled matrix has the correct order and content.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0 or m * n != r * c:
            return mat
        res = [[0] * c for _ in range(r)]
        for i in range(m):
            for j in range(n):
                k = i * n + j
                u = k // c
                v = k % c
                res[u][v] = mat[i][j]
        return res

# tests
sol = Solution()
assert sol.matrixReshape([[1,2],[3,4]], 1, 4) == [[1,2,3,4]]
assert sol.matrixReshape([[1,2],[3,4]], 2, 2) == [[1,2],[3,4]]
assert sol.matrixReshape([[1,2,3],[4,5,6]], 3, 2) == [[1,2],[3,4],[5,6]]
\end{minted}
\VALIDATION{Checked reshaping to a single row, identity reshape, and a nontrivial $2 \times 3 \to 3 \times 2$ case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the linear index mapping directly in a single pass with early infeasibility check; this achieves optimal $\Theta(mn)$ time and $O(1)$ auxiliary space.}
\ASSUMPTIONS{Total element count equality is necessary and sufficient; row-major order is the traversal order to preserve.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $m, n$; if $m \times n \ne r \times c$, return \texttt{mat}.
\item Initialize \texttt{res} with $r$ rows of length $c$.
\item For $k$ from $0$ to $mn-1$, set $(i,j) = (\lfloor k/n \rfloor, k \bmod n)$ and $(u,v) = (\lfloor k/c \rfloor, k \bmod c)$, then write \texttt{res[u][v] = mat[i][j]}.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect all $mn$ elements in the worst case to preserve their order; thus $\Theta(mn)$ time is optimal. Auxiliary space below $O(1)$ beyond the output is impossible because we must produce $rc$ outputs.}
\COMPLEXITY{Time $\Theta(mn)$, space $O(1)$ auxiliary.}
\[
\begin{aligned}
T(n) &= \Theta(mn), \\
S(n) &= O(1) \text{ auxiliary}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0 or m * n != r * c:
            return mat
        res = [[0] * c for _ in range(r)]
        # single linear pass
        for k in range(m * n):
            i, j = divmod(k, n)
            u, v = divmod(k, c)
            res[u][v] = mat[i][j]
        return res

# exactly 3 asserts
sol = Solution()
assert sol.matrixReshape([[1,2],[3,4]], 1, 4) == [[1,2,3,4]]
assert sol.matrixReshape([[1,2],[3,4]], 2, 4) == [[1,2],[3,4]]
assert sol.matrixReshape([[1,2,3],[4,5,6]], 2, 3) == [[1,2,3],[4,5,6]]
\end{minted}
\VALIDATION{Three asserts: reshape to one row, infeasible reshape returns original, identity reshape.}
\RESULT{Return the reshaped $r \times c$ matrix in row-major order when feasible, otherwise the original matrix unchanged.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover feasibility check boundaries, preservation of order across shapes, single row or column, and maximum legal sizes within reasonable runtime.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on small randomly generated matrices and shapes where $m \times n = r \times c$; ensure identical results and that infeasible requests return the original matrix.}
\LINE{EDGE-CASE GENERATOR}{Generate small $m, n, r, c$ pairs with values including negatives and zeros in content; verify feasibility condition and order preservation.}
\begin{minted}{python}
from typing import List
import random

def gen_matrix(m: int, n: int) -> List[List[int]]:
    rng = random.Random(0)
    return [[rng.randint(-3, 3) for _ in range(n)] for _ in range(m)]

class A:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat); n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0 or m * n != r * c: return mat
        flat = [mat[i][j] for i in range(m) for j in range(n)]
        return [flat[t * c:(t + 1) * c] for t in range(r)]

class B:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat); n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0 or m * n != r * c: return mat
        res = [[0] * c for _ in range(r)]
        for i in range(m):
            for j in range(n):
                k = i * n + j
                u, v = divmod(k, c)
                res[u][v] = mat[i][j]
        return res

class C:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat); n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0 or m * n != r * c: return mat
        res = [[0] * c for _ in range(r)]
        for k in range(m * n):
            i, j = divmod(k, n)
            u, v = divmod(k, c)
            res[u][v] = mat[i][j]
        return res

def cross_check():
    rng = random.Random(1)
    for m in range(1, 5):
        for n in range(1, 5):
            mat = gen_matrix(m, n)
            total = m * n
            divisors = [d for d in range(1, total + 1) if total % d == 0]
            for r in divisors:
                c = total // r
                a = A().matrixReshape(mat, r, c)
                b = B().matrixReshape(mat, r, c)
                csol = C().matrixReshape(mat, r, c)
                assert a == b == csol
            # infeasible case
            r = total + 1; c = 1
            assert A().matrixReshape(mat, r, c) == mat
            assert B().matrixReshape(mat, r, c) == mat
            assert C().matrixReshape(mat, r, c) == mat

cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        if m == 0 or n == 0 or m * n != r * c:
            return mat
        res = [[0] * c for _ in range(r)]
        for k in range(m * n):
            i, j = divmod(k, n)
            u, v = divmod(k, c)
            res[u][v] = mat[i][j]
        return res

# sanity tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.matrixReshape([[1,2],[3,4]], 1, 4) == [[1,2,3,4]]
    assert sol.matrixReshape([[1,2],[3,4]], 2, 4) == [[1,2],[3,4]]
    assert sol.matrixReshape([[1,2,3],[4,5,6]], 3, 2) == [[1,2],[3,4],[5,6]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reshape a matrix to $r \times c$ preserving row-major order if and only if the total element count matches.}
\WHY{This checks understanding of array linearization, index arithmetic, and careful handling of feasibility and edge conditions.}
\CHECKLIST{
\begin{bullets}
\item Compute $m, n$; check $m \times n = r \times c$.
\item If infeasible, return the original matrix immediately.
\item Use linear index mapping to preserve order.
\item Preallocate result and write each element exactly once.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Infeasible sizes where $m \times n \ne r \times c$.
\item Single element $1 \times 1$.
\item Single row or single column inputs.
\item Negative numbers in \texttt{mat}.
\item Large sizes near limits, e.g., $100 \times 100$ reshaped to $50 \times 200$.
\item Empty inner lists are not part of constraints; still guard for $m = 0$ defensively.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting early return on infeasible reshape.
\item Using nested pops from a queue causing $O(N^2)$ behavior.
\item Miscomputing target indices with $n$ instead of $c$ or vice versa.
\item Off-by-one errors in chunk slicing.
\item Allocating ragged rows of incorrect length.
\item Assuming column-major instead of row-major order.
\item Not handling $m=0$ or $n=0$ gracefully in general-purpose code.
\end{bullets}
}
\FAILMODES{Approaches that rely on repeatedly inserting at the front or popping from the start of Python lists can degrade to quadratic time; the index-mapping method avoids that.}
\ELI{Count the boxes in the old grid. If the number of boxes does not match the new grid, keep the old grid. If it matches, copy items left-to-right, top-to-bottom into the new grid in the same order.}
\NotePages{3}

\end{document}