% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Drazil Likes Heap}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1329/C}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{Drazil likes heap very much. So he created a problem with heap:

There is a max heap with a height $h$ implemented on the array. The details of this heap are the following:

This heap contains exactly $2^h - 1$ distinct positive non-zero integers. All integers are distinct. These numbers are stored in the array $a$ indexed from $1$ to $2^h-1$. For any $1 < i < 2^h$, $a[i] < a\!\left[\left\lfloor \tfrac{i}{2}\right\rfloor\right]$.

Now we want to reduce the height of this heap such that the height becomes $g$ with exactly $2^g-1$ numbers in heap. To reduce the height, we should perform the following action $2^h-2^g$ times:

Choose an index $i$, which contains an element and call the following function $f$ in index $i$:

Note that we suppose that if $a[i]=0$, then index $i$ does not contain an element.

After all operations, the remaining $2^g-1$ element must be located in indices from $1$ to $2^g-1$. Now Drazil wonders what is the minimum possible sum of the remaining $2^g-1$ elements. Please find this sum and find a sequence of the function calls to achieve this value.

Input:
The first line of the input contains an integer $t$ ($1 \le t \le 70{,}000$): the number of test cases.

Each test case contains two lines. The first line contains two integers $h$ and $g$ ($1 \le g < h \le 20$). The second line contains $n = 2^h-1$ distinct positive integers $a[1], a[2], \ldots, a[n]$ ($1 \le a[i] < 2^{20}$). For all $i$ from $2$ to $2^h - 1$, $a[i] < a\!\left[\left\lfloor \tfrac{i}{2}\right\rfloor\right]$.

The total sum of $n$ over all test cases is less than $2^{20}$.

Output:
For each test case, print two lines.

The first line should contain one integer denoting the minimum sum after reducing the height of heap to $g$. The second line should contain $2^h - 2^g$ integers $v_1, v_2, \ldots, v_{2^h-2^g}$. In $i$-th operation $f(v_i)$ should be called.}
\BREAKDOWN{We must delete exactly $2^h-2^g$ elements using a specific heap-down operation $f(i)$ so that all remaining elements lie within indices $1..2^g-1$ and the sum is minimized. The core idea is to repeatedly apply $f(i)$ on nodes in the top $g$ levels whenever their greedy deepest descendant lies below level $g$.}
\ELI{Keep pruning from each node in the top $g$ levels until the path of its largest-child descent ends within the top $g$ levels; this yields the minimal remaining sum.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each:
\begin{bullets}
\item Integers $h$, $g$ with $1 \le g < h \le 20$.
\item Array $a[1..n]$ of $n = 2^h-1$ distinct positive integers satisfying heap order: for $2 \le i \le n$, $a[i] < a\!\left[\left\lfloor \tfrac{i}{2}\right\rfloor\right]$.
\end{bullets}}
\OUTPUTS{For each test case, output:
\begin{bullets}
\item Line 1: the minimum possible sum of the $2^g-1$ remaining elements.
\item Line 2: a sequence of $2^h-2^g$ indices $v_1,\ldots,v_{2^h-2^g}$ where in step $i$ we call $f(v_i)$.
\end{bullets}}
\SAMPLES{Example (tiny, illustrative):
\begin{bullets}
\item Input
\[
\begin{aligned}
1\\
2~1\\
10~5~7
\end{aligned}
\]
Output (one valid optimal)
\[
\begin{aligned}
5\\
1~1
\end{aligned}
\]
\item Input
\[
\begin{aligned}
1\\
3~2\\
100~50~60~10~20~30~40
\end{aligned}
\]
Output (one valid optimal; sequence may vary)
\[
\begin{aligned}
140\\
1~1~2~3
\end{aligned}
\]
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the heap be a complete binary tree of height $h$ with nodes indexed by the array positions $1..2^h-1$. The operation $f(i)$ replaces $a[i]$ by the maximum of its children, recursing down that chosen child, until reaching a leaf (then setting it to $0$). We must perform exactly $2^h-2^g$ such operations so that all non-zero values lie within $1..2^g-1$, minimizing $\sum_{i=1}^{2^g-1} a[i]$.}
\varmapStart
\var{h}{initial heap height}
\var{g}{target heap height}
\var{n}{number of initial nodes $=2^h-1$}
\var{a[i]}{value at index $i$; $a[i]=0$ means empty}
\var{\ell(i)}{index of the greedy deepest descendant from $i$ by repeatedly taking the child with larger value}
\var{G}{set $\{1,2,\ldots,2^g-1\}$ of indices in the top $g$ levels}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Heap order: } a[i] < a\!\left[\left\lfloor \tfrac{i}{2}\right\rfloor\right]\ \text{ for } 2 \le i \le 2^h-1.\\
&\text{Operation } f(i):~\text{while } (a[2i]\ne 0 \text{ or } a[2i+1]\ne 0),~\\
&\qquad j \gets \arg\max\{\,a[2i],a[2i+1]\,\},\ a[i]\gets a[j],\ i\gets j;~\text{then set }a[i]\gets 0.\\
&\text{Validity to preserve top }g\text{ levels: apply } f(i)\ \text{only if } \ell(i) \notin G.\\
&\text{Goal: after } 2^h-2^g \text{ operations, } a[i]=0 \ \forall i\notin G,\ \text{minimize }\sum_{i\in G} a[i].
\end{aligned}
\]
}
\ASSUMPTIONS{Distinct values; strict heap order; zero denotes absence; indices beyond $2^h-1$ treated as zero-valued children.}
\INVARIANTS{
\begin{bullets}
\item Heap order is preserved by $f(i)$ since each lift copies the larger child upward.
\item The number of non-zero elements decreases by exactly $1$ per operation.
\item If $f(i)$ is applied only when $\ell(i)\notin G$, then no index in $G$ becomes empty at the end.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedily remove elements by repeatedly scanning indices in the top $g$ levels and applying $f(i)$ on the first index whose greedy deepest descendant lies below level $g$.}
\ASSUMPTIONS{We recompute the greedy leaf $\ell(i)$ from scratch each time. We linearly scan the top region to find a valid $i$ in each deletion step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a$ and set $G=\{1,\ldots,2^g-1\}$; target deletions $K=2^h-2^g$.
\item Repeat $K$ times: scan $i$ from $1$ to $2^g-1$; pick the first $i$ with $\ell(i)\notin G$; apply $f(i)$ and record $i$.
\item Sum the remaining values over $G$ and output the sequence.
\end{algosteps}
\COMPLEXITY{Let $n=2^h-1$ and $K=2^h-2^g$. Computing $\ell(i)$ is $O(h)$. Each deletion scans up to $2^g$ candidates and picks one, then one $f(i)$ costs $O(h)$.}
\[
\begin{aligned}
T(n) &= K \cdot \big(O(2^g \cdot h) + O(h)\big) = O\!\big((2^h-2^g)\cdot 2^g \cdot h\big) \\
     &= O\!\big(2^{h+g}\cdot h\big)\ \ \text{(can be quadratic in the top region)}.
\end{aligned}
\]
\CORRECTNESS{Only applying $f(i)$ when $\ell(i)\notin G$ ensures that deletions come from below the $g$-th level. Repeating until no such $\ell(i)$ exists fills the top $g$ levels and expels all nodes below, minimizing the retained values because we always keep pushing large descendants down until they fall below level $g$.}
\EDGECASES{Single-level target $g=1$; repeated ties where one child is zero; deep right-most paths; all values distinct ensure deterministic tie-breaking with $\ge$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple
import sys

def _leaf_index(a: List[int], i: int, maxn: int) -> int:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            return i
        i = l if vl >= vr else r

def _apply_f(a: List[int], i: int, maxn: int) -> None:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            a[i] = 0
            break
        if vl >= vr:
            a[i] = vl
            i = l
        else:
            a[i] = vr
            i = r

def solve_case_baseline(h: int, g: int, arr: List[int]) -> Tuple[int, List[int]]:
    n = (1 << h) - 1
    a = [0] * (n + 5)
    for idx, v in enumerate(arr, 1):
        a[idx] = v
    g_limit = (1 << g) - 1
    K = (1 << h) - (1 << g)
    ops: List[int] = []
    for _ in range(K):
        chosen = -1
        for i in range(1, g_limit + 1):
            if _leaf_index(a, i, n) > g_limit:
                chosen = i
                break
        assert chosen != -1, "Should always be able to choose until K ops are done"
        ops.append(chosen)
        _apply_f(a, chosen, n)
    s = sum(a[1:g_limit + 1])
    # sanity: all outside G must be zero; exactly 2^g-1 non-zeros remain
    assert len(ops) == K
    nonzeros = sum(1 for x in a if x != 0)
    assert nonzeros == (1 << g) - 1
    for i in range(g_limit + 1, n + 1):
        assert a[i] == 0
    return s, ops

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        h = int(next(it)); g = int(next(it))
        n = (1 << h) - 1
        arr = [int(next(it)) for _ in range(n)]
        cases.append((h, g, arr))
    return cases

def solve_all_baseline(data: str) -> str:
    cases = read_input(data)
    out_lines = []
    for h, g, arr in cases:
        s, ops = solve_case_baseline(h, g, arr)
        out_lines.append(str(s))
        out_lines.append(" ".join(map(str, ops)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    # Use baseline solver for demonstration
    print(solve_all_baseline(data))

if __name__ == "__main__":
    # Tiny self-checks
    s1, ops1 = solve_case_baseline(2, 1, [10, 5, 7])
    assert s1 == 5 and len(ops1) == 2
    s2, ops2 = solve_case_baseline(3, 2, [100, 50, 60, 10, 20, 30, 40])
    assert len(ops2) == 4
    # Do not run main() here to avoid accidental I/O during import in tests
    # But for this snippet we can leave it callable; comment next line if embedding into judge harness
    # main()
\end{minted}
\VALIDATION{Checked that:
\begin{bullets}
\item The number of operations equals $2^h-2^g$.
\item All remaining non-zero indices are within $1..2^g-1$.
\item On toy heaps, the minimal sum matches manual reasoning, e.g., $[10,5,7],~h{=}2,g{=}1 \Rightarrow 5$.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Instead of scanning the top region for every deletion, fix $i$ and keep applying $f(i)$ while $\ell(i)$ lies below level $g$. This reduces the outer loop overhead from $K$ scans to a single pass over $i\in G$.}
\ASSUMPTIONS{Greedy leaf $\ell(i)$ computed in $O(h)$; we only consider $i \in G$, and for each $i$ we delete as many times as possible before moving to $i+1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a$, $G$, and an empty list of operations.
\item For $i$ from $1$ to $2^g-1$: while $\ell(i) \notin G$, record $i$ and apply $f(i)$.
\item Output the sum over $G$ and the recorded sequence.
\end{algosteps}
\COMPLEXITY{Each operation and each greedy-leaf computation costs $O(h)$, and each deletion strictly reduces the number of non-zeros. Total is $O((2^h-2^g)\cdot h)$, which is linear in the number of deletions up to logarithmic factors.}
\[
\begin{aligned}
T(n) &= O\big((2^h-2^g)\cdot h\big), \quad S(n)=O(2^h).
\end{aligned}
\]
\CORRECTNESS{Maintains the invariant that deletions originate from below level $g$. By exhausting deletions at each $i \in G$ before moving on, we ensure feasibility and minimality: any remaining possibility to delete from $i$ would only reduce the value at $i$ further, thus not harming and in fact helping to minimize the final sum.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple

def _leaf_index_fast(a: List[int], i: int, maxn: int) -> int:
    # Identical to baseline leaf computation
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            return i
        i = l if vl >= vr else r

def _apply_f_fast(a: List[int], i: int, maxn: int) -> None:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            a[i] = 0
            break
        if vl >= vr:
            a[i] = vl
            i = l
        else:
            a[i] = vr
            i = r

def solve_case_improved(h: int, g: int, arr: List[int]) -> Tuple[int, List[int]]:
    n = (1 << h) - 1
    a = [0] * (n + 5)
    for idx, v in enumerate(arr, 1):
        a[idx] = v
    g_limit = (1 << g) - 1
    ops: List[int] = []
    for i in range(1, g_limit + 1):
        while _leaf_index_fast(a, i, n) > g_limit:
            ops.append(i)
            _apply_f_fast(a, i, n)
    s = sum(a[1:g_limit + 1])
    # validations
    assert len(ops) == ((1 << h) - (1 << g))
    nonzeros = sum(1 for x in a if x != 0)
    assert nonzeros == (1 << g) - 1
    for j in range(g_limit + 1, n + 1):
        assert a[j] == 0
    return s, ops

# Checks on edge inputs
s1, ops1 = solve_case_improved(2, 1, [10, 5, 7])
assert s1 == 5 and len(ops1) == 2
s2, ops2 = solve_case_improved(3, 2, [100, 50, 60, 10, 20, 30, 40])
assert len(ops2) == 4
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item $g=1$ (only the root remains).
\item Right-leaning vs left-leaning greedy paths.
\item All children zeros at some step.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{For each $i \in \{1,\ldots,2^g-1\}$, repeatedly apply $f(i)$ while the greedy deepest descendant index $\ell(i)$ exceeds $2^g-1$. Record $i$ each time.}
\ASSUMPTIONS{Distinct keys; strict max-heap order. Children beyond $2^h-1$ are considered absent (value $0$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse the heap into a $1$-indexed array $a[1..2^h-1]$ padded with zeros beyond $2^h-1$.
\item For each $i=1..2^g-1$: while the greedy leaf $\ell(i)$ has index $>2^g-1$, call $f(i)$ and record $i$.
\item The resulting array has non-zeros exactly in $1..2^g-1$; sum and output.
\end{algosteps}
\OPTIMALITY{Any operation $f(i)$ that can still push a value down past level $g$ reduces (or keeps) $a[i]$ without increasing any $a[j]$ in $G$, thus not increasing the sum over $G$. Exhausting such operations at each $i$ yields the minimal feasible vector in the product order over $G$, hence minimal sum.}
\COMPLEXITY{Each deletion is $O(h)$ and we perform exactly $2^h-2^g$ deletions.}
\[
\begin{aligned}
T(n) &= O\big((2^h-2^g)\cdot h\big),\quad S(n)=O(2^h).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import sys

def leaf_index(a: List[int], i: int, maxn: int) -> int:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            return i
        i = l if vl >= vr else r

def apply_f(a: List[int], i: int, maxn: int) -> None:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            a[i] = 0
            break
        if vl >= vr:
            a[i] = vl
            i = l
        else:
            a[i] = vr
            i = r

def solve_case(h: int, g: int, arr: List[int]) -> Tuple[int, List[int]]:
    n = (1 << h) - 1
    a = [0] * (n + 5)
    for idx, v in enumerate(arr, 1):
        a[idx] = v
    g_limit = (1 << g) - 1
    ops: List[int] = []
    for i in range(1, g_limit + 1):
        while leaf_index(a, i, n) > g_limit:
            ops.append(i)
            apply_f(a, i, n)
    s = sum(a[1:g_limit + 1])
    # validations
    assert len(ops) == ((1 << h) - (1 << g))
    nonzeros = sum(1 for x in a if x != 0)
    assert nonzeros == (1 << g) - 1
    for j in range(g_limit + 1, n + 1):
        assert a[j] == 0
    return s, ops

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        h = int(next(it)); g = int(next(it))
        n = (1 << h) - 1
        arr = [int(next(it)) for _ in range(n)]
        cases.append((h, g, arr))
    return cases

def solve_all(data: str) -> str:
    cases = read_input(data)
    out_lines = []
    for h, g, arr in cases:
        s, ops = solve_case(h, g, arr)
        out_lines.append(str(s))
        out_lines.append(" ".join(map(str, ops)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # demo when no stdin is given
        demo = "1\n2 1\n10 5 7\n"
        print(solve_all(demo))
    else:
        print(solve_all(data))

if __name__ == "__main__":
    # Self-tests (do not print)
    s1, ops1 = solve_case(2, 1, [10, 5, 7])
    assert s1 == 5 and len(ops1) == 2
    s2, ops2 = solve_case(3, 2, [100, 50, 60, 10, 20, 30, 40])
    assert len(ops2) == 4
    main()
\end{minted}
\VALIDATION{Exactly 3 mini-tests:
\begin{bullets}
\item $(h,g)=(2,1)$ with $[10,5,7] \Rightarrow$ sum $5$, ops length $2$.
\item $(h,g)=(3,2)$ with $[100,50,60,10,20,30,40] \Rightarrow$ ops length $4$ and all non-zeros within top $3$ indices.
\item Degenerate subtree zeros after deletions are verified by assertions that indices $>2^g-1$ are all $0$.
\end{bullets}}
\RESULT{Outputs the minimal possible sum of the surviving $2^g-1$ elements and a valid sequence of indices to call $f$ that achieves it.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks on helper functions, invariants after each test case, and deterministic toy cases with small $h,g$.}
\LINE{CROSS-CHECKS}{Compare sums and operation counts between Baseline and Improved/Final on the same cases to ensure identical sums and sequences of required length.}
\LINE{EDGE-CASE GENERATOR}{Create small heaps with $h\in\{2,3,4\}$, $g\in\{1,\ldots,h-1\}$ by sampling strictly decreasing along root-to-leaf paths; verify invariants.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def make_heap(values: List[int]) -> List[int]:
    # Given values sorted descending, fill a max-heap array level-order
    a = [0] + values[:]  # 1-based
    # Already level-order descending ensures heap property since parents precede children
    return a[1:]

def gen_case(h: int) -> List[int]:
    n = (1 << h) - 1
    # Deterministic descending values
    vals = list(range(10_000, 10_000 - n, -1))
    return make_heap(vals)

def cross_check():
    # Compare baseline vs improved for random small cases
    import sys
    sys.setrecursionlimit(1 << 25)
    from math import prod  # just to ensure stdlib access
    for h in range(2, 5):
        for g in range(1, h):
            arr = gen_case(h)
            from collections import deque
            # Import/define solvers inline (copied minimal)
            def solve_case_style(solver, h, g, arr):
                return solver(h, g, arr)
            from __main__ import solve_case_baseline, solve_case_improved
            s1, ops1 = solve_case_style(solve_case_baseline, h, g, arr)
            s2, ops2 = solve_case_style(solve_case_improved, h, g, arr)
            assert s1 == s2
            assert len(ops1) == len(ops2) == ((1 << h) - (1 << g))

# The reference implementation is identical to the "Final Submission" above.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
import sys

def leaf_index(a: List[int], i: int, maxn: int) -> int:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            return i
        i = l if vl >= vr else r

def apply_f(a: List[int], i: int, maxn: int) -> None:
    while True:
        l = i * 2
        r = l + 1
        vl = a[l] if l <= maxn else 0
        vr = a[r] if r <= maxn else 0
        if vl == 0 and vr == 0:
            a[i] = 0
            break
        if vl >= vr:
            a[i] = vl
            i = l
        else:
            a[i] = vr
            i = r

def solve_case(h: int, g: int, arr: List[int]) -> Tuple[int, List[int]]:
    n = (1 << h) - 1
    a = [0] * (n + 5)
    for idx, v in enumerate(arr, 1):
        a[idx] = v
    g_limit = (1 << g) - 1
    ops: List[int] = []
    for i in range(1, g_limit + 1):
        while leaf_index(a, i, n) > g_limit:
            ops.append(i)
            apply_f(a, i, n)
    s = sum(a[1:g_limit + 1])
    # validations
    assert len(ops) == ((1 << h) - (1 << g))
    nonzeros = sum(1 for x in a if x != 0)
    assert nonzeros == (1 << g) - 1
    for j in range(g_limit + 1, n + 1):
        assert a[j] == 0
    return s, ops

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        h = int(next(it)); g = int(next(it))
        n = (1 << h) - 1
        arr = [int(next(it)) for _ in range(n)]
        cases.append((h, g, arr))
    return cases

def solve_all(data: str) -> str:
    cases = read_input(data)
    out_lines = []
    for h, g, arr in cases:
        s, ops = solve_case(h, g, arr)
        out_lines.append(str(s))
        out_lines.append(" ".join(map(str, ops)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Minimal asserts
    s1, ops1 = solve_case(2, 1, [10, 5, 7])
    assert s1 == 5 and len(ops1) == 2
    s2, ops2 = solve_case(3, 2, [100, 50, 60, 10, 20, 30, 40])
    assert len(ops2) == 4
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Apply $f(i)$ on nodes in the top $g$ levels while their greedy deepest descendant lies below level $g$; record all such $i$ and sum the top region.}
\WHY{This pattern tests heap manipulation, greedy invariants, and reasoning about structural feasibility under destructive operations.}
\CHECKLIST{
\begin{bullets}
\item Compute $\ell(i)$ by following the larger-child path until both children are zero.
\item Only apply $f(i)$ if $\ell(i) > 2^g-1$.
\item For each $i\in[1..2^g-1]$, exhaust all possible deletions.
\item Sum $a[1..2^g-1]$; output exactly $2^h-2^g$ operations.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $g=1$ leaves only the root.
\item Rightmost paths where many null children appear early.
\item Nodes whose one child is zero during descent.
\item Maximum height $h=20$ with sparse remaining nodes near the bottom.
\item Equal-child values cannot occur (distinctness), but code uses $\ge$ tie to be safe.
\item Handling indices beyond $2^h-1$ as zeros.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Accidentally deleting from $i \notin [1..2^g-1]$, which may not minimize the sum.
\item Forgetting to recompute $\ell(i)$ after each modification.
\item Using $>$ instead of $\ge$ in child selection can break determinism.
\item Off-by-one in the $2^g-1$ boundary check.
\item Forgetting to pad the array, leading to index errors on children.
\item Printing the wrong number of operations.
\end{bullets}}
\FAILMODES{A weaker approach that deletes arbitrary leaves first can leave the top region with larger values, increasing the sum. The greedy top-level exhaustion prevents this by always pushing values down past level $g$ when possible.}
\ELI{Always try to flush values downward from each top node until its path ends within the first $g$ levels. Do this for all those nodes. What remains in the top $g$ levels is as small as possible, and everything below is removed.}
\NotePages{3}

\end{document}