% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Infinite Card Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1895/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Monocarp and Bicarp are playing a card game. Each card has two parameters: an attack value and a defence value. A card $s$ beats another card $t$ if the attack of $s$ is strictly greater than the defence of $t$.

Monocarp has $n$ cards, the $i$-th of them has an attack value of $\mathit{ax}_i$ and a defence value of $\mathit{ay}_i$. Bicarp has $m$ cards, the $j$-th of them has an attack value of $\mathit{bx}_j$ and a defence value of $\mathit{by}_j$.

On the first move, Monocarp chooses one of his cards and plays it. Bicarp has to respond with his own card that beats that card. After that, Monocarp has to respond with a card that beats Bicarp's card. After that, it's Bicarp's turn, and so forth.

After a card is beaten, it returns to the hand of the player who played it. It implies that each player always has the same set of cards to play as at the start of the game. The game ends when the current player has no cards that beat the card which their opponent just played, and the current player loses.

If the game lasts for $100^{500}$ moves, it's declared a draw.

Both Monocarp and Bicarp play optimally. That is, if a player has a winning strategy regardless of his opponent's moves, he plays for a win. Otherwise, if he has a drawing strategy, he plays for a draw.

You are asked to calculate three values:
\begin{bullets}
\item the number of Monocarp's starting moves that result in a win for Monocarp;
\item the number of Monocarp's starting moves that result in a draw;
\item the number of Monocarp's starting moves that result in a win for Bicarp.
\end{bullets}

Input:

The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains an integer $n$ ($1 \le n \le 3 \cdot 10^5$) — the number of cards Monocarp has.

The second line contains $n$ integers $\mathit{ax}_1, \mathit{ax}_2, \dots, \mathit{ax}_n$ ($1 \le \mathit{ax}_i \le 10^6$) — the attack values of Monocarp's cards.

The third line contains $n$ integers $\mathit{ay}_1, \mathit{ay}_2, \dots, \mathit{ay}_n$ ($1 \le \mathit{ay}_i \le 10^6$) — the defence values of Monocarp's cards.

The fourth line contains a single integer $m$ ($1 \le m \le 3 \cdot 10^5$) — the number of cards Bicarp has.

The fifth line contains $m$ integers $\mathit{bx}_1, \mathit{bx}_2, \dots, \mathit{bx}_m$ ($1 \le \mathit{bx}_j \le 10^6$) — the attack values of Bicarp's cards.

The sixth line contains $m$ integers $\mathit{by}_1, \mathit{by}_2, \dots, \mathit{by}_m$ ($1 \le \mathit{by}_j \le 10^6$) — the defence values of Bicarp's cards.

Additional constraints on the input: the sum of $n$ over all test cases doesn't exceed $3 \cdot 10^5$, the sum of $m$ over all test cases doesn't exceed $3 \cdot 10^5$.

Output: For each test case, print three integers:
\begin{bullets}
\item the number of Monocarp's starting moves that result in a win for Monocarp;
\item the number of Monocarp's starting moves that result in a draw;
\item the number of Monocarp's starting moves that result in a win for Bicarp.
\end{bullets}}
\BREAKDOWN{Model as an alternating move game on a bipartite directed graph: from a Monocarp card $i$ to all Bicarp cards $j$ with $\mathit{bx}_j > \mathit{ay}_i$, and from a Bicarp card $j$ to all Monocarp cards $i$ with $\mathit{ax}_i > \mathit{by}_j$. Evaluate each Monocarp starting node (Bicarp to move) as win/lose/draw via retrograde analysis without materializing $\mathcal{O}(nm)$ edges by exploiting threshold structure and union-find over sorted orders.}
\ELI{Think of two sorted shelves of cards; each response must come from a suffix past a threshold. We peel off forced wins layer by layer using disjoint-set jumps, and whatever remains is a draw.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n$, arrays $(\mathit{ax}_i)_{i=1}^n$, $(\mathit{ay}_i)_{i=1}^n$; integer $m$, arrays $(\mathit{bx}_j)_{j=1}^m$, $(\mathit{by}_j)_{j=1}^m$. Ranges: $1 \le n,m \le 3\cdot 10^5$, values in $[1,10^6]$, sums $\sum n,\sum m \le 3\cdot 10^5$.}
\OUTPUTS{For each test case, three integers separated by spaces: count of starting Monocarp cards that (1) are wins for Monocarp, (2) draws, (3) wins for Bicarp (i.e., losses for Monocarp).}
\SAMPLES{
Example 1:
Input
1
1
10
10
1
5
5
Output
1 0 0

Example 2:
Input
1
1
5
1
1
5
1
Output
0 1 0
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M=\{1,\ldots,n\}$ be Monocarp's cards, $B=\{1,\ldots,m\}$ be Bicarp's cards. Directed bipartite graph $G=(V,E)$ with $V=M\cup B$, and edges:
\[
i\in M \to j\in B \iff \mathit{bx}_j > \mathit{ay}_i,\quad
j\in B \to i\in M \iff \mathit{ax}_i > \mathit{by}_j.
\]
The initial position for starting card $i\in M$ is node $i$ with Bicarp to move. The result is the standard impartial game outcome on $G$: Win (current player has a winning strategy), Lose (current player loses), or Draw (infinite play under optimal play).}
\varmapStart
\var{ax_i}{attack of Monocarp's $i$-th card}
\var{ay_i}{defence of Monocarp's $i$-th card}
\var{bx_j}{attack of Bicarp's $j$-th card}
\var{by_j}{defence of Bicarp's $j$-th card}
\var{W(v)}{boolean: node $v$ winning for the player to move}
\var{L(v)}{boolean: node $v$ losing for the player to move}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
L(v) &\iff \text{outdeg}(v)=0 \ \lor\ \big(\forall u\in N^+(v): W(u)\big),\\
W(v) &\iff \exists u\in N^+(v): L(u),\\
\text{Draw}(v) &\iff \neg W(v)\land \neg L(v).
\end{aligned}
\]
}
\ASSUMPTIONS{Cards are independent and reusable; graph is bipartite; edges are threshold-based suffixes when nodes are sorted by attack.}
\INVARIANTS{Unknown nodes that never get forced into $W$/$L$ form at least one directed cycle (hence draw). Outdegree-0 nodes are immediately losing. Winning nodes come only as predecessors of losing nodes.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Retrograde analysis on the full bipartite graph using BFS/queue over $W/L$ with explicit adjacency and predecessor lists.}
\ASSUMPTIONS{Build all $\mathcal{O}(nm)$ edges explicitly; fine for sanity and tiny tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacencies $M\to B$ and $B\to M$ and predecessor lists.
\item Initialize queue with outdegree-0 nodes as losing.
\item While queue nonempty, pop $v$:
  if $v$ is losing, mark all predecessors winning; else decrement predecessors' remaining outdegree and mark those reaching $0$ as losing.
\item Classify each $i\in M$: Lose $\Rightarrow$ Monocarp wins; Win $\Rightarrow$ Bicarp wins; else Draw.
\end{algosteps}
\COMPLEXITY{Worst case $\Theta(nm)$ memory/time.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm) \\
S(n,m) &= \Theta(nm)
\end{aligned}
\]
\CORRECTNESS{Standard game-graph retrograde: losing propagates to predecessors as winning; winning exhausts options of predecessors to force losing; remaining nodes lie in cycles and are draws.}
\EDGECASES{No response from Bicarp (immediate Monocarp win); no response from Monocarp after any Bicarp move (immediate Bicarp win for all starts); mutual infinite responses (draw).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    tests = []
    for _ in range(t):
        n = int(next(it))
        ax = [int(next(it)) for _ in range(n)]
        ay = [int(next(it)) for _ in range(n)]
        m = int(next(it))
        bx = [int(next(it)) for _ in range(m)]
        by = [int(next(it)) for _ in range(m)]
        tests.append((ax, ay, bx, by))
    return tests

def solve_case_baseline(ax, ay, bx, by):
    n, m = len(ax), len(bx)
    M_to_B = [[] for _ in range(n)]
    B_to_M = [[] for _ in range(m)]
    # Build edges (naive)
    for i in range(n):
        for j in range(m):
            if bx[j] > ay[i]:
                M_to_B[i].append(j)
            if ax[i] > by[j]:
                B_to_M[j].append(i)
    outM = [len(M_to_B[i]) for i in range(n)]
    outB = [len(B_to_M[j]) for j in range(m)]
    # Predecessors
    predM = [[] for _ in range(n)]
    predB = [[] for _ in range(m)]
    for i in range(n):
        for j in M_to_B[i]:
            predB[j].append(i)
    for j in range(m):
        for i in B_to_M[j]:
            predM[i].append(j)
    # Labels: 0 unknown, 1 win, 2 lose
    labM = [0]*n
    labB = [0]*m
    dq = deque()
    for i in range(n):
        if outM[i] == 0:
            labM[i] = 2
            dq.append(('M', i))
    for j in range(m):
        if outB[j] == 0:
            labB[j] = 2
            dq.append(('B', j))
    while dq:
        typ, idx = dq.popleft()
        if typ == 'M':
            if labM[idx] == 2:
                # predecessors on B become winning
                for j in predM[idx]:
                    if labB[j] == 0:
                        labB[j] = 1
                        dq.append(('B', j))
            else:
                # winning node: reduce predecessors' outdegree
                for j in predM[idx]:
                    if labB[j] == 0:
                        outB[j] -= 1
                        if outB[j] == 0:
                            labB[j] = 2
                            dq.append(('B', j))
        else:
            if labB[idx] == 2:
                for i in predB[idx]:
                    if labM[i] == 0:
                        labM[i] = 1
                        dq.append(('M', i))
            else:
                for i in predB[idx]:
                    if labM[i] == 0:
                        outM[i] -= 1
                        if outM[i] == 0:
                            labM[i] = 2
                            dq.append(('M', i))
    # Count results for Monocarp starts (nodes in M with Bicarp to move)
    win_m = sum(1 for i in range(n) if labM[i] == 2)   # Bicarp loses
    draw_m = sum(1 for i in range(n) if labM[i] == 0)
    lose_m = sum(1 for i in range(n) if labM[i] == 1)  # Bicarp wins
    return win_m, draw_m, lose_m

def solve_all_baseline():
    out_lines = []
    for ax, ay, bx, by in read_input():
        w, d, l = solve_case_baseline(ax, ay, bx, by)
        out_lines.append(f"{w} {d} {l}")
    sys.stdout.write("\n".join(out_lines))

def _self_test_baseline():
    # Test 1: immediate Monocarp win
    assert solve_case_baseline([10], [10], [5], [5]) == (1, 0, 0)
    # Test 2: draw loop
    assert solve_case_baseline([5], [1], [5], [1]) == (0, 1, 0)
    # Test 3: Bicarp always wins
    assert solve_case_baseline([10, 20], [10, 20], [100], [100]) == (0, 0, 2)

if __name__ == "__main__":
    _self_test_baseline()
    if not sys.stdin.isatty():
        try:
            solve_all_baseline()
        except Exception:
            pass
\end{minted}
\VALIDATION{Small custom asserts embedded cover immediate win, draw, and Bicarp-forced win cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Threshold Bucketing with Union-Find Skips}
\WHICHFORMULA{Exploit that edges are suffixes in attack-sorted orders. Use two union-find structures per side: one to paint winners by defence-threshold prefixes, another to maintain the rightmost non-winning index in attack order. Losing nodes appear when the successor suffix becomes entirely winning.}
\ASSUMPTIONS{Maintain buckets of potential losers keyed by successor-start indices $s_j=1+\#\{i:\mathit{ax}_i\le \mathit{by}_j\}$ and $t_i=1+\#\{j:\mathit{bx}_j\le \mathit{ay}_i\}$. Process as $R_M$/$R_B$ (max non-winning positions) decrease.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $M$ by $\mathit{ax}$ and $\mathit{ay}$; sort $B$ by $\mathit{bx}$ and $\mathit{by}$; precompute $s_j$ and $t_i$ and bucket nodes by these indices.
\item Initialize $R_M=n$, $R_B=m$; enqueue outdegree-0 nodes ($s_j=n+1$, $t_i=m+1$) as losing.
\item When a $B$-node loses, mark all $M$ with $\mathit{ay}<\mathit{bx}_j$ as winning using DSU-skips over $\mathit{ay}$-order; update $R_M$ by removing corresponding $\mathit{ax}$-positions with DSU.
\item Each time $R_M$ decreases from $r_{\text{old}}$ to $r_{\text{new}}$, all $B$ with $s_j\in(r_{\text{new}},r_{\text{old}}]$ become losing; enqueue them. Symmetrically for $M$ when $R_B$ decreases.
\item Remaining unknown nodes are draws. Count outcomes for $M$-nodes.
\end{algosteps}
\COMPLEXITY{Each node is painted/removed at most once and each bucket processed once. Sorting dominates.}
\[
\begin{aligned}
T(n,m) &= \mathcal{O}\big((n+m)\log(n+m)\big) \\
S(n,m) &= \mathcal{O}(n+m)
\end{aligned}
\]
\CORRECTNESS{Union-find ensures we only touch freshly promoted winners. Losing thresholds depend solely on whether successor suffix contains any non-winning node; tracking the rightmost non-winning index suffices to detect when an entire suffix becomes winning.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right
from collections import deque

class DSUPrev:
    def __init__(self, n):
        self.p = list(range(n+1))
    def find(self, x):
        p = self.p
        while p[x] != x:
            p[x] = p[p[x]]
            x = p[x]
        return x
    def remove(self, x):
        self.p[x] = self.find(x-1)

def solve_case_improved(ax, ay, bx, by):
    n, m = len(ax), len(bx)
    # Orders and positions
    ord_ax = sorted(range(n), key=lambda i: ax[i])
    ord_ay = sorted(range(n), key=lambda i: ay[i])
    ord_bx = sorted(range(m), key=lambda j: bx[j])
    ord_by = sorted(range(m), key=lambda j: by[j])
    ax_vals = [ax[i] for i in ord_ax]
    ay_vals = [ay[i] for i in ord_ay]
    bx_vals = [bx[j] for j in ord_bx]
    by_vals = [by[j] for j in ord_by]
    pos_ax = [0]*n
    for idx, i in enumerate(ord_ax, start=1):
        pos_ax[i] = idx
    pos_bx = [0]*m
    for idx, j in enumerate(ord_bx, start=1):
        pos_bx[j] = idx
    id_by_ay_idx = [None]*(n+1)
    for idx, i in enumerate(ord_ay, start=1):
        id_by_ay_idx[idx] = i
    id_by_by_idx = [None]*(m+1)
    for idx, j in enumerate(ord_by, start=1):
        id_by_by_idx[idx] = j
    # Buckets for losing detection
    bucket_B_by_s = [[] for _ in range(n+2)]  # s in [1..n+1]
    for j in range(m):
        s = bisect_right(ax_vals, by[j]) + 1
        bucket_B_by_s[s].append(j)
    bucket_M_by_t = [[] for _ in range(m+2)]  # t in [1..m+1]
    for i in range(n):
        t = bisect_right(bx_vals, ay[i]) + 1
        bucket_M_by_t[t].append(i)
    # DSUs
    dsu_M_ay = DSUPrev(n)
    dsu_B_by = DSUPrev(m)
    dsu_M_ax = DSUPrev(n)
    dsu_B_bx = DSUPrev(m)
    # Labels
    labM = [0]*n  # 0 unk, 1 win (current player), 2 lose
    labB = [0]*m
    # R trackers and range heads
    R_M = dsu_M_ax.find(n)  # max ax-index not yet winning
    R_B = dsu_B_bx.find(m)
    rprev_B = R_M
    rprev_M = R_B
    # Queues for losing nodes to process
    qB = deque()
    qM = deque()
    # Seed outdegree-0 nodes
    for j in bucket_B_by_s[n+1]:
        qB.append(j)
    for i in bucket_M_by_t[m+1]:
        qM.append(i)
    def process_new_B_losers():
        nonlocal rprev_B, R_M
        while rprev_B > R_M:
            s = rprev_B
            for j in bucket_B_by_s[s]:
                qB.append(j)
            rprev_B -= 1
    def process_new_M_losers():
        nonlocal rprev_M, R_B
        while rprev_M > R_B:
            t = rprev_M
            for i in bucket_M_by_t[t]:
                qM.append(i)
            rprev_M -= 1
    def mark_M_winners_upto_k(k):
        nonlocal R_M
        while True:
            idx = dsu_M_ay.find(k)
            if idx == 0:
                break
            i = id_by_ay_idx[idx]
            dsu_M_ay.remove(idx)
            if labM[i] == 0:
                labM[i] = 1
                # remove from ax DSU if not already removed
                pos = pos_ax[i]
                if dsu_M_ax.find(pos) == pos:
                    dsu_M_ax.remove(pos)
        R_M = dsu_M_ax.find(n)
        process_new_B_losers()
    def mark_B_winners_upto_k(k):
        nonlocal R_B
        while True:
            idx = dsu_B_by.find(k)
            if idx == 0:
                break
            j = id_by_by_idx[idx]
            dsu_B_by.remove(idx)
            if labB[j] == 0:
                labB[j] = 1
                pos = pos_bx[j]
                if dsu_B_bx.find(pos) == pos:
                    dsu_B_bx.remove(pos)
        R_B = dsu_B_bx.find(m)
        process_new_M_losers()
    # Main propagation
    while qB or qM:
        while qB:
            j = qB.popleft()
            if labB[j] != 0:
                continue
            # this B node is losing now
            labB[j] = 2
            # mark M winners with ay < bx[j]
            k = bisect_left(ay_vals, bx[j])
            mark_M_winners_upto_k(k)
        while qM:
            i = qM.popleft()
            if labM[i] != 0:
                continue
            labM[i] = 2
            # mark B winners with by < ax[i]
            k = bisect_left(by_vals, ax[i])
            mark_B_winners_upto_k(k)
    win_m = sum(1 for i in range(n) if labM[i] == 2)
    draw_m = sum(1 for i in range(n) if labM[i] == 0)
    lose_m = sum(1 for i in range(n) if labM[i] == 1)
    return win_m, draw_m, lose_m

def solve_all_improved():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    out = []
    for _ in range(t):
        n = int(next(it)); ax = [int(next(it)) for _ in range(n)]
        ay = [int(next(it)) for _ in range(n)]
        m = int(next(it)); bx = [int(next(it)) for _ in range(m)]
        by = [int(next(it)) for _ in range(m)]
        w, d, l = solve_case_improved(ax, ay, bx, by)
        out.append(f"{w} {d} {l}")
    sys.stdout.write("\n".join(out))

def _self_test_improved():
    assert solve_case_improved([10], [10], [5], [5]) == (1, 0, 0)
    assert solve_case_improved([5], [1], [5], [1]) == (0, 1, 0)
    assert solve_case_improved([10, 20], [10, 20], [100], [100]) == (0, 0, 2)

if __name__ == "__main__":
    _self_test_improved()
    # For interactive judge, uncomment the next line:
    # solve_all_improved()
\end{minted}
\VALIDATION{Same asserts as baseline; DSU-based solution matches expected outputs on edge cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Union-Find Attractor on Threshold Graph}
\WHICHFORMULA{Maintain two monotone ``frontiers'' $R_M$ and $R_B$ (rightmost non-winning indices in attack order). Losing nodes appear when successor suffix is all-winning. Winners are entire prefixes in defence order induced by a losing node on the opposite side. Use DSU with path-compression to process each node once.}
\ASSUMPTIONS{Sort by attacks/defences; all thresholds are static; union-find amortized near-constant.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute attack-order indices and defence-order indices; bucket $B$ by $s_j=1+\#\{\mathit{ax}\le \mathit{by}_j\}$ and $M$ by $t_i=1+\#\{\mathit{bx}\le \mathit{ay}_i\}$.
\item Seed queues with outdegree-0 nodes ($s_j=n+1$, $t_i=m+1$).
\item Pop a losing $B_j$: mark all $M$ with $\mathit{ay}<\mathit{bx}_j$ as winning via DSU over $\mathit{ay}$; remove them from $R_M$ via DSU over $\mathit{ax}$; for each $s$ crossed by $R_M$ decrease, enqueue bucket $B[s]$ as losing.
\item Symmetrically for losing $M_i$.
\item Remaining unknown nodes are draws; tally outcomes for starts at $M$ nodes.
\end{algosteps}
\OPTIMALITY{Each card is labeled exactly once; each bucket is processed exactly once; DSU operations are inverse-Ackermann. Sorting is optimal under comparison model.}
\COMPLEXITY{
\[
\begin{aligned}
T(n,m) &= \mathcal{O}((n+m)\log(n+m) + (n+m)\,\alpha(n+m)),\\
S(n,m) &= \mathcal{O}(n+m).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right
from collections import deque

class DSUPrev:
    def __init__(self, n):
        self.p = list(range(n+1))
    def find(self, x):
        p = self.p
        while p[x] != x:
            p[x] = p[p[x]]
            x = p[x]
        return x
    def remove(self, x):
        self.p[x] = self.find(x-1)

def solve_case(ax, ay, bx, by):
    n, m = len(ax), len(bx)
    # Sort orders and helpers
    ord_ax = sorted(range(n), key=lambda i: ax[i])
    ord_ay = sorted(range(n), key=lambda i: ay[i])
    ord_bx = sorted(range(m), key=lambda j: bx[j])
    ord_by = sorted(range(m), key=lambda j: by[j])
    ax_vals = [ax[i] for i in ord_ax]
    ay_vals = [ay[i] for i in ord_ay]
    bx_vals = [bx[j] for j in ord_bx]
    by_vals = [by[j] for j in ord_by]
    pos_ax = [0]*n
    for idx, i in enumerate(ord_ax, start=1):
        pos_ax[i] = idx
    pos_bx = [0]*m
    for idx, j in enumerate(ord_bx, start=1):
        pos_bx[j] = idx
    id_by_ay_idx = [None]*(n+1)
    for idx, i in enumerate(ord_ay, start=1):
        id_by_ay_idx[idx] = i
    id_by_by_idx = [None]*(m+1)
    for idx, j in enumerate(ord_by, start=1):
        id_by_by_idx[idx] = j
    # Buckets by successor-start indices
    bucket_B_by_s = [[] for _ in range(n+2)]
    for j in range(m):
        s = bisect_right(ax_vals, by[j]) + 1
        bucket_B_by_s[s].append(j)
    bucket_M_by_t = [[] for _ in range(m+2)]
    for i in range(n):
        t = bisect_right(bx_vals, ay[i]) + 1
        bucket_M_by_t[t].append(i)
    # DSUs
    dsu_M_ay = DSUPrev(n)
    dsu_B_by = DSUPrev(m)
    dsu_M_ax = DSUPrev(n)
    dsu_B_bx = DSUPrev(m)
    # Labels
    labM = [0]*n  # 0 unk, 1 win, 2 lose
    labB = [0]*m
    # Track rightmost non-winning indices in attack orders
    R_M = dsu_M_ax.find(n)
    R_B = dsu_B_bx.find(m)
    rprev_B = R_M
    rprev_M = R_B
    qB = deque()
    qM = deque()
    # Seed: outdegree-0 losing nodes
    for j in bucket_B_by_s[n+1]:
        qB.append(j)
    for i in bucket_M_by_t[m+1]:
        qM.append(i)
    def process_new_B_losers():
        nonlocal rprev_B, R_M
        while rprev_B > R_M:
            s = rprev_B
            for j in bucket_B_by_s[s]:
                qB.append(j)
            rprev_B -= 1
    def process_new_M_losers():
        nonlocal rprev_M, R_B
        while rprev_M > R_B:
            t = rprev_M
            for i in bucket_M_by_t[t]:
                qM.append(i)
            rprev_M -= 1
    def mark_M_winners_upto_k(k):
        nonlocal R_M
        while True:
            idx = dsu_M_ay.find(k)
            if idx == 0:
                break
            i = id_by_ay_idx[idx]
            dsu_M_ay.remove(idx)
            if labM[i] == 0:
                labM[i] = 1
                pos = pos_ax[i]
                if dsu_M_ax.find(pos) == pos:
                    dsu_M_ax.remove(pos)
        R_M = dsu_M_ax.find(n)
        process_new_B_losers()
    def mark_B_winners_upto_k(k):
        nonlocal R_B
        while True:
            idx = dsu_B_by.find(k)
            if idx == 0:
                break
            j = id_by_by_idx[idx]
            dsu_B_by.remove(idx)
            if labB[j] == 0:
                labB[j] = 1
                pos = pos_bx[j]
                if dsu_B_bx.find(pos) == pos:
                    dsu_B_bx.remove(pos)
        R_B = dsu_B_bx.find(m)
        process_new_M_losers()
    # Propagation
    while qB or qM:
        while qB:
            j = qB.popleft()
            if labB[j] != 0:
                continue
            labB[j] = 2
            k = bisect_left(ay_vals, bx[j])  # ay < bx[j]
            mark_M_winners_upto_k(k)
        while qM:
            i = qM.popleft()
            if labM[i] != 0:
                continue
            labM[i] = 2
            k = bisect_left(by_vals, ax[i])  # by < ax[i]
            mark_B_winners_upto_k(k)
    win_m = sum(1 for i in range(n) if labM[i] == 2)
    draw_m = sum(1 for i in range(n) if labM[i] == 0)
    lose_m = sum(1 for i in range(n) if labM[i] == 1)
    return win_m, draw_m, lose_m

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    tests = []
    for _ in range(t):
        n = int(next(it)); ax = [int(next(it)) for _ in range(n)]
        ay = [int(next(it)) for _ in range(n)]
        m = int(next(it)); bx = [int(next(it)) for _ in range(m)]
        by = [int(next(it)) for _ in range(m)]
        tests.append((ax, ay, bx, by))
    return tests

def solve_all():
    out_lines = []
    for ax, ay, bx, by in read_input():
        w, d, l = solve_case(ax, ay, bx, by)
        out_lines.append(f"{w} {d} {l}")
    sys.stdout.write("\n".join(out_lines))

def _self_test_final():
    # Immediate Monocarp win
    assert solve_case([10], [10], [5], [5]) == (1, 0, 0)
    # Draw
    assert solve_case([5], [1], [5], [1]) == (0, 1, 0)
    # Bicarp always wins
    assert solve_case([10, 20], [10, 20], [100], [100]) == (0, 0, 2)

if __name__ == "__main__":
    _self_test_final()
    # Uncomment for judge:
    # solve_all()
\end{minted}
\VALIDATION{Exactly three asserts cover immediate win, perpetual draw, and opponent-forced win.}
\RESULT{For each Monocarp card $i$, output is: Lose-label at $i$ (Bicarp to move) counts towards Monocarp wins; Win-label counts towards Bicarp wins; Unknown counts towards draws.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test on micro-cases: single-card immediate win/loss; symmetric always-beatable sets; random small instances cross-checked against baseline.}
\LINE{CROSS-CHECKS}{Compare baseline $\Theta(nm)$ retrograde and optimal DSU-based solution on random $n,m\le 40$ with random stats; ensure identical counts.}
\LINE{EDGE-CASE GENERATOR}{Generate extremes: all defences huge (no responses); all attacks huge (always responses); mixed thresholds.}
\begin{minted}{python}
import random

def generate_case(n, m, vmax=20, seed=0):
    rng = random.Random(seed)
    ax = [rng.randint(1, vmax) for _ in range(n)]
    ay = [rng.randint(1, vmax) for _ in range(n)]
    bx = [rng.randint(1, vmax) for _ in range(m)]
    by = [rng.randint(1, vmax) for _ in range(m)]
    return ax, ay, bx, by

def reference_solve(ax, ay, bx, by):
    # Use optimal solve_case from Approach C
    return solve_case(ax, ay, bx, by)

def brute_solve(ax, ay, bx, by):
    return solve_case_baseline(ax, ay, bx, by)

def self_check():
    for seed in range(50):
        n = random.randint(1, 8)
        m = random.randint(1, 8)
        ax, ay, bx, by = generate_case(n, m, vmax=15, seed=seed)
        ref = reference_solve(ax, ay, bx, by)
        brute = brute_solve(ax, ay, bx, by)
        assert ref == brute, (seed, ax, ay, bx, by, ref, brute)

if __name__ == "__main__":
    # Cross-check on randoms
    self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right
from collections import deque

class DSUPrev:
    def __init__(self, n):
        self.p = list(range(n+1))
    def find(self, x):
        p = self.p
        while p[x] != x:
            p[x] = p[p[x]]
            x = p[x]
        return x
    def remove(self, x):
        self.p[x] = self.find(x-1)

def solve_case(ax, ay, bx, by):
    n, m = len(ax), len(bx)
    ord_ax = sorted(range(n), key=lambda i: ax[i])
    ord_ay = sorted(range(n), key=lambda i: ay[i])
    ord_bx = sorted(range(m), key=lambda j: bx[j])
    ord_by = sorted(range(m), key=lambda j: by[j])
    ax_vals = [ax[i] for i in ord_ax]
    ay_vals = [ay[i] for i in ord_ay]
    bx_vals = [bx[j] for j in ord_bx]
    by_vals = [by[j] for j in ord_by]
    pos_ax = [0]*n
    for idx, i in enumerate(ord_ax, start=1):
        pos_ax[i] = idx
    pos_bx = [0]*m
    for idx, j in enumerate(ord_bx, start=1):
        pos_bx[j] = idx
    id_by_ay_idx = [None]*(n+1)
    for idx, i in enumerate(ord_ay, start=1):
        id_by_ay_idx[idx] = i
    id_by_by_idx = [None]*(m+1)
    for idx, j in enumerate(ord_by, start=1):
        id_by_by_idx[idx] = j
    bucket_B_by_s = [[] for _ in range(n+2)]
    for j in range(m):
        s = bisect_right(ax_vals, by[j]) + 1
        bucket_B_by_s[s].append(j)
    bucket_M_by_t = [[] for _ in range(m+2)]
    for i in range(n):
        t = bisect_right(bx_vals, ay[i]) + 1
        bucket_M_by_t[t].append(i)
    dsu_M_ay = DSUPrev(n)
    dsu_B_by = DSUPrev(m)
    dsu_M_ax = DSUPrev(n)
    dsu_B_bx = DSUPrev(m)
    labM = [0]*n
    labB = [0]*m
    R_M = dsu_M_ax.find(n)
    R_B = dsu_B_bx.find(m)
    rprev_B = R_M
    rprev_M = R_B
    qB = deque()
    qM = deque()
    for j in bucket_B_by_s[n+1]:
        qB.append(j)
    for i in bucket_M_by_t[m+1]:
        qM.append(i)
    def process_new_B_losers():
        nonlocal rprev_B, R_M
        while rprev_B > R_M:
            s = rprev_B
            for j in bucket_B_by_s[s]:
                qB.append(j)
            rprev_B -= 1
    def process_new_M_losers():
        nonlocal rprev_M, R_B
        while rprev_M > R_B:
            t = rprev_M
            for i in bucket_M_by_t[t]:
                qM.append(i)
            rprev_M -= 1
    def mark_M_winners_upto_k(k):
        nonlocal R_M
        while True:
            idx = dsu_M_ay.find(k)
            if idx == 0:
                break
            i = id_by_ay_idx[idx]
            dsu_M_ay.remove(idx)
            if labM[i] == 0:
                labM[i] = 1
                pos = pos_ax[i]
                if dsu_M_ax.find(pos) == pos:
                    dsu_M_ax.remove(pos)
        R_M = dsu_M_ax.find(n)
        process_new_B_losers()
    def mark_B_winners_upto_k(k):
        nonlocal R_B
        while True:
            idx = dsu_B_by.find(k)
            if idx == 0:
                break
            j = id_by_by_idx[idx]
            dsu_B_by.remove(idx)
            if labB[j] == 0:
                labB[j] = 1
                pos = pos_bx[j]
                if dsu_B_bx.find(pos) == pos:
                    dsu_B_bx.remove(pos)
        R_B = dsu_B_bx.find(m)
        process_new_M_losers()
    while qB or qM:
        while qB:
            j = qB.popleft()
            if labB[j] != 0:
                continue
            labB[j] = 2
            k = bisect_left(ay_vals, bx[j])
            mark_M_winners_upto_k(k)
        while qM:
            i = qM.popleft()
            if labM[i] != 0:
                continue
            labM[i] = 2
            k = bisect_left(by_vals, ax[i])
            mark_B_winners_upto_k(k)
    win_m = sum(1 for i in range(n) if labM[i] == 2)
    draw_m = sum(1 for i in range(n) if labM[i] == 0)
    lose_m = sum(1 for i in range(n) if labM[i] == 1)
    return win_m, draw_m, lose_m

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    tests = []
    for _ in range(t):
        n = int(next(it)); ax = [int(next(it)) for _ in range(n)]
        ay = [int(next(it)) for _ in range(n)]
        m = int(next(it)); bx = [int(next(it)) for _ in range(m)]
        by = [int(next(it)) for _ in range(m)]
        tests.append((ax, ay, bx, by))
    return tests

def solve_all():
    out_lines = []
    for ax, ay, bx, by in read_input():
        w, d, l = solve_case(ax, ay, bx, by)
        out_lines.append(f"{w} {d} {l}")
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    assert solve_case([10], [10], [5], [5]) == (1, 0, 0)
    assert solve_case([5], [1], [5], [1]) == (0, 1, 0)
    assert solve_case([10, 20], [10, 20], [100], [100]) == (0, 0, 2)

if __name__ == "__main__":
    _self_test()
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Evaluate an alternating-response game on a bipartite threshold graph via retrograde analysis without enumerating all edges.}
\WHY{Appears in graph game theory and adversarial DP; tests ability to exploit monotonicity and use DSU to avoid $\mathcal{O}(nm)$.}
\CHECKLIST{
\begin{bullets}
\item Sort by attacks and defences; precompute $s_j$ and $t_i$.
\item Initialize losing nodes with zero outdegree.
\item Use DSU over defence-order to paint winners; DSU over attack-order to shrink $R_M$, $R_B$.
\item On $R$ decrease, release new losing buckets.
\item Count $M$-node labels into (win, draw, lose) for output.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Some $i$ with $\mathit{ay}_i \ge \max_j \mathit{bx}_j$ (immediate Monocarp win).
\item Some $j$ with $\mathit{by}_j \ge \max_i \mathit{ax}_i$ (Bicarp move traps Monocarp).
\item All attacks huge vs. all defences small (draw likely).
\item Equal values at thresholds: use strict $>$; binary searches must use bisect\_left vs. bisect\_right correctly.
\item Duplicate cards; stability of sorting does not matter, but mapping indices must be consistent.
\item No initial losing nodes; algorithm must leave nodes as draw.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mixing up who moves at $M$-nodes (it is Bicarp).
\item Using $\ge$ instead of $>$ in edges (strict inequality).
\item Off-by-one in $s_j=1+\text{upper\_bound}$ and $t_i=1+\text{upper\_bound}$.
\item Forgetting to update $R_M$/$R_B$ after painting winners.
\item Not skipping already labeled nodes when processing buckets.
\item Incorrect DSU direction (must be ``previous'' to consume prefixes).
\end{bullets}
}
\FAILMODES{Naive degree-decrement over explicit predecessors yields $\Theta(nm)$ updates and times out for large inputs; DSU-based approach survives by touching each node only once and processing buckets per threshold exactly once.}
\ELI{Each time someone gets stuck responding to a big-enough card, that card makes many of the opponent's cards instant wins. We remove those from consideration and repeat; whatever we cannot force into win/lose must be part of an endless back-and-forth, i.e., a draw.}
\NotePages{3}

\end{document}