% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kevin and Binary String (Easy Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2061/F1}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{This is the easy version of the problem. The difference between the versions is that in this version, string $t$ consists of only \texttt{'0'} and \texttt{'1'}. You can hack only if you solved all versions of this problem.

Kevin has a binary string $s$ of length $n$. Kevin can perform the following operation:
\begin{bullets}
\item Choose two adjacent blocks of $s$ and swap them.
\end{bullets}
A block is a maximal substring$^{\text{*}}$ of identical characters. Formally, denote $s[l,r]$ as the substring $s_l s_{l+1} \ldots s_r$. A block is $s[l,r]$ satisfying:
\begin{bullets}
\item $l=1$ or $s_l\ne s_{l-1}$.
\item $s_l=s_{l+1}=\ldots=s_r$.
\item $r=n$ or $s_r\ne s_{r+1}$.
\end{bullets}
Adjacent blocks are two blocks $s[l_1,r_1]$ and $s[l_2,r_2]$ satisfying $r_1+1=l_2$.

For example, if $s=\mathtt{000}\,\mathbf{11}\,\mathbf{00}\,\mathtt{111}$, Kevin can choose the two blocks $s[4,5]$ and $s[6,7]$ and swap them, transforming $s$ into $\mathtt{000}\,\mathbf{00}\,\mathbf{11}\,\mathtt{111}$.

Given a string $t$ of length $n$ consisting only of \texttt{'0'} and \texttt{'1'}, Kevin wants to determine the minimum number of operations required to perform such that for any index $i$ ($1\le i\le n$), $s_i=t_i$. If it is impossible, output $-1$.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line of each test case contains a string $s$ consisting of \texttt{'0'} and \texttt{'1'}.

The second line of each test case contains a string $t$ consisting of \texttt{'0'} and \texttt{'1'}.

It is guaranteed that the lengths of $s$ and $t$ are the same.

It is guaranteed that the sum of the length of $s$ over all test cases will not exceed $4\cdot 10^5$.

Output: For each test case, output one integer — the minimum number of operations required. If it is impossible, output $-1$.

Note: In the first test case, the possible way is shown in the statement.

In the second test case, one possible way could be:
\begin{bullets}
\item Swap blocks $[2,2],[3,3]$, $s$ will become $\mathtt{001101}$.
\item Swap blocks $[3,4],[5,5]$, $s$ will become $\mathtt{000111}$.
\item Swap blocks $[1,3],[4,6]$, $s$ will become $\mathtt{111000}$.
\end{bullets}}
\BREAKDOWN{Model strings by their runs (blocks). You may swap adjacent runs, which can cause merges with neighbors. Transformability requires matching counts of characters and a feasible regrouping of runs; the cost counts how many opposite-color separators you must cross.}
\ELI{Think of runs like colored bricks; moving a run across one neighbor costs 1, and same-color bricks stick together when they touch.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: strings $s,t$ of equal length $n$ ($1\le n$, total $\sum n \le 4\cdot 10^5$). Each is binary over $\{0,1\}$.}
\OUTPUTS{For each test, the minimum number of adjacent-block swaps to transform $s$ into $t$ exactly, or $-1$ if impossible.}
\SAMPLES{Example 1: $s=\texttt{00011011}$, $t=\texttt{00001111}$ $\to$ minimal operations $=1$.

Example 2: $s=\texttt{0101}$, $t=\texttt{1010}$ $\to$ output $-1$ (cannot split merged zeros).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathrm{RLE}(x)$ be the run-length encoding of $x$, i.e., a sequence of blocks $(c_i,\ell_i)$ with $c_i\in\{0,1\}$ alternating and $\ell_i\ge 1$. One operation swaps two adjacent blocks; if neighbors with same character become adjacent, they merge. Objective: reach $\mathrm{RLE}(t)$ from $\mathrm{RLE}(s)$ with minimum operations.}
\varmapStart
\var{s,t}{input and target binary strings}
\var{(c_i,\ell_i)}{runs of $s$}
\var{(d_j,m_j)}{runs of $t$}
\var{K_j}{number of source runs of color $d_j$ grouped to form target run $j$}
\var{B(x)}{number of runs in string $x$}
\var{Z(x),O(x)}{the total counts of zeros and ones in $x$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&Z(s)=Z(t),\quad O(s)=O(t)\quad\text{(necessary)}\\
&\text{For each color }b\in\{0,1\},\ \text{source }b\text{-runs can be partitioned into contiguous groups summing to target }b\text{-runs}.\\
&\text{If }c_1\ne d_1\text{ and }B(s)\ge 3,\ \text{then first and third runs of }s\text{ (both }c_1)\text{ merge once when swapping first two.}
\end{aligned}
\]
}
\ASSUMPTIONS{Runs alternate perfectly; swapping two adjacent runs is atomic and merges only occur between equal adjacent characters created by the swap.}
\INVARIANTS{
- Total counts of 0s and 1s are preserved.
- Blocks are never split; only entire runs can be merged (sum of lengths).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Greedy Simulation with a Deque of Runs}
\WHICHFORMULA{Directly simulate building $t$ from the front: at each step bring the needed color to the front (one swap if needed), then repeatedly swap the second and third runs to merge another same-color run until the front run reaches the target length.}
\ASSUMPTIONS{Maintain a deque of runs; local operations only touch the first three runs; merges are applied eagerly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute RLE of $s$ into a deque of $(c,\ell)$.
\item For each target run $(d,m)$ from RLE of $t$:
  \begin{bullets}
  \item If front color $\ne d$, swap the first two runs; if the deque has $\le 1$ run or the second is not $d$, impossible. Count $+1$. Apply merges with third if needed.
  \item While front length $< m$: ensure third exists with color $d$, swap second and third ($+1$), then merge the first two (same color) into the front.
  \item If front length $\ne m$ after merges, impossible; otherwise remove the front run (consumed).
  \end{bullets}
\item If the deque is empty at the end, output the total swaps; else impossible.
\end{algosteps}
\COMPLEXITY{Worst-case $O(B(s)^2)$ swaps/moves in pathological cases; space $O(B(s))$. Suitable as a correctness reference for small instances.}
\[
\begin{aligned}
T(n) &\le O(\#\text{runs}^2)\le O(n^2),\quad S(n)=O(\#\text{runs})\le O(n).
\end{aligned}
\]
\CORRECTNESS{Each required merge of same-color runs across one opposite separator costs exactly one swap. Bringing the correct front color when mismatched costs exactly one swap. The greedy never blocks a feasible solution because operations are local and only reduce separators needed for future steps.}
\EDGECASES{Single run; two runs; first mismatch with at least three runs causing outer merge; exact-length matching without overshoot; inability to split a run (overshoot).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

def rle(s: str) -> List[Tuple[int, int]]:
    if not s:
        return []
    res = []
    cur = s[0]
    cnt = 1
    for ch in s[1:]:
        if ch == cur:
            cnt += 1
        else:
            res.append((int(cur), cnt))
            cur = ch
            cnt = 1
    res.append((int(cur), cnt))
    return res

def simulate_baseline(s: str, t: str) -> int:
    if len(s) != len(t):
        return -1
    if s.count('0') != t.count('0'):
        return -1
    rs = deque(rle(s))
    rt = rle(t)
    ops = 0

    def merge_front_two(rs: deque):
        # assumes len>=2 and rs[0][0] == rs[1][0]
        c, a = rs.popleft()
        c2, b = rs.popleft()
        assert c == c2
        rs.appendleft((c, a + b))

    for d, m in rt:
        if not rs:
            return -1
        # bring color d to front if needed
        if rs[0][0] != d:
            if len(rs) < 2 or rs[1][0] != d:
                return -1
            # swap first two: [A,B,C,...] -> [B,A,C,...]
            a = rs.popleft()
            b = rs.popleft()
            rs.appendleft(a)
            rs.appendleft(b)
            ops += 1
            # after swap, if there is a third and rs[1] (old A) has same color as rs[2], they merged by adjacency:
            # [B, A, C, ...] with A.color == C.color -> merge A and C
            if len(rs) >= 3 and rs[1][0] == rs[2][0]:
                c1 = rs[1]
                c2 = rs[2]
                # remove positions 1 and 2 and insert merged at position 1
                rs.remove(c1)  # O(n), acceptable for baseline
                rs.remove(c2)
                rs.insert(1, (c1[0], c1[1] + c2[1]))
        # now front color matches
        if rs[0][0] != d:
            return -1
        # grow front to length m by swapping 2nd and 3rd, then merging
        while rs and rs[0][1] < m:
            if len(rs) < 3 or rs[2][0] != d:
                return -1
            # swap rs[1] and rs[2]
            x = rs[1]
            y = rs[2]
            rs[1], rs[2] = y, x
            ops += 1
            # merge rs[0] and rs[1] (both color d)
            merge_front_two(rs)
        if not rs or rs[0][0] != d or rs[0][1] != m:
            return -1
        # consume the matched front block
        rs.popleft()
    # after building all target runs, nothing must remain
    if rs:
        return -1
    return ops

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    tc = int(next(it))
    cases = []
    for _ in range(tc):
        s = next(it)
        t = next(it)
        cases.append((s, t))
    return cases

def solve_case(s: str, t: str) -> int:
    return simulate_baseline(s, t)

def solve_all():
    cases = read_input()
    out_lines = []
    for s, t in cases:
        out_lines.append(str(solve_case(s, t)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # basic asserts
    assert rle("0001110") == [(0,3),(1,3),(0,1)]
    assert simulate_baseline("0011", "1100") == 1
    assert simulate_baseline("0101", "1010") == -1
    assert simulate_baseline("0100", "1000") == 1
    # no I/O run here
    pass
\end{minted}
\VALIDATION{Checked equality, simple swaps, and impossibility due to forced merge.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-Color Grouping with Forced-First-Merge Adjustment}
\WHICHFORMULA{Runs of a given color can only be merged, never split. Each target run of color $b$ is a sum of an integer number $K$ of source $b$-runs, in order. Swapping across one opposite run costs 1; merging $K$ runs costs $K-1$. If the first characters differ and there are at least three runs, the initial swap forces a merge of the first and third runs (same color), decreasing available groups of that color by 1.}
\ASSUMPTIONS{Run-length encodings are precomputed; grouping per color is feasible iff greedy accumulation never overshoots.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item RLE $s$ and $t$; verify $Z(s)=Z(t)$.
\item Build per-color lists $S_0,S_1$ (source) and $T_0,T_1$ (target) of run lengths in order of appearance.
\item If $s[1]\ne t[1]$ and $B(s)\ge 3$, merge the first two elements of $S_{s[1]}$ (forced outer merge).
\item For each color $b$, greedily partition $S_b$ into contiguous groups that sum to $T_b$; record group sizes $K$; if any overshoot occurs, impossible.
\item Answer $=\mathbf{1}[s[1]\ne t[1]]+\sum (K-1)$ over all groups of both colors.
\end{algosteps}
\COMPLEXITY{All steps linear in number of runs.}
\[
\begin{aligned}
T(n) &= O(\#\text{runs}(s) + \#\text{runs}(t)) \le O(n),\quad S(n)=O(\#\text{runs})\le O(n).
\end{aligned}
\]
\CORRECTNESS{Necessity: you cannot split runs, so each target run is a sum of source runs of the same color in order; crossing each separator costs exactly one swap, hence $K-1$ per group. If the first characters differ and at least three runs exist, swapping the first two necessarily merges the first and third runs (same color), reducing available groups of that color by 1; the adjustment captures this. Sufficiency: after the first possible swap, process target runs sequentially; for each group, perform $K-1$ merges by swapping the intervening separators. The front color matches from the second group onward, so no further front-fix swaps are needed.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

def rle(s: str) -> List[Tuple[int, int]]:
    if not s:
        return []
    res = []
    cur = s[0]
    cnt = 1
    for ch in s[1:]:
        if ch == cur:
            cnt += 1
        else:
            res.append((int(cur), cnt))
            cur = ch
            cnt = 1
    res.append((int(cur), cnt))
    return res

def group_sizes(source: List[int], target: List[int]) -> List[int] or None:
    """Return list of K (how many source runs per target run) or None if impossible."""
    ks = []
    i = 0
    cur = 0
    k = 0
    for need in target:
        cur = 0
        k = 0
        while cur < need:
            if i >= len(source):
                return None
            cur += source[i]
            i += 1
            k += 1
            if cur > need:
                return None
        ks.append(k)
    if i != len(source):
        # leftover source runs unused -> impossible (counts mismatch)
        return None
    return ks

def min_ops_improved(s: str, t: str) -> int:
    if len(s) != len(t):
        return -1
    if s.count('0') != t.count('0'):
        return -1
    rs = rle(s)
    rt = rle(t)
    # per-color lists
    S = {0: [], 1: []}
    for c, L in rs:
        S[c].append(L)
    T = {0: [], 1: []}
    for c, L in rt:
        T[c].append(L)
    # forced outer merge if first chars differ and at least 3 runs
    first_mismatch = 1 if rs and rt and rs[0][0] != rt[0][0] else 0
    S_adj = {0: S[0][:], 1: S[1][:]}
    if first_mismatch == 1 and len(rs) >= 3:
        c_opp = rs[0][0]
        if len(S_adj[c_opp]) < 2:
            return -1
        merged = S_adj[c_opp][0] + S_adj[c_opp][1]
        S_adj[c_opp] = [merged] + S_adj[c_opp][2:]
    # group per color
    K0 = group_sizes(S_adj[0], T[0])
    if K0 is None:
        return -1
    K1 = group_sizes(S_adj[1], T[1])
    if K1 is None:
        return -1
    ops = first_mismatch + sum(k - 1 for k in K0) + sum(k - 1 for k in K1)
    return ops

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    tc = int(next(it))
    cases = []
    for _ in range(tc):
        s = next(it)
        t = next(it)
        cases.append((s, t))
    return cases

def solve_case(s: str, t: str) -> int:
    return min_ops_improved(s, t)

def solve_all():
    cases = read_input()
    print("\n".join(str(solve_case(s, t)) for s, t in cases))

if __name__ == "__main__":
    # validation
    assert min_ops_improved("0011", "1100") == 1
    assert min_ops_improved("0101", "1010") == -1
    assert min_ops_improved("0100", "1000") == 1
    assert min_ops_improved("0", "0") == 0
\end{minted}
\VALIDATION{Covers trivial, forced-merge, and impossible due to needing to split.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Linear-Time RLE Grouping with Cost Formula}
\WHICHFORMULA{Let $S_b$ be the list of source $b$-run lengths and $T_b$ be the list of target $b$-run lengths for $b\in\{0,1\}$. If $s_1\ne t_1$ and $B(s)\ge 3$, merge $S_{s_1}[0]$ and $S_{s_1}[1]$ (forced outer merge). Feasibility holds iff $S_b$ can be partitioned to sum to $T_b$ per color, in order. Cost equals $\mathbf{1}[s_1\ne t_1]+\sum (K-1)$ over all target runs (both colors), where $K$ is the number of source runs grouped for that target run.}
\ASSUMPTIONS{Binary alphabet, runs alternate, and only adjacent-block swaps are allowed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item RLE both strings; check total counts of zeros match (equivalently ones).
\item Build $S_0,S_1,T_0,T_1$.
\item If $s_1\ne t_1$ and $B(s)\ge 3$, force-merge $S_{s_1}$'s first two entries.
\item Greedily group $S_b$ to match $T_b$ (return list of $K$'s) for $b=0,1$; if overshoot or leftover, impossible.
\item Output $1$ if $s_1\ne t_1$ else $0$, plus $\sum (K-1)$ across both colors.
\end{algosteps}
\OPTIMALITY{Each merge across one separator is necessary and sufficient, hence exactly $K-1$ swaps per target run. If the first colors differ, exactly one swap is necessary (and sufficient) to align the front color; from then on, the front color always matches the next target block. No other sequence can use fewer swaps.}
\COMPLEXITY{$O(n)$ time and $O(\#\text{runs})$ space.}
\[
\begin{aligned}
T(n) &= O(\#\text{runs}(s)+\#\text{runs}(t)) \le O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def rle(s: str) -> List[Tuple[int, int]]:
    if not s:
        return []
    res = []
    cur = s[0]
    cnt = 1
    for ch in s[1:]:
        if ch == cur:
            cnt += 1
        else:
            res.append((int(cur), cnt))
            cur = ch
            cnt = 1
    res.append((int(cur), cnt))
    return res

def group_sizes(source: List[int], target: List[int]) -> List[int] or None:
    ks = []
    i = 0
    for need in target:
        ssum = 0
        k = 0
        while ssum < need:
            if i >= len(source):
                return None
            ssum += source[i]
            i += 1
            k += 1
            if ssum > need:
                return None
        ks.append(k)
    if i != len(source):
        return None
    return ks

def min_adjacent_block_swaps(s: str, t: str) -> int:
    if len(s) != len(t):
        return -1
    if s.count('0') != t.count('0'):
        return -1
    rs = rle(s)
    rt = rle(t)
    S0, S1 = [], []
    for c, L in rs:
        (S1 if c == 1 else S0).append(L)
    T0, T1 = [], []
    for c, L in rt:
        (T1 if c == 1 else T0).append(L)
    first_mismatch = 1 if rs and rt and rs[0][0] != rt[0][0] else 0
    # forced outer merge if first colors differ and at least three runs exist
    if first_mismatch == 1 and len(rs) >= 3:
        c_opp = rs[0][0]
        if c_opp == 0:
            if len(S0) < 2:
                return -1
            S0 = [S0[0] + S0[1]] + S0[2:]
        else:
            if len(S1) < 2:
                return -1
            S1 = [S1[0] + S1[1]] + S1[2:]
    K0 = group_sizes(S0, T0)
    if K0 is None:
        return -1
    K1 = group_sizes(S1, T1)
    if K1 is None:
        return -1
    ops = first_mismatch + sum(k - 1 for k in K0) + sum(k - 1 for k in K1)
    return ops

# CF bindings
def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    tc = int(next(it))
    cases = []
    for _ in range(tc):
        s = next(it)
        t = next(it)
        cases.append((s, t))
    return cases

def solve_case(s: str, t: str) -> int:
    return min_adjacent_block_swaps(s, t)

def solve_all():
    cases = read_input()
    print("\n".join(str(solve_case(s, t)) for s, t in cases))

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    assert min_adjacent_block_swaps("0011", "1100") == 1
    assert min_adjacent_block_swaps("0101", "1010") == -1
    assert min_adjacent_block_swaps("0100", "1000") == 1
    # No I/O execution here
\end{minted}
\VALIDATION{Three asserts cover a direct swap, an impossible case due to forced merge, and a case where the initial swap suffices.}
\RESULT{If feasible, the minimal number of operations equals $\mathbf{1}[s_1\ne t_1] + \sum (K-1)$, where $K$ runs are merged for each target run, accounting for the forced outer merge when the first characters differ.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test RLE, grouping, forced-merge adjustment, and final solver on crafted cases: equality, single swap, multi-merge, and impossibility.}
\LINE{CROSS-CHECKS}{Compare Baseline simulation vs Improved/Final on small random strings to ensure same outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate random small $s,t$ with equal counts and verify Baseline == Final; include cases with many short runs to stress merging.}
\begin{minted}{python}
import random

def gen_strings(n):
    s = "".join(random.choice("01") for _ in range(n))
    t = "".join(random.choice("01") for _ in range(n))
    # balance counts
    zeros = s.count('0')
    ones = n - zeros
    t_list = list(t)
    need0 = zeros - t.count('0')
    # adjust t to have same zero count
    for i in range(n):
        if need0 == 0:
            break
        if need0 > 0 and t_list[i] == '1':
            t_list[i] = '0'
            need0 -= 1
        elif need0 < 0 and t_list[i] == '0':
            t_list[i] = '1'
            need0 += 1
    t = "".join(t_list)
    return s, t

def test_cross_small(trials=200):
    for _ in range(trials):
        n = random.randint(1, 10)
        s, t = gen_strings(n)
        b = simulate_baseline(s, t)
        f = min_adjacent_block_swaps(s, t)
        assert (b == f), (s, t, b, f)

if __name__ == "__main__":
    # Reference execution for local testing only
    test_cross_small(100)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

def rle(s: str) -> List[Tuple[int, int]]:
    if not s:
        return []
    res = []
    cur = s[0]
    cnt = 1
    for ch in s[1:]:
        if ch == cur:
            cnt += 1
        else:
            res.append((int(cur), cnt))
            cur = ch
            cnt = 1
    res.append((int(cur), cnt))
    return res

def group_sizes(source: List[int], target: List[int]) -> List[int] or None:
    ks = []
    i = 0
    for need in target:
        ssum = 0
        k = 0
        while ssum < need:
            if i >= len(source):
                return None
            ssum += source[i]
            i += 1
            k += 1
            if ssum > need:
                return None
        ks.append(k)
    if i != len(source):
        return None
    return ks

def min_adjacent_block_swaps(s: str, t: str) -> int:
    if len(s) != len(t):
        return -1
    if s.count('0') != t.count('0'):
        return -1
    rs = rle(s)
    rt = rle(t)
    S0, S1 = [], []
    for c, L in rs:
        (S1 if c == 1 else S0).append(L)
    T0, T1 = [], []
    for c, L in rt:
        (T1 if c == 1 else T0).append(L)
    first_mismatch = 1 if rs and rt and rs[0][0] != rt[0][0] else 0
    if first_mismatch == 1 and len(rs) >= 3:
        c_opp = rs[0][0]
        if c_opp == 0:
            if len(S0) < 2:
                return -1
            S0 = [S0[0] + S0[1]] + S0[2:]
        else:
            if len(S1) < 2:
                return -1
            S1 = [S1[0] + S1[1]] + S1[2:]
    K0 = group_sizes(S0, T0)
    if K0 is None:
        return -1
    K1 = group_sizes(S1, T1)
    if K1 is None:
        return -1
    ops = first_mismatch + sum(k - 1 for k in K0) + sum(k - 1 for k in K1)
    return ops

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    tc = int(next(it))
    cases = []
    for _ in range(tc):
        s = next(it)
        t = next(it)
        cases.append((s, t))
    return cases

def solve_case(s: str, t: str) -> int:
    return min_adjacent_block_swaps(s, t)

def solve_all():
    cases = read_input()
    print("\n".join(str(solve_case(s, t)) for s, t in cases))

if __name__ == "__main__":
    # final asserts
    assert min_adjacent_block_swaps("0011", "1100") == 1
    assert min_adjacent_block_swaps("0101", "1010") == -1
    assert min_adjacent_block_swaps("0100", "1000") == 1
    # guard main left uncalled in unit context
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Group source runs per color to match target runs; cost is separators crossed, plus one for the initial front-color swap if needed.}
\WHY{Swapping adjacent runs is a common interview twist on greedy/RLE reasoning: it forces careful handling of merges and invariants.}
\CHECKLIST{
- RLE both strings.
- Check counts of zeros (or ones) match.
- If first chars differ and $B(s)\ge 3$, merge first two runs of the starting color in $s$ (forced merge).
- Greedily group per color; detect overshoot.
- Cost $=\mathbf{1}[s_1\ne t_1]+\sum(K-1)$.}
\EDGECASES{
- $s=t$ $\Rightarrow 0$.
- One run in $s$: must equal $t$ exactly.
- Two runs: initial swap does not merge outer runs.
- First chars differ with at least three runs: forced outer merge.
- Overshoot when grouping (cannot split a run).
- Target has more runs than source (impossible).
- All runs of a color concentrated in one side.}
\PITFALLS{
- Forgetting the forced merge when swapping the first two runs with a third present.
- Allowing partial consumption of a run (illegal).
- Not verifying leftover source runs after grouping.
- Mixing per-character counts (they must match).
- Assuming parity invariants on run count (not true at ends).
- Off-by-one when summing group sizes.}
\FAILMODES{Naive per-color grouping without forced-merge adjustment wrongly accepts cases like $s=\texttt{0101}$, $t=\texttt{1010}$. The improved method rejects them via the adjustment.}
\ELI{You can glue same-colored bricks, but you can never cut them. To build $t$, you bundle whole bricks of the needed color; each time you pull a brick past one of the other color, you pay 1. If the first colors differ and there are at least three bricks, the first move glues two outer bricks of the other color automatically, reducing how many such bricks you can later use separately.}
\NotePages{3}

\end{document}