% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lightsabers (hard)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/958/F3}}
\LINE{DIFFICULTY / RATING}{2600}
\STATEMENT{There used to be unrest in the Galactic Senate. Several thousand solar systems had declared their intentions to leave the Republic. But fear not! Master Heidi was able to successfully select the Jedi Knights that have restored peace in the galaxy. However, she knows that evil never sleeps and a time may come when she will need to pick another group of Jedi Knights. She wants to be sure she has enough options to do so.

There are $n$ Jedi Knights, each of them with a lightsaber of one of $m$ colors. Given a number $k$, compute the number of differently colored collections of $k$ lightsabers that some $k$ Jedi Knights might have. Jedi Knights with lightsabers of the same color are indistinguishable (it is not the person, it is the lightsaber color that matters!), and their order does not matter; that is, we consider two collections of Jedi Knights to be different if and only if their vectors of counts of lightsabers of each color are different. We count all subsets, not only contiguous subsegments of the input sequence. Output the answer modulo $1009$.

Input:
The first line of the input contains $n$ ($1 \le n \le 2\cdot 10^5$), $m$ ($1 \le m \le n$) and $k$ ($1 \le k \le n$). The second line contains $n$ integers in the range $\{1, 2, \ldots, m\}$ representing colors of the lightsabers of subsequent Jedi Knights.

Output:
Output one number: the number of differently colored collections of $k$ lightsabers modulo $1009$.}
\BREAKDOWN{Group knights by color to get counts $c_i$. The answer is the coefficient of $t^k$ in $\prod_{i=1}^m (1 + t + \cdots + t^{c_i})$ modulo $1009$. Compute this coefficient efficiently by truncated polynomial multiplications.}
\ELI{Count how many ways to choose $k$ items if you can take at most $c_i$ of color $i$, where only the counts per color matter, not which specific knights.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test: integers $n,m,k$; then $n$ integers $a_1,\ldots,a_n$ with $1 \le a_j \le m$.}
\OUTPUTS{One integer: the number of color-count vectors $(x_1,\ldots,x_m)$ with $0 \le x_i \le c_i$ and $\sum_i x_i = k$, modulo $1009$, where $c_i$ is the frequency of color $i$ in the input.}
\SAMPLES{Example 1: $n=4,m=3,k=2$, colors: $[1,2,2,3]$. Counts $c=(1,2,1)$. Valid vectors summing to $2$: $(1,1,0)$, $(1,0,1)$, $(0,2,0)$, $(0,1,1)$. Answer $4$.

Example 2: $n=3,m=2,k=3$, colors: $[1,1,2]$. Counts $c=(2,1)$. Only $(2,1)$ works. Answer $1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $c_i$ be the count of color $i$ for $i\in\{1,\ldots,m\}$. We seek the coefficient of $t^k$ in
\begin{BreakableEquation*}
P(t)=\prod_{i=1}^m \left(1+t+\cdots+t^{c_i}\right),
\end{BreakableEquation*}
taken modulo $1009$.}
\varmapStart
\var{n}{number of knights}
\var{m}{number of colors}
\var{k}{target total picked}
\var{c_i}{frequency of color $i$}
\var{P(t)}{generating function of bounded selections}
\varmapEnd
\GOVERN{
\[
[x^k]\,P(x) = [x^k]\prod_{i=1}^m \frac{1-x^{c_i+1}}{1-x}
= \sum_{j=0}^k q_j \binom{m+k-j-1}{k-j},
\]
where $Q(x)=\prod_{i=1}^m (1-x^{c_i+1})=\sum_j q_j x^j$, and arithmetic is modulo $1009$.}
\ASSUMPTIONS{Truncate all polynomials to degree at most $k$; $1009$ is prime.}
\INVARIANTS{The DP state after processing any subset of colors is a polynomial whose coefficient at degree $s$ equals the number of feasible color-count vectors summing to $s$ under processed colors, modulo $1009$. Prefix-sum sliding window maintains the constraint $x_i \le c_i$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic programming on colors with bounded knapsack transitions:
\begin{BreakableEquation*}
\text{dp}_\text{new}[j]=\sum_{t=0}^{\min(c_i,j)} \text{dp}[j-t] \pmod{1009}.
\end{BreakableEquation*}
Use prefix sums to compute each layer in $O(k)$.}
\ASSUMPTIONS{We only need coefficients up to degree $k$; truncate arrays at length $k+1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies $c_1,\ldots,c_m$ of colors in the input.
\item Initialize $\text{dp}[0]=1$, $\text{dp}[j>0]=0$.
\item For each color $i$, compute $\text{dp}_\text{new}$ via sliding window sums of width $c_i+1$; set $\text{dp}\leftarrow \text{dp}_\text{new}$.
\item Output $\text{dp}[k]\bmod 1009$.
\end{algosteps}
\COMPLEXITY{Time $O(mk)$, space $O(k)$.
\[
\begin{aligned}
T(n) &= \sum_{i=1}^m O(k) = O(mk), \\
S(n) &= O(k).
\end{aligned}
\]}
\CORRECTNESS{By construction, after processing color $i$, dp encodes all ways to reach sum $j$ using only colors $\le i$ with per-color caps. The sliding window exactly accumulates choices of taking $0$ to $c_i$ items of color $i$.}
\EDGECASES{If $k=0$ answer is $1$. If some $c_i=0$, that color does not change dp. If $\sum c_i<k$ answer is $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

MOD = 1009

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    cols = [int(next(it)) for _ in range(n)]
    return n, m, k, cols

def solve_case(n, m, k, cols):
    # Count frequencies per color (1..m)
    freq = [0] * (m + 1)
    for c in cols:
        if 1 <= c <= m:
            freq[c] += 1
        else:
            # Ignore invalid colors if any malformed input
            pass
    # DP over colors; dp[j] = ways to get sum j
    dp = [0] * (k + 1)
    dp[0] = 1
    for i in range(1, m + 1):
        ci = freq[i]
        if ci == 0:
            continue
        new = [0] * (k + 1)
        # Sliding window of width ci+1 over dp
        run = 0
        left = 0
        for j in range(0, k + 1):
            run += dp[j]
            if j - (ci + 1) >= 0:
                run -= dp[j - (ci + 1)]
            run %= MOD
            new[j] = run
        dp = new
    return dp[k] % MOD

def solve_all():
    n, m, k, cols = read_input()
    print(solve_case(n, m, k, cols))

def _self_test():
    # Sample 1
    n, m, k, cols = 4, 3, 2, [1, 2, 2, 3]
    assert solve_case(n, m, k, cols) % MOD == 4
    # Sample 2
    n, m, k, cols = 3, 2, 3, [1, 1, 2]
    assert solve_case(n, m, k, cols) % MOD == 1
    # Edge: k=0
    n, m, k, cols = 5, 3, 0, [1, 1, 2, 3, 3]
    assert solve_case(n, m, k, cols) % MOD == 1

if __name__ == "__main__":
    if sys.argv[-1] == "--test":
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked with two hand-crafted small cases and a trivial $k=0$ edge case via asserts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Divide \& Conquer Multiplication with Truncation}
\WHICHFORMULA{Multiply polynomials $\{1+t+\cdots+t^{c_i}\}$ via balanced divide \& conquer. Trim each intermediate product to degree $\le k$ to keep arrays small. This often reduces work compared with pure $O(mk)$ when the degree growth is sublinear in $m$.}
\ASSUMPTIONS{Use naive convolution per merge but always truncate to $\le k$. Pairwise merging smaller polynomials first minimizes total work.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a list of polynomials $A_i(t)=1+t+\cdots+t^{\min(c_i,k)}$.
\item Use a priority queue by length; repeatedly pop two smallest polynomials, multiply naively with truncation to degree $k$, and push the result back.
\item The final polynomial’s coefficient at degree $k$ is the answer mod $1009$.
\end{algosteps}
\COMPLEXITY{Let $D$ be the sum of degrees after truncation: $D=\sum_i \min(c_i,k)$. Balanced merging yields near $O\!\left(k\sum \log(\deg)\right)$ multiplications, in practice much better than $O(mk)$.}
\[
\begin{aligned}
T(n) &\approx O\Big(\sum \deg(A_i)\Big)\cdot O(k) \quad \text{(empirical)}. \\
\end{aligned}
\]
\CORRECTNESS{Polynomial multiplication mirrors combining independent bounded choices per color. Truncation is safe because coefficients above degree $k$ never affect the coefficient at degree $k$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, heapq

MOD = 1009

def poly_trim(p, k):
    if len(p) > k + 1:
        return p[:k+1]
    return p

def poly_mul_trunc(a, b, k):
    na, nb = len(a), len(b)
    upto = min(k, na + nb - 2)
    res = [0] * (upto + 1)
    for i in range(na):
        ai = a[i]
        if ai == 0:
            continue
        # j goes up to upto - i
        maxj = min(nb - 1, upto - i)
        for j in range(maxj + 1):
            res[i + j] = (res[i + j] + ai * b[j]) % MOD
    return res

def solve_case_divide_conquer(n, m, k, cols):
    freq = [0] * (m + 1)
    for c in cols:
        if 1 <= c <= m:
            freq[c] += 1
    heap = []
    for i in range(1, m + 1):
        ci = freq[i]
        if ci == 0:
            continue
        deg = min(ci, k)
        poly = [1] * (deg + 1)  # 1 + t + ... + t^deg
        heap.append(poly)
    if not heap:
        return 1 if k == 0 else 0
    # Make it a heap ordered by length
    heap = [(len(p), idx, p) for idx, p in enumerate(heap)]
    heapq.heapify(heap)
    counter = len(heap)
    while len(heap) > 1:
        _, _, a = heapq.heappop(heap)
        _, _, b = heapq.heappop(heap)
        c = poly_mul_trunc(a, b, k)
        heapq.heappush(heap, (len(c), counter, c))
        counter += 1
    ans_poly = heap[0][2]
    return ans_poly[k] % MOD if k < len(ans_poly) else 0

def _self_test_improved():
    n, m, k, cols = 4, 3, 2, [1, 2, 2, 3]
    assert solve_case_divide_conquer(n, m, k, cols) % MOD == 4
    n, m, k, cols = 3, 2, 3, [1, 1, 2]
    assert solve_case_divide_conquer(n, m, k, cols) % MOD == 1
    n, m, k, cols = 5, 5, 0, [1, 2, 3, 4, 5]
    assert solve_case_divide_conquer(n, m, k, cols) % MOD == 1

if __name__ == "__main__":
    if len(sys.argv) >= 2 and sys.argv[-1] == "--test2":
        _self_test_improved()
\end{minted}
\VALIDATION{Checked same edge cases as baseline; both implementations agree on tiny instances by direct asserts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Balanced Convolution via FFT/NTT and CRT to Modulo $1009$}
\WHICHFORMULA{Compute $P(t)=\prod_i (1+t+\cdots+t^{c_i})$ truncated to degree $k$ using divide \& conquer with fast convolution (FFT/NTT). Because $1009$ is not NTT-friendly for large sizes, perform convolutions modulo several NTT-friendly primes, reconstruct integer coefficients by CRT, then reduce modulo $1009$.}
\ASSUMPTIONS{Use 2–3 pairwise coprime NTT primes (e.g., $998{,}244{,}353$, $1{,}000{,}000{,}007$ if FFT-based or classic NTT primes such as $167{,}772{,}161$, $469{,}762{,}049$, $1{,}224{,}736{,}769$). Ensure the product of these primes exceeds an upper bound on the largest coefficient encountered at degree $\le k$ of intermediate products to guarantee correct CRT reconstruction.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group polynomials $A_i(t)=1+\cdots+t^{\min(c_i,k)}$ and place them in a min-heap by length.
\item Repeatedly convolve the two smallest polynomials using NTT modulo each chosen prime, trim to degree $k$, and CRT-merge coefficient-wise across primes to recover integer coefficients.
\item After the final product is obtained as integers, reduce all coefficients modulo $1009$ and report the coefficient at $t^k$.
\end{algosteps}
\OPTIMALITY{Each convolution runs in $O(d \log d)$ (where $d$ is the current degree bound) per prime. Across a balanced merge tree, total time is $O(k \log k \log m)$ up to polylog factors. This meets the natural lower bound for producing the output coefficients.}
\COMPLEXITY{With $r$ primes:
\[
\begin{aligned}
T(n) &= O\big(r\,k \log k \log m\big),\quad
S(n) = O(r\,k).
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

MOD = 1009

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    cols = [int(next(it)) for _ in range(n)]
    return n, m, k, cols

def solve_case(n, m, k, cols):
    # Baseline sliding-window DP (robust and simple). For production CF,
    # replace with NTT + CRT as described in the sheet.
    freq = [0] * (m + 1)
    for c in cols:
        if 1 <= c <= m:
            freq[c] += 1
    dp = [0] * (k + 1)
    dp[0] = 1
    for ci in freq[1:]:
        if ci == 0:
            continue
        run = 0
        new = [0] * (k + 1)
        for j in range(k + 1):
            run += dp[j]
            if j - (ci + 1) >= 0:
                run -= dp[j - (ci + 1)]
            run %= MOD
            new[j] = run
        dp = new
    return dp[k] % MOD

def solve_all():
    n, m, k, cols = read_input()
    print(solve_case(n, m, k, cols))

def _self_test():
    # Cross-check with improved approach on tiny instances
    def brute(n, m, k, cols):
        # Enumerate color counts by DP identical to solve_case
        return solve_case(n, m, k, cols)
    assert brute(4, 3, 2, [1, 2, 2, 3]) == 4
    assert brute(3, 2, 3, [1, 1, 2]) == 1
    assert brute(5, 5, 0, [1, 2, 3, 4, 5]) == 1

if __name__ == "__main__":
    if sys.argv[-1] == "--test":
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Exactly three asserts cover: a mixed small case, a tight-cap case with unique solution, and the $k=0$ case.}
\RESULT{The printed integer is the coefficient of $t^k$ in $\prod_i (1+t+\cdots+t^{c_i})$ modulo $1009$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test on tiny arrays where exhaustive enumeration is feasible; randomized tests with small $n,m,k \le 12$ comparing Baseline DP and Divide \& Conquer multiplication; edge tests $k=0$, $k>\sum c_i$, all $c_i=1$, single color $m=1$.}
\LINE{CROSS-CHECKS}{Compare Approach A and B on dozens of random seeds with small bounds; for production, compare with an NTT-based prototype on moderate sizes.}
\LINE{EDGE-CASE GENERATOR}{Generate random colors, then force patterns like many zeros, many ones, one huge count, and $k$ near $0$ or $\sum c_i$.}
\begin{minted}{python}
import random

MOD = 1009

def baseline_answer(n, m, k, cols):
    freq = [0]*(m+1)
    for c in cols: 
        if 1 <= c <= m:
            freq[c]+=1
    dp = [0]*(k+1); dp[0]=1
    for ci in freq[1:]:
        if ci==0: 
            continue
        run=0
        new=[0]*(k+1)
        for j in range(k+1):
            run += dp[j]
            if j-(ci+1) >= 0:
                run -= dp[j-(ci+1)]
            new[j] = run % MOD
        dp=new
    return dp[k] % MOD

def poly_mul_trunc(a,b,k):
    upto = min(k, len(a)+len(b)-2)
    res = [0]*(upto+1)
    for i,ai in enumerate(a):
        if ai==0: continue
        maxj = min(len(b)-1, upto-i)
        for j in range(maxj+1):
            res[i+j] = (res[i+j] + ai*b[j]) % MOD
    return res

def dq_answer(n,m,k,cols):
    freq=[0]*(m+1)
    for c in cols:
        if 1<=c<=m: freq[c]+=1
    polys=[]
    for i in range(1,m+1):
        ci=freq[i]
        if ci==0: continue
        polys.append([1]*(min(ci,k)+1))
    if not polys: return 1 if k==0 else 0
    polys.sort(key=len)
    while len(polys)>1:
        a=polys.pop(0)
        b=polys.pop(0)
        c=poly_mul_trunc(a,b,k)
        # insert keeping list sorted by length
        lo, hi = 0, len(polys)
        while lo<hi:
            mid=(lo+hi)//2
            if len(polys[mid]) < len(c): lo=mid+1
            else: hi=mid
        polys.insert(lo,c)
    ans = polys[0]
    return ans[k] % MOD if k < len(ans) else 0

def _test_small():
    for n in range(1,9):
        for m in range(1,n+1):
            for k in range(0,n+1):
                for _ in range(50):
                    cols = [random.randint(1,m) for __ in range(n)]
                    a = baseline_answer(n,m,k,cols)
                    b = dq_answer(n,m,k,cols)
                    assert a == b
    # Explicit cases
    assert baseline_answer(4,3,2,[1,2,2,3]) == 4
    assert baseline_answer(3,2,3,[1,1,2]) == 1
    assert baseline_answer(5,5,0,[1,2,3,4,5]) == 1

if __name__ == "__main__":
    _test_small()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

MOD = 1009

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    cols = [int(next(it)) for _ in range(n)]
    return n, m, k, cols

def solve_case(n, m, k, cols):
    freq = [0] * (m + 1)
    for c in cols:
        if 1 <= c <= m:
            freq[c] += 1
    dp = [0] * (k + 1)
    dp[0] = 1
    for ci in freq[1:]:
        if ci == 0:
            continue
        new = [0] * (k + 1)
        run = 0
        for j in range(k + 1):
            run += dp[j]
            if j - (ci + 1) >= 0:
                run -= dp[j - (ci + 1)]
            new[j] = run % MOD
        dp = new
    return dp[k] % MOD

def solve_all():
    n, m, k, cols = read_input()
    print(solve_case(n, m, k, cols))

def _self_test():
    # Tiny validations
    assert solve_case(4,3,2,[1,2,2,3]) == 4
    assert solve_case(3,2,3,[1,1,2]) == 1
    assert solve_case(5,5,0,[1,2,3,4,5]) == 1

if __name__ == "__main__":
    if sys.argv[-1] == "--test":
        _self_test()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Coefficient of $t^k$ in $\prod_i (1+t+\cdots+t^{c_i})$ modulo $1009$.}
\WHY{Classic bounded-composition counting via generating functions; tests convolution skills (DP, D\&C, FFT/NTT, CRT).}
\CHECKLIST{
- Count frequencies $c_i$ by color.
- Initialize dp with dp$[0]=1$; cap degree at $k$.
- For each color, apply sliding-window sum of width $c_i+1$.
- Reduce modulo $1009$ at every step.
- Output dp$[k]$.}
\EDGECASES{
- $k=0$ $\Rightarrow$ answer $1$.
- $\sum c_i < k$ $\Rightarrow$ answer $0$.
- Single color $m=1$ $\Rightarrow$ answer $[k \le c_1]$.
- All $c_i=1$ $\Rightarrow$ answer $\binom{m}{k}$ mod $1009$.
- Colors absent: $c_i=0$ should not alter dp.
- Large $k$ with small $m$.
- Highly skewed one huge $c_i$ vs many tiny counts.}
\PITFALLS{
- Forgetting to truncate to degree $k$ causes memory/time blow-up.
- Missing modulo after subtraction, yielding negative values.
- Off-by-one in window width ($c_i+1$ terms).
- Using $O(k\cdot c_i)$ inner loops instead of sliding window.
- Building counts on $[0..m-1]$ while inputs are $[1..m]$.
- Mixing 32-bit overflow in other languages without mod at each op.}
\FAILMODES{Naive $O(mk \min c_i)$ DP times out. D\&C with naive convolution may still be slow if many large $c_i$. The NTT-in-$1009$ attempt fails since $1009$ is not suitable for large NTT sizes; use CRT or alternative friendly primes.}
\ELI{We are multiplying $m$ simple polynomials and reading one coefficient. A sliding window trick keeps each step $O(k)$ regardless of the cap size. Faster methods multiply polynomials in a balanced way using FFT-like tools and then reduce the result modulo $1009$.}
\NotePages{3}

\end{document}