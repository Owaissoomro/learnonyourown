% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kirei and the Linear Function}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1729/F}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Given the string $s$ of decimal digits (0--9) of length $n$.

A substring is a sequence of consecutive characters of a string. The substring of this string is defined by a pair of indexes --- with its left and right ends. So, each pair of indexes $(l, r)$, where $1 \le l \le r \le n$, corresponds to a substring of the string $s$. We will define as $v(l,r)$ the numeric value of the corresponding substring (leading zeros are allowed in it).

For example, if $n=7$, $s=$"1003004", then $v(1,3)=100$, $v(2,3)=0$ and $v(2,7)=3004$.

You are given $n$, $s$ and an integer $w$ ($1 \le w < n$).

You need to process $m$ queries, each of which is characterized by $3$ numbers $l_i, r_i, k_i$ ($1 \le l_i \le r_i \le n; 0 \le k_i \le 8$).

The answer to the $i$th query is such a pair of substrings of length $w$ that if we denote them as $(L_1, L_1+w-1)$ and $(L_2, L_2+w-1)$, then:
\begin{bullets}
\item $L_1 \ne L_2$, that is, the substrings are different;
\item the remainder of dividing a number $v(L_1, L_1+w-1) \cdot v(l_i, r_i) + v(L_2, L_2 + w - 1)$ by $9$ is equal to $k_i$.
\end{bullets}

If there are many matching substring pairs, then find a pair where $L_1$ is as small as possible. If there are many matching pairs in this case, then minimize $L_2$.

Note that the answer may not exist.

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^4$) --- number of input test cases.

The first line of each test case contains a string $s$, which contains only the characters 0--9 and has a length $n$ ($2 \le n \le 2 \cdot 10^5$).

The second line contains two integers $w, m$ ($1 \le w < n, 1 \le m \le 2 \cdot 10^5$), where $n$ --- is the length of the given string $s$. The number $w$ denotes the lengths of the substrings being searched for, and $m$ is the number of queries to be processed.

The following $m$ lines contain integers $l_i, r_i, k_i$ ($1 \le l_i \le r_i \le n$, $0 \le k_i \le 8$) --- $i$th query parameters.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$. It is also guaranteed that the sum of $m$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each request, print in a separate line:
\begin{bullets}
\item left borders of the required substrings: $L_1$ and $L_2$;
\item -1 -1 otherwise, if there is no solution.
\end{bullets}

If there are several solutions, minimize $L_1$ first, and minimize $L_2$ second.

Note:
Consider the first test case of example inputs. In this test case $n=7$, $s=$"1003004", $w=4$ and one query $l_1=1$, $r_1=2$, $k_1=1$. Note that $v(1,2)=10$. We need to find a pair of substrings of length $4$ such that $v(L_1, L_1+3)\cdot10+v(L_2,L_2+3)$ has a remainder of $k_1=1$ when divided by $9$. The values $L_1=2, L_2=4$ actually satisfy all the requirements: $v(L_1, L_1+w-1)=v(2,5)=30$, $v(L_2, L_2+w-1)=v(4,7)=3004$. Indeed, $30\cdot10+3004=3304$, which has a remainder of $1$ when divided by $9$. It can be shown that $L_1=2$ is the minimum possible value, and $L_2=4$ is the minimum possible with $L_1=2$.}
\BREAKDOWN{Exploit that $10 \equiv 1 \pmod{9}$ so any decimal number is congruent modulo $9$ to the sum of its digits. Reduce all substrings to their residue modulo $9$ and search for two $w$-length substrings whose residues satisfy a linear congruence. Precompute residues of all length-$w$ substrings and answer queries by checking a constant number of residue pairs.}
\ELI{Modulo $9$, a number equals the sum of its digits. So every substring is just a small residue 0--8. Queries ask for two length-$w$ substrings whose residues solve $r_1 \cdot x + r_2 \equiv k \pmod{9}$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: string $s$ of digits with $2 \le |s| \le 2\cdot 10^5$; integers $w,m$ with $1 \le w < |s|$, $1 \le m \le 2\cdot 10^5$; then $m$ queries with $l,r,k$ where $1 \le l \le r \le |s|$, $0 \le k \le 8$. Across all tests, total $n$ and total $m$ do not exceed $2\cdot 10^5$.}
\OUTPUTS{For each query, print two integers $L_1,L_2$ (1-based starts of two length-$w$ substrings, $L_1 \ne L_2$) that minimize $L_1$ then $L_2$, satisfying $(v(L_1,L_1+w-1)\cdot v(l,r)+v(L_2,L_2+w-1)) \bmod 9 = k$. If impossible, print $-1 -1$.}
\SAMPLES{Example 1:
\begin{verbatim}
Input
1
1003004
4 1
1 2 1

Output
2 4
\end{verbatim}
Example 2:
\begin{verbatim}
Input
1
012345
2 1
2 5 8

Output
1 4
\end{verbatim}
Explanation 2: $v(2,5) \equiv 1 \pmod{9}$, residues of length-2 substrings are $[1,3,5,7,0]$, and $1\cdot 1 + 7 \equiv 8 \ (\bmod\ 9)$ with starts $(1,4)$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let digits be $d_1,\ldots,d_n \in \{0,\ldots,9\}$. For any interval $[i,j]$, define $x(i,j) \equiv \sum_{t=i}^j d_t \pmod{9}$. For each $w$-window start $L \in [1,n-w+1]$, set $a_L \equiv x(L,L+w-1)$. For a query with $x \equiv x(l,r)$ and target $k$, find $L_1 \ne L_2$ such that $a_{L_1}\cdot x + a_{L_2} \equiv k \pmod{9}$ with lexicographically minimal $(L_1,L_2)$.}
\varmapStart
\var{d_i}{digit at position $i$}
\var{x(i,j)}{sum of digits from $i$ to $j$ modulo $9$}
\var{a_L}{residue modulo $9$ of the length-$w$ substring at start $L$}
\var{x}{query residue $x(l,r)$ modulo $9$}
\var{k}{target modulo $9$ residue}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
10 &\equiv 1 \pmod{9} \ \Rightarrow\ v(i,j) \equiv x(i,j) \equiv \sum_{t=i}^j d_t \pmod{9},\\
\text{Find }(L_1,L_2),\ L_1\ne L_2\ \text{s.t. }&\ a_{L_1}\cdot x + a_{L_2} \equiv k \pmod{9}.
\end{aligned}
\]
}
\ASSUMPTIONS{All indices are 1-based. Use modulo-$9$ arithmetic with residues in $\{0,\ldots,8\}$.}
\INVARIANTS{The residue $a_L$ depends only on digits in $[L,L+w-1]$. Prefix sums modulo $9$ yield $x(i,j)$ in $O(1)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Check every ordered pair of starts $(L_1,L_2)$ with $L_1\ne L_2$ among $n-w+1$ windows. Evaluate $a_{L_1},a_{L_2}$ and test $a_{L_1}\cdot x+a_{L_2}\equiv k \pmod{9}$. Keep lexicographically minimal.}
\ASSUMPTIONS{Compute $a_L$ and $x$ via digit-sum modulo $9$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $a_L$ for all $L$ by sliding window sums modulo $9$.
\item For each query, compute $x=x(l,r)$ via prefix sums modulo $9$.
\item Loop all $L_1 \ne L_2$ and test congruence; track best pair.
\end{algosteps}
\COMPLEXITY{Let $N=n-w+1$. Per query $O(N^2)$, space $O(N)$.}
\[
\begin{aligned}
T_{\text{per query}}(n) &= \Theta\big((n-w+1)^2\big) \\
&= \Theta(n^2)\ \text{in the worst case, too slow.}
\end{aligned}
\]
\CORRECTNESS{Exhaustive search enumerates all valid ordered pairs and selects the lexicographically smallest.}
\EDGECASES{If all windows share the same residue, need two distinct starts. If no pair satisfies the congruence, print $-1 -1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (Baseline brute-force; correct but intended only for tiny inputs)
from typing import List, Tuple
import sys
import io

def windows_residues(s: str, w: int) -> List[int]:
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    N = n - w + 1
    a = [0] * (N + 1)  # 1-based for convenience
    for L in range(1, N + 1):
        a[L] = (pref[L + w - 1] - pref[L - 1]) % 9
    return a

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        s = next(it)
        w = int(next(it)); m = int(next(it))
        qs = []
        for __ in range(m):
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((l, r, k))
        tests.append((s, w, m, qs))
    return tests

def solve_case_brutal(s: str, w: int, qs: List[Tuple[int,int,int]]) -> List[Tuple[int,int]]:
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    a = windows_residues(s, w)
    N = n - w + 1
    ans = []
    for (l, r, k) in qs:
        x = (pref[r] - pref[l-1]) % 9
        best = (10**9, 10**9)
        for L1 in range(1, N + 1):
            for L2 in range(1, N + 1):
                if L1 == L2: continue
                if (a[L1] * x + a[L2]) % 9 == k:
                    cand = (L1, L2)
                    if cand < best:
                        best = cand
        if best[0] == 10**9:
            ans.append((-1, -1))
        else:
            ans.append(best)
    return ans

def solve_all():
    tests = read_input()
    out_lines = []
    for (s, w, m, qs) in tests:
        # Note: Brutal is too slow for large; this is a correctness baseline.
        res = solve_case_brutal(s, w, qs)
        out_lines.extend(f"{a} {b}" for (a, b) in res)
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # Tiny correctness checks
    s = "1003004"; w = 4
    qs = [(1, 2, 1)]
    got = solve_case_brutal(s, w, qs)
    assert got == [(2, 4)]
    s = "012345"; w = 2
    # x = sum(1..4)=10 ≡ 1; k=8 -> expect (1,4)
    qs = [(2, 5, 8)]
    got = solve_case_brutal(s, w, qs)
    assert got == [(1, 4)]
    # No-solution case
    qs = [(2, 5, 0)]
    got = solve_case_brutal(s, w, qs)
    assert got == [(-1, -1)]

if __name__ == "__main__":
    # Run baseline self-tests only; avoid heavy I/O by default
    _self_test()
    # Commented out to prevent TLE on large inputs; keep API completeness.
    # solve_all()
\end{minted}
\VALIDATION{Self-test covers: sample from statement; a crafted case with unique solution; and a no-solution case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-query enumeration over residues}
\WHICHFORMULA{Instead of scanning all window pairs, precompute the two smallest starts for each residue $r \in \{0,\ldots,8\}$ among length-$w$ windows. For a query with $x$ and $k$, enumerate $r_1 \in [0,8]$ and deduce $r_2 \equiv k - r_1 x \pmod{9}$. Use the earliest start(s) per residue to form $(L_1,L_2)$.}
\ASSUMPTIONS{Store up to two smallest starts per residue to handle the $r_1=r_2$ case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build prefix sums modulo $9$ and compute each $a_L$ for $L=1\ldots n-w+1$.
\item For each residue $r$, keep a sorted list of up to two smallest starts having $a_L=r$.
\item For a query $(l,r,k)$ compute $x=x(l,r)$. For each $r_1$ compute $r_2=(k-r_1 x)\bmod 9$.
\item If $r_1 \ne r_2$ and both residue lists nonempty, candidate is $(\text{first}[r_1], \text{first}[r_2])$. If $r_1=r_2$ need at least two starts in that residue: candidate $(\text{first}[r], \text{second}[r])$.
\item Pick lexicographically minimal candidate.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n)$. Each query checks $9$ residues, $O(1)$ work each.}
\[
\begin{aligned}
T_{\text{build}} &= O(n),\quad T_{\text{per query}} = O(9)=O(1),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{If a solution exists, some residues $(r_1,r_2)$ satisfy the congruence. Choosing the earliest starts for those residues yields the lexicographically minimal $(L_1,L_2)$ among all windows with those residues, and scanning all $r_1$ ensures global minimality.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        s = next(it)
        w = int(next(it)); m = int(next(it))
        qs = []
        for __ in range(m):
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((l, r, k))
        tests.append((s, w, m, qs))
    return tests

def preprocess_pos(s: str, w: int):
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    N = n - w + 1
    pos = [[] for _ in range(9)]
    for L in range(1, N + 1):
        r = (pref[L + w - 1] - pref[L - 1]) % 9
        if len(pos[r]) < 2:
            pos[r].append(L)
    return pref, pos

def solve_case_fast(s: str, w: int, qs: List[Tuple[int,int,int]]) -> List[Tuple[int,int]]:
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref, pos = preprocess_pos(s, w)
    ans = []
    for (l, r, k) in qs:
        x = (pref[r] - pref[l-1]) % 9
        best = (10**9, 10**9)
        for r1 in range(9):
            r2 = (k - (r1 * x) % 9) % 9
            if r1 != r2:
                if pos[r1] and pos[r2]:
                    cand = (pos[r1][0], pos[r2][0])
                    if cand < best:
                        best = cand
            else:
                if len(pos[r1]) >= 2:
                    cand = (pos[r1][0], pos[r1][1])
                    if cand < best:
                        best = cand
        if best[0] == 10**9:
            ans.append((-1, -1))
        else:
            ans.append(best)
    return ans

def solve_all():
    tests = read_input()
    out_lines = []
    for (s, w, m, qs) in tests:
        res = solve_case_fast(s, w, qs)
        out_lines.extend(f"{a} {b}" for (a, b) in res)
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    s = "1003004"; w = 4
    assert solve_case_fast(s, w, [(1, 2, 1)]) == [(2, 4)]
    s = "012345"; w = 2
    assert solve_case_fast(s, w, [(2, 5, 8)]) == [(1, 4)]
    # same-residue needs two positions
    s = "909090"; w = 2  # residues: [0,0,0,0,0]
    assert solve_case_fast(s, w, [(1, 6, 0)]) == [(1, 2)]

if __name__ == "__main__":
    _self_test()
    # solve_all()
\end{minted}
\VALIDATION{Covers: example; crafted case; and a case forcing $r_1=r_2$ using two distinct starts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Precompute answers for all $(x,k)$ pairs}
\WHICHFORMULA{Since $x \in \{0,\ldots,8\}$ and $k \in \{0,\ldots,8\}$, precompute the lexicographically minimal $(L_1,L_2)$ for every $(x,k)$ once per test case using the per-residue earliest starts. Then answer each query in $O(1)$.}
\ASSUMPTIONS{Residue lists per $r$ contain at most two smallest starts. Enumerating $r_1$ for each $(x,k)$ is constant ($9$ options).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build prefix sums modulo $9$ and the two-earliest-starts lists $pos[r]$ for each residue $r$.
\item For every $x \in [0,8]$ and $k \in [0,8]$, enumerate $r_1 \in [0,8]$, set $r_2=(k-r_1 x)\bmod 9$, and assemble candidate pairs from $pos$ as in Approach B. Store lexicographically minimal or $(-1,-1)$ if none.
\item For each query, compute $x=x(l,r)$ and print the precomputed pair for $(x,k)$.
\end{algosteps}
\OPTIMALITY{Per-query time $O(1)$ is information-theoretically optimal once input is read, as each query produces a constant-size output.}
\COMPLEXITY{Preprocessing $O(n + 9\cdot 9 \cdot 9)$ per test; per query $O(1)$.}
\[
\begin{aligned}
T_{\text{build}} &= O(n) + 729,\quad T_{\text{per query}}=O(1),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import sys
import io

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        s = next(it)
        w = int(next(it)); m = int(next(it))
        qs = []
        for __ in range(m):
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((l, r, k))
        tests.append((s, w, m, qs))
    return tests

def preprocess(s: str, w: int):
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    N = n - w + 1
    pos = [[] for _ in range(9)]
    for L in range(1, N + 1):
        r = (pref[L + w - 1] - pref[L - 1]) % 9
        if len(pos[r]) < 2:
            pos[r].append(L)
    # Precompute best pair for every (x,k)
    best = [[(-1, -1) for _ in range(9)] for __ in range(9)]
    for x in range(9):
        for k in range(9):
            cur = (10**9, 10**9)
            for r1 in range(9):
                r2 = (k - (r1 * x) % 9) % 9
                if r1 != r2:
                    if pos[r1] and pos[r2]:
                        cand = (pos[r1][0], pos[r2][0])
                        if cand < cur:
                            cur = cand
                else:
                    if len(pos[r1]) >= 2:
                        cand = (pos[r1][0], pos[r1][1])
                        if cand < cur:
                            cur = cand
            if cur[0] != 10**9:
                best[x][k] = cur
    return pref, best

def solve_case(s: str, w: int, qs: List[Tuple[int,int,int]]) -> List[Tuple[int,int]]:
    pref, best = preprocess(s, w)
    out = []
    for (l, r, k) in qs:
        x = (pref[r] - pref[l-1]) % 9
        out.append(best[x][k])
    return out

def solve_all():
    tests = read_input()
    out_lines = []
    for (s, w, m, qs) in tests:
        res = solve_case(s, w, qs)
        out_lines.extend(f"{a} {b}" for (a, b) in res)
    sys.stdout.write("\n".join(out_lines))

def _run_io(inp: str) -> str:
    buf_in = io.StringIO(inp)
    buf_out = io.StringIO()
    bk_in, bk_out = sys.stdin, sys.stdout
    try:
        sys.stdin, sys.stdout = buf_in, buf_out
        solve_all()
        return buf_out.getvalue()
    finally:
        sys.stdin, sys.stdout = bk_in, bk_out

def _self_tests():
    # 1) Sample-like test from statement
    inp = "1\n1003004\n4 1\n1 2 1\n"
    out = _run_io(inp).strip()
    assert out == "2 4"
    # 2) Crafted example
    inp = "1\n012345\n2 1\n2 5 8\n"
    out = _run_io(inp).strip()
    assert out == "1 4"
    # 3) Multiple queries; includes no-solution and same-residue case
    s = "909090"; w = 2
    # residues all 0; x(l,r)=sum digits mod 9 -> 9 ≡ 0 for any full even length
    # For k=0, need two starts: expect (1,2)
    inp = f"1\n{s}\n{w} 3\n1 6 0\n1 2 1\n2 5 0\n"
    out = _run_io(inp).strip().splitlines()
    assert out[0] == "1 2"     # exists
    assert out[1] == "-1 -1"   # impossible k=1
    assert out[2] == "1 2"     # also exists

if __name__ == "__main__":
    _self_tests()
    # For submission, uncomment the next line.
    # solve_all()
\end{minted}
\VALIDATION{Exactly three asserts: a sample-like test, a crafted test, and a multi-query test including an impossible case and a same-residue case.}
\RESULT{For each query, prints the lexicographically minimal pair $(L_1,L_2)$ of distinct length-$w$ starts satisfying $a_{L_1}\cdot x + a_{L_2} \equiv k \pmod{9}$, or $-1 -1$ if none.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test helpers, then end-to-end I/O tests with tiny crafted cases that cover: unique-solution, no-solution, and $r_1=r_2$ scenarios.}
\LINE{CROSS-CHECKS}{Verify Approach B and Approach C produce identical outputs on random tiny strings and queries.}
\LINE{EDGE-CASE GENERATOR}{Generate random strings of small $n$, random $w$, and random queries; compare outputs between brute force and optimal.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def brute_force_answer(s: str, w: int, queries: List[Tuple[int,int,int]]) -> List[Tuple[int,int]]:
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    N = n - w + 1
    a = [0] * (N + 1)
    for L in range(1, N + 1):
        a[L] = (pref[L + w - 1] - pref[L - 1]) % 9
    out = []
    for (l, r, k) in queries:
        x = (pref[r] - pref[l-1]) % 9
        best = (10**9, 10**9)
        for L1 in range(1, N + 1):
            for L2 in range(1, N + 1):
                if L1 == L2: continue
                if (a[L1]*x + a[L2]) % 9 == k:
                    cand = (L1, L2)
                    if cand < best:
                        best = cand
        out.append(best if best[0] != 10**9 else (-1, -1))
    return out

def optimal_answer(s: str, w: int, queries: List[Tuple[int,int,int]]) -> List[Tuple[int,int]]:
    from collections import defaultdict
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    N = n - w + 1
    pos = [[] for _ in range(9)]
    for L in range(1, N + 1):
        r = (pref[L + w - 1] - pref[L - 1]) % 9
        if len(pos[r]) < 2:
            pos[r].append(L)
    best = [[(-1, -1) for _ in range(9)] for __ in range(9)]
    for x in range(9):
        for k in range(9):
            cur = (10**9, 10**9)
            for r1 in range(9):
                r2 = (k - (r1 * x) % 9) % 9
                if r1 != r2:
                    if pos[r1] and pos[r2]:
                        cand = (pos[r1][0], pos[r2][0])
                        if cand < cur:
                            cur = cand
                else:
                    if len(pos[r1]) >= 2:
                        cand = (pos[r1][0], pos[r1][1])
                        if cand < cur:
                            cur = cand
            if cur[0] != 10**9:
                best[x][k] = cur
    out = []
    for (l, r, k) in queries:
        x = (pref[r] - pref[l-1]) % 9
        out.append(best[x][k])
    return out

def randomized_cross_check(seed: int = 0, trials: int = 200):
    random.seed(seed)
    for _ in range(trials):
        n = random.randint(2, 15)
        s = "".join(str(random.randint(0, 9)) for _ in range(n))
        w = random.randint(1, n-1)
        m = random.randint(1, 20)
        queries = []
        for __ in range(m):
            l = random.randint(1, n)
            r = random.randint(l, n)
            k = random.randint(0, 8)
            queries.append((l, r, k))
        b = brute_force_answer(s, w, queries)
        o = optimal_answer(s, w, queries)
        assert b == o, (s, w, queries, b, o)

if __name__ == "__main__":
    randomized_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        s = next(it)
        w = int(next(it)); m = int(next(it))
        qs = []
        for __ in range(m):
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((l, r, k))
        tests.append((s, w, m, qs))
    return tests

def preprocess(s: str, w: int):
    n = len(s)
    d = [ord(c) - 48 for c in s]
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = (pref[i] + d[i]) % 9
    N = n - w + 1
    pos = [[] for _ in range(9)]
    for L in range(1, N + 1):
        r = (pref[L + w - 1] - pref[L - 1]) % 9
        if len(pos[r]) < 2:
            pos[r].append(L)
    # Precompute best (L1,L2) for each (x,k)
    best = [[(-1, -1) for _ in range(9)] for __ in range(9)]
    for x in range(9):
        for k in range(9):
            cur = (10**9, 10**9)
            for r1 in range(9):
                r2 = (k - (r1 * x) % 9) % 9
                if r1 != r2:
                    if pos[r1] and pos[r2]:
                        cand = (pos[r1][0], pos[r2][0])
                        if cand < cur:
                            cur = cand
                else:
                    if len(pos[r1]) >= 2:
                        cand = (pos[r1][0], pos[r1][1])
                        if cand < cur:
                            cur = cand
            if cur[0] != 10**9:
                best[x][k] = cur
    return pref, best

def solve_case(s: str, w: int, qs: List[Tuple[int,int,int]]) -> List[Tuple[int,int]]:
    pref, best = preprocess(s, w)
    ans = []
    for (l, r, k) in qs:
        x = (pref[r] - pref[l-1]) % 9
        ans.append(best[x][k])
    return ans

def solve_all():
    tests = read_input()
    out_lines = []
    for (s, w, m, qs) in tests:
        res = solve_case(s, w, qs)
        out_lines.extend(f"{a} {b}" for (a, b) in res)
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # Minimal internal checks
    s = "1003004"; w = 4
    assert solve_case(s, w, [(1, 2, 1)]) == [(2, 4)]
    s = "012345"; w = 2
    assert solve_case(s, w, [(2, 5, 8)]) == [(1, 4)]
    # Edge: all residues equal -> need two starts for k=0 when x=0
    s = "909090"; w = 2
    assert solve_case(s, w, [(1, 6, 0)])[0] == (1, 2)

if __name__ == "__main__":
    _self_test()
    # Uncomment next line for judge
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce substrings to modulo-$9$ digit sums and solve $a_{L_1}x + a_{L_2} \equiv k \pmod{9}$ using precomputed earliest starts per residue.}
\WHY{Classic trick: base-$10$ modulo $9$ collapses powers of $10$ to $1$, turning substrings into simple digit-sum residues and enabling constant-time answers.}
\CHECKLIST{
\begin{bullets}
\item Build prefix sums modulo $9$.
\item Compute residues of all length-$w$ windows.
\item Store up to two smallest starts for each residue $0\ldots 8$.
\item Precompute best pair for each $(x,k)$ or enumerate residues per query.
\item Ensure $L_1 \ne L_2$. Lexicographically minimize.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All windows same residue: require two distinct starts for $r_1=r_2$.
\item $x=0$: condition reduces to $a_{L_2} \equiv k$; any $a_{L_1}$ works but still need $L_1 \ne L_2$.
\item $w=1$ or $w=n-1$ extreme window counts.
\item Leading zeros allowed: handled by digit-sum modulo $9$.
\item Queries with $l=r$ (single digit).
\item No valid pair: print $-1 -1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in prefix sums ($pref[r]-pref[l-1]$).
\item Forgetting to restrict to two smallest starts per residue.
\item Mishandling $r_1=r_2$ requiring two distinct starts.
\item Negative modulo in other languages; in Python it is nonnegative.
\item Printing 0-based instead of 1-based indices.
\item Ties: must compare $(L_1,L_2)$ lexicographically.
\end{bullets}
}
\FAILMODES{Brute force per query times out. Storing only one start per residue fails when $r_1=r_2$. Using actual numeric values overflows or is unnecessary; modulo-$9$ suffices.}
\ELI{Because $10 \equiv 1 \pmod{9}$, every substring is just the sum of its digits modulo $9$. Precompute where each residue occurs earliest among fixed-size windows, and then combine residues to hit the target congruence in constant time per query.}
\NotePages{3}

\end{document}