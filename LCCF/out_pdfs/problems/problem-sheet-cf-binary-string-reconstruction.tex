% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Binary String Reconstruction}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1400/C}}
\LINE{DIFFICULTY / RATING}{CF: 1400/C \quad Rating: 1500}
\STATEMENT{Consider the following process. You have a binary string $w$ of length $n$ and an integer $x$. You build a new binary string $s$ consisting of $n$ characters. The $i$-th character of $s$ is chosen as follows:
\begin{bullets}
\item if the character $w_{i-x}$ exists and is equal to $1$, then $s_i$ is $1$ (formally, if $i > x$ and $w_{i-x} = 1$, then $s_i = 1$);
\item if the character $w_{i+x}$ exists and is equal to $1$, then $s_i$ is $1$ (formally, if $i + x \le n$ and $w_{i+x} = 1$, then $s_i = 1$);
\item if both of the aforementioned conditions are false, then $s_i$ is $0$.
\end{bullets}
You are given the integer $x$ and the resulting string $s$. Reconstruct the original string $w$.

Input: The first line contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases.

Each test case consists of two lines. The first line contains the resulting string $s$ ($2 \le |s| \le 10^5$, each character of $s$ is either $0$ or $1$). The second line contains one integer $x$ ($1 \le x \le |s| - 1$).

The total length of all strings $s$ in the input does not exceed $10^5$.

Output: For each test case, print the answer on a separate line as follows:
\begin{bullets}
\item if no string $w$ can produce the string $s$ at the end of the process, print $-1$;
\item otherwise, print the binary string $w$ consisting of $|s|$ characters. If there are multiple answers, print any of them.
\end{bullets}}
\BREAKDOWN{Exploit the forward rule: $s_i=1$ iff at least one of positions $i-x$ or $i+x$ in $w$ (when in range) is $1$. First force zeros in $w$ from positions where $s_i=0$; then verify that the resulting $w$ indeed regenerates $s$.}
\ELI{Zeros in $s$ forbid nearby ones in $w$ at distance $x$; after forbidding, check that every $1$ in $s$ still sees a $1$ at distance $x$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case: a binary string $s$ with $2 \le |s| \le 10^5$; and an integer $x$ with $1 \le x \le |s|-1$. Total $\sum |s| \le 10^5$.}
\OUTPUTS{For each case, either a valid preimage $w$ of length $|s|$ or $-1$ if impossible. Any valid $w$ is acceptable.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
3
10
1
00
1
01
1
\end{verbatim}
Output
\begin{verbatim}
01
00
-1
\end{verbatim}
\end{tcolorbox}
Example 2:
\begin{tcolorbox}
Input
\begin{verbatim}
2
111
2
0101
1
\end{verbatim}
Output
\begin{verbatim}
111
0000
\end{verbatim}
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $w \in \{0,1\}^n$ be unknown and $s \in \{0,1\}^n$ be given. Index positions are $1$-based. For fixed $x$, $s$ is generated by the logical rule: $s_i=1$ iff at least one valid neighbor at distance $x$ in $w$ is $1$.}
\varmapStart
\var{n}{length of strings}
\var{x}{given offset distance}
\var{w_i}{unknown bit at position $i$}
\var{s_i}{observed bit at position $i$}
\varmapEnd
\GOVERN{
\[
  s_i \;=\; \begin{cases}
  1, & (i-x \ge 1 \text{ and } w_{i-x}=1)\ \lor\ (i+x \le n \text{ and } w_{i+x}=1),\\
  0, & \text{otherwise},
  \end{cases}
  \quad \text{for } i=1,\ldots,n.
\]
}
\ASSUMPTIONS{Binary alphabet; indices outside $[1,n]$ are ignored; multiple valid $w$ may exist.}
\INVARIANTS{
\begin{bullets}
\item If $s_i=0$, then all existing $w_{i-x}$ and $w_{i+x}$ must be $0$.
\item If $s_i=1$, then at least one of existing $w_{i-x}$ or $w_{i+x}$ must be $1$.
\item The construction that sets forced zeros from $s_i=0$ and then validates $s$ is both necessary and sufficient.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct constraints: for every $i$ with $s_i=0$, force $w_{i-x}=0$ and $w_{i+x}=0$ when in range. Then compute $\hat{s}$ from the resulting $w$ and check $\hat{s}=s$.}
\ASSUMPTIONS{This follows the necessary constraints induced by zeros in $s$; verification guarantees correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $w$ as an all-$1$ string of length $n$.
\item For each $i$ with $s_i=0$, set $w_{i-x}=0$ and $w_{i+x}=0$ if those indices are within $[1,n]$.
\item Compute $\hat{s}$ from $w$ using the generation rule; if $\hat{s}=s$ output $w$, else output $-1$.
\end{algosteps}
\COMPLEXITY{Single linear scan to force zeros and single linear pass to verify.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(n)\ \text{for storing }w\text{ and }\hat{s}.
\end{aligned}
\]
\CORRECTNESS{All positions with $s_i=0$ forbid ones at distance $x$ in $w$; setting them to zero is necessary. If after enforcing these zeros, regenerating $s$ matches the given $s$, then all $s_i=1$ have a witness neighbor $1$ and the construction is valid; otherwise, no $w$ can satisfy the rules.}
\EDGECASES{Endpoints where $i-x<1$ or $i+x>n$; strings with all zeros; $x=1$; alternating patterns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def reconstruct_w_baseline(s: str, x: int) -> str:
    n = len(s)
    w = ['1'] * n
    # Force zeros from s_i == '0'
    for i, ch in enumerate(s):
        if ch == '0':
            if i - x >= 0:
                w[i - x] = '0'
            if i + x < n:
                w[i + x] = '0'
    # Verify by regenerating s
    if generate_s_from_w(''.join(w), x) == s:
        return ''.join(w)
    return "-1"

def generate_s_from_w(w: str, x: int) -> str:
    n = len(w)
    out = ['0'] * n
    for i in range(n):
        one = False
        if i - x >= 0 and w[i - x] == '1':
            one = True
        if i + x < n and w[i + x] == '1':
            one = True
        out[i] = '1' if one else '0'
    return ''.join(out)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        s = next(it).strip()
        x = int(next(it))
        cases.append((s, x))
    return cases

def solve_case(s: str, x: int) -> str:
    return reconstruct_w_baseline(s, x)

def solve_all(cases):
    return '\n'.join(solve_case(s, x) for (s, x) in cases)

def _tests():
    # Tiny sanity tests
    assert generate_s_from_w("01", 1) == "10"
    assert reconstruct_w_baseline("10", 1) in {"01", "-1"}
    # Known correct pairs
    assert reconstruct_w_baseline("10", 1) == "01"
    assert reconstruct_w_baseline("00", 1) == "00"
    assert reconstruct_w_baseline("01", 1) == "-1"
    # Random small consistency
    s = "111"; x = 2
    w = reconstruct_w_baseline(s, x)
    if w != "-1":
        assert generate_s_from_w(w, x) == s

def main():
    _tests()
    cases = read_input()
    if cases:
        sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked endpoints and simple patterns: "10" with $x=1$ gives "01"; "00" with $x=1$ gives "00"; "01" with $x=1$ is impossible.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Validation without Rebuilding Full $\hat{s}$}
\WHICHFORMULA{Enforce zeros as before. Instead of reconstructing $\hat{s}$, directly verify each $i$ with $s_i=1$ sees at least one $1$ in $w$ at distance $x$. This avoids building an extra string.}
\ASSUMPTIONS{Binary alphabet and identical constraint structure; early failure detection on $s_i=1$ positions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $w$ to all ones; for each $i$ with $s_i=0$, set neighbors at distance $x$ in $w$ to zero if in range.
\item For each $i$ with $s_i=1$, check whether $(i-x \ge 1 \land w_{i-x}=1)$ or $(i+x \le n \land w_{i+x}=1)$; if neither holds, return $-1$.
\item Otherwise return $w$.
\end{algosteps}
\COMPLEXITY{Same asymptotics but with slightly less constant overhead by not materializing $\hat{s}$.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(n).
\end{aligned}
\]
\CORRECTNESS{If any $s_i=1$ fails to have a witnessing neighbor $1$ in $w$, no valid $w$ exists because zeros from $s_j=0$ are necessary. If all $s_i=1$ have a witness, then the forward rule produces $s$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def reconstruct_w_improved(s: str, x: int) -> str:
    n = len(s)
    w = ['1'] * n
    # Enforce zeros from s_i == '0'
    for i, ch in enumerate(s):
        if ch == '0':
            if i - x >= 0:
                w[i - x] = '0'
            if i + x < n:
                w[i + x] = '0'
    # Validate only positions with s_i == '1'
    for i, ch in enumerate(s):
        if ch == '1':
            ok = False
            if i - x >= 0 and w[i - x] == '1':
                ok = True
            if i + x < n and w[i + x] == '1':
                ok = True
            if not ok:
                return "-1"
    return ''.join(w)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        s = next(it).strip()
        x = int(next(it))
        cases.append((s, x))
    return cases

def solve_case(s: str, x: int) -> str:
    return reconstruct_w_improved(s, x)

def solve_all(cases):
    return '\n'.join(solve_case(s, x) for (s, x) in cases)

def _tests():
    # Baseline known outcomes
    assert reconstruct_w_improved("10", 1) == "01"
    assert reconstruct_w_improved("00", 1) == "00"
    assert reconstruct_w_improved("01", 1) == "-1"
    # Extra checks
    assert reconstruct_w_improved("111", 2) == "111"
    ans = reconstruct_w_improved("0101", 1)
    assert ans in {"0000"}  # one valid output

def main():
    _tests()
    cases = read_input()
    if cases:
        sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on small crafted cases and ensured every $s_i=1$ has a neighbor witness in the produced $w$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Canonical Constraint-Then-Check Method}
\WHICHFORMULA{The necessary-zero propagation from $s_i=0$ followed by local verification for $s_i=1$ is optimal and linear.}
\ASSUMPTIONS{Applies for all $n \ge 2$ and $1 \le x \le n-1$ with binary strings.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $w$ to all ones.
\item For each $i$ with $s_i=0$, set $w_{i-x}$ and $w_{i+x}$ (if within range) to zero.
\item For each $i$ with $s_i=1$, ensure at least one of $w_{i-x}$ or $w_{i+x}$ equals one; otherwise impossible.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect $\Theta(n)$ input bits; this method is linear-time with constant passes, thus asymptotically optimal.}
\COMPLEXITY{Two linear scans of length $n$.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def reconstruct_w(s: str, x: int) -> str:
    n = len(s)
    w = ['1'] * n
    # Force zeros from s_i == '0'
    for i, ch in enumerate(s):
        if ch == '0':
            if i - x >= 0:
                w[i - x] = '0'
            if i + x < n:
                w[i + x] = '0'
    # Validate s_i == '1' have a witness
    for i, ch in enumerate(s):
        if ch == '1':
            ok = False
            if i - x >= 0 and w[i - x] == '1':
                ok = True
            if i + x < n and w[i + x] == '1':
                ok = True
            if not ok:
                return "-1"
    return ''.join(w)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        s = next(it).strip()
        x = int(next(it))
        cases.append((s, x))
    return cases

def solve_case(s: str, x: int) -> str:
    return reconstruct_w(s, x)

def solve_all(cases):
    return '\n'.join(solve_case(s, x) for (s, x) in cases)

def _tests():
    # Exactly 3 asserts
    assert solve_case("10", 1) == "01"
    assert solve_case("01", 1) == "-1"
    assert solve_case("00", 1) == "00"

def main():
    _tests()
    cases = read_input()
    if cases:
        sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: ("10",1) -> "01"; ("01",1) -> "-1"; ("00",1) -> "00".}
\RESULT{Output any valid $w$ that regenerates $s$ under the given rule, or $-1$ if no such $w$ exists.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny strings for correctness; random small cross-checks by regenerating $s$ from produced $w$; adversarial cases with clusters of zeros and ones and boundary indices.}
\LINE{CROSS-CHECKS}{Compare reconstruction result, then recompute forward $s$ and ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate patterns like all zeros, all ones, alternating, and runs separated by at least $x$ to stress neighbor logic.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def brute_generate_s(w: str, x: int) -> str:
    n = len(w)
    s = []
    for i in range(n):
        one = False
        if i - x >= 0 and w[i - x] == '1':
            one = True
        if i + x < n and w[i + x] == '1':
            one = True
        s.append('1' if one else '0')
    return ''.join(s)

def gen_cases():
    cases = []
    for n in range(2, 7):
        for x in range(1, n):
            # All zeros and all ones
            cases.append(("0"*n, x))
            cases.append(("1"*n, x))
            # Alternating
            alt = ''.join('01'[(i % 2)] for i in range(n))
            cases.append((alt, x))
    return cases
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def reconstruct_w(s: str, x: int) -> str:
    n = len(s)
    w = ['1'] * n
    # Force zeros dictated by s_i == '0'
    for i, ch in enumerate(s):
        if ch == '0':
            if i - x >= 0:
                w[i - x] = '0'
            if i + x < n:
                w[i + x] = '0'
    # Validate s_i == '1' have a witness neighbor 1 at distance x
    for i, ch in enumerate(s):
        if ch == '1':
            ok = False
            if i - x >= 0 and w[i - x] == '1':
                ok = True
            if i + x < n and w[i + x] == '1':
                ok = True
            if not ok:
                return "-1"
    return ''.join(w)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        s = next(it).strip()
        x = int(next(it))
        cases.append((s, x))
    return cases

def solve_case(s: str, x: int) -> str:
    return reconstruct_w(s, x)

def solve_all(cases):
    return '\n'.join(solve_case(s, x) for (s, x) in cases)

def _tests():
    # Quick sanity tests
    assert solve_case("10", 1) == "01"
    assert solve_case("01", 1) == "-1"
    assert solve_case("00", 1) == "00"
    # Cross-check regeneration
    def regen(w, x):  # local
        n = len(w)
        out = []
        for i in range(n):
            one = False
            if i - x >= 0 and w[i - x] == '1':
                one = True
            if i + x < n and w[i + x] == '1':
                one = True
            out.append('1' if one else '0')
        return ''.join(out)
    # Random small patterns
    for s in ["111", "000", "1010", "0101", "1100"]:
        for x in [1, 2][:]:
            ans = solve_case(s, x)
            if ans != "-1":
                assert regen(ans, x) == s

def main():
    _tests()
    cases = read_input()
    if cases:
        sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Force zeros in $w$ from $s_i=0$, then ensure every $s_i=1$ has a witnessing neighbor $1$ at distance $x$.}
\WHY{Common pattern: invert a local OR-convolution style rule by using necessary constraints and validation.}
\CHECKLIST{
\begin{bullets}
\item Read $s$ and $x$; set $w$ initially all ones.
\item For each $i$ with $s_i=0$, zero out $w_{i-x}$ and $w_{i+x}$ if in range.
\item For each $i$ with $s_i=1$, check at least one of $w_{i-x}$ or $w_{i+x}$ is one; else impossible.
\item Print $w$ or $-1$ accordingly.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $x=1$ with short strings like $n=2$.
\item All zeros $s=00\ldots0$.
\item All ones $s=11\ldots1$.
\item Alternating patterns e.g., $s=0101\ldots$ with various $x$.
\item $i-x<1$ or $i+x>n$ boundaries.
\item Single forced conflict: $s_i=1$ but both neighbors forced zero.
\item Long runs of zeros creating many forced zeros in $w$.
\item $x$ close to $n-1$ (far neighbors).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one when translating between $0$- and $1$-based indices.
\item Forgetting to check both neighbors for $s_i=1$.
\item Overwriting previously forced zeros back to ones.
\item Not handling out-of-bounds neighbors properly.
\item Building $\hat{s}$ incorrectly when verifying.
\item Mixing characters and integers in comparisons.
\item Missing the case where both neighbors are out of range for $s_i=1$.
\item Assuming uniqueness of $w$ (not required).
\end{bullets}
}
\FAILMODES{Greedy attempts that set $w_{i-x}=1$ for every $s_i=1$ can conflict with zeros forced by other positions and falsely report impossible; the constraint-then-validate approach avoids this by using necessary zeros first and only rejecting when a $1$ lacks any possible witness.}
\ELI{Zeros in $s$ block out nearby ones in $w$. After blocking, every one in $s$ must still see a one at distance $x$. If any cannot, there was never a valid original string.}
\NotePages{3}

\end{document}