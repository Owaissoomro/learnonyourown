% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Costs Using the Train Line}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-costs-using-the-train-line/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given two arrays of non-negative integers, $\text{regular}$ and $\text{express}$, each of length $n$, and a non-negative integer $\text{expressCost}$. There are stations numbered $0,1,\ldots,n$. You start at station $0$.

For each $i$ from $0$ to $n-1$ you can move from station $i$ to station $i+1$ by one of the following:
\begin{bullets}
\item Use the regular line and pay $\text{regular}[i]$.
\item Use the express train line and pay $\text{express}[i]$. However, the first time in your journey that you board the express line, you must additionally pay a one-time onboarding fee of $\text{expressCost}$. After you have paid this fee once, you may use the express line any number of times at no additional onboarding cost. Switching between regular and express after the fee is paid is free.
\end{bullets}

For each station index $j$ with $1 \le j \le n$, compute the minimum total cost to reach station $j$ from station $0$ under the above rules. Return an array $\text{ans}$ of length $n$ where $\text{ans}[j-1]$ is this minimum cost for station $j$.

Constraints (typical): $1 \le n \le 10^5$; $0 \le \text{regular}[i], \text{express}[i], \text{expressCost} \le 10^9$. All results fit in 64-bit signed integer.}
\BREAKDOWN{Model the journey as a shortest-path or dynamic programming problem with a boolean state indicating whether the express onboarding fee has been paid. The answer for station $j$ is the minimum of the costs for states that end at station $j$.}
\ELI{Pay the one-time fee the first time you ride the express; after that, each step costs the cheaper of regular or express.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function signature:
\begin{itemize}
\item $\text{regular}$: list of $n$ non-negative integers; $\text{regular}[i]$ is the regular cost to go from station $i$ to $i+1$.
\item $\text{express}$: list of $n$ non-negative integers; $\text{express}[i]$ is the express cost to go from station $i$ to $i+1$.
\item $\text{expressCost}$: non-negative integer, the one-time fee to board the express line the first time.
\end{itemize}}
\OUTPUTS{List $\text{ans}$ of length $n$, where $\text{ans}[j-1]$ is the minimum total cost to reach station $j$ from station $0$.}
\SAMPLES{Example 1:
\begin{BreakableEquation*}
\text{regular}=[1,3,2],\;\text{express}=[2,1,3],\;\text{expressCost}=2\;\Rightarrow\;\text{ans}=[1,4,6].
\end{BreakableEquation*}
Example 2:
\begin{BreakableEquation*}
\text{regular}=[2,2,1],\;\text{express}=[1,2,2],\;\text{expressCost}=1\;\Rightarrow\;\text{ans}=[2,4,5].
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let stations be $0,\ldots,n$. Define two cost-to-reach states:
\begin{bullets}
\item $a_i$: minimum cost to reach station $i$ having never boarded express yet (fee not paid).
\item $b_i$: minimum cost to reach station $i$ having boarded express at least once (fee paid).
\end{bullets}
We seek $\text{ans}_j=\min(a_j,b_j)$ for $j=1,\ldots,n$.}
\varmapStart
\var{n}{number of legs; $\lvert\text{regular}\rvert=\lvert\text{express}\rvert=n$}
\var{\text{regular}[i]}{cost of regular edge $i \to i+1$}
\var{\text{express}[i]}{cost of express edge $i \to i+1$}
\var{\text{expressCost}}{one-time onboarding fee for express}
\var{a_i}{min cost to reach station $i$ without boarding express}
\var{b_i}{min cost to reach station $i$ after having boarded express}
\var{\text{ans}_j}{answer for station $j$, $\min(a_j,b_j)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
a_0 &= 0, \qquad b_0 = +\infty,\\
a_{i+1} &= a_i + \text{regular}[i],\\
b_{i+1} &= \min\bigl(b_i + \min(\text{regular}[i],\text{express}[i]),\; a_i + \text{expressCost} + \text{express}[i]\bigr),\\
\text{ans}_j &= \min(a_j,b_j)\quad\text{for }j=1,\ldots,n.
\end{aligned}
\]
}
\ASSUMPTIONS{All costs are non-negative; onboarding fee is paid at the first use of express; after paying, switching between lines is free.}
\INVARIANTS{
\begin{bullets}
\item $a_i$ is non-decreasing with $i$ and equals $\sum_{k=0}^{i-1}\text{regular}[k]$.
\item $b_i \le a_i + \text{expressCost} + \sum_{k=0}^{i-1}\text{express}[k]$ (using express from start is an upper bound).
\item $\text{ans}_i=\min(a_i,b_i)$ is non-decreasing in $i$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model as shortest paths on a layered directed acyclic graph with three layers encoding payment state and current line; run Dijkstra.}
\ASSUMPTIONS{All edge weights are non-negative; we can generate neighbors on-the-fly to avoid explicit $O(n)$-sized adjacency lists per node.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build conceptual nodes $(i,s)$ for $i\in[0..n]$ and $s\in\{\text{R0},\text{E1},\text{R1}\}$:
  R0 = regular, fee not paid; E1 = on express, fee paid; R1 = regular, fee paid.
\item Add edges per $i\in[0..n-1]$: R0$(i)\to$R0$(i+1)$ with $\text{regular}[i]$; R1$(i)\to$R1$(i+1)$ with $\text{regular}[i]$; E1$(i)\to$E1$(i+1)$ with $\text{express}[i]$. Switching at any station $i$: R0$(i)\to$E1$(i)$ with $\text{expressCost}$; E1$(i)\to$R1$(i)$ with $0$; R1$(i)\to$E1$(i)$ with $0$.
\item Run Dijkstra from R0$(0)$. For each $j=1..n$, the answer is $\min\{\text{dist}(\text{R0}(j)),\text{dist}(\text{E1}(j)),\text{dist}(\text{R1}(j))\}$.
\end{algosteps}
\COMPLEXITY{Dijkstra over $3(n+1)$ nodes and $O(n)$ edges, so $T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O\big((n + n)\log(n)\big) = O(n\log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{The layered graph faithfully encodes costs and the one-time onboarding constraint using state E1/R1 to represent “fee paid”. All paths from R0$(0)$ to any $(j,\cdot)$ correspond to feasible journeys with the same cost, and vice versa. Dijkstra finds the minimum cost among these.}
\EDGECASES{Zero costs, $\text{expressCost}=0$, always-regular-better, always-express-better, $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        n = len(regular)
        # Node indexing: R0(i)=i, E1(i)=(n+1)+i, R1(i)=2*(n+1)+i for i in [0..n]
        def idx_R0(i: int) -> int: return i
        def idx_E1(i: int) -> int: return (n + 1) + i
        def idx_R1(i: int) -> int: return 2 * (n + 1) + i

        N = 3 * (n + 1)
        INF = 10**30
        dist = [INF] * N
        start = idx_R0(0)
        dist[start] = 0
        pq: List[Tuple[int, int]] = [(0, start)]

        while pq:
            d, u = heapq.heappop(pq)
            if d != dist[u]:
                continue
            # decode node
            if u < (n + 1):
                layer = "R0"; i = u
            elif u < 2 * (n + 1):
                layer = "E1"; i = u - (n + 1)
            else:
                layer = "R1"; i = u - 2 * (n + 1)
            # neighbors along the line (forward move)
            if i < n:
                if layer == "R0":
                    v, w = idx_R0(i + 1), regular[i]
                    if dist[v] > d + w:
                        dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
                elif layer == "E1":
                    v, w = idx_E1(i + 1), express[i]
                    if dist[v] > d + w:
                        dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
                else:  # R1
                    v, w = idx_R1(i + 1), regular[i]
                    if dist[v] > d + w:
                        dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
            # switch edges at station i
            if layer == "R0":
                v, w = idx_E1(i), expressCost
                if dist[v] > d + w:
                    dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
            elif layer == "E1":
                v, w = idx_R1(i), 0
                if dist[v] > d + w:
                    dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
            else:  # R1
                v, w = idx_E1(i), 0
                if dist[v] > d + w:
                    dist[v] = d + w; heapq.heappush(pq, (dist[v], v))

        ans = []
        for j in range(1, n + 1):
            best = min(dist[idx_R0(j)], dist[idx_E1(j)], dist[idx_R1(j)])
            ans.append(best)
        return ans

# Basic asserts
if __name__ == "__main__":
    s = Solution()
    assert s.minimumCosts([1,3,2], [2,1,3], 2) == [1,4,6]
    assert s.minimumCosts([2,2,1], [1,2,2], 1) == [2,4,5]
    assert s.minimumCosts([5], [1], 0) == [0 + min(5,1)]
\end{minted}
\VALIDATION{Cross-check sample cases; verify $n=1$ and $\text{expressCost}=0$ behave as expected.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Collapse to a 2-state DP tracking whether the express has ever been used: $a_i$ (not used) and $b_i$ (used). This removes the need for a priority queue and yields linear time.}
\ASSUMPTIONS{Non-negative edge costs; onboarding fee applied only on the first express step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a_0=0$, $b_0=+\infty$.
\item For each leg $i=0..n-1$:
  \begin{bullets}
  \item $a_{i+1}=a_i+\text{regular}[i]$.
  \item $b_{i+1}=\min\bigl(b_i+\min(\text{regular}[i],\text{express}[i]),\; a_i+\text{expressCost}+\text{express}[i]\bigr)$.
  \end{bullets}
\item At each station $j$, record $\text{ans}[j-1]=\min(a_j,b_j)$.
\end{algosteps}
\COMPLEXITY{Linear time and constant extra space beyond the output.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1) \text{ (excluding the output)}.
\end{aligned}
\]
\CORRECTNESS{The state $a_i$ forbids any express usage, so it must follow only regular edges. The state $b_i$ captures all paths that have paid the fee: it can traverse either line at each subsequent step at the cheaper per-leg cost, and it can be entered exactly once by paying $\text{expressCost}$ when taking express the first time. The minimum over $a_j,b_j$ is the true optimum at station $j$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        n = len(regular)
        INF = 10**30
        a = 0           # a_0
        b = INF         # b_0
        ans: List[int] = []
        for i in range(n):
            na = a + regular[i]
            nb = min(b + min(regular[i], express[i]), a + expressCost + express[i])
            a, b = na, nb
            ans.append(min(a, b))
        return ans

# Basic asserts
if __name__ == "__main__":
    s = Solution()
    assert s.minimumCosts([1,3,2], [2,1,3], 2) == [1,4,6]
    assert s.minimumCosts([2,2,1], [1,2,2], 1) == [2,4,5]
    # Edge: express never beneficial
    assert s.minimumCosts([1,1,1], [10,10,10], 5) == [1,2,3]
\end{minted}
\VALIDATION{Compares well with baseline on samples; handles express never used and always used regimes.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two-state DP with space optimization and streaming output; identical recurrences as in Approach B.}
\ASSUMPTIONS{Costs are non-negative so greedy transitions via $\min(\text{regular}[i],\text{express}[i])$ after paying are optimal.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain two running totals $a$ and $b$ as in Approach B.
\item Update along the array and emit $\min(a,b)$ per station.
\item Use 64-bit integer space to avoid overflow in other languages; Python int is unbounded.
\end{algosteps}
\OPTIMALITY{Any feasible path is classified by whether it has boarded express. Once boarded, paying the one-time fee is sunk and the cheapest per-leg cost dominates at every subsequent leg. The DP captures the exact Bellman optimality equations, giving an $O(n)$ lower bound that is tight.}
\COMPLEXITY{$T(n)=O(n)$, $S(n)=O(1)$ beyond output.}
\[
\begin{aligned}
T(n) &= O(n). 
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        n = len(regular)
        INF = 10**30
        a = 0        # cost without having used express yet
        b = INF      # cost after having used express at least once
        ans: List[int] = []
        for i in range(n):
            next_a = a + regular[i]
            next_b = min(b + min(regular[i], express[i]),
                         a + expressCost + express[i])
            a, b = next_a, next_b
            ans.append(min(a, b))
        return ans

# Exact 3 asserts or I/O mini-tests
if __name__ == "__main__":
    s = Solution()
    assert s.minimumCosts([1,3,2], [2,1,3], 2) == [1,4,6]
    assert s.minimumCosts([2,2,1], [1,2,2], 1) == [2,4,5]
    assert s.minimumCosts([5], [1], 0) == [1]
\end{minted}
\VALIDATION{Three asserts cover typical, mixed, and zero-fee cases.}
\RESULT{Returns the minimum cumulative cost to reach each station $1..n$, respecting the one-time express onboarding fee and allowing free switching thereafter.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted cases: all-regular, all-express, mixed with late onboarding, zero onboarding fee, large values to test accumulation. Property test: DP result equals Dijkstra baseline for random small $n$.}
\LINE{CROSS-CHECKS}{Compare Approach A (Dijkstra) and Approach C (DP) on random instances for $n\le 20$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with zeros, equal costs, monotone increasing/decreasing costs, and random noise; include $\text{expressCost}\in\{0,1,10^6\}$.}
\begin{minted}{python}
from typing import List, Tuple
import random
import heapq

def baseline_dijkstra(regular: List[int], express: List[int], expressCost: int) -> List[int]:
    n = len(regular)
    def idx_R0(i: int) -> int: return i
    def idx_E1(i: int) -> int: return (n + 1) + i
    def idx_R1(i: int) -> int: return 2 * (n + 1) + i
    N = 3 * (n + 1)
    INF = 10**30
    dist = [INF] * N
    start = idx_R0(0); dist[start] = 0
    pq = [(0, start)]
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        if u < (n + 1):
            layer = "R0"; i = u
        elif u < 2 * (n + 1):
            layer = "E1"; i = u - (n + 1)
        else:
            layer = "R1"; i = u - 2 * (n + 1)
        if i < n:
            if layer == "R0":
                v, w = idx_R0(i + 1), regular[i]
            elif layer == "E1":
                v, w = idx_E1(i + 1), express[i]
            else:
                v, w = idx_R1(i + 1), regular[i]
            if dist[v] > d + w:
                dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
        if layer == "R0":
            v, w = idx_E1(i), expressCost
            if dist[v] > d + w:
                dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
        elif layer == "E1":
            v, w = idx_R1(i), 0
            if dist[v] > d + w:
                dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
        else:
            v, w = idx_E1(i), 0
            if dist[v] > d + w:
                dist[v] = d + w; heapq.heappush(pq, (dist[v], v))
    return [min(dist[idx_R0(j)], dist[idx_E1(j)], dist[idx_R1(j)]) for j in range(1, n + 1)]

class Solution:
    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        n = len(regular)
        INF = 10**30
        a = 0
        b = INF
        ans: List[int] = []
        for i in range(n):
            na = a + regular[i]
            nb = min(b + min(regular[i], express[i]), a + expressCost + express[i])
            a, b = na, nb
            ans.append(min(a, b))
        return ans

def run_cross_checks():
    rng = random.Random(12345)
    for _ in range(200):
        n = rng.randint(1, 20)
        regular = [rng.randint(0, 9) for _ in range(n)]
        express = [rng.randint(0, 9) for _ in range(n)]
        expressCost = rng.randint(0, 20)
        ref = baseline_dijkstra(regular, express, expressCost)
        got = Solution().minimumCosts(regular, express, expressCost)
        assert ref == got, (regular, express, expressCost, ref, got)

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        n = len(regular)
        INF = 10**30
        a = 0        # cost without having used express yet
        b = INF      # cost after having used express at least once
        ans: List[int] = []
        for i in range(n):
            next_a = a + regular[i]
            next_b = min(b + min(regular[i], express[i]),
                         a + expressCost + express[i])
            a, b = next_a, next_b
            ans.append(min(a, b))
        return ans

# Sanity checks
if __name__ == "__main__":
    s = Solution()
    assert s.minimumCosts([1,3,2], [2,1,3], 2) == [1,4,6]
    assert s.minimumCosts([2,2,1], [1,2,2], 1) == [2,4,5]
    assert s.minimumCosts([0,0,0], [0,0,0], 0) == [0,0,0]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Track whether the express has been used; once paid, each leg costs the cheaper of regular and express.}
\WHY{A classic two-state DP that tests your ability to model a one-time fee and mode switching under cumulative costs.}
\CHECKLIST{
\begin{bullets}
\item Define states: not-yet-used-express vs used-express.
\item Initialize $a_0=0$, $b_0=+\infty$.
\item Update $a$ with regular cost only.
\item Update $b$ with either onboarding+express or continue with $\min(\text{regular},\text{express})$.
\item Append $\min(a,b)$ each step.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $\text{expressCost}=0$.
\item $\text{regular}[i]=0$ or $\text{express}[i]=0$.
\item Express always worse than regular.
\item Express always better than regular even with fee.
\item $n=1$.
\item Large costs requiring 64-bit accumulation.
\item Early onboarding optimal vs late onboarding optimal.
\item Alternating cheaper line across legs.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Double-charging the onboarding fee when switching back to express.
\item Using $\min(\text{regular},\text{express})$ before paying the fee.
\item Off-by-one between legs $i$ and stations $i+1$.
\item Forgetting that the answer at station $j$ is $\min(a_j,b_j)$.
\item Overflow in languages without big integers.
\item Incorrect Dijkstra layering that allows multiple payments without state.
\end{bullets}}
\FAILMODES{Graph approaches with only two layers (regular vs express) overcharge upon re-entering express; naive greedy that decides per leg without state fails when the fee changes future choices. The DP survives by explicitly encoding the fee-paid state.}
\ELI{Before you pay the fee, you can only take regular steps. When you decide to pay the fee and take your first express step, you add the fee once. After that, each step just costs the cheaper of the two lines. Keep the best totals for these two phases and take the minimum at each station.}
\NotePages{3}

\end{document}