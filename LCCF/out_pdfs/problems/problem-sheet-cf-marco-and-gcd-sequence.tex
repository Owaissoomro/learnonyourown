% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Marco and GCD Sequence}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/894/C}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{In a dream Marco met an elderly man with a pair of black glasses. The man told him the key to immortality and then disappeared with the wind of time.

When he woke up, he only remembered that the key was a sequence of positive integers of some length $n$, but forgot the exact sequence. Let the elements of the sequence be $a_1, a_2, \ldots, a_n$. He remembered that he calculated $\gcd(a_i, a_{i+1}, \ldots, a_j)$ for every $1 \le i \le j \le n$ and put it into a set $S$. $\gcd$ here means the greatest common divisor.

Note that even if a number is put into the set $S$ twice or more, it only appears once in the set.

Now Marco gives you the set $S$ and asks you to help him figure out the initial sequence. If there are many solutions, print any of them. It is also possible that there are no sequences that produce the set $S$, in this case print $-1$.

Input:
The first line contains a single integer $m$ ($1 \le m \le 1000$) — the size of the set $S$.

The second line contains $m$ integers $s_1, s_2, \ldots, s_m$ ($1 \le s_i \le 10^6$) — the elements of the set $S$. It is guaranteed that the elements of the set are given in strictly increasing order, that means $s_1 < s_2 < \ldots < s_m$.

Output:
If there is no solution, print a single line containing $-1$.

Otherwise, in the first line print a single integer $n$ denoting the length of the sequence, $n$ should not exceed $4000$.

In the second line print $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^6$) — the sequence.

We can show that if a solution exists, then there is a solution with $n$ not exceeding $4000$ and $a_i$ not exceeding $10^6$.

If there are multiple solutions, print any of them.

Note:
In the first example $2 = \gcd(4, 6)$, the other elements from the set appear in the sequence, and we can show that there are no values different from $2, 4, 6$ and $12$ among $\gcd(a_i, a_{i+1}, \ldots, a_j)$ for every $1 \le i \le j \le n$.}
\BREAKDOWN{Recognize the necessary and sufficient feasibility condition: the set $S$ must be closed under $\gcd$. If closed, output any sequence that yields exactly $S$ as the set of all contiguous subarray gcds; a simple valid choice is to output the numbers of $S$ themselves.}
\ELI{Check that taking $\gcd$ of any two numbers in $S$ never leaves $S$; if so, just print the sorted set as the sequence.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $m$ ($1 \le m \le 1000$).
- Strictly increasing sequence $s_1 < s_2 < \ldots < s_m$, each in $[1, 10^6]$.}
\OUTPUTS{Either a single line $-1$ if impossible; otherwise two lines:
- $n$ (length of sequence), with $1 \le n \le 4000$.
- $a_1, a_2, \ldots, a_n$ with each $a_i \in [1, 10^6]$.}
\SAMPLES{Example 1:
- Input:
  - $m=4$
  - $S = [2, 4, 6, 12]$
- Output:
  - $n=4$
  - Sequence: $2~4~6~12$

Example 2:
- Input:
  - $m=3$
  - $S = [2, 3, 6]$
- Output:
  - $-1$ (because $\gcd(2,3)=1 \notin S$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite strictly increasing set $S \subset \mathbb{Z}_{>0}$, find a sequence $A=(a_1,\ldots,a_n)$ with $n \ge 1$ such that
\begin{BreakableEquation*}
\{\gcd(a_i, a_{i+1}, \ldots, a_j) \mid 1 \le i \le j \le n\} = S.
\end{BreakableEquation*}
Decide feasibility and output any valid $A$ if feasible.}
\varmapStart
\var{S}{given sorted set $\{s_1<\ldots<s_m\}$}
\var{A}{unknown sequence $(a_1,\ldots,a_n)$ to construct}
\var{G_{i,j}}{$\gcd(a_i,\ldots,a_j)$; contiguous subarray gcd}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility condition: } \forall x,y \in S:\ \gcd(x,y) \in S.\\
&\text{One valid construction if feasible: } A = (s_1, s_2, \ldots, s_m).
\end{aligned}
\]
}
\ASSUMPTIONS{The input $S$ is strictly increasing and within bounds. If feasible, $n \le 4000$ is guaranteed by the construction $n=m \le 1000$.}
\INVARIANTS{
- Closure: If $S$ is closed under $\gcd$, then folding $\gcd$ across any contiguous block never leaves $S$.
- Coverage: For $A=S$, each $s_k \in S$ appears as a singleton subarray gcd.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the necessary and sufficient condition that $S$ must be closed under pairwise $\gcd$. If true, output the sequence $A=S$ (the members of $S$ in the given order).}
\ASSUMPTIONS{No optimization; check all ordered pairs $(i,j)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $m$ and the sorted list $S$.
\item Build a hash set for $S$ for $O(1)$ membership checks.
\item For all $0 \le i,j < m$, compute $d=\gcd(s_i,s_j)$ and verify $d \in S$; if any fail, print $-1$.
\item Otherwise print $n=m$ and the sequence equal to $S$. 
\end{algosteps}
\COMPLEXITY{$T(m)=O(m^2 \log V)$ with $V=\max S$, and $S(m)=O(m)$.}
\[
\begin{aligned}
T(m) &= m^2 \cdot T_{\gcd}(V) + O(m) \\
     &\approx O(m^2 \log V).
\end{aligned}
\]
\CORRECTNESS{If any $\gcd$ of two set elements leaves $S$, no sequence can have $S$ as the set of all subarray gcds since any subarray gcd can be expressed as an iterated $\gcd$ of elements that themselves are subarray gcds. Conversely, if closed, the sequence $A=S$ yields exactly $S$: every $s_k$ appears as a singleton gcd, and folding $\gcd$ over any interval stays within $S$.}
\EDGECASES{Single element set; presence/absence of $1$; large values; $m=1000$; strictly increasing guaranteed.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from math import gcd
import sys

def read_input_from_tokens(tokens):
    it = iter(tokens)
    try:
        m = int(next(it))
    except StopIteration:
        return None
    S = [int(next(it)) for _ in range(m)]
    return S

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    return read_input_from_tokens(data)

def is_closed_under_gcd(S):
    setS = set(S)
    m = len(S)
    for i in range(m):
        for j in range(m):
            if gcd(S[i], S[j]) not in setS:
                return False
    return True

def solve_case(S):
    if not is_closed_under_gcd(S):
        return None
    # Sequence equals the set itself
    return S[:]  # copy

def solve_all():
    S = read_input()
    if S is None:
        return
    ans = solve_case(S)
    out = []
    if ans is None:
        out.append("-1")
    else:
        out.append(str(len(ans)))
        out.append(" ".join(map(str, ans)))
    sys.stdout.write("\n".join(out))

def main():
    solve_all()

if __name__ == "__main__":
    # Tiny self-tests (do not print on success)
    assert solve_case([2,4,6,12]) == [2,4,6,12]
    assert solve_case([1]) == [1]
    assert solve_case([2,3,6]) is None  # gcd(2,3)=1 not in S
    # No stdin -> no output. With stdin, solves the single case.
    main()
\end{minted}
\VALIDATION{Checked: 
- Valid closed set $[2,4,6,12]$ returns itself.
- Single-element $[1]$ returns itself.
- Non-closed $[2,3,6]$ returns impossible.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Pairwise Check}
\WHICHFORMULA{Exploit symmetry $\gcd(x,y)=\gcd(y,x)$ and early pruning: first check that the minimum $s_1$ divides all elements (a necessary condition), then check only pairs with $i \le j$.}
\ASSUMPTIONS{Membership in $S$ is $O(1)$ via a hash set; $\gcd$ cost is negligible for $m \le 1000$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Verify $\forall k:\ s_k \bmod s_1 = 0$; if not, impossible.
\item For $0 \le i \le j < m$, ensure $\gcd(s_i,s_j) \in S$; early exit on first failure.
\item Output $A=S$ if all checks pass.
\end{algosteps}
\COMPLEXITY{Same asymptotic but nearly halves the pairwise checks.}
\[
\begin{aligned}
T(m) &= O\!\left(m + \frac{m(m+1)}{2}\log V\right) = O(m^2 \log V).
\end{aligned}
\]
\CORRECTNESS{Divisibility by the minimum is necessary because $s_1$ must be the gcd of itself with any $s_k$. Limiting to $i \le j$ preserves completeness due to commutativity of $\gcd$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from math import gcd
import sys

def read_input_tokens(tokens):
    it = iter(tokens)
    try:
        m = int(next(it))
    except StopIteration:
        return None
    S = [int(next(it)) for _ in range(m)]
    return S

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    return read_input_tokens(data)

def feasible_and_sequence(S):
    m = len(S)
    setS = set(S)
    smin = S[0]
    # Necessary condition: smin divides all
    for x in S:
        if x % smin != 0:
            return None
    # Symmetric pairwise gcd check
    for i in range(m):
        for j in range(i, m):
            if gcd(S[i], S[j]) not in setS:
                return None
    return S[:]  # valid sequence

def solve_all():
    S = read_input()
    if S is None:
        return
    ans = feasible_and_sequence(S)
    if ans is None:
        print(-1)
    else:
        print(len(ans))
        print(*ans)

def main():
    solve_all()

if __name__ == "__main__":
    # Asserts
    assert feasible_and_sequence([2,4,6,12]) == [2,4,6,12]
    assert feasible_and_sequence([3,6,9]) == [3,6,9]
    assert feasible_and_sequence([2,3,6]) is None
    main()
\end{minted}
\VALIDATION{Covers:
- Proper multiples of minimum (3,6,9) succeed.
- Non-closed (2,3,6) fails.
- Mixed set (2,4,6,12) succeeds.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closure Test and Direct Construction}
\WHICHFORMULA{Characterize feasibility by the closure of $S$ under $\gcd$ and construct $A=S$. This is optimal in time and output size for the constraints.}
\ASSUMPTIONS{Input set is sorted; $m \le 1000$; computing $\gcd$ is fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Put $S$ into a hash set for membership.
\item For all $i \le j$, ensure $\gcd(s_i,s_j) \in S$.
\item If any check fails, print $-1$; else print $n=m$ and $A=S$.
\end{algosteps}
\OPTIMALITY{Any algorithm must, in the worst case, inspect $\Theta(m^2)$ pairwise interactions to certify closure. The output sequence has minimal length $m$ because each element of $S$ must appear as a subarray gcd at least once.}
\COMPLEXITY{$T(m)=O(m^2 \log V)$, $S(m)=O(m)$.}
\[
\begin{aligned}
T(m) &= \Theta(m^2 \log V).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from math import gcd
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    m = int(next(it))
    S = [int(next(it)) for _ in range(m)]
    return S

def is_closed(S):
    setS = set(S)
    m = len(S)
    for i in range(m):
        for j in range(i, m):
            if gcd(S[i], S[j]) not in setS:
                return False
    return True

def solve_case(S):
    if not is_closed(S):
        return None
    return S[:]  # sequence equals the set

def solve_all():
    S = read_input()
    if S is None:
        return
    ans = solve_case(S)
    if ans is None:
        print(-1)
    else:
        print(len(ans))
        print(*ans)

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case([2,4,6,12]) == [2,4,6,12]
    assert solve_case([1,2,4,8]) == [1,2,4,8]
    assert solve_case([2,3,6]) is None
    main()
\end{minted}
\VALIDATION{Asserted three cases: a typical closed set, a set containing $1$, and a failing non-closed set.}
\RESULT{Print $-1$ when not closed under $\gcd$; otherwise output $n=m$ and the sequence equal to the given sorted set $S$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for closure detection; random fuzzing by generating random sets and closing them under $\gcd$; adversarial cases with missing $\gcd$.}
\LINE{CROSS-CHECKS}{Compare baseline vs improved vs final on crafted inputs to ensure identical outputs or identical impossibility verdicts.}
\LINE{EDGE-CASE GENERATOR}{Generates sets with $m=1$, sets including $1$, arithmetic progressions scaled by a base, and sets violating divisibility by the minimum.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from math import gcd
import random

def close_under_gcd(sorted_list):
    S = set(sorted_list)
    changed = True
    while changed:
        changed = False
        L = sorted(S)
        for i in range(len(L)):
            for j in range(i, len(L)):
                d = gcd(L[i], L[j])
                if d not in S:
                    S.add(d)
                    changed = True
    return sorted(S)

def gen_edge_cases():
    cases = []
    # Single element
    cases.append([7])
    # Includes 1
    cases.append([1, 2, 3, 6])
    # Multiples of a base
    cases.append([5, 10, 15, 20])
    # Non-closed: gcd(6,10)=2 missing
    cases.append([6, 10, 15])
    # Powers of two
    cases.append([2, 4, 8, 16])
    # Missing 1 despite coprimes present
    cases.append([2, 9, 18])
    return cases

def reference_solve(S):
    setS = set(S)
    m = len(S)
    for i in range(m):
        for j in range(i, m):
            if gcd(S[i], S[j]) not in setS:
                return None
    return S[:]

def run_tests():
    # Edge cases
    for S in gen_edge_cases():
        ans = reference_solve(S)
        # If closed, the answer must be S; else None
        if ans is not None:
            assert ans == S
        else:
            # Verify non-closure witness exists
            ok = True
            setS = set(S)
            m = len(S)
            w = None
            for i in range(m):
                for j in range(i, m):
                    if gcd(S[i], S[j]) not in setS:
                        ok = False
                        w = (S[i], S[j])
                        break
                if not ok:
                    break
            assert not ok and w is not None
    # Random: create random base and multiples, then optionally close
    random.seed(0)
    for _ in range(50):
        base = random.randint(1, 50)
        L = sorted(set(base * random.randint(1, 20) for _ in range(8)))
        if random.choice([True, False]):
            S = close_under_gcd(L)
            assert reference_solve(S) == S
        else:
            S = L
            ans = reference_solve(S)
            if ans is not None:
                assert ans == S

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from math import gcd
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    m = int(next(it))
    S = [int(next(it)) for _ in range(m)]
    return S

def is_closed_under_gcd(S):
    setS = set(S)
    m = len(S)
    for i in range(m):
        for j in range(i, m):
            if gcd(S[i], S[j]) not in setS:
                return False
    return True

def solve_case(S):
    return S[:] if is_closed_under_gcd(S) else None

def main():
    S = read_input()
    if S is None:
        return
    ans = solve_case(S)
    if ans is None:
        print(-1)
    else:
        print(len(ans))
        print(*ans)

if __name__ == "__main__":
    # Sanity asserts
    assert solve_case([2,4,6,12]) == [2,4,6,12]
    assert solve_case([1]) == [1]
    assert solve_case([2,3,6]) is None
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Feasibility equals closure of $S$ under $\gcd$; if closed, print the set itself as the sequence.}
\WHY{Sets of subarray gcds form a $\gcd$-closed set; recognizing and using this algebraic structure is a classic insight in number-theoretic array problems.}
\CHECKLIST{
- Read $m$ and $S$; ensure sorted as given.
- Build membership set.
- Check all $\gcd(s_i,s_j) \in S$ for $i \le j$.
- If any fail, print $-1$.
- Else print $n=m$ and the list $S$.}
\EDGECASES{
- $m=1$ (always feasible; answer is $[s_1]$).
- $1 \in S$ implies many gcds collapse to $1$; closure must include $1$.
- Non-multiples of $\min(S)$ indicate impossibility quickly.
- Large values near $10^6$; ensure no overflow in other languages.
- Already closed sets with sparse elements.
- Cases where $\gcd$ of neighbors introduces small divisors not present.}
\PITFALLS{
- Forgetting to include $i=j$ pairs (though harmless, closure must hold).
- Using a list for membership checks instead of a set (slow).
- Printing extra whitespace or wrong formatting across lines.
- Assuming the sequence must be strictly increasing; it need not be, but printing $S$ works.
- Misreading $10^6$ as $106$.
- Not short-circuiting on failure, wasting time.}
\FAILMODES{Any approach that does not check $\gcd$-closure can output a sequence that produces gcds outside $S$, violating the requirement. The closure test prevents this.}
\ELI{All subarray gcds form a set that is stable under taking gcds again. So just check that the given $S$ has this property; if it does, listing the elements of $S$ as the array works perfectly.}
\NotePages{3}

\end{document}