% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Uncrossed Lines}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/uncrossed-lines/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given two integer arrays \texttt{nums1} and \texttt{nums2}. We write the integers of \texttt{nums1} and \texttt{nums2} (in the order they are given) on two separate horizontal lines.

We may draw connecting lines: a straight line connecting two numbers \texttt{nums1[i]} and \texttt{nums2[j]} such that:
\begin{bullets}
\item \texttt{nums1[i] == nums2[j]}, and
\item the line we draw does not intersect any other connecting (non-horizontal) line.
\end{bullets}

Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way.

Examples:
\begin{bullets}
\item Input: \texttt{nums1 = [1,4,2]}, \texttt{nums2 = [1,2,4]}; Output: \texttt{2}. Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from \texttt{nums1[1] = 4} to \texttt{nums2[2] = 4} will intersect the line from \texttt{nums1[2] = 2} to \texttt{nums2[1] = 2}.
\item Input: \texttt{nums1 = [2,5,1,2,5]}, \texttt{nums2 = [10,5,2,1,5,2]}; Output: \texttt{3}.
\item Input: \texttt{nums1 = [1,3,7,1,7,5]}, \texttt{nums2 = [1,9,2,5,1]}; Output: \texttt{2}.
\end{bullets}

Constraints:
\begin{bullets}
\item $1 \le \texttt{nums1.length}, \texttt{nums2.length} \le 500$,
\item $1 \le \texttt{nums1[i]}, \texttt{nums2[j]} \le 2000$.
\end{bullets}}
\BREAKDOWN{Model each connecting line as pairing equal elements with preserved order on both arrays; this is exactly the Longest Common Subsequence (LCS) of \texttt{nums1} and \texttt{nums2}. Compute the LCS length.}
\ELI{Count the most matches you can take in order from both arrays without reordering, which is the LCS.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two arrays of integers \texttt{nums1}, \texttt{nums2}. Valid lengths: $1 \le n,m \le 500$. Each value in $[1,2000]$.}
\OUTPUTS{A single integer: the maximum number of non-intersecting connecting lines, i.e., the LCS length of the two arrays.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{nums1=[1,4,2]}, \texttt{nums2=[1,2,4]} $\to$ Output: \texttt{2}
\item Input: \texttt{nums1=[2,5,1,2,5]}, \texttt{nums2=[10,5,2,1,5,2]} $\to$ Output: \texttt{3}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let sequences $A=(a_1,\ldots,a_n)$ and $B=(b_1,\ldots,b_m)$. Find the length of the longest common subsequence of $A$ and $B$.}
\varmapStart
\var{n,m}{Lengths of the two sequences}
\var{a_i,b_j}{Elements of the sequences}
\var{dp[i][j]}{LCS length of $A[1..i]$ and $B[1..j]$}
\varmapEnd
\GOVERN{
\[
dp[i][j]=
\begin{cases}
0, & i=0 \text{ or } j=0,\\
dp[i-1][j-1]+1, & a_i=b_j,\\
\max\{dp[i-1][j],\,dp[i][j-1]\}, & a_i\ne b_j.
\end{cases}
\]
}
\ASSUMPTIONS{Indices are 1-based in the recurrence; arrays are finite with integer elements; subsequence order must be preserved.}
\INVARIANTS{
\begin{bullets}
\item $dp[i][j]$ never decreases when $i$ or $j$ increases by one while holding the other fixed.
\item $dp[i][j]\le \min(i,j)$ always.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Recursive choice: at $(i,j)$, if $a_i=b_j$ take $1+\text{solve}(i+1,j+1)$; otherwise try skipping either side and take the maximum.}
\ASSUMPTIONS{Direct recursion without memoization; exponential but simple; suitable only for tiny inputs or correctness scaffolding.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define \texttt{dfs(i,j)} returning the best from suffixes starting at $i,j$.
\item If $i=n$ or $j=m$, return 0.
\item If $A[i]=B[j]$, return $1+\texttt{dfs}(i+1,j+1)$; else return $\max(\texttt{dfs}(i+1,j),\texttt{dfs}(i,j+1))$.
\end{algosteps}
\COMPLEXITY{Exponential in the worst case.}
\[
\begin{aligned}
T(n,m) &=
\begin{cases}
1, & \text{if } n=0 \text{ or } m=0,\\
T(n-1,m-1)+1, & \text{if } a_n=b_m,\\
T(n-1,m)+T(n,m-1)+1, & \text{otherwise,}
\end{cases}\\
&= \Theta(2^{n+m}) \text{ in the worst case; } S(n,m)=\Theta(n+m) \text{ recursion depth.}
\end{aligned}
\]
\CORRECTNESS{The recursion explores all legal choices respecting order and pairing each element at most once, taking a maximum over complete partitions of decisions.}
\EDGECASES{All elements distinct $\Rightarrow 0$; arrays identical $\Rightarrow n$; repeated values handled by branching.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)

        def dfs(i: int, j: int) -> int:
            if i == n or j == m:
                return 0
            if nums1[i] == nums2[j]:
                return 1 + dfs(i + 1, j + 1)
            # try skipping one element from either sequence
            a = dfs(i + 1, j)
            b = dfs(i, j + 1)
            return a if a >= b else b

        return dfs(0, 0)


if __name__ == "__main__":
    # Tiny baseline checks (keep sizes very small due to exponential time)
    s = Solution()
    assert s.maxUncrossedLines([1, 4, 2], [1, 2, 4]) == 2
    assert s.maxUncrossedLines([2, 5, 1], [10, 5, 2]) == 1
    assert s.maxUncrossedLines([1, 3], [4, 1]) == 1
\end{minted}
\VALIDATION{The three asserts exercise matching, skipping, and order constraints on tiny inputs.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Tabulate the classic LCS DP over a $(n+1)\times(m+1)$ grid to avoid recomputation.}
\ASSUMPTIONS{Bottom-up fills each cell once; transitions mirror the recurrence.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp$ with zeros of size $(n+1)\times(m+1)$.
\item For $i=1..n$, $j=1..m$, set $dp[i][j]=dp[i-1][j-1]+1$ if equal, else $\max(dp[i-1][j],dp[i][j-1])$.
\item Return $dp[n][m]$.
\end{algosteps}
\COMPLEXITY{Each state computed once.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm),\quad S(n,m)=\Theta(nm).
\end{aligned}
\]
\CORRECTNESS{Induction on $i+j$: base row/column is $0$; transitions respect whether the last elements are matched or skipped, preserving optimal substructure.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(1, n + 1):
            ai = nums1[i - 1]
            for j in range(1, m + 1):
                if ai == nums2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    # keep best of skipping from either side
                    if dp[i - 1][j] >= dp[i][j - 1]:
                        dp[i][j] = dp[i - 1][j]
                    else:
                        dp[i][j] = dp[i][j - 1]
        return dp[n][m]


if __name__ == "__main__":
    s = Solution()
    assert s.maxUncrossedLines([1, 4, 2], [1, 2, 4]) == 2
    assert s.maxUncrossedLines([2, 5, 1, 2, 5], [10, 5, 2, 1, 5, 2]) == 3
    assert s.maxUncrossedLines([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1]) == 2
\end{minted}
\VALIDATION{Checks the three official-style examples and returns expected outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Space-optimized LCS using a single rolling row over the second array.}
\ASSUMPTIONS{We only need the previous row to fill the current row; store it implicitly with a running diagonal value.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep an array \texttt{dp[0..m]} where \texttt{dp[j]} holds the LCS for current $i$ and prefix $j$.
\item For each $i$, sweep $j=1..m$, track \texttt{prev} as the value of $dp[j-1]$ from the previous $i-1$ row (the diagonal).
\item Update \texttt{dp[j]} using match or $\max(dp[j], dp[j-1])$.
\end{algosteps}
\OPTIMALITY{Time $\Theta(nm)$ matches the DP lower bound for general LCS; space reduced to $\Theta(m)$ while preserving correctness.}
\COMPLEXITY{
\[
\begin{aligned}
T(n,m)&=\Theta(nm),\quad S(n,m)=\Theta(m).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        # Ensure we roll over the smaller dimension for cache locality if desired
        n, m = len(nums1), len(nums2)
        if m == 0 or n == 0:
            return 0
        # Rolling DP on nums2
        dp = [0] * (m + 1)
        for i in range(1, n + 1):
            prev = 0  # dp[j-1] from previous row
            ai = nums1[i - 1]
            for j in range(1, m + 1):
                tmp = dp[j]  # will become prev for next j
                if ai == nums2[j - 1]:
                    dp[j] = prev + 1
                else:
                    if dp[j] < dp[j - 1]:
                        dp[j] = dp[j - 1]
                prev = tmp
        return dp[m]


if __name__ == "__main__":
    s = Solution()
    # Exactly 3 asserts
    assert s.maxUncrossedLines([1, 4, 2], [1, 2, 4]) == 2
    assert s.maxUncrossedLines([2, 5, 1, 2, 5], [10, 5, 2, 1, 5, 2]) == 3
    assert s.maxUncrossedLines([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1]) == 2
\end{minted}
\VALIDATION{Three asserts cover the typical scenarios: reordering conflict, repeated elements, and partial overlaps.}
\RESULT{Return the LCS length, which equals the maximum number of uncrossed connecting lines.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for example cases, adversarial patterns (all equal, all distinct, interleaved duplicates), and random small cases cross-checked against a slow baseline.}
\LINE{CROSS-CHECKS}{Compare outputs of baseline recursion (tiny sizes) vs. optimized DP on many random seeds to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate sequences with extremes: identical arrays, reversed arrays, alternating duplicates, and disjoint sets.}
\begin{minted}{python}
from typing import List
import random

def slow_lcs(nums1: List[int], nums2: List[int]) -> int:
    # Safe for small inputs; used for cross-checks
    n, m = len(nums1), len(nums2)
    def dfs(i: int, j: int) -> int:
        if i == n or j == m:
            return 0
        if nums1[i] == nums2[j]:
            return 1 + dfs(i + 1, j + 1)
        a = dfs(i + 1, j)
        b = dfs(i, j + 1)
        return a if a >= b else b
    return dfs(0, 0)

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        # Rolling LCS
        n, m = len(nums1), len(nums2)
        dp = [0] * (m + 1)
        for i in range(1, n + 1):
            prev = 0
            ai = nums1[i - 1]
            for j in range(1, m + 1):
                tmp = dp[j]
                if ai == nums2[j - 1]:
                    dp[j] = prev + 1
                else:
                    if dp[j] < dp[j - 1]:
                        dp[j] = dp[j - 1]
                prev = tmp
        return dp[m]

def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_all_distinct(n: int, start: int = 1) -> List[int]:
    return list(range(start, start + n))

def gen_alternating(n: int, a: int, b: int) -> List[int]:
    out = []
    for i in range(n):
        out.append(a if i % 2 == 0 else b)
    return out

if __name__ == "__main__":
    s = Solution()
    # Deterministic boundary/adversarial checks
    assert s.maxUncrossedLines(gen_all_equal(5, 7), gen_all_equal(7, 7)) == 5
    assert s.maxUncrossedLines(gen_all_distinct(5), gen_all_distinct(5)) == 5
    assert s.maxUncrossedLines(gen_all_distinct(5), gen_all_distinct(5)[::-1]) == 1

    # Cross-check on random small cases
    rnd = random.Random(0)
    for n in range(1, 7):
        for m in range(1, 7):
            a = [rnd.randrange(1, 6) for _ in range(n)]
            b = [rnd.randrange(1, 6) for _ in range(m)]
            assert s.maxUncrossedLines(a, b) == slow_lcs(a, b)

    print("All tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        # Space-optimized LCS
        n, m = len(nums1), len(nums2)
        if n == 0 or m == 0:
            return 0
        dp = [0] * (m + 1)
        for i in range(1, n + 1):
            prev = 0
            ai = nums1[i - 1]
            for j in range(1, m + 1):
                tmp = dp[j]
                if ai == nums2[j - 1]:
                    dp[j] = prev + 1
                else:
                    if dp[j] < dp[j - 1]:
                        dp[j] = dp[j - 1]
                prev = tmp
        return dp[m]


if __name__ == "__main__":
    s = Solution()
    # Sanity asserts
    assert s.maxUncrossedLines([1, 4, 2], [1, 2, 4]) == 2
    assert s.maxUncrossedLines([2, 5, 1, 2, 5], [10, 5, 2, 1, 5, 2]) == 3
    assert s.maxUncrossedLines([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the LCS length of two integer arrays; it equals the maximum number of uncrossed lines.}
\WHY{Classic DP pattern; mapping problems to LCS recurrences is a common interview skill.}
\CHECKLIST{
\begin{bullets}
\item Recognize ``uncrossed lines'' as LCS with order preserved.
\item Write the recurrence and base cases.
\item Choose 2D DP or 1D rolling optimization.
\item Mind indices and off-by-one between arrays and DP table.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All elements equal $\Rightarrow$ answer is $\min(n,m)$.
\item All elements distinct across arrays $\Rightarrow 0$.
\item Reversed identical arrays $\Rightarrow 1$ if values unique.
\item Many duplicates with interleaving.
\item One array length $1$.
\item Values at the bounds (1 and 2000).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to reset the diagonal tracker \texttt{prev} per row in 1D DP.
\item Overwriting \texttt{dp[j]} before storing its old value for diagonal use.
\item Mixing 0-based array indices with 1-based DP dimensions.
\item Using $\max(dp[i-1][j-1],\ldots)$ on mismatch (should be $\max(dp[i-1][j],dp[i][j-1])$).
\item Returning \texttt{dp[n-1][m-1]} instead of \texttt{dp[n][m]}.
\item Not handling empty inputs in generic utilities.
\end{bullets}
}
\FAILMODES{A greedy ``match earliest equal'' strategy can fail when skipping yields more matches later; only DP with optimal substructure is reliable.}
\ELI{We want the longest list of matching numbers that appear in the same order in both arrays. Dynamic programming counts the best we can do using prefixes of the arrays, building up to the full answer.}
\NotePages{3}

\end{document}