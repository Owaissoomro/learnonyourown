% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Isomorphic Strings}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/isomorphic-strings/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given two strings \texttt{s} and \texttt{t}, \emph{determine if they are isomorphic}. Two strings \texttt{s} and \texttt{t} are isomorphic if the characters in \texttt{s} can be replaced to get \texttt{t}. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

Example 1: Input: s = "egg", t = "add". Output: true. Explanation: The strings \texttt{s} and \texttt{t} can be made identical by: Mapping 'e' to 'a'. Mapping 'g' to 'd'.

Example 2: Input: s = "foo", t = "bar". Output: false. Explanation: The strings \texttt{s} and \texttt{t} cannot be made identical as 'o' needs to be mapped to both 'a' and 'r'.

Example 3: Input: s = "paper", t = "title". Output: true.

Constraints:
- $1 \le \texttt{s.length} \le 5 \times 10^4$.
- $\texttt{t.length} = \texttt{s.length}$.
- \texttt{s} and \texttt{t} consist of any valid ASCII character.}
\BREAKDOWN{We must decide whether there exists a one-to-one character mapping $f$ from characters of \texttt{s} to characters of \texttt{t} such that applying $f$ to \texttt{s} yields \texttt{t}. Enforce both direction consistency: same-source implies same-target, and different-source implies different-target.}
\ELI{Walk both strings together and ensure a consistent, one-to-one mapping between characters; no character in \texttt{s} can point to two in \texttt{t}, and no two in \texttt{s} can share the same target.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode, a function is provided with signature \texttt{def isIsomorphic(self, s: str, t: str) -> bool}, where \texttt{s} and \texttt{t} satisfy the constraints above.}
\OUTPUTS{Return \texttt{True} if \texttt{s} and \texttt{t} are isomorphic under some one-to-one character mapping; otherwise return \texttt{False}.}
\SAMPLES{Examples:
- Input: \texttt{s="egg"}, \texttt{t="add"}; Output: \texttt{True}.
- Input: \texttt{s="foo"}, \texttt{t="bar"}; Output: \texttt{False}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma$ be the ASCII character set. Given $s,t \in \Sigma^n$ with equal length $n$, decide if there exists an injective function $f:\Sigma\to\Sigma$ such that for all $i\in\{1,\ldots,n\}$ we have $f(s_i)=t_i$.}
\varmapStart
\var{s,t}{input strings of equal length $n$}
\var{n}{common length of the two strings}
\var{f}{character mapping from source alphabet to target alphabet}
\var{\Sigma}{ASCII alphabet}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i\in\{1,\ldots,n\}:\ f(s_i)=t_i,\qquad \text{and}\quad f \text{ is injective on the characters that appear in } s.
\end{BreakableEquation*}
}
\ASSUMPTIONS{ASCII domain size is at most $256$. Indexing is $0$-based in implementations.}
\INVARIANTS{While scanning left-to-right:
- If $s_i=s_j$ then $t_i=t_j$ must hold; if not, reject.
- If $s_i\ne s_j$ then $t_i\ne t_j$ must hold; if not, reject.
- Established mappings never change once set.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct pairwise consistency: for all $0 \le j < i < n$, require $(s_i=s_j) \Leftrightarrow (t_i=t_j)$.}
\ASSUMPTIONS{No auxiliary maps; just nested loops over positions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $|s| \ne |t|$, return \texttt{False}.
\item For each $i$ from $0$ to $n-1$, for each $j$ from $0$ to $i-1$, check consistency: $(s[i]==s[j])$ equals $(t[i]==t[j])$. If not equal, return \texttt{False}.
\item If all pairs pass, return \texttt{True}.
\end{algosteps}
\COMPLEXITY{Quadratic time, constant extra space.}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-1} i \;=\; \frac{n(n-1)}{2} \;=\; \Theta(n^2),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{The pairwise equivalence precisely enforces that equal source positions map to equal target positions and vice versa, which is necessary and sufficient for some injective mapping to exist.}
\EDGECASES{Empty string (not possible here), single character, all identical chars, all distinct chars, mixed ASCII including spaces and punctuation.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        n = len(s)
        for i in range(n):
            for j in range(i):
                if (s[i] == s[j]) != (t[i] == t[j]):
                    return False
        return True

# Tiny tests for Approach A
sol = Solution()
assert sol.isIsomorphic("egg", "add") is True
assert sol.isIsomorphic("foo", "bar") is False
assert sol.isIsomorphic("paper", "title") is True
\end{minted}
\VALIDATION{Checks cover a positive case with repeated letters, a negative case with conflict, and a positive case with multiple distinct mappings.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use two hash maps to maintain forward and reverse mappings and validate on-the-fly in one pass.}
\ASSUMPTIONS{ASCII or general characters; Python dicts for $O(1)$ expected-time access.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If lengths differ, return \texttt{False}.
\item Maintain dicts \texttt{st} and \texttt{ts}. For each position $i$, let $a=s[i], b=t[i]$.
\item If $a$ is already in \texttt{st}, ensure \texttt{st[a] == b}; else set \texttt{st[a]=b}.
\item If $b$ is already in \texttt{ts}, ensure \texttt{ts[b] == a}; else set \texttt{ts[b]=a}.
\item If any check fails, return \texttt{False}. Otherwise, return \texttt{True} at the end.
\end{algosteps}
\COMPLEXITY{Single pass, linear time, linear space in number of distinct characters.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(k)\ \text{with}\ k\le \min(n,|\Sigma|).
\end{aligned}
\]
\CORRECTNESS{Maintaining both directions ensures injectivity and consistency. Once a mapping is established, it is enforced for all future occurrences.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        st, ts = {}, {}
        for a, b in zip(s, t):
            if a in st and st[a] != b:
                return False
            if b in ts and ts[b] != a:
                return False
            st[a] = b
            ts[b] = a
        return True

# Tiny tests for Approach B
sol = Solution()
assert sol.isIsomorphic("egg", "add") is True
assert sol.isIsomorphic("ab", "aa") is False
assert sol.isIsomorphic("paper", "title") is True
\end{minted}
\VALIDATION{Added a case where two different source chars try to map to the same target char.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use last-seen index trick with two fixed-size arrays of length $256$ (ASCII). If the last seen indices for current pair mismatch, violate isomorphism.}
\ASSUMPTIONS{Characters are ASCII; for general Unicode, fall back to dict approach.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If lengths differ, return \texttt{False}.
\item Initialize two arrays \texttt{lastS[256]} and \texttt{lastT[256]} to zeros.
\item For each index $i$, compute $x=\text{ord}(s[i])$, $y=\text{ord}(t[i])$. If \texttt{lastS[x] != lastT[y]}, return \texttt{False}.
\item Set \texttt{lastS[x] = lastT[y] = i+1} and continue.
\item Return \texttt{True} after the loop completes.
\end{algosteps}
\OPTIMALITY{The algorithm is one pass with $O(1)$ extra memory bounded by alphabet size, which is optimal in the word-RAM model for this decision problem.}
\COMPLEXITY{Linear time, constant extra space (w.r.t. input length).}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1)\ \text{(fixed arrays of size }256\text{)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        # ASCII assumption per problem statement
        lastS = [0] * 256
        lastT = [0] * 256
        for i, (a, b) in enumerate(zip(s, t), start=1):
            xa = ord(a) & 255
            yb = ord(b) & 255
            if lastS[xa] != lastT[yb]:
                return False
            lastS[xa] = i
            lastT[yb] = i
        return True

# Exact 3 asserts
sol = Solution()
assert sol.isIsomorphic("egg", "add") is True
assert sol.isIsomorphic("foo", "bar") is False
assert sol.isIsomorphic("badc", "baba") is False
\end{minted}
\VALIDATION{Covers positive repeated mapping, negative conflicting mapping, and a crafted case where pattern breaks late.}
\RESULT{Return boolean indicating whether a bijection exists from characters of \texttt{s} to characters of \texttt{t} that reproduces \texttt{t} from \texttt{s}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests should include: equal-length trivial cases, all same char vs. all same/different, all distinct chars, early and late conflicts, spaces/punctuation, full ASCII sweep on short strings.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, and C on random small strings (e.g., length up to 8) to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate pairs by randomly assigning a bijection on a subset of ASCII to synthesize positive cases; introduce single-point violations to synthesize negatives.}
\begin{minted}{python}
import random
import string

def brute_isomorphic(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False
    for i in range(len(s)):
        for j in range(i):
            if (s[i] == s[j]) != (t[i] == t[j]):
                return False
    return True

class DictIso:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        st, ts = {}, {}
        for a, b in zip(s, t):
            if a in st and st[a] != b:
                return False
            if b in ts and ts[b] != a:
                return False
            st[a] = b
            ts[b] = a
        return True

class ArrayIso:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        lastS = [0]*256
        lastT = [0]*256
        for i, (a, b) in enumerate(zip(s, t), start=1):
            if lastS[ord(a) & 255] != lastT[ord(b) & 255]:
                return False
            lastS[ord(a) & 255] = i
            lastT[ord(b) & 255] = i
        return True

# Cross-check small random tests
rng = random.Random(0)
alphabet = string.ascii_letters + string.digits + " .,:;!?$#@"
for _ in range(200):
    n = rng.randint(0, 10)
    s = "".join(rng.choice(alphabet) for _ in range(n))
    # Randomly generate t either via a random mapping or random noise
    if rng.random() < 0.5:
        # create a random injective mapping on seen chars of s
        uniq = list(dict.fromkeys(s))
        tgt_pool = list(dict.fromkeys("".join(rng.choice(alphabet) for _ in range(max(1, len(uniq)+5)))))
        rng.shuffle(tgt_pool)
        m = {c: tgt_pool[i] for i, c in enumerate(uniq)}
        t = "".join(m[c] for c in s)
    else:
        t = "".join(rng.choice(alphabet) for _ in range(n))
    b = brute_isomorphic(s, t)
    d = DictIso().isIsomorphic(s, t)
    a = ArrayIso().isIsomorphic(s, t)
    assert b == d == a

print("Cross-checks passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        lastS = [0] * 256
        lastT = [0] * 256
        for i, (a, b) in enumerate(zip(s, t), start=1):
            xa = ord(a) & 255
            yb = ord(b) & 255
            if lastS[xa] != lastT[yb]:
                return False
            lastS[xa] = i
            lastT[yb] = i
        return True

# Sanity asserts
sol = Solution()
assert sol.isIsomorphic("egg", "add")
assert not sol.isIsomorphic("ab", "aa")
assert sol.isIsomorphic("paper", "title")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check if there exists a one-to-one character mapping that transforms \texttt{s} into \texttt{t}.}
\WHY{Appears frequently to test understanding of bijections, hash maps, and linear scans under constraints.}
\CHECKLIST{
- Verify equal lengths.
- Enforce forward mapping consistency.
- Enforce reverse mapping consistency (injectivity).
- Single pass over both strings.
- Return early on first conflict.}
\EDGECASES{
- Length $1$ strings.
- All characters identical in \texttt{s}.
- All characters distinct in \texttt{s}.
- Late conflict only at the end.
- Includes spaces or punctuation.
- Non-printable ASCII characters.
- Case sensitivity differences.
- Very long inputs near $5 \times 10^4$.}
\PITFALLS{
- Forgetting reverse mapping check, allowing two-to-one mappings.
- Updating mapping after a conflict instead of rejecting.
- Using default \texttt{dict} without checking existing binding.
- Assuming only lowercase letters and using arrays of size $26$.
- Mishandling empty arrays or off-by-one in last-seen trick.
- Not handling full ASCII range.}
\FAILMODES{Approaches that only check frequency counts fail because order and positional equality constraints matter. Forward-only maps fail on cases where two different \texttt{s} chars map to the same \texttt{t} char.}
\ELI{We walk both strings together and remember how each character should translate. If we ever see a character try to translate differently than before, or two different characters try to become the same one, we stop and say no.}
\NotePages{3}

\end{document}