% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find Subarray With Bitwise OR Closest to K}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-subarray-with-bitwise-or-closest-to-k/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an array \texttt{nums} and an integer \texttt{k}. You need to find a subarray of \texttt{nums} such that the absolute difference between \texttt{k} and the bitwise OR of the subarray elements is as small as possible. In other words, select a subarray \texttt{nums[l..r]} such that $\lvert k - (\texttt{nums[l]} \operatorname{\,OR\,} \texttt{nums[l + 1]} \ldots \operatorname{\,OR\,} \texttt{nums[r]})\rvert$ is minimum. Return the minimum possible value of the absolute difference. A subarray is a contiguous non-empty sequence of elements within an array.

\textbf{Example 1:} Input: \texttt{nums = [1,2,4,5]}, \texttt{k = 3}. Output: \texttt{0}. Explanation: The subarray \texttt{nums[0..1]} has OR value 3, which gives the minimum absolute difference $\lvert 3 - 3\rvert = 0$.

\textbf{Example 2:} Input: \texttt{nums = [1,3,1,3]}, \texttt{k = 2}. Output: \texttt{1}. Explanation: The subarray \texttt{nums[1..1]} has OR value 3, which gives the minimum absolute difference $\lvert 3 - 2\rvert = 1$.

\textbf{Example 3:} Input: \texttt{nums = [1]}, \texttt{k = 10}. Output: \texttt{9}. Explanation: There is a single subarray with OR value 1, which gives the minimum absolute difference $\lvert 10 - 1\rvert = 9$.

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \texttt{nums.length} \le 10^5$
\item $1 \le \texttt{nums[i]} \le 10^9$
\item $1 \le \texttt{k} \le 10^9$
\end{itemize}
}
\BREAKDOWN{Compute the bitwise OR over all subarrays implicitly without enumerating all $O(n^2)$ intervals. Use the fact that the number of distinct OR values of subarrays ending at a fixed index is $O(B)$ where $B$ is the bit width (at most 32). Track these values incrementally and minimize the absolute difference to $k$.}
\ELI{Carry forward all possible ORs of subarrays that end at each position; there are only about 32 of them, so check how close they are to $k$ and keep the best.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer array \texttt{nums} of length $n$ with $1 \le n \le 10^5$, values in $[1,10^9]$; an integer \texttt{k} with $1 \le k \le 10^9$.}
\OUTPUTS{Return a single integer: $\min_{1 \le l \le r \le n} \lvert k - (\bigvee_{i=l}^{r} \texttt{nums[i]})\rvert$.}
\SAMPLES{
\begin{itemize}
\item \texttt{nums = [1,2,4,5]}, \texttt{k = 3} $\rightarrow$ \texttt{0}
\item \texttt{nums = [1,3,1,3]}, \texttt{k = 2} $\rightarrow$ \texttt{1}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{N}$, an array $\mathbf{a} = (a_1,\ldots,a_n)$ with $a_i \in \mathbb{Z}_{>0}$, and a target $k \in \mathbb{Z}_{>0}$, define for $1 \le l \le r \le n$ the subarray OR $O(l,r) = \bigvee_{i=l}^{r} a_i$. Objective:
\begin{BreakableEquation*}
\text{Minimize }~ f(l,r) = \lvert O(l,r) - k\rvert \quad \text{over all } 1 \le l \le r \le n.
\end{BreakableEquation*}
}
\varmapStart
\var{n}{array length}
\var{a_i}{the $i$-th element of \texttt{nums}}
\var{k}{the target integer}
\var{O(l,r)}{bitwise OR of $a_l,\ldots,a_r$}
\var{S_i}{set of all distinct OR values of subarrays ending at index $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S_1 &= \{a_1\},\\
S_i &= \{a_i\} ~\cup~ \{\, v \,\operatorname{OR}\, a_i \;:\; v \in S_{i-1}\,\} \quad \text{for } i \ge 2,\\
\text{Ans} &= \min_{i=1}^{n}~ \min_{v \in S_i} \lvert v - k\rvert.
\end{aligned}
\]
}
\ASSUMPTIONS{Use 32-bit representation; at most 32 distinct values in each $S_i$ as bits only turn on while extending subarrays. Indexing is $1$-based above; implementation may use $0$-based.}
\INVARIANTS{
\begin{itemize}
\item Monotonicity: For fixed right endpoint $i$, if $l_1 < l_2 \le i$ then $O(l_1,i) \ge O(l_2,i)$ bitwise.
\item Bounded diversity: $\lvert S_i\rvert \le 32$ for 32-bit nonnegative integers.
\item Closure: $S_i$ contains all and only the ORs of subarrays ending at $i$.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $O(l,r)$ for all subarrays using incremental OR and minimize $\lvert O(l,r) - k\rvert$.}
\ASSUMPTIONS{Early break when $O(l,r) \ge k$ because extending $r$ cannot decrease OR, hence $\lvert O(l,r)-k\rvert$ cannot improve for larger $r$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{ans = +inf}.
\item For each left index $l$ from $0$ to $n-1$, set \texttt{v = 0}; for each right index $r \ge l$, set \texttt{v |= nums[r]} and update \texttt{ans = min(ans, abs(v - k))}.
\item If \texttt{v >= k}, break the inner loop early; continue with next $l$.
\end{algosteps}
\COMPLEXITY{Worst case $T(n)=O(n^2)$, $S(n)=O(1)$ auxiliary. Early breaks help but do not change the worst-case bound.}
\[
\begin{aligned}
T(n) &\le \sum_{l=0}^{n-1} (n-l) = \frac{n(n+1)}{2} \in O(n^2),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Every subarray is considered; OR is accumulated correctly; early termination is safe because OR is nondecreasing as $r$ increases, so distance to $k$ cannot improve once $O(l,r) \ge k$.}
\EDGECASES{Single-element array; all numbers identical; $k$ much larger than all ORs; $k$ equal to some subarray OR exactly.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = float('inf')
        for l in range(n):
            v = 0
            for r in range(l, n):
                v |= nums[r]
                diff = v - k
                if diff < 0:
                    diff = -diff
                if diff < ans:
                    ans = diff
                if v >= k:
                    # OR is nondecreasing with r, abs(v - k) cannot get smaller now
                    break
        return int(ans)

if __name__ == "__main__":
    # Tiny sanity checks for the baseline algorithm
    sol = Solution()
    assert sol.minimumDifference([1, 2, 4, 5], 3) == 0
    assert sol.minimumDifference([1, 3, 1, 3], 2) == 1
    assert sol.minimumDifference([1], 10) == 9
\end{minted}
\VALIDATION{Checked on the three examples; also implicitly covers the $n=1$ case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Distinct ORs per suffix using rolling set}
\WHICHFORMULA{Use $S_i = \{a_i\} \cup \{v \operatorname{OR} a_i : v \in S_{i-1}\}$; deduplicate with a set. Each $S_i$ has size $O(32)$, yielding $O(n \cdot 32)$ time.}
\ASSUMPTIONS{Integers are nonnegative within 32 bits; Python integers are unbounded but bit width is effectively $\le 32$ here.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a set \texttt{prev} of all distinct OR values for subarrays ending at the previous index.
\item For each element \texttt{x}, build \texttt{cur = \{x\} union \{(v | x) for v in prev\}}.
\item Update the answer with all values in \texttt{cur}; then set \texttt{prev = cur} and continue.
\end{algosteps}
\COMPLEXITY{Each step keeps at most 32 values; thus $T(n) = O(n \cdot 32)$, $S(n) = O(32)$.}
\[
\begin{aligned}
T(n) &\le \sum_{i=1}^{n} (1 + |S_{i-1}|) \le n \cdot 33 \in O(n),\\
S(n) &\le 32.
\end{aligned}
\]
\CORRECTNESS{By construction, \texttt{cur} enumerates exactly the ORs of all subarrays ending at the current index. Minimizing over all \texttt{cur} across all indices yields the global minimum.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        prev = set()  # ORs for subarrays ending at previous index
        ans = float('inf')
        for x in nums:
            cur = {x}
            for v in prev:
                cur.add(v | x)
            # Update answer
            for v in cur:
                diff = v - k
                if diff < 0:
                    diff = -diff
                if diff < ans:
                    ans = diff
            prev = cur
            if ans == 0:
                # Early exit if perfect match found
                return 0
        return int(ans)

if __name__ == "__main__":
    sol = Solution()
    # Provided examples
    assert sol.minimumDifference([1, 2, 4, 5], 3) == 0
    assert sol.minimumDifference([1, 3, 1, 3], 2) == 1
    assert sol.minimumDifference([1], 10) == 9
    # Additional check: repeated values
    assert sol.minimumDifference([7, 7, 7], 7) == 0
\end{minted}
\VALIDATION{Validated on examples; added a case with repeated identical numbers to confirm set-based deduplication works.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Ordered unique ORs with linear-time per index}
\WHICHFORMULA{Maintain an increasing list of unique ORs for subarrays ending at each index. For fixed $x$, the mapping $v \mapsto v \operatorname{OR} x$ is monotone, so deduplication can be done by skipping consecutive duplicates, keeping the list size $\le 32$.}
\ASSUMPTIONS{As $v$ increases, $v \operatorname{OR} x$ is nondecreasing. Also, $x \le (v \operatorname{OR} x)$ for any $v$, so prepending $x$ maintains the global ordering when we append deduped images.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep \texttt{vals} as an increasing list of unique ORs for subarrays ending at the previous index.
\item For each \texttt{x}, start \texttt{nxt = [x]}; for each \texttt{v in vals} in order, compute \texttt{nv = v | x}, and append \texttt{nv} to \texttt{nxt} only if it differs from the last appended value.
\item Update the running minimum with all values in \texttt{nxt}; set \texttt{vals = nxt}.
\end{algosteps}
\OPTIMALITY{Each iteration performs $O(|\texttt{vals}|)$ operations with $|\texttt{vals}| \le 32$, hence $O(n)$ total time up to a small constant. The bound is tight for worst-case bit growth.}
\COMPLEXITY{$T(n) = O(n \cdot 32)$, $S(n) = O(32)$.}
\[
\begin{aligned}
T(n) &\le \sum_{i=1}^{n} (1 + |\texttt{vals}_{i-1}|) \le 33n, \\
S(n) &\le 32.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        vals: List[int] = []  # increasing unique ORs for subarrays ending at previous index
        ans = float('inf')
        for x in nums:
            # Build next list in increasing order with dedup
            nxt: List[int] = [x]
            for v in vals:
                nv = v | x
                if nv != nxt[-1]:
                    nxt.append(nv)
            # Update answer
            for v in nxt:
                diff = v - k
                if diff < 0:
                    diff = -diff
                if diff < ans:
                    ans = diff
            vals = nxt
            if ans == 0:
                return 0
        return int(ans)

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts or I/O mini-tests
    assert sol.minimumDifference([1, 2, 4, 5], 3) == 0
    assert sol.minimumDifference([1, 3, 1, 3], 2) == 1
    assert sol.minimumDifference([1], 10) == 9
\end{minted}
\VALIDATION{The three asserts cover a perfect match, a nearest-above case, and a nearest-below case.}
\RESULT{Return the minimum possible absolute difference $\min_{l,r} \lvert O(l,r) - k\rvert$; no special tie-breaking beyond the value itself.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small arrays; property-based cross-check that Approach B and C agree for random small cases; edge cases: single element, repeated values, strictly increasing powers of two, and $k$ outside the achievable OR range.}
\LINE{CROSS-CHECKS}{Compare outputs of the set-based and ordered-list implementations on random seeds with small $n$ to ensure equivalence.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with zeros absent (all positive), values that share bits, and powers of two to stress the OR lattice size.}
\begin{minted}{python}
from typing import List
import random

def brute_force(nums: List[int], k: int) -> int:
    n = len(nums)
    ans = float('inf')
    for l in range(n):
        v = 0
        for r in range(l, n):
            v |= nums[r]
            diff = abs(v - k)
            if diff < ans:
                ans = diff
    return int(ans)

class SolutionFinal:
    # Ordered unique ORs (Approach C)
    def minimumDifference(self, nums: List[int], k: int) -> int:
        vals: List[int] = []
        ans = float('inf')
        for x in nums:
            nxt: List[int] = [x]
            for v in vals:
                nv = v | x
                if nv != nxt[-1]:
                    nxt.append(nv)
            for v in nxt:
                diff = v - k
                if diff < 0:
                    diff = -diff
                if diff < ans:
                    ans = diff
            vals = nxt
            if ans == 0:
                return 0
        return int(ans)

def cross_check():
    rng = random.Random(12345)
    for _ in range(200):
        n = rng.randint(1, 20)
        nums = [rng.randint(1, 63) for _ in range(n)]  # small bit width to allow BF
        k = rng.randint(1, 63)
        bf = brute_force(nums, k)
        sf = SolutionFinal().minimumDifference(nums, k)
        assert bf == sf, (nums, k, bf, sf)

if __name__ == "__main__":
    # Edge and random tests
    assert brute_force([1], 10) == 9
    assert brute_force([7, 7, 7], 7) == 0
    assert brute_force([1, 2, 4, 8, 16], 3) == 1  # subarray [1,2] OR=3
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        # Ordered unique ORs per suffix; O(n * 32)
        vals: List[int] = []
        ans = float('inf')
        for x in nums:
            nxt: List[int] = [x]
            for v in vals:
                nv = v | x
                if nv != nxt[-1]:
                    nxt.append(nv)
            for v in nxt:
                diff = v - k
                if diff < 0:
                    diff = -diff
                if diff < ans:
                    ans = diff
            vals = nxt
            if ans == 0:
                return 0
        return int(ans)

if __name__ == "__main__":
    sol = Solution()
    # Samples and a couple of extras
    assert sol.minimumDifference([1, 2, 4, 5], 3) == 0
    assert sol.minimumDifference([1, 3, 1, 3], 2) == 1
    assert sol.minimumDifference([1], 10) == 9
    assert sol.minimumDifference([7, 7, 7], 6) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Track distinct ORs of subarrays ending at each index; there are $O(32)$ of them, so scan all indices and keep the closest to $k$.}
\WHY{This pattern (distinct bitwise aggregates per suffix/prefix) appears often in bitwise DP/greedy interview problems to collapse $O(n^2)$ intervals to $O(n \cdot \text{bits})$.}
\CHECKLIST{
\begin{itemize}
\item Maintain rolling set/list of ORs for the previous index.
\item Build current ORs by OR-ing with the new element and dedup.
\item Update the global best with absolute differences to $k$.
\item Early exit if you hit 0.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $n=1$.
\item All elements identical.
\item $k$ much larger than any achievable OR.
\item $k$ smaller than any single element.
\item Arrays of powers of two (maximizes diversity).
\item Alternating bits, e.g., \texttt{[5,10,5,10]}.
\item Very large values near $10^9$.
\item Cases where only long subarrays match best.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to deduplicate OR values, causing quadratic blow-up.
\item Using a list without order-aware dedup leading to duplicates.
\item Not updating the answer for the singleton subarray \texttt{[x]}.
\item Incorrect early break conditions that skip valid candidates.
\item Overflow concerns in other languages; use 64-bit if needed.
\item Miscomputing absolute difference for negative intermediate results.
\item Mixing $0$-based and $1$-based thinking in descriptions vs. code.
\item Recomputing OR from scratch per candidate instead of rolling.
\end{itemize}
}
\FAILMODES{Naive $O(n^2)$ can time out on $n=10^5$. The rolling-distinct-OR method bounds per-step work to $\le 32$, surviving adversarial inputs such as alternating bit patterns.}
\ELI{At each position, there are only a handful of different OR values you can get by choosing where to start the subarray. Keep those few values, update them with the next number, and keep track of how close they are to $k$. This is fast because bits only turn on, so the set stays small.}
\NotePages{3}

\end{document}