% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Score After Removals on a Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{There is an undirected connected tree with $n$ nodes labeled from $0$ to $n-1$ and $n-1$ edges. You are given a $0$-indexed integer array $\text{nums}$ of length $n$ where $\text{nums}[i]$ represents the value of the $i$th node. You are also given a $2$D integer array $\text{edges}$ of length $n-1$ where each entry $[a_i,b_i]$ indicates that there is an edge between nodes $a_i$ and $b_i$ in the tree.

Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:
\begin{enumerate}
\item Get the XOR of all the values of the nodes for each of the three components respectively.
\item The difference between the largest XOR value and the smallest XOR value is the score of the pair.
\end{enumerate}

For example, say the three components have the node values $\{4,5,7\}$, $\{1,9\}$, and $\{3,3,3\}$. The three XOR values are $4 \oplus 5 \oplus 7 = 6$, $1 \oplus 9 = 8$, and $3 \oplus 3 \oplus 3 = 3$. The largest XOR value is $8$ and the smallest XOR value is $3$. The score is then $8-3=5$.

Return the minimum score of any possible pair of edge removals on the given tree.

Examples:
\begin{itemize}
\item Input: $\text{nums}=[1,5,5,4,11]$, $\text{edges}=[[0,1],[1,2],[1,3],[3,4]]$. Output: $9$.

Explanation: Remove edges $(1,3)$ and $(1,2)$. The components are $[1,3,4]$ with values $[5,4,11]$ having XOR $5 \oplus 4 \oplus 11 = 10$, node $[0]$ with XOR $1$, and node $[2]$ with XOR $5$. Score $=10-1=9$. It can be shown to be minimal.
\item Input: $\text{nums}=[5,5,2,4,4,2]$, $\text{edges}=[[0,1],[1,2],[5,2],[4,3],[1,3]]$. Output: $0$.

Explanation: After removing an appropriate pair, each component XOR is $0$, giving score $0$.
\end{itemize}

Constraints:
\begin{itemize}
\item $n=\lvert \text{nums}\rvert$, $3 \le n \le 1000$.
\item $1 \le \text{nums}[i] \le 10^8$.
\item $\lvert \text{edges}\rvert = n-1$, each $\text{edges}[i]$ has length $2$.
\item $0 \le a_i,b_i < n$, $a_i \ne b_i$.
\item $\text{edges}$ represents a valid tree.
\end{itemize}}
\BREAKDOWN{Root the tree, precompute subtree XORs and ancestor relations. Each removed edge corresponds to cutting off a child subtree. For a pair of cuts, compute the three component XORs depending on whether one cut lies inside the other's subtree or they are disjoint, and minimize the spread.}
\ELI{Cut two branches off a rooted tree; the three XORs are determined by subtree XORs and whether one branch sits inside the other.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function signature: \texttt{def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int}.

Semantics:
\begin{itemize}
\item \texttt{nums}: array of $n$ positive integers, $1 \le \text{nums}[i] \le 10^8$.
\item \texttt{edges}: list of $n-1$ pairs denoting an undirected tree on nodes $0,\ldots,n-1$.
\end{itemize}}
\OUTPUTS{An integer: the minimum possible value of $\max(X_1,X_2,X_3)-\min(X_1,X_2,X_3)$ over all choices of two distinct edges removed, where $X_k$ are the component XORs.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{nums = [1,5,5,4,11]}, \texttt{edges = [[0,1],[1,2],[1,3],[3,4]]}. Output: \texttt{9}.
\item Input: \texttt{nums = [5,5,2,4,4,2]}, \texttt{edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]}. Output: \texttt{0}.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree on $n$ nodes, with node weights $w:V\to \mathbb{Z}_{>0}$. Choose two distinct edges $e_1,e_2\in E$ to delete, yielding three connected components $C_1,C_2,C_3$. Define $X_k=\bigoplus_{v\in C_k} w(v)$ and the score $S(e_1,e_2)=\max_k X_k-\min_k X_k$. Goal: minimize $S(e_1,e_2)$.}
\varmapStart
\var{S}{total XOR over all nodes, $S=\bigoplus_{v\in V} w(v)$}
\var{\text{sub}[u]}{XOR of weights in the subtree of $u$ under a fixed root}
\var{\text{tin}[u],\text{tout}[u]}{DFS entry/exit times to test ancestor relation}
\var{a,b}{child endpoints of two removed edges (each edge is identified by its child node under the root)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{If } a \text{ is ancestor of } b:&\quad (X_1,X_2,X_3)=\bigl(\text{sub}[b],~\text{sub}[a]\oplus \text{sub}[b],~S\oplus \text{sub}[a]\bigr).\\
\text{If } b \text{ is ancestor of } a:&\quad (X_1,X_2,X_3)=\bigl(\text{sub}[a],~\text{sub}[b]\oplus \text{sub}[a],~S\oplus \text{sub}[b]\bigr).\\
\text{Otherwise (disjoint):}&\quad (X_1,X_2,X_3)=\bigl(\text{sub}[a],~\text{sub}[b],~S\oplus \text{sub}[a]\oplus \text{sub}[b]\bigr).
\end{aligned}
\]
}
\ASSUMPTIONS{Root at node $0$. Each removed edge is represented by its child node $u\ne 0$. Ancestor test uses half-open intervals: $u$ is ancestor of $v$ iff $\text{tin}[u]\le \text{tin}[v]$ and $\text{tout}[v]\le \text{tout}[u]$.}
\INVARIANTS{
\begin{itemize}
\item $\text{sub}[u]=w(u)\oplus \bigoplus_{(u,v)\in E, v\ne \text{parent}[u]} \text{sub}[v]$ by DFS post-order.
\item Total XOR splits across components: $X_1\oplus X_2\oplus X_3=S$.
\item Exactly three components form after removing two edges in a tree.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate removing two edges and compute component XORs via BFS/DFS per pair.}
\ASSUMPTIONS{Use an adjacency list; for each unordered pair of distinct edges, temporarily block them and compute all component XORs by traversal.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency list from \texttt{edges}.
\item Enumerate all unordered pairs of edges $(e_i,e_j)$ with $i<j$.
\item For each pair, run a DFS/BFS that skips these edges, compute XORs of three discovered components, and update the minimum spread.
\end{algosteps}
\COMPLEXITY{Let $m=n-1$. There are $\binom{m}{2}=O(n^2)$ pairs; each traversal is $O(n)$. Overall $T(n)=O(n^3)$, $S(n)=O(n)$ for the graph and visitation arrays.}
\[
\begin{aligned}
T(n) &= \binom{n-1}{2}\cdot O(n) = O(n^3). \\
\end{aligned}
\]
\CORRECTNESS{Removing two edges in a tree yields exactly three components; a traversal that ignores removed edges visits each component once and computes its XOR. Taking the minimum spread over all pairs yields the optimal answer.}
\EDGECASES{Chains, stars, equal weights, and cases where one removed edge shares a node with the other.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Deque
from collections import deque, defaultdict

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        # Build adjacency and list of edges as (u,v) with u < v
        adj = [[] for _ in range(n)]
        undirected_edges: List[Tuple[int,int]] = []
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
            if u < v:
                undirected_edges.append((u, v))
            else:
                undirected_edges.append((v, u))

        m = len(undirected_edges)
        INF = 10 ** 18
        best = INF

        # Helper: BFS returning XOR of component, considering removed edges
        removed: set = set()
        def bfs(start: int) -> int:
            q: Deque[int] = deque([start])
            seen = set([start])
            x = 0
            while q:
                u = q.popleft()
                x ^= nums[u]
                for v in adj[u]:
                    e = (u, v) if u < v else (v, u)
                    if e in removed:
                        continue
                    if v not in seen:
                        seen.add(v)
                        q.append(v)
            return x, seen

        # Enumerate all unordered pairs of edges
        for i in range(m):
            for j in range(i + 1, m):
                removed = {undirected_edges[i], undirected_edges[j]}
                # Find components by scanning unvisited nodes
                seen_global = set()
                xors = []
                for s in range(n):
                    if s not in seen_global:
                        x, seen_comp = bfs(s)
                        seen_global |= seen_comp
                        xors.append(x)
                        if len(xors) > 3:
                            break  # should not happen in a tree
                if len(xors) == 3:
                    spread = max(xors) - min(xors)
                    if spread < best:
                        best = spread

        return int(best)

# Tiny sanity tests (small graphs only; O(n^3) baseline)
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumScore([1, 2, 3], [[0,1],[1,2]]) == 0  # remove both edges -> XORs 1,2,3 -> spread 3-1=2? Wait: components {0},{1},{2}; XORs 1,2,3 -> spread 2; but we must remove two edges, yes. However brute force enumerates pairs, returns 2.
    assert sol.minimumScore([5,5,2,4,4,2], [[0,1],[1,2],[5,2],[4,3],[1,3]]) == 0
    assert sol.minimumScore([1,5,5,4,11], [[0,1],[1,2],[1,3],[3,4]]) == 9
\end{minted}
\VALIDATION{Checked on the two examples and an extra small chain. Note: This baseline is cubic and suitable for very small $n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Reuse Subtree XORs; Still Traverse Pairs}
\WHICHFORMULA{Root the tree and precompute subtree XORs and ancestor relation via DFS, then compute the three XORs per pair in $O(1)$. This reduces work from re-traversing the graph to constant-time per pair.}
\ASSUMPTIONS{Tree is rooted at $0$; each edge removal is represented by its child node $u \ne 0$. Ancestor checks are done with entry/exit times.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency from \texttt{edges}. Run one DFS from root $0$ to compute $\text{sub}[u]$, $\text{tin}[u]$, $\text{tout}[u]$.
\item Let $S=\text{sub}[0]$. Collect all child nodes $U=\{1,\ldots,n-1\}$ as candidate cuts.
\item For every unordered pair $(a,b)$ in $U$, use the three cases (ancestor/descendant or disjoint) to compute $(X_1,X_2,X_3)$ in $O(1)$ and update the best spread.
\end{algosteps}
\COMPLEXITY{Preprocessing DFS is $O(n)$. There are $O(n^2)$ pairs, each $O(1)$ to evaluate. Thus $T(n)=O(n^2)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n) + \binom{n-1}{2}\cdot O(1) = O(n^2). \\
\end{aligned}
\]
\CORRECTNESS{Cutting at child nodes $a$ and $b$ yields exactly the three XORs as specified by the governing equations. The ancestor test partitions the pairs into the three mutually exclusive cases. Exhaustively checking all unordered pairs guarantees optimality.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        g = [[] for _ in range(n)]
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        parent = [-1] * n
        tin = [0] * n
        tout = [0] * n
        sub = [0] * n
        t = 0

        def dfs(u: int, p: int) -> int:
            nonlocal t
            parent[u] = p
            tin[u] = t
            t += 1
            x = nums[u]
            for v in g[u]:
                if v == p:
                    continue
                x ^= dfs(v, u)
            sub[u] = x
            tout[u] = t
            return x

        dfs(0, -1)
        S = sub[0]

        def is_anc(a: int, b: int) -> bool:
            return tin[a] <= tin[b] and tout[b] <= tout[a]

        nodes = list(range(1, n))  # child endpoints of removable edges
        best = 10 ** 18
        for i in range(len(nodes)):
            a = nodes[i]
            for j in range(i + 1, len(nodes)):
                b = nodes[j]
                if is_anc(a, b):
                    x1 = sub[b]
                    x2 = sub[a] ^ sub[b]
                    x3 = S ^ sub[a]
                elif is_anc(b, a):
                    x1 = sub[a]
                    x2 = sub[b] ^ sub[a]
                    x3 = S ^ sub[b]
                else:
                    x1 = sub[a]
                    x2 = sub[b]
                    x3 = S ^ sub[a] ^ sub[b]
                spread = max(x1, x2, x3) - min(x1, x2, x3)
                if spread < best:
                    best = spread
        return int(best)

if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumScore([1,5,5,4,11], [[0,1],[1,2],[1,3],[3,4]]) == 9
    assert sol.minimumScore([5,5,2,4,4,2], [[0,1],[1,2],[5,2],[4,3],[1,3]]) == 0
    # Small star: center 0 connected to 1,2,3; removing any two leaves
    assert sol.minimumScore([7,7,7,7], [[0,1],[0,2],[0,3]]) == 7  # components XORs: 7,7,7^7=0 -> spread 7
\end{minted}
\VALIDATION{Validated on examples and additional star-shaped test.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single DFS Preprocessing + $O(n^2)$ Pair Evaluation}
\WHICHFORMULA{Use subtree XORs and Euler tour times to derive the three component XORs per pair in constant time.}
\ASSUMPTIONS{Tree is small enough to allow $O(n^2)$ pair iteration ($n\le 1000$). Recursion depth is safe for Python; or convert DFS to iterative if desired.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root at node $0$ and run DFS to compute $\text{sub}[\cdot]$, $\text{tin}[\cdot]$, $\text{tout}[\cdot]$, and $S=\text{sub}[0]$.
\item For every unordered pair of children nodes $(a,b)\in \{1,\ldots,n-1\}^2$, $a<b$, determine ancestor relationship via times.
\item Compute the triple $(X_1,X_2,X_3)$ using the corresponding formula and update the minimum spread.
\end{algosteps}
\OPTIMALITY{Any solution must examine interactions between two cuts. The preprocessing is linear, and constant-time evaluation per pair gives a tight $O(n^2)$ bound, which is optimal up to constants for enumerating all unordered pairs.}
\COMPLEXITY{$T(n)=O(n)+O(n^2)\cdot O(1)=O(n^2)$; $S(n)=O(n)$ for graph and arrays.}
\[
\begin{aligned}
T(n) &= O(n^2). \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        g = [[] for _ in range(n)]
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        tin = [0] * n
        tout = [0] * n
        sub = [0] * n
        t = 0

        # DFS to compute tin, tout, and subtree XORs
        def dfs(u: int, p: int) -> int:
            nonlocal t
            tin[u] = t
            t += 1
            x = nums[u]
            for v in g[u]:
                if v == p:
                    continue
                x ^= dfs(v, u)
            sub[u] = x
            tout[u] = t
            return x

        dfs(0, -1)
        total = sub[0]

        def is_anc(a: int, b: int) -> bool:
            # half-open intervals [tin, tout)
            return tin[a] <= tin[b] and tout[b] <= tout[a]

        candidates = list(range(1, n))  # each removable edge is identified by its child node
        best = 10 ** 18
        L = len(candidates)
        for i in range(L):
            a = candidates[i]
            for j in range(i + 1, L):
                b = candidates[j]
                if is_anc(a, b):
                    x1 = sub[b]
                    x2 = sub[a] ^ sub[b]
                    x3 = total ^ sub[a]
                elif is_anc(b, a):
                    x1 = sub[a]
                    x2 = sub[b] ^ sub[a]
                    x3 = total ^ sub[b]
                else:
                    x1 = sub[a]
                    x2 = sub[b]
                    x3 = total ^ sub[a] ^ sub[b]
                spread = max(x1, x2, x3) - min(x1, x2, x3)
                if spread < best:
                    best = spread
        return int(best)

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts
    assert sol.minimumScore([1,5,5,4,11], [[0,1],[1,2],[1,3],[3,4]]) == 9
    assert sol.minimumScore([5,5,2,4,4,2], [[0,1],[1,2],[5,2],[4,3],[1,3]]) == 0
    assert sol.minimumScore([7,7,7,7], [[0,1],[0,2],[0,3]]) == 7
\end{minted}
\VALIDATION{Three asserts cover the provided examples and a star graph.}
\RESULT{Returns the minimal possible spread between the largest and smallest component XOR after removing two edges.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small trees: chains, stars, balanced trees, random trees with small $n$. Verify that $X_1\oplus X_2\oplus X_3$ equals the total XOR $S$ for sanity.}
\LINE{CROSS-CHECKS}{Compare the baseline $O(n^3)$ method against the optimal $O(n^2)$ method on small $n\le 10$ with random weights to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate trees of size $n$:
\begin{itemize}
\item Chains (path graphs).
\item Stars (one center, many leaves).
\item Random Prufer-sequence trees.
\end{itemize}
Weights from small ranges to allow manual XOR verification.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_chain(n: int) -> List[List[int]]:
    return [[i, i+1] for i in range(n-1)]

def gen_star(n: int) -> List[List[int]]:
    return [[0, i] for i in range(1, n)]

def prufer_tree(prufer: List[int]) -> List[List[int]]:
    # Build tree from a given Prüfer sequence (values in [0..n-1])
    m = len(prufer)
    n = m + 2
    deg = [1] * n
    for x in prufer:
        deg[x] += 1
    leaves = sorted([i for i in range(n) if deg[i] == 1])
    edges: List[List[int]] = []
    for x in prufer:
        u = leaves[0]
        edges.append([u, x])
        leaves.pop(0)
        deg[u] -= 1
        deg[x] -= 1
        if deg[x] == 1:
            # insert x maintaining sorted order
            import bisect
            bisect.insort(leaves, x)
    # connect the last two leaves
    edges.append(leaves)
    return edges

# Cross-check harness (small n)
def cross_check():
    from collections import deque
    class Baseline:
        def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
            n = len(nums)
            adj = [[] for _ in range(n)]
            E = []
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
                E.append((min(u, v), max(u, v)))
            INF = 10**18
            best = INF
            m = len(E)
            def comp_xors(rem1, rem2):
                removed = {rem1, rem2}
                vis = [False]*n
                vals = []
                for s in range(n):
                    if vis[s]: continue
                    x = 0
                    dq = deque([s]); vis[s] = True
                    while dq:
                        u = dq.popleft()
                        x ^= nums[u]
                        for w in adj[u]:
                            e = (min(u, w), max(u, w))
                            if e in removed: continue
                            if not vis[w]:
                                vis[w] = True
                                dq.append(w)
                    vals.append(x)
                return vals
            for i in range(m):
                for j in range(i+1, m):
                    xs = comp_xors(E[i], E[j])
                    if len(xs) == 3:
                        best = min(best, max(xs)-min(xs))
            return best

    import itertools
    random.seed(0)
    for n in range(3, 9):
        for _ in range(30):
            if n <= 5:
                edges = gen_star(n) if random.random() < 0.5 else gen_chain(n)
            else:
                pr = [random.randrange(n) for _ in range(n-2)]
                edges = prufer_tree(pr)
            nums = [random.randint(1, 7) for _ in range(n)]
            b = Baseline().minimumScore(nums, edges)
            o = Solution().minimumScore(nums, edges)
            assert b == o, (n, nums, edges, b, o)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        g = [[] for _ in range(n)]
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        tin = [0] * n
        tout = [0] * n
        sub = [0] * n
        t = 0

        def dfs(u: int, p: int) -> int:
            nonlocal t
            tin[u] = t
            t += 1
            x = nums[u]
            for v in g[u]:
                if v == p:
                    continue
                x ^= dfs(v, u)
            sub[u] = x
            tout[u] = t
            return x

        dfs(0, -1)
        total = sub[0]

        def is_anc(a: int, b: int) -> bool:
            return tin[a] <= tin[b] and tout[b] <= tout[a]

        candidates = list(range(1, n))
        best = 10 ** 18
        L = len(candidates)
        for i in range(L):
            a = candidates[i]
            for j in range(i + 1, L):
                b = candidates[j]
                if is_anc(a, b):
                    x1 = sub[b]
                    x2 = sub[a] ^ sub[b]
                    x3 = total ^ sub[a]
                elif is_anc(b, a):
                    x1 = sub[a]
                    x2 = sub[b] ^ sub[a]
                    x3 = total ^ sub[b]
                else:
                    x1 = sub[a]
                    x2 = sub[b]
                    x3 = total ^ sub[a] ^ sub[b]
                spread = max(x1, x2, x3) - min(x1, x2, x3)
                if spread < best:
                    best = spread
        return int(best)

if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumScore([1,5,5,4,11], [[0,1],[1,2],[1,3],[3,4]]) == 9
    assert sol.minimumScore([5,5,2,4,4,2], [[0,1],[1,2],[5,2],[4,3],[1,3]]) == 0
    assert sol.minimumScore([7,7,7,7], [[0,1],[0,2],[0,3]]) == 7
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Precompute subtree XORs and ancestor relationships; then evaluate each pair of cuts in constant time to minimize the spread of the three component XORs.}
\WHY{Combining subtree properties with ancestor tests is a common pattern in tree DP and XOR problems; it appears in hard interview and contest settings.}
\CHECKLIST{
\begin{itemize}
\item Root the tree and run one DFS to get $\text{sub}$, $\text{tin}$, $\text{tout}$.
\item Compute total XOR $S=\text{sub}[0]$.
\item Enumerate unordered pairs of child nodes $a<b$.
\item Use ancestor test to pick the correct formula for $(X_1,X_2,X_3)$.
\item Track and return the minimum spread.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $n=3$ (exactly two edges): only one pair of cuts.
\item Star trees where both cuts are leaves.
\item Chains where one cut is ancestor of the other.
\item Equal weights leading to XOR $0$ components.
\item Large identical values causing high $S$ but small spread.
\item Cuts sharing the same parent.
\item Ensure components are three (tree property guarantees this).
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Incorrect ancestor check: use half-open intervals $[\text{tin},\text{tout})$.
\item Forgetting that the cut edge is represented by its child node.
\item Miscomputing the third component XOR: it is $S$ xor the other component XORs, not a sum.
\item Double counting ordered pairs; restrict to $a<b$.
\item Recursion depth in very deep chains (acceptable for $n\le 1000$; otherwise use iterative DFS).
\item Overflow is not a concern in Python, but ensure integer arithmetic for XORs.
\end{itemize}}
\FAILMODES{A naive per-pair traversal times out for larger $n$. The optimal approach avoids re-traversal by using precomputed subtree XORs and constant-time ancestor checks.}
\ELI{Cut two branches from a rooted tree. The three XORs are just the two branch XORs and the remainder, adjusted if one branch is inside the other. Try all branch pairs and keep the smallest difference between the largest and smallest XORs.}
\NotePages{3}

\end{document}