% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Campus}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/571/D}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{Oscolcovo city has a campus consisting of $n$ student dormitories, $n$ universities and $n$ military offices. Initially, the $i$-th dormitory belongs to the $i$-th university and is assigned to the $i$-th military office.

Life goes on and the campus is continuously going through some changes. The changes can be of four types:

1. University $a_j$ merges with university $b_j$. After that all the dormitories that belonged to university $b_j$ are assigned to to university $a_j$, and university $b_j$ disappears.
2. Military office $c_j$ merges with military office $d_j$. After that all the dormitories that were assigned to military office $d_j$, are assigned to military office $c_j$, and military office $d_j$ disappears.
3. Students of university $x_j$ move in dormitories. Let $k_{x_j}$ be the number of dormitories that belong to this university at the time when the students move in. Then the number of students in each dormitory of university $x_j$ increases by $k_{x_j}$ (note that the more dormitories belong to the university, the more students move in each dormitory of the university).
4. Military office number $y_j$ conducts raids on all the dormitories assigned to it and takes all students from there.

Thus, at each moment of time each dormitory is assigned to exactly one university and one military office. Initially, all the dormitories are empty.

Your task is to process the changes that take place in the campus and answer the queries, how many people currently live in dormitory $q_j$.

Input:
The first line contains two integers, $n$ and $m$ ($1 \le n, m \le 5\cdot 10^5$) — the number of dormitories and the number of queries, respectively.

Next $m$ lines contain the queries, each of them is given in one of the following formats:

- «U $a_j$ $b_j$» — merging universities;
- «M $c_j$ $d_j$» — merging military offices;
- «A $x_j$» — students of university $x_j$ moving in the dormitories;
- «Z $y_j$» — a raid in military office $y_j$;
- «Q $q_j$» — a query asking the number of people in dormitory $q_j$.

Output:
In the $i$-th line print the answer to the $i$-th query asking the number of people in the dormitory.

Note:
Consider the first sample test:

- In the first query university $1$ owns only dormitory $1$, so after the query dormitory $1$ will have $1$ student.
- After the third query university $1$ owns dormitories $1$ and $2$.
- The fourth query increases by $2$ the number of students living in dormitories $1$ and $2$ that belong to university number $1$. After that $3$ students live in the first dormitory and $2$ students live in the second dormitory.
- At the fifth query the number of students living in dormitory $1$, assigned to the military office $1$, becomes zero.}
\BREAKDOWN{We must support dynamic unions of two partitions (universities and offices), range-like adds to all dorms in a university by its current size, zeroing of all dorms in an office, and point queries per dorm.}
\ELI{Track per-dorm contribution from its university and subtract the last snapshot taken when its office was raided; unions are handled by DSU.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n, m$.
- $m$ operations, each one of U $a$ $b$, M $c$ $d$, A $x$, Z $y$, Q $q$. All indices in $[1,n]$.}
\OUTPUTS{For every Q $q$, print one integer — the current number of students in dormitory $q$. Each answer on its own line, in the order of queries.}
\SAMPLES{Example:
- Input:
  n=2, m=7
  A 1
  Q 1
  U 1 2
  A 1
  Q 1
  Z 1
  Q 1

- Output:
  1
  3
  0}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $D=\{1,\ldots,n\}$ dorms. There are two evolving partitions: $\mathcal{U}$ over $D$ (universities) and $\mathcal{M}$ over $D$ (offices). An operation A on a university class $U\in\mathcal{U}$ adds $|U|$ to every dorm in $U$. An operation Z on an office class $M\in\mathcal{M}$ sets the value of every dorm in $M$ to $0$. Unions U and M merge the respective classes. Queries return the current value at a dorm.}
\varmapStart
\var{U(d)}{current university class of dorm $d$}
\var{M(d)}{current office class of dorm $d$}
\var{A_U}{per-class accumulation for university class $U$}
\var{S(d)}{per-dorm last snapshot at the last Z affecting $d$}
\varmapEnd
\GOVERN{
\[
\text{value}(d) \;=\; \Big(\text{uni\_acc}(d)\Big) \;-\; S(d), \quad
\text{uni\_acc}(d) \;=\; A_{U(d)} - \text{join\_offset}(d).
\]
}
\ASSUMPTIONS{All indices are valid; merges produce proper partitions; no deletions except merges; operations are processed online.}
\INVARIANTS{
- Each dorm belongs to exactly one university class and one office class.
- $A_U$ is the same for all dorms in university class $U$; differences between dorms are entirely via their join offsets.
- After a raid Z on an office class $M$, for all $d\in M$ we set $S(d) \leftarrow \text{uni\_acc}(d)$ so subsequent value is $0$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain explicit sets for universities and offices; on A or Z, iterate the whole set and update each dorm.}
\ASSUMPTIONS{Suitable only for very small $n,m$ due to $O(n)$ per operation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep arrays: current university id $u[i]$, office id $o[i]$, and value $val[i]$.
\item On U $a$ $b$: for all $i$ with $u[i]=b$, set $u[i]\leftarrow a$.
\item On M $c$ $d$: for all $i$ with $o[i]=d$, set $o[i]\leftarrow c$.
\item On A $x$: let $k=\#\{i:u[i]=x\}$; for all $i$ with $u[i]=x$, do $val[i]{+}{=}k$.
\item On Z $y$: for all $i$ with $o[i]=y$, set $val[i]\leftarrow 0$; on Q $q$: print $val[q]$.
\end{algosteps}
\COMPLEXITY{$T(m)=O(mn)$ worst-case; $S(n)=O(n)$.}
\[
\begin{aligned}
T(m) &= \sum \text{(size of affected set)} \\
     &= O(mn) \text{ in the worst case.}
\end{aligned}
\]
\CORRECTNESS{Directly simulates the statement; invariants are preserved by construction.}
\EDGECASES{Merging already merged ids; repeated raids on empty offices; querying untouched dorms (remain $0$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from io import StringIO

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    return data.strip().splitlines()

def solve_all(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    # 1-indexed
    u = list(range(n + 1))
    o = list(range(n + 1))
    val = [0] * (n + 1)
    out = []
    for _ in range(m):
        parts = next(it).split()
        t = parts[0]
        if t == 'U':
            a = int(parts[1]); b = int(parts[2])
            for i in range(1, n + 1):
                if u[i] == b:
                    u[i] = a
        elif t == 'M':
            c = int(parts[1]); d = int(parts[2])
            for i in range(1, n + 1):
                if o[i] == d:
                    o[i] = c
        elif t == 'A':
            x = int(parts[1])
            k = sum(1 for i in range(1, n + 1) if u[i] == x)
            for i in range(1, n + 1):
                if u[i] == x:
                    val[i] += k
        elif t == 'Z':
            y = int(parts[1])
            for i in range(1, n + 1):
                if o[i] == y:
                    val[i] = 0
        elif t == 'Q':
            q = int(parts[1])
            out.append(str(val[q]))
        else:
            raise ValueError("unknown op")
    return "\n".join(out)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Tiny self-checks
    data = """2 7
A 1
Q 1
U 1 2
A 1
Q 1
Z 1
Q 1
"""
    assert solve_all(read_input(data)) == "1\n3\n0"
    data2 = """1 4
Q 1
A 1
Q 1
Z 1
"""
    assert solve_all(read_input(data2)) == "0\n1"
    # Uncomment to run with real stdin
    # main()
    pass
\end{minted}
\VALIDATION{Checked initial zero query; merge then add; raid then query returns $0$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DSU for Universities + Office Components with Members}
\WHICHFORMULA{Use DSU with potentials for universities to aggregate A operations in $O(\alpha(n))$; track offices as DSU with small-to-large member lists. On Z, snapshot each member’s current university-accumulated value.}
\ASSUMPTIONS{Union-by-size amortizes member moves across M merges; practical for moderate inputs; worst-case many Z operations can still be heavy.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item University-DSU (parent, size, add, diff): add[root] stores per-dorm accumulated adds for the component; diff[x] stores offset to parent so that uni\_acc(x) = add[find(x)] - diff\_to\_root(x).
\item On A $x$: let $r=\mathrm{find}(x)$; do add[$r$] $+=$ size[$r$].
\item On U $a$ $b$: union sets with union-by-size; when linking child root $rb$ under $ra$, set diff[$rb$] $=$ add[$ra$] $-$ add[$rb$].
\item Office-DSU tracks members of each root; on M merges, append smaller member list into larger.
\item Keep per-dorm snapshot $S[i]$; on Z $y$, for each $i$ in members of office-root $r$, set $S[i]\leftarrow$ uni\_acc($i$).
\item Answer Q $q$ by uni\_acc($q$) $-$ $S[q]$.
\end{algosteps}
\COMPLEXITY{All U/M/A/Q are near-constant amortized; Z costs linear in the office component size. If many raids hit large components, worst-case time increases, but member moves across M are amortized small-to-large.}
\[
\begin{aligned}
T(m) &\approx O\big(m\,\alpha(n) + \sum_{\text{raids}} |M_{\text{root}}|\big). \\
\end{aligned}
\]
\CORRECTNESS{University contributions are tracked lazily via DSU potentials. Raids store exact snapshots of each affected dorm’s university-accumulated value, so subtraction yields the correct remaining count. Merges preserve memberships and do not alter stored per-dorm snapshots.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from io import StringIO

class DSUUni:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.add = [0] * (n + 1)  # per-dorm accumulated adds for root
        self.diff = [0] * (n + 1) # offset to parent; to root after find

    def find(self, x):
        if self.parent[x] == x:
            return x
        p = self.parent[x]
        r = self.find(p)
        self.diff[x] += self.diff[p]
        self.parent[x] = r
        return r

    def uni_value(self, x):
        r = self.find(x)
        return self.add[r] - self.diff[x]

    def unite(self, a, b):
        ra = self.find(a); rb = self.find(b)
        if ra == rb:
            return ra
        # union by size
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        # link rb under ra
        self.parent[rb] = ra
        # set diff[rb] so that values for nodes in rb remain unchanged
        self.diff[rb] = self.add[ra] - self.add[rb]
        self.size[ra] += self.size[rb]
        return ra

    def add_op(self, x):
        r = self.find(x)
        self.add[r] += self.size[r]

class DSUOff:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.members = [[] for _ in range(n + 1)]
        for i in range(1, n + 1):
            self.members[i].append(i)

    def find(self, x):
        if self.parent[x] == x:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def unite(self, a, b):
        ra = self.find(a); rb = self.find(b)
        if ra == rb:
            return ra
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        # merge rb into ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]
        if self.members[rb]:
            self.members[ra].extend(self.members[rb])
            self.members[rb].clear()
        return ra

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    return data.strip().splitlines()

def solve_all(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    dsuU = DSUUni(n)
    dsuM = DSUOff(n)
    snap = [0] * (n + 1)  # last snapshot at raid for each dorm
    out = []
    for _ in range(m):
        parts = next(it).split()
        t = parts[0]
        if t == 'U':
            a = int(parts[1]); b = int(parts[2])
            dsuU.unite(a, b)
        elif t == 'M':
            c = int(parts[1]); d = int(parts[2])
            dsuM.unite(c, d)
        elif t == 'A':
            x = int(parts[1])
            dsuU.add_op(x)
        elif t == 'Z':
            y = int(parts[1])
            ry = dsuM.find(y)
            # snapshot all members at current university-accumulated value
            for v in dsuM.members[ry]:
                snap[v] = dsuU.uni_value(v)
        elif t == 'Q':
            q = int(parts[1])
            ans = dsuU.uni_value(q) - snap[q]
            out.append(str(ans))
        else:
            raise ValueError("unknown op")
    return "\n".join(out)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Tiny validations
    data = """2 7
A 1
Q 1
U 1 2
A 1
Q 1
Z 1
Q 1
"""
    assert solve_all(read_input(data)) == "1\n3\n0"
    data2 = """3 8
A 1
A 2
Q 1
U 1 2
A 1
Q 2
M 1 2
Z 1
"""
    # After A1: dorm1+=1; A2: dorm2+=1; Q1=1; U1 2 -> uni {1,2}; A1 -> +2 to dorm1,dorm2 => dorm1=3,dorm2=3; Q2=3; M1 2 merge offices; Z1 raid both dorm1,dorm2->0
    assert solve_all(read_input(data2)) == "1\n3"
    # main()
    pass
\end{minted}
\VALIDATION{Covers: add before and after university merges; raid after office merge; queries before/after raids.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Dual DSU with Potentials + Lazy Snapshots via Small-to-Large or Offline D\&C}
\WHICHFORMULA{Provably optimal solutions maintain:
- A DSU with potentials for universities; A-operations become $O(1)$ updates.
- An office structure that avoids per-dorm scans on Z. Two classic routes exist:
  (i) Maintain, for each office component, a map keyed by university-root to the last snapshot and merge maps small-to-large on office merges; and carefully reconcile keys on university merges via potential differences.
  (ii) Offline divide-and-conquer on time with DSU rollbacks: push A-contributions and Z-zeroing as signed events to time intervals between raids, and answer Q by accumulating contributions valid at the query time.}
\ASSUMPTIONS{Amortized $O(m \log n)$ or $O(m \alpha(n))$ with careful small-to-large/map/rollback engineering; persistence or rollback guarantees needed for the offline approach.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Track university adds with DSU potentials as in Approach B.
\item For offices:
  - Either store a hash map per office root: lastSeen[ru] = snapshot for university-root ru; on Z, set lastSeen[ru] to current add[ru] for all ru present in the office (obtainable from a per-office multiset of university roots); merge these maps small-to-large on M merges.
  - Or build an offline recursion over time, adding/removing contributions with DSU rollback and querying at leaves.
\item Queries subtract lastSeen for their current office and current university roots from the current accumulated add. Potential offsets guarantee correctness across future merges.
\end{algosteps}
\OPTIMALITY{Each dorm and each (office, university) pair migrates $O(\log n)$ times due to small-to-large merges; each map entry is touched $O(\log n)$ times, leading to near-linearithmic time. Rollback solutions achieve $O(m \log m)$ with polylog factors.}
\COMPLEXITY{With small-to-large maps: $T(m)=O(m \log n)$ expected with hashing, $S(n)=O(n)$ to $O(n \log n)$ for maps. With rollback D\&C: $T(m)=O(m \log m)$, $S(n)=O(n \log m)$.}
\[
\begin{aligned}
T(n,m) &= O\Big(m\,\alpha(n) + \sum \log n \Big) \quad \text{(small-to-large)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from io import StringIO

# Final reference: practical improved solver (Approach B).
# Note: This is a clear, correct implementation suitable for interviews and small to medium inputs.
# The theoretically optimal CF submission requires additional engineering (maps or rollback).

class DSUUni:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.add = [0] * (n + 1)
        self.diff = [0] * (n + 1)

    def find(self, x):
        if self.parent[x] == x:
            return x
        p = self.parent[x]
        r = self.find(p)
        self.diff[x] += self.diff[p]
        self.parent[x] = r
        return r

    def uni_value(self, x):
        r = self.find(x)
        return self.add[r] - self.diff[x]

    def unite(self, a, b):
        ra = self.find(a); rb = self.find(b)
        if ra == rb:
            return ra
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.diff[rb] = self.add[ra] - self.add[rb]
        self.size[ra] += self.size[rb]
        return ra

    def add_op(self, x):
        r = self.find(x)
        self.add[r] += self.size[r]

class DSUOff:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.members = [[] for _ in range(n + 1)]
        for i in range(1, n + 1):
            self.members[i].append(i)

    def find(self, x):
        if self.parent[x] == x:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def unite(self, a, b):
        ra = self.find(a); rb = self.find(b)
        if ra == rb:
            return ra
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]
        if self.members[rb]:
            self.members[ra].extend(self.members[rb])
            self.members[rb].clear()
        return ra

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    return data.strip().splitlines()

def solve_all(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    dsuU = DSUUni(n)
    dsuM = DSUOff(n)
    snap = [0] * (n + 1)
    out = []
    for _ in range(m):
        parts = next(it).split()
        t = parts[0]
        if t == 'U':
            a = int(parts[1]); b = int(parts[2])
            dsuU.unite(a, b)
        elif t == 'M':
            c = int(parts[1]); d = int(parts[2])
            dsuM.unite(c, d)
        elif t == 'A':
            x = int(parts[1])
            dsuU.add_op(x)
        elif t == 'Z':
            y = int(parts[1])
            ry = dsuM.find(y)
            for v in dsuM.members[ry]:
                snap[v] = dsuU.uni_value(v)
        elif t == 'Q':
            q = int(parts[1])
            out.append(str(dsuU.uni_value(q) - snap[q]))
        else:
            raise ValueError("unknown op")
    return "\n".join(out)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Exactly 3 asserts as smoke tests
    data = """2 7
A 1
Q 1
U 1 2
A 1
Q 1
Z 1
Q 1
"""
    assert solve_all(read_input(data)) == "1\n3\n0"
    data2 = """3 9
A 1
A 2
Q 1
U 1 2
A 1
Q 2
M 1 2
Z 1
Q 2
"""
    assert solve_all(read_input(data2)) == "1\n3\n0"
    data3 = """3 6
U 1 2
U 1 3
A 2
Q 1
Q 2
Q 3
"""
    # After merges, uni {1,2,3} size=3; A 2 adds 3 to all three; queries are 3
    assert solve_all(read_input(data3)) == "3\n3\n3"
    # main()
    pass
\end{minted}
\VALIDATION{Three asserts: sequence with adds/merges/raids; full-merge then add; post-raid query zero.}
\RESULT{Answers for Q are the current students per dorm; ties do not arise.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the DSU-university potential logic; test office merges with small-to-large; validate Z snapshots after interleaved U/M/A operations; random tiny fuzz comparing to baseline simulation.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and B on random $n\le 12$, $m\le 40$ sequences to validate correctness; ensure invariants are preserved after each step.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial sequences: repeated Z on same office; many U or M merges chaining; A on vanished labels; Q on never-touched dorms.}
\begin{minted}{python}
import random

def gen_case(n=8, m=30, seed=0):
    random.seed(seed)
    ops = []
    for _ in range(m):
        t = random.choice(['U','M','A','Z','Q'])
        if t in ('U','M'):
            a = random.randint(1,n)
            b = random.randint(1,n)
            while b == a:
                b = random.randint(1,n)
            ops.append(f"{t} {a} {b}")
        elif t in ('A','Z','Q'):
            x = random.randint(1,n)
            ops.append(f"{t} {x}")
    return f"{n} {m}\n" + "\n".join(ops) + "\n"

# Cross-check runner comparing baseline and improved
def run_cross_check():
    from io import StringIO
    # import the two solvers from previous sections
    def baseline(lines):
        it = iter(lines)
        n, m = map(int, next(it).split())
        u = list(range(n + 1))
        o = list(range(n + 1))
        val = [0] * (n + 1)
        out = []
        for _ in range(m):
            parts = next(it).split()
            t = parts[0]
            if t == 'U':
                a = int(parts[1]); b = int(parts[2])
                for i in range(1, n + 1):
                    if u[i] == b:
                        u[i] = a
            elif t == 'M':
                c = int(parts[1]); d = int(parts[2])
                for i in range(1, n + 1):
                    if o[i] == d:
                        o[i] = c
            elif t == 'A':
                x = int(parts[1])
                k = sum(1 for i in range(1, n + 1) if u[i] == x)
                for i in range(1, n + 1):
                    if u[i] == x:
                        val[i] += k
            elif t == 'Z':
                y = int(parts[1])
                for i in range(1, n + 1):
                    if o[i] == y:
                        val[i] = 0
            elif t == 'Q':
                q = int(parts[1])
                out.append(str(val[q]))
        return "\n".join(out)

    def improved(lines):
        return solve_all(lines)

    for seed in range(10):
        case = gen_case(8, 40, seed)
        bl = baseline(case.strip().splitlines())
        im = improved(case.strip().splitlines())
        assert bl == im, f"Mismatch on seed {seed}\n{case}\nBL:\n{bl}\nIM:\n{im}"
    return "ok"

if __name__ == "__main__":
    print(run_cross_check())
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Same as "Final Submission" in Approach C. See above for asserts.
import sys

class DSUUni:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.add = [0] * (n + 1)
        self.diff = [0] * (n + 1)

    def find(self, x):
        if self.parent[x] == x:
            return x
        p = self.parent[x]
        r = self.find(p)
        self.diff[x] += self.diff[p]
        self.parent[x] = r
        return r

    def uni_value(self, x):
        r = self.find(x)
        return self.add[r] - self.diff[x]

    def unite(self, a, b):
        ra = self.find(a); rb = self.find(b)
        if ra == rb:
            return ra
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.diff[rb] = self.add[ra] - self.add[rb]
        self.size[ra] += self.size[rb]
        return ra

    def add_op(self, x):
        r = self.find(x)
        self.add[r] += self.size[r]

class DSUOff:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.members = [[] for _ in range(n + 1)]
        for i in range(1, n + 1):
            self.members[i].append(i)

    def find(self, x):
        if self.parent[x] == x:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def unite(self, a, b):
        ra = self.find(a); rb = self.find(b)
        if ra == rb:
            return ra
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]
        if self.members[rb]:
            self.members[ra].extend(self.members[rb])
            self.members[rb].clear()
        return ra

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    return data.strip().splitlines()

def solve_all(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    dsuU = DSUUni(n)
    dsuM = DSUOff(n)
    snap = [0] * (n + 1)
    out = []
    for _ in range(m):
        parts = next(it).split()
        t = parts[0]
        if t == 'U':
            a = int(parts[1]); b = int(parts[2])
            dsuU.unite(a, b)
        elif t == 'M':
            c = int(parts[1]); d = int(parts[2])
            dsuM.unite(c, d)
        elif t == 'A':
            x = int(parts[1])
            dsuU.add_op(x)
        elif t == 'Z':
            y = int(parts[1])
            ry = dsuM.find(y)
            for v in dsuM.members[ry]:
                snap[v] = dsuU.uni_value(v)
        elif t == 'Q':
            q = int(parts[1])
            out.append(str(dsuU.uni_value(q) - snap[q]))
    return "\n".join(out)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # quick asserts
    data = """2 7
A 1
Q 1
U 1 2
A 1
Q 1
Z 1
Q 1
"""
    assert solve_all(read_input(data)) == "1\n3\n0"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Use DSU with potentials to aggregate university adds; handle office raids by per-dorm snapshots; unions of offices via small-to-large lists.}
\WHY{Exercises dynamic connectivity with aggregated updates and resets, a pattern common in advanced data structure interviews and CF hard problems.}
\CHECKLIST{
- Find-Compress for universities updates diff to root.
- On university union, set child-root diff = add[parent] $-$ add[child].
- On A, add to add[root] the size of the component.
- Maintain office members; on Z, snapshot each member’s current uni\_acc.
- Answer Q as uni\_acc $-$ snapshot.
}
\EDGECASES{
- Merging already merged components (U or M).
- A on a label that has been merged into another (find root).
- Z on an office with no members (noop).
- Q before any operations (should be $0$).
- Chains of U merges followed by A.
- Office merges followed by Z affecting multiple previously separate offices.
- Dorm moves between offices after a raid (snapshot remains attached to dorm).}
\PITFALLS{
- Forgetting to union-by-size for offices causing quadratic member moves.
- Incorrect diff update on university union (must preserve existing values).
- Using component size before path compression (size must be on root).
- Not compressing paths in university DSU leading to deep recursion and TLE.
- Overwriting office member lists when merging (must extend and clear donor).
- Off-by-one with 1-indexed dorms.}
\FAILMODES{Approach A will time out. Approach B can degrade if many raids hit very large office components repeatedly; optimal solutions avoid per-dorm scans using small-to-large maps per office or offline rollback.}
\ELI{Think of each dorm’s count as “what its university has ever added to it” minus “what was recorded for it at the last raid of its current office.” DSU lets us keep track of university additions after merges without touching every dorm.}
\NotePages{3}

\end{document}