% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Developing Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/377/D}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{Pavel is going to make a game of his dream. However, he knows that he cannot make it on his own so he founded a development company and hired $n$ workers of staff. Now he wants to pick workers from the staff who will be directly responsible for developing a game.

Each worker has a certain skill level $v_i$. Besides, each worker does not want to work with the one whose skill is very different. In other words, the $i$-th worker will not work with those whose skill is less than $l_i$, and with those whose skill is more than $r_i$.

Pavel understands that the game of his dream is not too hard to develop, so the worker with any skill will be equally useful. That is why he wants to pick a team of the maximum possible size. Help him pick such team.

Input:

The first line contains a single integer $n$ ($1 \le n \le 10^5$) — the number of workers Pavel hired.

Each of the following $n$ lines contains three space-separated integers $l_i$, $v_i$, $r_i$ ($1 \le l_i \le v_i \le r_i \le 3\cdot 10^5$) — the minimum skill value of the workers that the $i$-th worker can work with, the $i$-th worker's skill and the maximum skill value of the workers that the $i$-th worker can work with.

Output:

In the first line print a single integer $m$ — the number of workers Pavel must pick for developing the game.

In the next line print $m$ space-separated integers — the numbers of the workers in any order.

If there are multiple optimal solutions, print any of them.}
\BREAKDOWN{We must choose the largest set of indices such that each chosen worker tolerates all others' skill values. Equivalently, if $L$ and $R$ are the minimum and maximum skills within the team, then for every chosen $i$ we need $l_i \le L \le v_i \le R \le r_i$. We will find $L,R$ maximizing the count of workers satisfying this, then output all such indices.}
\ELI{Sweep a pointer $L$ across skills and maintain, over $R$, how many workers accept $[L,R]$ while having $v_i$ inside it; pick the best.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. Integer $n$; then $n$ lines each with integers $l_i$, $v_i$, $r_i$. Ranges: $1 \le n \le 10^5$, $1 \le l_i \le v_i \le r_i \le 3\cdot 10^5$. Indices are $1$-based in output.}
\OUTPUTS{First line: integer $m$ — the size of a maximum valid team. Second line: $m$ distinct indices (in any order) of workers forming such a team. Any maximum solution is acceptable.}
\SAMPLES{Example 1:

Input:
\begin{BreakableEquation*}
\begin{aligned}
3\\
1~2~3\\
2~2~2\\
1~3~3
\end{aligned}
\end{BreakableEquation*}
Output (one of many):
\begin{BreakableEquation*}
\begin{aligned}
2\\
1~2
\end{aligned}
\end{BreakableEquation*}

Example 2:

Input:
\begin{BreakableEquation*}
\begin{aligned}
4\\
1~1~10\\
1~5~10\\
1~7~10\\
1~10~10
\end{aligned}
\end{BreakableEquation*}
Output:
\begin{BreakableEquation*}
\begin{aligned}
4\\
1~2~3~4
\end{aligned}
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let each worker $i$ define a rectangle in the $(L,R)$ plane: $L \in [l_i, v_i]$ and $R \in [v_i, r_i]$. A team is feasible iff there exists a pair $(L,R)$ with $L \le R$ such that for every chosen worker $i$, its rectangle contains $(L,R)$. The objective is to maximize the count of rectangles covering a common point $(L,R)$.}
\varmapStart
\var{l_i}{Left tolerance bound of worker $i$}
\var{v_i}{Skill value of worker $i$}
\var{r_i}{Right tolerance bound of worker $i$}
\var{L}{Minimum skill inside the chosen team}
\var{R}{Maximum skill inside the chosen team}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For worker }i\text{ to be included:}\quad l_i \le L \le v_i \le R \le r_i.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Maximize }~|\{i:\ (L,R)\in [l_i,v_i]\times[v_i,r_i]\}|\quad \text{over integers }L\le R.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All $l_i,v_i,r_i$ are integers. Choosing all workers whose rectangles cover a common point $(L,R)$ yields a valid team.}
\INVARIANTS{While sweeping $L$ from left to right, the active set is $\{i: l_i \le L \le v_i\}$. Over this set, the coverage over $R$ equals the sum of indicator intervals $[v_i,r_i]$. The maximum coverage over $R$ at each $L$ is a well-defined integer and changes only at event positions.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the rectangle formulation. Try all candidate $L$ and for each, scan all workers to count, for every $R$, how many active rectangles cover $R$; pick the best $(L,R)$.}
\ASSUMPTIONS{Skill domain size up to $3\cdot 10^5$. Brute forces $L$ and updates a frequency array over $R$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each integer $L$ within observed bounds, find the set $A_L=\{i: l_i \le L \le v_i\}$.
\item Build an array $cnt$ over $R$ by adding $+1$ on $[v_i,r_i]$ for all $i\in A_L$.
\item Take $R$ with maximal $cnt[R]$; track the global best and reconstruct the team as $\{i: l_i \le L \le v_i \le R \le r_i\}$.
\end{algosteps}
\COMPLEXITY{Brute force across all $L$ and scanning all $n$ per $L$ gives $O(U\cdot n + U)$, where $U$ is the skill universe size. With $U\approx 3\cdot 10^5$, this is too slow for $n\approx 10^5$.}
\[
\begin{aligned}
T(n) &\approx O\bigl(U \cdot n\bigr) \\
S(n) &= O(U).
\end{aligned}
\]
\CORRECTNESS{Directly computes, for each $L$, the exact coverage over $R$ by summing contributions of active rectangles, thus identifies the optimal $(L,R)$.}
\EDGECASES{All workers identical; completely disjoint tolerances; single worker; many workers sharing same $v$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    arr = []
    for i in range(n):
        l = int(next(it)); v = int(next(it)); r = int(next(it))
        arr.append((l, v, r))
    return n, arr

def solve_case(n: int, arr: List[Tuple[int,int,int]]) -> Tuple[int, int, int, List[int]]:
    if n == 0:
        return 0, 0, 0, []
    max_coord = 0
    min_l = 10**9
    max_v = 0
    for (l, v, r) in arr:
        max_coord = max(max_coord, r, v)
        min_l = min(min_l, l)
        max_v = max(max_v, v)
    best = -1
    bestL = min_l
    bestR = min_l
    # Brute force over L but optimized counting would be required; here we keep as reference but
    # we will not actually run this on huge inputs in tests.
    # We still implement it correctly but with early break for small ranges in tests.
    # For safety, cap loops if domain too large; still correct for our asserts.
    U_L = range(min_l, max_v + 1)
    # We'll implement a difference-array trick per L to compute counts in O(n + U) per L.
    # For big inputs, this is slow; fine for tests.
    for L in U_L:
        # active rectangles: l_i <= L <= v_i
        diff = [0] * (max_coord + 3)
        active = 0
        for idx, (l, v, r) in enumerate(arr):
            if l <= L <= v:
                # add +1 on [v, r]
                diff[v] += 1
                diff[r + 1] -= 1
                active += 1
        if active == 0:
            continue
        cur = 0
        local_best = -1
        local_R = L
        for R in range(L, max_coord + 1):
            cur += diff[R]
            if cur > local_best:
                local_best = cur
                local_R = R
        if local_best > best:
            best = local_best
            bestL = L
            bestR = local_R
    # reconstruct indices (1-based)
    team = []
    for i, (l, v, r) in enumerate(arr, start=1):
        if l <= bestL <= v <= bestR <= r:
            team.append(i)
    return len(team), bestL, bestR, team

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    m, L, R, team = solve_case(n, arr)
    out_lines = []
    out_lines.append(str(m))
    out_lines.append(" ".join(map(str, team)))
    sys.stdout.write("\n".join(out_lines))

def _is_valid_team(arr: List[Tuple[int,int,int]], team: List[int]) -> bool:
    if not team:
        return True
    # Convert to 0-based
    vs = [arr[i-1][1] for i in team]
    L = min(vs); R = max(vs)
    for i in team:
        l, v, r = arr[i-1]
        if not (l <= L <= v <= R <= r):
            return False
    return True

def _bruteforce_best(arr: List[Tuple[int,int,int]]) -> int:
    # For small n only: returns size of optimal team
    n = len(arr)
    best = 0
    from itertools import combinations
    for k in range(n, -1, -1):
        for comb in combinations(range(1, n+1), k):
            if _is_valid_team(arr, list(comb)):
                return k
    return 0

def _self_test():
    # Tiny tests only (baseline is slow).
    arr = [(1,2,3),(2,2,2),(1,3,3)]
    m, L, R, team = solve_case(len(arr), arr)
    assert _is_valid_team(arr, team)
    assert m == _bruteforce_best(arr)
    arr2 = [(1,1,10),(1,5,10),(1,7,10),(1,10,10)]
    m2, L2, R2, team2 = solve_case(len(arr2), arr2)
    assert _is_valid_team(arr2, team2)
    assert m2 == 4
    arr3 = [(1,1,1),(2,2,2)]
    m3, L3, R3, team3 = solve_case(len(arr3), arr3)
    assert _is_valid_team(arr3, team3)
    assert m3 == 1

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        n, arr = read_input(data)
        m, L, R, team = solve_case(n, arr)
        sys.stdout.write(str(m) + "\n")
        sys.stdout.write(" ".join(map(str, team)) + ("\n" if team else "\n"))
\end{minted}
\VALIDATION{Includes brute-force checker for tiny arrays to ensure optimality and validity. Two crafted examples match expected sizes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Sweep $L$ and maintain, over $R$, a coverage of active rectangles via a range-add, range-maximum structure. For each $L$, add $+1$ on $[v_i,r_i]$ when $L$ reaches $l_i$, and add $-1$ when $L$ passes $v_i$.}
\ASSUMPTIONS{Skill coordinates are integers in $[1,3\cdot 10^5]$, enabling an indexed segment tree.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build event lists: at $L=l_i$ add interval $[v_i,r_i]$ with $+1$; at $L=v_i+1$ add interval $[v_i,r_i]$ with $-1$.
\item Sweep $L$ over sorted event keys; apply all interval updates to a lazy segment tree supporting range add and global maximum with argmax (smallest $R$ on ties).
\item Track the best coverage value and corresponding $(L,R)$ from the segment tree root at each sweep step; reconstruct the team. 
\end{algosteps}
\COMPLEXITY{Each of $2n$ updates costs $O(\log U)$ where $U \le 3\cdot 10^5$, and each step queries the root in $O(1)$.}
\[
\begin{aligned}
T(n) &= O\bigl((n + K)\log U\bigr),\ \text{with }K\le 2n \\
S(n) &= O(U + n).
\end{aligned}
\]
\CORRECTNESS{At any $L$, active workers are exactly those with $l_i \le L \le v_i$. Their contributions to feasible $R$ are intervals $[v_i,r_i]$. The segment tree stores the pointwise sum of these intervals; its maximum is the largest team size achievable with this $L$. Taking the maximum over all $L$ yields a globally optimal $(L,R)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

class SegTree:
    def __init__(self, n: int):
        self.N = 1
        while self.N < n:
            self.N <<= 1
        sz = self.N << 1
        self.val = [0] * sz     # max value
        self.add = [0] * sz     # lazy add
        self.idx = [0] * sz     # argmax index (global coordinate)
        # initialize idx so that leaves represent positions [0..N-1]
        def build(p: int, l: int, r: int):
            if l + 1 == r:
                self.idx[p] = l
            else:
                m = (l + r) // 2
                build(p*2, l, m)
                build(p*2+1, m, r)
                # tie-break to left child
                if self.val[p*2] >= self.val[p*2+1]:
                    self.val[p] = self.val[p*2]
                    self.idx[p] = self.idx[p*2]
                else:
                    self.val[p] = self.val[p*2+1]
                    self.idx[p] = self.idx[p*2+1]
        build(1, 0, self.N)

    def _push(self, p: int):
        if self.add[p] != 0:
            for c in (p*2, p*2+1):
                self.val[c] += self.add[p]
                self.add[c] += self.add[p]
            self.add[p] = 0

    def _pull(self, p: int):
        if self.val[p*2] >= self.val[p*2+1]:
            self.val[p] = self.val[p*2]
            self.idx[p] = self.idx[p*2]
        else:
            self.val[p] = self.val[p*2+1]
            self.idx[p] = self.idx[p*2+1]

    def range_add(self, L: int, R: int, delta: int, p: int = 1, l: int = 0, r: int = None):
        if r is None:
            r = self.N
        if R <= l or r <= L:
            return
        if L <= l and r <= R:
            self.val[p] += delta
            self.add[p] += delta
            return
        self._push(p)
        m = (l + r) // 2
        self.range_add(L, R, delta, p*2, l, m)
        self.range_add(L, R, delta, p*2+1, m, r)
        self._pull(p)

    def query_max(self) -> Tuple[int, int]:
        # returns (max_value, argmax_index)
        return self.val[1], self.idx[1]

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    arr = []
    for i in range(n):
        l = int(next(it)); v = int(next(it)); r = int(next(it))
        arr.append((l, v, r))
    return n, arr

def solve_case(n: int, arr: List[Tuple[int,int,int]]) -> Tuple[int, int, int, List[int]]:
    if n == 0:
        return 0, 0, 0, []
    max_coord = 0
    min_l = 10**9
    for (l, v, r) in arr:
        max_coord = max(max_coord, r, v)
        min_l = min(min_l, l)
    U = max_coord + 2  # coordinates [0..max_coord], we will use [1..max_coord] for skills
    st = SegTree(U + 5)
    # events: at L -> list of (v, r, delta)
    add_at: Dict[int, List[Tuple[int,int,int]]] = {}
    for (l, v, r) in arr:
        add_at.setdefault(l, []).append((v, r, +1))
        add_at.setdefault(v + 1, []).append((v, r, -1))
    best = -1
    bestL = min_l
    bestR = min_l
    for L in sorted(add_at.keys()):
        for (v, r, d) in add_at[L]:
            st.range_add(v, r + 1, d)  # inclusive r, so [v, r+1)
        cur, R = st.query_max()
        if cur > best:
            best = cur
            bestL = L
            bestR = R
    # reconstruct
    team = []
    for i, (l, v, r) in enumerate(arr, start=1):
        if l <= bestL <= v <= bestR <= r:
            team.append(i)
    return len(team), bestL, bestR, team

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    m, L, R, team = solve_case(n, arr)
    out_lines = []
    out_lines.append(str(m))
    out_lines.append(" ".join(map(str, team)))
    sys.stdout.write("\n".join(out_lines))

def _is_valid_team(arr: List[Tuple[int,int,int]], team: List[int]) -> bool:
    if not team:
        return True
    vs = [arr[i-1][1] for i in team]
    L = min(vs); R = max(vs)
    for i in team:
        l, v, r = arr[i-1]
        if not (l <= L <= v <= R <= r):
            return False
    return True

def _bruteforce_best(arr: List[Tuple[int,int,int]]) -> int:
    n = len(arr)
    best = 0
    from itertools import combinations
    for k in range(n, -1, -1):
        for comb in combinations(range(1, n+1), k):
            if _is_valid_team(arr, list(comb)):
                return k
    return 0

def _self_test():
    arr = [(1,2,3),(2,2,2),(1,3,3)]
    m, L, R, team = solve_case(len(arr), arr)
    assert _is_valid_team(arr, team)
    assert m == _bruteforce_best(arr)
    arr2 = [(1,1,10),(1,5,10),(1,7,10),(1,10,10)]
    m2, L2, R2, team2 = solve_case(len(arr2), arr2)
    assert _is_valid_team(arr2, team2)
    assert m2 == 4
    arr3 = [(1,1,1),(2,2,2)]
    m3, L3, R3, team3 = solve_case(len(arr3), arr3)
    assert _is_valid_team(arr3, team3)
    assert m3 == 1

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        n, arr = read_input(data)
        m, L, R, team = solve_case(n, arr)
        sys.stdout.write(str(m) + "\n")
        sys.stdout.write(" ".join(map(str, team)) + ("\n" if team else "\n"))
\end{minted}
\VALIDATION{Cross-check against a brute force solver on tiny random or crafted cases. Ensures returned team satisfies $l_i \le L \le v_i \le R \le r_i$ for all chosen $i$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Rectangle stabbing with maximum overlap via sweep line on $L$ and a lazy segment tree on $R$ for range add and global maximum with argmax.}
\ASSUMPTIONS{Discrete integer coordinates; updates happen only at $L\in\{l_i, v_i+1\}$. Any optimal $(L,R)$ can be realized at an event $L$ and an integer $R$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Create events: for each worker $i$, add $+1$ to $[v_i,r_i]$ at $L=l_i$, and $-1$ at $L=v_i+1$.
\item Sweep $L$ in increasing order, applying all its events to the segment tree.
\item After each $L$, read the tree's root: it gives best team size for this $L$ and the smallest $R$ attaining it. Track the global best and store $(L,R)$.
\item Reconstruct the team: all $i$ with $l_i \le L \le v_i \le R \le r_i$.
\end{algosteps}
\OPTIMALITY{Each worker contributes to all $(L,R)$ in its rectangle $[l_i,v_i]\times[v_i,r_i]$. The sweep maintains the exact superposition over $R$ for active rectangles. The maximum over $R$ at each $L$ is exact; maximizing over all event $L$ captures a global maximizer because the overlap function is piecewise-constant between events.}
\COMPLEXITY{$O\bigl((n + E)\log U\bigr)$ time with $E\le 2n$, $U\le 3\cdot 10^5+2$; $O(U)$ memory for the segment tree and $O(n)$ for events and reconstruction.}
\[
\begin{aligned}
T(n) &= O(n \log U), \quad S(n)=O(U+n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

class SegTree:
    def __init__(self, n: int):
        self.N = 1
        while self.N < n:
            self.N <<= 1
        sz = self.N << 1
        self.val = [0] * sz     # max value
        self.add = [0] * sz     # lazy add
        self.idx = [0] * sz     # argmax index
        def build(p: int, l: int, r: int):
            if l + 1 == r:
                self.idx[p] = l
            else:
                m = (l + r) // 2
                build(p*2, l, m)
                build(p*2+1, m, r)
                if self.val[p*2] >= self.val[p*2+1]:
                    self.val[p] = self.val[p*2]
                    self.idx[p] = self.idx[p*2]
                else:
                    self.val[p] = self.val[p*2+1]
                    self.idx[p] = self.idx[p*2+1]
        build(1, 0, self.N)

    def _push(self, p: int):
        if self.add[p] != 0:
            for c in (p*2, p*2+1):
                self.val[c] += self.add[p]
                self.add[c] += self.add[p]
            self.add[p] = 0

    def _pull(self, p: int):
        if self.val[p*2] >= self.val[p*2+1]:
            self.val[p] = self.val[p*2]
            self.idx[p] = self.idx[p*2]
        else:
            self.val[p] = self.val[p*2+1]
            self.idx[p] = self.idx[p*2+1]

    def range_add(self, L: int, R: int, delta: int, p: int = 1, l: int = 0, r: int = None):
        if r is None:
            r = self.N
        if R <= l or r <= L:
            return
        if L <= l and r <= R:
            self.val[p] += delta
            self.add[p] += delta
            return
        self._push(p)
        m = (l + r) // 2
        self.range_add(L, R, delta, p*2, l, m)
        self.range_add(L, R, delta, p*2+1, m, r)
        self._pull(p)

    def query_max(self) -> Tuple[int, int]:
        return self.val[1], self.idx[1]

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    arr = []
    for _ in range(n):
        l = int(next(it)); v = int(next(it)); r = int(next(it))
        arr.append((l, v, r))
    return n, arr

def solve_case(n: int, arr: List[Tuple[int,int,int]]) -> Tuple[int, int, int, List[int]]:
    if n == 0:
        return 0, 0, 0, []
    max_coord = 0
    min_l = 10**9
    for (l, v, r) in arr:
        max_coord = max(max_coord, r, v)
        min_l = min(min_l, l)
    U = max_coord + 3
    st = SegTree(U + 5)
    add_at: Dict[int, List[Tuple[int,int,int]]] = {}
    for (l, v, r) in arr:
        add_at.setdefault(l, []).append((v, r, +1))
        add_at.setdefault(v + 1, []).append((v, r, -1))
    best = -1
    bestL = min_l
    bestR = min_l
    for L in sorted(add_at.keys()):
        for (v, r, d) in add_at[L]:
            st.range_add(v, r + 1, d)
        cur, R = st.query_max()
        if cur > best:
            best = cur
            bestL = L
            bestR = R
    team = []
    for i, (l, v, r) in enumerate(arr, start=1):
        if l <= bestL <= v <= bestR <= r:
            team.append(i)
    return len(team), bestL, bestR, team

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    m, L, R, team = solve_case(n, arr)
    print(m)
    print(" ".join(map(str, team)))

def _is_valid_team(arr: List[Tuple[int,int,int]], team: List[int]) -> bool:
    if not team:
        return True
    vs = [arr[i-1][1] for i in team]
    L = min(vs); R = max(vs)
    for i in team:
        l, v, r = arr[i-1]
        if not (l <= L <= v <= R <= r):
            return False
    return True

def _bruteforce_best(arr: List[Tuple[int,int,int]]) -> int:
    n = len(arr)
    best = 0
    from itertools import combinations
    for k in range(n, -1, -1):
        for comb in combinations(range(1, n+1), k):
            if _is_valid_team(arr, list(comb)):
                return k
    return 0

def _self_test():
    # Deterministic mini-tests
    arr1 = [(1,2,3),(2,2,2),(1,3,3)]
    m1, L1, R1, team1 = solve_case(len(arr1), arr1)
    assert _is_valid_team(arr1, team1)
    assert m1 == _bruteforce_best(arr1)
    arr2 = [(1,1,10),(1,5,10),(1,7,10),(1,10,10)]
    m2, L2, R2, team2 = solve_case(len(arr2), arr2)
    assert _is_valid_team(arr2, team2) and m2 == 4
    arr3 = [(1,1,1),(2,2,2)]
    m3, L3, R3, team3 = solve_case(len(arr3), arr3)
    assert _is_valid_team(arr3, team3) and m3 == 1

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        n, arr = read_input(data)
        m, L, R, team = solve_case(n, arr)
        sys.stdout.write(str(m) + "\n")
        sys.stdout.write(" ".join(map(str, team)) + ("\n" if team else "\n"))
\end{minted}
\VALIDATION{Exactly 3 asserts in the self-test verify feasibility, optimality on tiny cases, and a case where the answer is the full set.}
\RESULT{Outputs any maximum-cardinality set of indices satisfying $l_i \le L \le v_i \le R \le r_i$, where $(L,R)$ is chosen to maximize coverage.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check the segment tree for range-add and argmax behavior. Validate on random tiny instances by comparing to a brute-force solver. Include crafted edge cases: identical workers, disjoint intervals, nested intervals, all $v_i$ equal, extreme coordinates.}
\LINE{CROSS-CHECKS}{On small $n$, compare the improved/optimal solver's team size to brute force. Ensure the reconstructed team indeed satisfies the inclusion inequalities for all members.}
\LINE{EDGE-CASE GENERATOR}{Generates adversarial patterns: increasing $v_i$ with shrinking $[l_i,r_i]$; clustered $v_i$ with wide $[l_i,r_i]$; single-point tolerances $l_i=v_i=r_i$.}
\begin{minted}{python}
import random
from typing import List, Tuple

def gen_case(n: int, V: int) -> List[Tuple[int,int,int]]:
    arr = []
    for _ in range(n):
        v = random.randint(1, V)
        L = random.randint(1, v)
        R = random.randint(v, V)
        arr.append((L, v, R))
    return arr

def brute_best(arr: List[Tuple[int,int,int]]) -> int:
    from itertools import combinations
    n = len(arr)
    def ok(team: List[int]) -> bool:
        if not team:
            return True
        vs = [arr[i][1] for i in team]
        L = min(vs); R = max(vs)
        for i in team:
            l, v, r = arr[i]
            if not (l <= L <= v <= R <= r):
                return False
        return True
    for k in range(n, -1, -1):
        for comb in combinations(range(n), k):
            if ok(list(comb)):
                return k
    return 0

# Reference solver (reusing optimal code)
class SegTree:
    def __init__(self, n: int):
        self.N = 1
        while self.N < n:
            self.N <<= 1
        sz = self.N << 1
        self.val = [0] * sz
        self.add = [0] * sz
        self.idx = [0] * sz
        def build(p,l,r):
            if l+1==r:
                self.idx[p]=l
            else:
                m=(l+r)//2
                build(p*2,l,m); build(p*2+1,m,r)
                if self.val[p*2] >= self.val[p*2+1]:
                    self.val[p]=self.val[p*2]; self.idx[p]=self.idx[p*2]
                else:
                    self.val[p]=self.val[p*2+1]; self.idx[p]=self.idx[p*2+1]
        build(1,0,self.N)
    def _push(self,p):
        if self.add[p]:
            for c in (p*2,p*2+1):
                self.val[c]+=self.add[p]; self.add[c]+=self.add[p]
            self.add[p]=0
    def _pull(self,p):
        if self.val[p*2] >= self.val[p*2+1]:
            self.val[p]=self.val[p*2]; self.idx[p]=self.idx[p*2]
        else:
            self.val[p]=self.val[p*2+1]; self.idx[p]=self.idx[p*2+1]
    def range_add(self,L,R,d,p=1,l=0,r=None):
        if r is None: r=self.N
        if R<=l or r<=L: return
        if L<=l and r<=R:
            self.val[p]+=d; self.add[p]+=d; return
        self._push(p); m=(l+r)//2
        self.range_add(L,R,d,p*2,l,m); self.range_add(L,R,d,p*2+1,m,r)
        self._pull(p)
    def query_max(self): return self.val[1], self.idx[1]

def optimal(arr: List[Tuple[int,int,int]]) -> int:
    max_coord = 0; min_l = 10**9
    for (l,v,r) in arr:
        max_coord = max(max_coord, r, v); min_l = min(min_l, l)
    U = max_coord + 3
    st = SegTree(U+5)
    events = {}
    for (l,v,r) in arr:
        events.setdefault(l, []).append((v,r,1))
        events.setdefault(v+1, []).append((v,r,-1))
    best = -1
    for L in sorted(events.keys()):
        for (v,r,d) in events[L]:
            st.range_add(v, r+1, d)
        best = max(best, st.query_max()[0])
    return best

def run_tests():
    random.seed(0)
    # crafted
    arr1 = [(1,2,3),(2,2,2),(1,3,3)]
    assert optimal(arr1) == brute_best(arr1)
    # random tiny
    for _ in range(200):
        n = random.randint(1, 7)
        V = random.randint(3, 12)
        arr = gen_case(n, V)
        assert optimal(arr) == brute_best(arr)

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

class SegTree:
    def __init__(self, n: int):
        self.N = 1
        while self.N < n:
            self.N <<= 1
        sz = self.N << 1
        self.val = [0] * sz
        self.add = [0] * sz
        self.idx = [0] * sz
        def build(p: int, l: int, r: int):
            if l + 1 == r:
                self.idx[p] = l
            else:
                m = (l + r) // 2
                build(p*2, l, m)
                build(p*2+1, m, r)
                if self.val[p*2] >= self.val[p*2+1]:
                    self.val[p] = self.val[p*2]
                    self.idx[p] = self.idx[p*2]
                else:
                    self.val[p] = self.val[p*2+1]
                    self.idx[p] = self.idx[p*2+1]
        build(1, 0, self.N)
    def _push(self, p: int):
        if self.add[p] != 0:
            for c in (p*2, p*2+1):
                self.val[c] += self.add[p]
                self.add[c] += self.add[p]
            self.add[p] = 0
    def _pull(self, p: int):
        if self.val[p*2] >= self.val[p*2+1]:
            self.val[p] = self.val[p*2]
            self.idx[p] = self.idx[p*2]
        else:
            self.val[p] = self.val[p*2+1]
            self.idx[p] = self.idx[p*2+1]
    def range_add(self, L: int, R: int, delta: int, p: int = 1, l: int = 0, r: int = None):
        if r is None:
            r = self.N
        if R <= l or r <= L:
            return
        if L <= l and r <= R:
            self.val[p] += delta
            self.add[p] += delta
            return
        self._push(p)
        m = (l + r) // 2
        self.range_add(L, R, delta, p*2, l, m)
        self.range_add(L, R, delta, p*2+1, m, r)
        self._pull(p)
    def query_max(self) -> Tuple[int, int]:
        return self.val[1], self.idx[1]

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    arr = []
    for _ in range(n):
        l = int(next(it)); v = int(next(it)); r = int(next(it))
        arr.append((l, v, r))
    return n, arr

def solve_case(n: int, arr: List[Tuple[int,int,int]]) -> Tuple[int, List[int]]:
    if n == 0:
        return 0, []
    max_coord = 0
    min_l = 10**9
    for (l, v, r) in arr:
        max_coord = max(max_coord, r, v)
        min_l = min(min_l, l)
    U = max_coord + 3
    st = SegTree(U + 5)
    events: Dict[int, List[Tuple[int,int,int]]] = {}
    for (l, v, r) in arr:
        events.setdefault(l, []).append((v, r, +1))
        events.setdefault(v + 1, []).append((v, r, -1))
    best = -1
    bestL = min_l
    bestR = min_l
    for L in sorted(events.keys()):
        for (v, r, d) in events[L]:
            st.range_add(v, r + 1, d)
        cur, R = st.query_max()
        if cur > best:
            best = cur
            bestL = L
            bestR = R
    team = []
    for i, (l, v, r) in enumerate(arr, start=1):
        if l <= bestL <= v <= bestR <= r:
            team.append(i)
    return len(team), team

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    m, team = solve_case(n, arr)
    print(m)
    print(" ".join(map(str, team)))

def _is_valid(arr: List[Tuple[int,int,int]], team: List[int]) -> bool:
    if not team:
        return True
    vs = [arr[i-1][1] for i in team]
    L = min(vs); R = max(vs)
    for i in team:
        l, v, r = arr[i-1]
        if not (l <= L <= v <= R <= r):
            return False
    return True

def _self_test():
    # Exactly 3 deterministic asserts
    arr1 = [(1,2,3),(2,2,2),(1,3,3)]
    m1, team1 = solve_case(len(arr1), arr1)
    assert _is_valid(arr1, team1) and m1 >= 2
    arr2 = [(1,1,10),(1,5,10),(1,7,10),(1,10,10)]
    m2, team2 = solve_case(len(arr2), arr2)
    assert _is_valid(arr2, team2) and m2 == 4
    arr3 = [(1,1,1),(2,2,2)]
    m3, team3 = solve_case(len(arr3), arr3)
    assert _is_valid(arr3, team3) and m3 == 1

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        n, arr = read_input(data)
        m, team = solve_case(n, arr)
        sys.stdout.write(str(m) + "\n")
        sys.stdout.write(" ".join(map(str, team)) + ("\n" if team else "\n"))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the number of workers whose rectangles $[l_i,v_i]\times[v_i,r_i]$ share a common integer point $(L,R)$.}
\WHY{This pattern (max overlap with range add + max query) appears in scheduling, interval stabbing, and sweep-line problems common in interviews and contests.}
\CHECKLIST{%
\begin{bullets}
\item Translate pairwise constraints to a global $(L,R)$ condition.
\item Build add/remove events at $L=l_i$ and $L=v_i+1$.
\item Maintain range-add and global max over $R$.
\item Track best count and $(L,R)$; reconstruct by checking $l_i \le L \le v_i \le R \le r_i$.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item Single worker: answer is $1$ with that index.
\item All $v_i$ equal: $L=R=v$; ensure events and updates handle equality.
\item Disjoint tolerances: expect answer $1$.
\item Wide tolerances: potentially include all workers.
\item Multiple $R$ tie: any smallest $R$ argmax is fine.
\item Large coordinates: ensure segment tree size accounts for $r_i+1$.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Off-by-one on removing at $L=v_i+1$ (not $L=v_i$).
\item Range updates should be $[v_i,r_i+1)$ to make $r_i$ inclusive.
\item Forgetting to tie-break argmax consistently can cause nondeterministic reconstruction.
\item Not sweeping only over event $L$ values wastes time.
\item Indexing mismatch between $0$-based tree and $1$-based skills.
\item Reconstructing team with wrong predicate (must check full chain $l_i \le L \le v_i \le R \le r_i$).
\end{bullets}}
\FAILMODES{Brute force over $L$ and $R$ times $n$ fails at constraints; naive per-$L$ recomputation of counts leads to $O(U\cdot n)$ time. The segment tree sweep survives by aggregating updates and querying the maximum in $O(\log U)$.}
\ELI{Imagine drawing each worker as a rectangle on a board. Slide a vertical line $L$ from left to right; at each position, stack all horizontal spans $[v_i,r_i]$ that are active. The tallest stack tells how many workers agree; remember where it is tallest and pick those workers.}
\NotePages{3}

\end{document}