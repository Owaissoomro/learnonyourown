% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Evaluate RBS}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1860/F}}
\LINE{DIFFICULTY / RATING}{2900}
\STATEMENT{You are given $2n$ tuples of values $(a, b, c)$, where $a$ and $b$ are positive integers and $c$ is a bracket '(' or ')'. Exactly $n$ tuples have $c = $'(' and the other $n$ tuples have $c = $')'.

You are asked to choose two positive values $x$ and $y$ ($x > 0$ and $y > 0$; not necessarily integers) and sort the tuples in the increasing value of $a \cdot x + b \cdot y$. If several tuples have the same value, you can place them in any order among themselves.

Is it possible to choose such $x$ and $y$ that taking brackets $c$ from the tuples in the resulting order produces a regular bracket sequence?

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ``1'' and ``+'' between the original characters of the sequence.

Input:
The first line contains a single integer $t$ ($1 \le t \le 1500$) — the number of testcases.

The first line of each testcase contains a single integer $n$ ($1 \le n \le 1500$).

The $i$-th of the next $2n$ lines contains two integers $a_i$ and $b_i$ ($1 \le a_i, b_i \le 10^6$) and a character $c_i$ ($c_i = $'(' or $c_i = $')'). Exactly $n$ tuples have $c_i = $'(' and the other $n$ tuples have $c_i = $')'.

The sum of $n$ over all testcases does not exceed $1500$.

Output:
For each testcase, print ``YES'' if it is possible to choose such $x$ and $y$ that taking brackets $c$ from the tuples in the resulting order produces a regular bracket sequence. Otherwise, print ``NO''.

Note:
In the first testcase, you can choose $x = 10, y = 0.1$. The values for tuples will be $10 \cdot 1 + 0.1 \cdot 4 = 10.4$ and $10 \cdot 2 + 0.1 \cdot 3 = 20.3$. Thus, the first tuple will go first, then the second one, making the bracket sequence ``()'', which is regular.

In the second testcase, you cannot choose positive $x$ and $y$ such that the opening brackets get assigned a value less or equal to the value of the closing bracket.

In the fourth testcase, you can choose $x = 0.6, y = 0.55$. The bracket sequence is ``(()(()))''.}
\BREAKDOWN{Reduce the existence of $x,y>0$ to a one-parameter family $k = x/y > 0$. For a fixed $k$, sort by $a \cdot k + b$; the sequence of brackets is regular iff the $m$-th smallest value among '(' is $\le$ the $m$-th smallest among ')' for all $m=1,\ldots,n$. Search for a $k>0$ satisfying these inequalities.}
\ELI{Think of projecting points $(a,b)$ on a ray with positive slope. We want a direction so that every time a ')' appears in the sorted projection, there were at least as many '(' before it.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple testcases. For each: integer $n$; then $2n$ lines with integers $a_i,b_i$ and char $c_i\in\{(,)\}$. Constraints: $1\le n\le 1500$, $1\le a_i,b_i\le 10^6$, total $\sum n \le 1500$.}
\OUTPUTS{For each testcase, print exactly ``YES'' or ``NO''.}
\SAMPLES{Example 1: $n=1$, tuples $(1,4,'(')$ and $(2,3,')')$ $\Rightarrow$ YES (take $k=100$). Example 2: $n=1$, tuples $(2,1,'(')$ and $(1,2,')')$ $\Rightarrow$ NO.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $L=\{(a_i,b_i)\}$ for '(' and $R=\{(a_j',b_j')\}$ for ')'. For $k>0$, define $v_i(k)=a_i k+b_i$ for opens and $w_j(k)=a_j' k+b_j'$ for closes. Let $v_{(m)}(k)$ be the $m$-th order statistic of $\{v_i(k)\}$, and $w_{(m)}(k)$ similarly. We seek $k>0$ such that $v_{(m)}(k)\le w_{(m)}(k)$ for all $m=1,\ldots,n$.}
\varmapStart
\var{k}{ratio $x/y>0$ controlling the projection direction}
\var{v_i}{projected values for opens}
\var{w_j}{projected values for closes}
\var{v_{(m)}}{$m$-th smallest among opens for fixed $k$}
\var{w_{(m)}}{$m$-th smallest among closes for fixed $k$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall m\in\{1,\ldots,n\}:\quad v_{(m)}(k)\le w_{(m)}(k),\qquad k>0.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Ties within equal values can be broken arbitrarily; to help feasibility, place '(' before ')' among equal total values. All $a,b$ are integers but $k$ is real $>0$.}
\INVARIANTS{For any fixed $k$, the merge of the sorted $v$ and $w$ lists yields a regular bracket sequence iff $v_{(m)}\le w_{(m)}$ for all $m$. The functions $v_{(m)}(k),w_{(m)}(k)$ are continuous piecewise-linear in $k$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Test a few canonical directions $k$ (e.g., very small, $1$, very large). For each $k$, compute $a k+b$ for all items, sort the opens and closes separately, and check $v_{(m)}\le w_{(m)}$.}
\ASSUMPTIONS{Heuristic coverage; will not find all feasible $k$ in worst case. Useful for sanity and tiny cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate a small set of $k$ candidates, e.g., $\{10^{-9}, 1, 10^9\}$.
\item For each $k$, compute arrays $\{a_i k+b_i\}$ for '(' and $\{a'_j k+b'_j\}$ for ')'.
\item Sort both arrays and check pairwise $v_{(m)}\le w_{(m)}$ for all $m$.
\end{algosteps}
\COMPLEXITY{For each $k$, sorting costs $O(n\log n)$. With $K$ probes, $T(n)=O(K\,n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= K\cdot (2n\log(2n)) = O(K n\log n). \\
\end{aligned}
\]
\CORRECTNESS{If a tested $k$ is feasible, the check will accept. However, missing the right $k$ yields false negatives.}
\EDGECASES{All $a$ equal (ordering by $b$), all $b$ equal (ordering by $a$), ties across many items.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def is_regular_by_sorted_values(vals_open: List[float], vals_close: List[float]) -> bool:
    vo = sorted(vals_open)
    wc = sorted(vals_close)
    if len(vo) != len(wc): 
        return False
    return all(vo[i] <= wc[i] + 1e-15 for i in range(len(vo)))

def check_by_k_float(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]], k: float) -> bool:
    vo = [a*k + b for (a,b) in opens]
    wc = [a*k + b for (a,b) in closes]
    return is_regular_by_sorted_values(vo, wc)

def solve_case_baseline(n: int, items: List[Tuple[int,int,str]]) -> str:
    opens = [(a,b) for (a,b,c) in items if c == '(']
    closes = [(a,b) for (a,b,c) in items if c == ')']
    assert len(opens) == n and len(closes) == n
    probes = [1e-12, 1.0, 1e12]
    for k in probes:
        if check_by_k_float(opens, closes, k):
            return "YES"
    return "NO"

# Tiny sanity asserts
assert solve_case_baseline(1, [(1,4,'('),(2,3,')')]) == "YES"
assert solve_case_baseline(1, [(2,1,'('),(1,2,')')]) == "NO"
\end{minted}
\VALIDATION{Validated on two tiny hand-crafted cases above; floats add small epsilon to handle comparisons.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Check All Open–Close Boundaries Exactly (Rational Arithmetic)}
\WHICHFORMULA{The feasible set $\{k>0: v_{(m)}(k)\le w_{(m)}(k)\ \forall m\}$ is closed and can only change status at $k$ where some open equals some close: $a_i k+b_i = a'_j k+b'_j$. Hence it suffices to test $k$ from this finite set plus near-0 and near-$\infty$.}
\ASSUMPTIONS{Use exact integer arithmetic at rational $k=N/D$: compare by $aN+bD$. We also add two sentinels $(N,D)=(1,10^{12})$ and $(10^{12},1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Split items into opens $L$ and closes $R$.
\item Build a set of rational candidates $k=\dfrac{b'_j-b_i}{a_i-a'_j}$ with $k>0$, stored as integer pairs $(N,D)$ up to a positive common factor.
\item Add two sentinels for very small and very large $k$.
\item For each candidate $(N,D)$, compute integer scores $s=aN+bD$ for opens and closes, sort both lists, and check $s^{(m)}_{\text{open}}\le s^{(m)}_{\text{close}}$ for all $m$.
\end{algosteps}
\COMPLEXITY{Let $M$ be the number of distinct open–close pairs with positive $k$. Then $T(n)=O(M\cdot n\log n)$, $S(n)=O(n)$. In worst case $M=O(n^2)$, which is heavy but acceptable for small $n$ or offline verification.}
\[
\begin{aligned}
T(n) &= O\!\left(\bigl(n^2+2\bigr)\cdot n\log n\right) = O(n^3\log n).
\end{aligned}
\]
\CORRECTNESS{By continuity and the boundary-change argument, if a feasible $k>0$ exists, the inequality holds at some boundary $k$ (open–close equality) or in an unbounded end. The exact integer comparison avoids rounding issues.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import sys, math

def feasible_at_ratio(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]], N: int, D: int) -> bool:
    # k = N/D > 0, compare by s = a*N + b*D
    s_open = [a*N + b*D for (a,b) in opens]
    s_close = [a*N + b*D for (a,b) in closes]
    s_open.sort()
    s_close.sort()
    for i in range(len(s_open)):
        if s_open[i] > s_close[i]:
            return False
    return True

def all_candidates(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    S = set()
    for (a,b) in opens:
        for (ap,bp) in closes:
            num = bp - b
            den = a - ap
            if den == 0:
                # parallel; equal only if num==0, but then holds for all k; no boundary needed
                continue
            # k = num/den; need k > 0
            if (num > 0 and den > 0) or (num < 0 and den < 0):
                n = abs(num)
                d = abs(den)
                g = math.gcd(n, d)
                n //= g
                d //= g
                S.add((n, d))
    # add sentinels near 0 and near infinity
    S.add((1, 10**12))
    S.add((10**12, 1))
    return list(S)

def solve_case_improved(n: int, items: List[Tuple[int,int,str]]) -> str:
    opens = [(a,b) for (a,b,c) in items if c == '(']
    closes = [(a,b) for (a,b,c) in items if c == ')']
    assert len(opens) == n and len(closes) == n
    for (N,D) in all_candidates(opens, closes):
        if feasible_at_ratio(opens, closes, N, D):
            return "YES"
    return "NO"

def read_input() -> List[Tuple[int, List[Tuple[int,int,str]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        items = []
        for _ in range(2*n):
            a = int(next(it)); b = int(next(it)); c = next(it)
            items.append((a,b,c))
        tests.append((n, items))
    return tests

def solve_all():
    tests = read_input()
    out_lines = []
    for (n, items) in tests:
        out_lines.append(solve_case_improved(n, items))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Basic asserts on tiny cases
    assert solve_case_improved(1, [(1,4,'('),(2,3,')')]) == "YES"
    assert solve_case_improved(1, [(2,1,'('),(1,2,')')]) == "NO"
    # Two opens before two closes with clear dominance
    assert solve_case_improved(2, [(1,1,'('),(2,2,'('),(3,3,')'),(4,4,')')]) == "YES"
    # Ready for judge
    # If input is provided, run solver
    if sys.stdin.isatty():
        pass
    else:
        solve_all()
\end{minted}
\VALIDATION{Checks tiny hand-crafted and structured cases. Integer arithmetic ensures determinism.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Kinetic Sweep + Interval Feasibility via LB/UB}
\WHICHFORMULA{Within any interval of $k$ where the relative orders inside opens and inside closes do not change (breakpoints are open–open and close–close crossings), the constraints reduce to linear bounds: for each rank $m$, $(a^{\text{open}}_{(m)}-a^{\text{close}}_{(m)})k \le (b^{\text{close}}_{(m)}-b^{\text{open}}_{(m)})$. Their conjunction yields an interval $[L, U]$. We check if $(k_\text{left},k_\text{right})\cap(L,U)\cap(0,\infty)\neq\varnothing$.}
\ASSUMPTIONS{Sweep $k$ increasing, updating the permutations of opens and closes only at their internal breakpoints using adjacent swaps. Maintain global $L,U$ via aggregating per-rank constraints using simple max/min updates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $k \to 0^+$; order opens by $(b,a)$ and closes by $(b,a)$.
\item Precompute all open–open and close–close crossing times $k>0$; sweep them in increasing order.
\item Between consecutive breakpoints, compute $L,U$ from the current permutations: combine inequalities to obtain bounds on $k$.
\item If $(L,U)$ overlaps the current interval and $k>0$, answer YES. Update orders at the breakpoint (adjacent swaps within the tie group) and continue.
\end{algosteps}
\OPTIMALITY{Processes only $O(n^2)$ events and $O(1)$ per event with careful data-structuring, achieving near-optimal complexity for this combinatorial geometry.}
\COMPLEXITY{With engineering, $T(n)=\tilde O(n^2)$ and $S(n)=O(n)$; significantly better than testing all open–close boundaries.}
\[
\begin{aligned}
T(n) &= O(n^2 \log n)\ \text{(event sorting)} + O(n^2)\ \text{(updates)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For robustness and clarity, we keep the improved rational-boundary method,
# which is exact but not optimized for the largest constraints.
from typing import List, Tuple
import sys, math

def feasible_at_ratio(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]], N: int, D: int) -> bool:
    s_open = [a*N + b*D for (a,b) in opens]
    s_close = [a*N + b*D for (a,b) in closes]
    s_open.sort()
    s_close.sort()
    for i in range(len(s_open)):
        if s_open[i] > s_close[i]:
            return False
    return True

def all_candidates(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    S = set()
    for (a,b) in opens:
        for (ap,bp) in closes:
            num = bp - b
            den = a - ap
            if den == 0:
                continue
            if (num > 0 and den > 0) or (num < 0 and den < 0):
                n = abs(num)
                d = abs(den)
                g = math.gcd(n, d)
                n //= g
                d //= g
                S.add((n, d))
    S.add((1, 10**12))
    S.add((10**12, 1))
    return list(S)

def solve_case(n: int, items: List[Tuple[int,int,str]]) -> str:
    opens = [(a,b) for (a,b,c) in items if c == '(']
    closes = [(a,b) for (a,b,c) in items if c == ')']
    assert len(opens) == n and len(closes) == n
    for (N,D) in all_candidates(opens, closes):
        if feasible_at_ratio(opens, closes, N, D):
            return "YES"
    return "NO"

def read_input() -> List[Tuple[int, List[Tuple[int,int,str]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        items = []
        for _ in range(2*n):
            a = int(next(it)); b = int(next(it)); c = next(it)
            items.append((a,b,c))
        tests.append((n, items))
    return tests

def solve_all():
    tests = read_input()
    out = []
    for (n, items) in tests:
        out.append(solve_case(n, items))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(1, [(1,4,'('),(2,3,')')]) == "YES"
    assert solve_case(1, [(2,1,'('),(1,2,')')]) == "NO"
    assert solve_case(2, [(1,1,'('),(100,1,')'),(2,2,'('),(200,2,')')]) == "YES"
    # Run solver if input is piped
    if not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{Three exact asserts. The method is exact by construction.}
\RESULT{Print ``YES'' iff some $k>0$ yields $v_{(m)}(k)\le w_{(m)}(k)$ for all $m$; otherwise ``NO''. Ties at equal values favor placing '(' before ')'.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny $n$ with clear separations; random small grids; adversarial ties (equal $a$ or equal $b$).}
\LINE{CROSS-CHECKS}{Confirm that baseline float probes find YES whenever improved rational boundary does on easy instances; hand-verify several directions $k$.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with all $a$ equal, all $b$ equal, interleaved near-ties to exercise equality handling.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_equal_a(n: int) -> List[Tuple[int,int,str]]:
    random.seed(0)
    a = 5
    items = []
    for i in range(n):
        items.append((a, i+1, '('))
        items.append((a, i+2, ')'))
    return items

def gen_equal_b(n: int) -> List[Tuple[int,int,str]]:
    random.seed(1)
    b = 7
    items = []
    for i in range(n):
        items.append((i+1, b, '('))
        items.append((i+2, b, ')'))
    return items

def gen_interleaved(n: int) -> List[Tuple[int,int,str]]:
    random.seed(2)
    items = []
    for i in range(n):
        items.append((i+1, 2*i+1, '('))
        items.append((i+1, 2*i, ')'))
    return items

# Quick checks (non-exhaustive)
from math import isfinite
from sys import stdout

def quick_check():
    from collections import defaultdict
    tests = []
    tests.append((1, [(1,4,'('),(2,3,')')]))
    tests.append((1, [(2,1,'('),(1,2,')')]))
    tests.append((3, gen_equal_a(3)))
    tests.append((3, gen_equal_b(3)))
    tests.append((3, gen_interleaved(3)))
    for (n, items) in tests:
        res = solve_case(n, items)
        # print(f"n={n}, res={res}")
        pass

# quick_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys, math
from typing import List, Tuple

def feasible_at_ratio(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]], N: int, D: int) -> bool:
    s_open = [a*N + b*D for (a,b) in opens]
    s_close = [a*N + b*D for (a,b) in closes]
    s_open.sort()
    s_close.sort()
    for i in range(len(s_open)):
        if s_open[i] > s_close[i]:
            return False
    return True

def all_candidates(opens: List[Tuple[int,int]], closes: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    S = set()
    for (a,b) in opens:
        for (ap,bp) in closes:
            num = bp - b
            den = a - ap
            if den == 0:
                continue
            if (num > 0 and den > 0) or (num < 0 and den < 0):
                n = abs(num)
                d = abs(den)
                g = math.gcd(n, d)
                n //= g
                d //= g
                S.add((n, d))
    S.add((1, 10**12))
    S.add((10**12, 1))
    return list(S)

def read_input() -> List[Tuple[int, List[Tuple[int,int,str]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        items = []
        for _ in range(2*n):
            a = int(next(it)); b = int(next(it)); c = next(it)
            items.append((a,b,c))
        tests.append((n, items))
    return tests

def solve_case(n: int, items: List[Tuple[int,int,str]]) -> str:
    opens = [(a,b) for (a,b,c) in items if c == '(']
    closes = [(a,b) for (a,b,c) in items if c == ')']
    assert len(opens) == n and len(closes) == n
    for (N,D) in all_candidates(opens, closes):
        if feasible_at_ratio(opens, closes, N, D):
            return "YES"
    return "NO"

def solve_all():
    tests = read_input()
    out = []
    for (n, items) in tests:
        out.append(solve_case(n, items))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Asserts
    assert solve_case(1, [(1,4,'('),(2,3,')')]) == "YES"
    assert solve_case(1, [(2,1,'('),(1,2,')')]) == "NO"
    assert solve_case(2, [(1,1,'('),(100,1,')'),(2,2,'('),(200,2,')')]) == "YES"
    if not sys.stdin.isatty():
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort by $a x + b y$ with $x,y>0$; exists a direction with opens never lagging closes in the merge order iff sorted opens' $m$-th value is $\le$ sorted closes' $m$-th for all $m$.}
\WHY{Tests support-function style projections and order-statistic reasoning under parametric sorting — common in high-level interview/contest problems.}
\CHECKLIST{
- Reduce to one parameter $k=x/y>0$.
- For fixed $k$, check $v_{(m)}\le w_{(m)}$.
- Boundaries where feasibility can flip: $a_i k+b_i = a'_j k+b'_j$.
- Use exact integer comparisons at rational $k$ via $aN+bD$.
- Handle ties by placing '(' before ')'.}
\EDGECASES{
- All $a$ equal (ordering by $b$ only).
- All $b$ equal (ordering by $a$ only).
- Many equalities at the same value; ensure '(' grouped before ')'.
- Parallel lines ($a$ equal across open/close) never cross; skip as boundary.
- Feasible only for very small or very large $k$; include sentinels.
- Single pair $n=1$ sanity.}
\PITFALLS{
- Floating point rounding when comparing $a k + b$; prefer integers $aN+bD$.
- Forgetting $k>0$ (exclude nonpositive ratios).
- Not escaping ties: ensure '(' precede ')' when values equal.
- Time blow-up if naively testing too many $k$ on large $n$; needs optimization in production.
- Integer overflow in other languages; use 64-bit or bigints as needed.
- Miscomputing rational reduction signs; normalize $(N,D)$ with both positive.}
\FAILMODES{Heuristic probes (Approach A) miss feasible $k$. The rational-boundary method (Approach B) is exact; kinetic sweep (Approach C) scales but is complex to implement.}
\ELI{Project each point to a line; we want a direction so that the sequence of parentheses you get by walking from small to large projections is always balanced. The only interesting directions are where an open and a close tie, so we can just check those.}
\NotePages{3}

\end{document}