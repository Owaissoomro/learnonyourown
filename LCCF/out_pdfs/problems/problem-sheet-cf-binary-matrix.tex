% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Binary Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/884/E}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{You are given a matrix of size $n \times m$. Each element of the matrix is either $1$ or $0$. You have to determine the number of connected components consisting of $1$'s. Two cells belong to the same component if they have a common border, and both elements in these cells are $1$'s.

Note that the memory limit is unusual.

Input:
The first line contains two numbers $n$ and $m$ ($1 \le n \le 2^{12}$, $4 \le m \le 2^{14}$) — the number of rows and columns, respectively. It is guaranteed that $m$ is divisible by $4$.

Then the representation of matrix follows. Each of $n$ next lines contains $m/4$ one-digit hexadecimal numbers (that is, these numbers can be represented either as digits from $0$ to $9$ or as uppercase Latin letters from A to F). Binary representation of each of these numbers denotes next $4$ elements of the matrix in the corresponding row. For example, if the number B is given, then the corresponding elements are $1011$, and if the number is $5$, then the corresponding elements are $0101$.

Elements are not separated by whitespaces.

Output:
Print the number of connected components consisting of $1$'s.

Note:
In the first example the matrix is:

It is clear that it has three components.

The second example:

It is clear that the number of components is $2$.

There are no $1$'s in the third example, so the answer is $0$.}
\BREAKDOWN{Parse hex rows to bits on the fly; treat consecutive $1$'s in a row as segments; sweep row by row, merging segments with overlapping segments from the previous row via DSU; maintain running component count: add segments, subtract successful unions.}
\ELI{Count islands of $1$'s in a big binary image given in hex, but only keep two rows' segment structure at a time to save memory.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$, $m$ with $1 \le n \le 2^{12}$, $4 \le m \le 2^{14}$ and $4 \mid m$. Then $n$ lines, each a string of length $m/4$ over $\{0,\ldots,9,\text{A},\ldots,\text{F}\}$.}
\OUTPUTS{A single integer: the number of connected components of $1$'s under $4$-neighborhood (up, down, left, right).}
\SAMPLES{Sample 1
\[
\begin{aligned}
\text{Input} &:~ 1~4\\
&~\text{F}\\
\text{Output} &:~ 1
\end{aligned}
\]

Sample 2
\[
\begin{aligned}
\text{Input} &:~ 2~4\\
&~\text{5}\\
&~\text{5}\\
\text{Output} &:~ 2
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \{0,1\}^{n \times m}$. Define an undirected graph $G=(V,E)$ where $V=\{(i,j)\mid A_{ij}=1\}$ and $E=\{\{(i,j),(i',j')\}\mid |i-i'|+|j-j'|=1,~A_{ij}=A_{i'j'}=1\}$. We want the number of connected components of $G$.}
\varmapStart
\var{n}{number of rows}
\var{m}{number of columns}
\var{S_i}{set of maximal horizontal segments of $1$'s in row $i$}
\var{\ell..r}{inclusive column interval of a segment}
\var{\mathrm{cls}}{equivalence class id (component label) maintained across adjacent rows}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \#\text{segments in all rows} \;-\; \#\text{successful unions of vertically overlapping segments}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Rows are processed top to bottom; within a row, maximal runs of $1$'s are single components unless connected vertically to previous rows.}
\INVARIANTS{
\begin{bullets}
\item After processing row $i$, every segment in row $i$ is assigned a class id equal across segments if and only if they are connected via some path in rows $\le i$.
\item The running answer equals the number of components in the prefix of rows processed.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Materialize the entire $n \times m$ binary grid and run a standard flood-fill (BFS/DFS) over $4$-neighbors to count connected components.}
\ASSUMPTIONS{Memory is sufficient to store $O(nm)$ booleans and a visited array; recursion is replaced with an explicit stack/queue to avoid recursion limits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse each hex line into $m$ bits, appending to a $n \times m$ boolean matrix.
\item Iterate all cells; when an unvisited $1$ is found, BFS its $4$-neighborhood marking visited and increment the component counter.
\item Print the counter.
\end{algosteps}
\COMPLEXITY{Time $O(nm)$; space $O(nm)$ for the grid and visited.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm), \\
S(n,m) &= \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{Flood-fill enumerates exactly the connected components under $4$-adjacency.}
\EDGECASES{Empty grid of $1$'s; full grid of $1$'s; single row or column; alternating bit patterns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def hex_to_bits_row(m, s):
    bits = [0] * m
    pos = 0
    for ch in s.strip():
        if '0' <= ch <= '9':
            v = ord(ch) - ord('0')
        else:
            v = 10 + ord(ch) - ord('A')
        for b in (3, 2, 1, 0):
            if pos < m:
                bits[pos] = (v >> b) & 1
                pos += 1
    return bits

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    rows = [next(it) for _ in range(n)]
    return n, m, rows

def solve_case(n, m, rows):
    grid = [hex_to_bits_row(m, rows[i]) for i in range(n)]
    vis = [[False] * m for _ in range(n)]
    comp = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 1 and not vis[i][j]:
                comp += 1
                dq = deque()
                dq.append((i, j))
                vis[i][j] = True
                while dq:
                    x, y = dq.popleft()
                    for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < n and 0 <= ny < m and not vis[nx][ny] and grid[nx][ny] == 1:
                            vis[nx][ny] = True
                            dq.append((nx, ny))
    return str(comp)

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, rows = inp
    print(solve_case(n, m, rows))

if __name__ == "__main__":
    # Tiny asserts
    assert hex_to_bits_row(4, "F") == [1,1,1,1]
    assert hex_to_bits_row(4, "5") == [0,1,0,1]
    # 1x4 all ones -> 1 component
    assert solve_case(1, 4, ["F"]) == "1"
    # 2x4: rows 5,5 -> 2 vertical columns of ones
    assert solve_case(2, 4, ["5", "5"]) == "2"
    # 2x4: rows 5,A -> no vertical connections
    assert solve_case(2, 4, ["5", "A"]) == "4"
    # Uncomment to run with stdin
    # solve_all()
\end{minted}
\VALIDATION{Cross-check tiny patterns: vertical-only, horizontal-only, checkerboard.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Row Segments + Rolling DSU}
\WHICHFORMULA{Represent each row by its maximal runs of $1$'s (segments). A segment is one component unless merged vertically with overlapping segments from the previous row. Maintain a DSU over previous classes and current segments to count unions.}
\ASSUMPTIONS{Only two adjacent rows interact; we retain only the previous row's segments and their compact class ids.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row, parse hex to bits on the fly and emit segments $[\ell,r]$ of consecutive $1$'s.
\item Maintain counter $ans$. For the current row with $c$ segments, set $ans \leftarrow ans + c$.
\item Build DSU of size $k+c$ where $k$ is the number of distinct classes among previous-row segments. Union node $k+i$ for current segment $i$ with node $prev\_class[j]$ for every previous-row segment $j$ that overlaps it; decrement $ans$ on each successful union.
\item Compact the DSU representatives of current segments into new class ids $0..k'-1$; store them with the current segments for the next iteration.
\end{algosteps}
\COMPLEXITY{Linear in the number of bits plus the number of segment overlaps.}
\[
\begin{aligned}
T &= \Theta\Big(nm + \sum_{i=2}^{n}(\#S_{i-1} + \#S_i)\Big) = \Theta(nm),\\
S &= \Theta(\#S_{i-1} + \#S_i) \le \Theta(m).
\end{aligned}
\]
\CORRECTNESS{Every horizontal run is counted once; every vertical connection between runs across adjacent rows is counted exactly once as a DSU union, reducing the component count accordingly. DSU maintains transitive connectivity across multiple rows.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0] * n
    def find(self, a):
        while self.p[a] != a:
            self.p[a] = self.p[self.p[a]]
            a = self.p[a]
        return a
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        return True

def parse_segments(m, s):
    segs = []
    col = 0
    in_run = False
    start = 0
    for ch in s.strip():
        if '0' <= ch <= '9':
            v = ord(ch) - ord('0')
        else:
            v = 10 + ord(ch) - ord('A')
        for b in (3, 2, 1, 0):
            bit = (v >> b) & 1
            if bit == 1:
                if not in_run:
                    in_run = True
                    start = col
            else:
                if in_run:
                    segs.append((start, col - 1))
                    in_run = False
            col += 1
    if in_run:
        segs.append((start, col - 1))
    return segs

def read_input():
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    rows = [next(it) for _ in range(n)]
    return n, m, rows

def solve_case(n, m, rows):
    prev_segs = []
    prev_labels = []
    k = 0  # number of classes among prev_segs
    ans = 0
    for i in range(n):
        curr_segs = parse_segments(m, rows[i])
        c = len(curr_segs)
        ans += c
        dsu = DSU(k + c)
        # sweep overlap
        j = 0
        P = len(prev_segs)
        for idx, (cl, cr) in enumerate(curr_segs):
            while j < P and prev_segs[j][1] < cl:
                j += 1
            t = j
            while t < P and prev_segs[t][0] <= cr:
                if dsu.union(prev_labels[t], k + idx):
                    ans -= 1
                t += 1
        # compact current labels
        mapping = [-1] * (k + c)
        next_labels = [0] * c
        next_k = 0
        for idx in range(c):
            root = dsu.find(k + idx)
            if mapping[root] == -1:
                mapping[root] = next_k
                next_k += 1
            next_labels[idx] = mapping[root]
        prev_segs = curr_segs
        prev_labels = next_labels
        k = next_k
    return str(ans)

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, rows = inp
    print(solve_case(n, m, rows))

if __name__ == "__main__":
    # basic asserts
    assert parse_segments(4, "0") == []
    assert parse_segments(4, "F") == [(0,3)]
    assert parse_segments(4, "5") == [(1,1),(3,3)]
    # 1x4
    assert solve_case(1, 4, ["0"]) == "0"
    assert solve_case(1, 4, ["F"]) == "1"
    # 2x4
    assert solve_case(2, 4, ["5","5"]) == "2"
    assert solve_case(2, 4, ["5","A"]) == "4"
    # Uncomment to run with stdin
    # solve_all()
\end{minted}
\VALIDATION{Compare against a slow BFS on random tiny grids; test degenerate rows with no segments; test full rows.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Row Segments + DSU with Overlap Sweep}
\WHICHFORMULA{Same as Approach B, with careful two-pointer sweep over sorted segments to achieve linear time per row and optional per-row deduplication to avoid redundant unions.}
\ASSUMPTIONS{Hex-to-bits is MSB-first per nibble; intervals overlap if and only if $\max(\ell_1,\ell_2) \le \min(r_1,r_2)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse current row into segments; add their count to the answer.
\item Build DSU over previous classes and current segments; sweep to union overlaps; decrement the answer upon each successful union.
\item Relabel current segments' representatives densely for the next iteration.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect all input bits; the sweep processes each segment boundary a constant number of times. Thus the method is optimal up to constant factors in $nm$.}
\COMPLEXITY{Time $\Theta(nm)$, space $O(m)$ working memory; no full grid storage.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm), \\
S(n,m) &= O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0] * n
    def find(self, a):
        while self.p[a] != a:
            self.p[a] = self.p[self.p[a]]
            a = self.p[a]
        return a
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        return True

def parse_segments(m, s):
    segs = []
    col = 0
    in_run = False
    start = 0
    for ch in s.strip():
        if '0' <= ch <= '9':
            v = ord(ch) - ord('0')
        else:
            v = 10 + ord(ch) - ord('A')
        for b in (3, 2, 1, 0):
            bit = (v >> b) & 1
            if bit == 1:
                if not in_run:
                    in_run = True
                    start = col
            else:
                if in_run:
                    segs.append((start, col - 1))
                    in_run = False
            col += 1
    if in_run:
        segs.append((start, col - 1))
    return segs

def read_input():
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    rows = [next(it) for _ in range(n)]
    return n, m, rows

def solve_case(n, m, rows):
    prev_segs = []
    prev_labels = []
    k = 0
    ans = 0
    for i in range(n):
        curr_segs = parse_segments(m, rows[i])
        c = len(curr_segs)
        ans += c
        dsu = DSU(k + c)
        j = 0
        P = len(prev_segs)
        for idx, (cl, cr) in enumerate(curr_segs):
            while j < P and prev_segs[j][1] < cl:
                j += 1
            t = j
            # Optional dedup per current segment to avoid repeated unions with same class
            last_seen_class = -1
            while t < P and prev_segs[t][0] <= cr:
                pc = prev_labels[t]
                # Union; no-op if already connected
                if dsu.union(pc, k + idx):
                    ans -= 1
                t += 1
        # Compact current segment representatives
        mapping = [-1] * (k + c)
        next_labels = [0] * c
        next_k = 0
        for idx in range(c):
            root = dsu.find(k + idx)
            if mapping[root] == -1:
                mapping[root] = next_k
                next_k += 1
            next_labels[idx] = mapping[root]
        prev_segs = curr_segs
        prev_labels = next_labels
        k = next_k
    return str(ans)

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, rows = inp
    print(solve_case(n, m, rows))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(1, 4, ["0"]) == "0"
    assert solve_case(1, 4, ["F"]) == "1"
    assert solve_case(2, 4, ["5","A"]) == "4"
    # Uncomment to run with stdin
    # solve_all()
\end{minted}
\VALIDATION{Three sanity checks included; further randomized cross-checks recommended.}
\RESULT{Print a single integer: the number of $4$-connected components of $1$'s.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-validate the optimized segment-DSU method against a slow BFS on random small cases; include degenerate rows with no $1$'s and fully $1$ rows.}
\LINE{CROSS-CHECKS}{For $n,m \le 16$, generate random grids, encode to hex, and compare counts from BFS and DSU solutions.}
\LINE{EDGE-CASE GENERATOR}{Produce rows with alternating nibbles, all zeros, all ones, and single-bit spikes.}
\begin{minted}{python}
import sys
import random
from collections import deque

# --- Slow BFS reference ---
def hex_to_bits_row(m, s):
    bits = [0] * m
    pos = 0
    for ch in s.strip():
        if '0' <= ch <= '9':
            v = ord(ch) - ord('0')
        else:
            v = 10 + ord(ch) - ord('A')
        for b in (3, 2, 1, 0):
            if pos < m:
                bits[pos] = (v >> b) & 1
                pos += 1
    return bits

def bfs_count(n, m, rows):
    grid = [hex_to_bits_row(m, rows[i]) for i in range(n)]
    vis = [[False]*m for _ in range(n)]
    comp = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 1 and not vis[i][j]:
                comp += 1
                dq = deque([(i,j)])
                vis[i][j] = True
                while dq:
                    x,y = dq.popleft()
                    for dx,dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and not vis[nx][ny] and grid[nx][ny] == 1:
                            vis[nx][ny] = True
                            dq.append((nx,ny))
    return comp

# --- Fast DSU row-segment method (reference) ---
class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0] * n
    def find(self, a):
        while self.p[a] != a:
            self.p[a] = self.p[self.p[a]]
            a = self.p[a]
        return a
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        return True

def parse_segments(m, s):
    segs = []
    col = 0
    in_run = False
    start = 0
    for ch in s.strip():
        if '0' <= ch <= '9':
            v = ord(ch) - ord('0')
        else:
            v = 10 + ord(ch) - ord('A')
        for b in (3,2,1,0):
            bit = (v >> b) & 1
            if bit == 1:
                if not in_run:
                    in_run = True
                    start = col
            else:
                if in_run:
                    segs.append((start, col-1))
                    in_run = False
            col += 1
    if in_run:
        segs.append((start, col-1))
    return segs

def fast_count(n, m, rows):
    prev_segs = []
    prev_labels = []
    k = 0
    ans = 0
    for i in range(n):
        curr_segs = parse_segments(m, rows[i])
        c = len(curr_segs)
        ans += c
        dsu = DSU(k + c)
        j = 0
        P = len(prev_segs)
        for idx, (cl, cr) in enumerate(curr_segs):
            while j < P and prev_segs[j][1] < cl:
                j += 1
            t = j
            while t < P and prev_segs[t][0] <= cr:
                if dsu.union(prev_labels[t], k + idx):
                    ans -= 1
                t += 1
        mapping = [-1] * (k + c)
        next_labels = [0] * c
        next_k = 0
        for idx in range(c):
            root = dsu.find(k + idx)
            if mapping[root] == -1:
                mapping[root] = next_k
                next_k += 1
            next_labels[idx] = mapping[root]
        prev_segs = curr_segs
        prev_labels = next_labels
        k = next_k
    return ans

def bits_to_hex_row(bits):
    # bits: list of 0/1 length m, m divisible by 4
    out = []
    for i in range(0, len(bits), 4):
        val = (bits[i] << 3) | (bits[i+1] << 2) | (bits[i+2] << 1) | bits[i+3]
        if val < 10:
            out.append(chr(ord('0') + val))
        else:
            out.append(chr(ord('A') + (val - 10)))
    return ''.join(out)

def gen_random_case(n, m, p=0.5, rng=random.Random(0)):
    rows = []
    for _ in range(n):
        bits = [1 if rng.random() < p else 0 for _ in range(m)]
        rows.append(bits_to_hex_row(bits))
    return rows

def read_input():
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    rows = [next(it) for _ in range(n)]
    return n, m, rows

def solve_case(n, m, rows):
    return str(fast_count(n, m, rows))

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, rows = inp
    print(solve_case(n, m, rows))

if __name__ == "__main__":
    # Cross-check random small cases
    rng = random.Random(123)
    for n in range(1, 6):
        for m in (4, 8, 12, 16):
            for _ in range(50):
                rows = gen_random_case(n, m, p=0.4, rng=rng)
                a = bfs_count(n, m, rows)
                b = fast_count(n, m, rows)
                assert a == b, (n, m, rows, a, b)
    # Edge patterns
    assert fast_count(1, 4, ["0"]) == 0
    assert fast_count(1, 4, ["F"]) == 1
    assert fast_count(2, 4, ["F", "0"]) == 1
    assert fast_count(2, 4, ["5", "5"]) == 2
    # Ready for submission
    # solve_all()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0] * n
    def find(self, a):
        while self.p[a] != a:
            self.p[a] = self.p[self.p[a]]
            a = self.p[a]
        return a
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        return True

def parse_segments(m, s):
    segs = []
    col = 0
    in_run = False
    start = 0
    for ch in s.strip():
        if '0' <= ch <= '9':
            v = ord(ch) - ord('0')
        else:
            v = 10 + ord(ch) - ord('A')
        for b in (3, 2, 1, 0):
            bit = (v >> b) & 1
            if bit == 1:
                if not in_run:
                    in_run = True
                    start = col
            else:
                if in_run:
                    segs.append((start, col - 1))
                    in_run = False
            col += 1
    if in_run:
        segs.append((start, col - 1))
    return segs

def read_input():
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    rows = [next(it) for _ in range(n)]
    return n, m, rows

def solve_case(n, m, rows):
    prev_segs = []
    prev_labels = []
    k = 0
    ans = 0
    for i in range(n):
        curr_segs = parse_segments(m, rows[i])
        c = len(curr_segs)
        ans += c
        dsu = DSU(k + c)
        j = 0
        P = len(prev_segs)
        for idx, (cl, cr) in enumerate(curr_segs):
            while j < P and prev_segs[j][1] < cl:
                j += 1
            t = j
            while t < P and prev_segs[t][0] <= cr:
                if dsu.union(prev_labels[t], k + idx):
                    ans -= 1
                t += 1
        mapping = [-1] * (k + c)
        next_labels = [0] * c
        next_k = 0
        for idx in range(c):
            root = dsu.find(k + idx)
            if mapping[root] == -1:
                mapping[root] = next_k
                next_k += 1
            next_labels[idx] = mapping[root]
        prev_segs = curr_segs
        prev_labels = next_labels
        k = next_k
    return str(ans)

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, rows = inp
    print(solve_case(n, m, rows))

if __name__ == "__main__":
    # Sanity asserts (no output)
    assert solve_case(1, 4, ["0"]) == "0"
    assert solve_case(1, 4, ["F"]) == "1"
    assert solve_case(2, 4, ["5","A"]) == "4"
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count $4$-connected components of $1$'s in a large binary matrix given in hex form, using only $O(m)$ memory.}
\WHY{A classic grid-connectivity task with a twist: compressed input and tight memory; tests ability to derive a streaming/rolling DSU solution.}
\CHECKLIST{
\begin{bullets}
\item Parse hex MSB-first per nibble.
\item Build segments $[\ell,r]$ per row.
\item Add segment count to answer.
\item Two-pointer sweep overlaps with previous row; DSU-union and decrement answer on merge.
\item Relabel current segments' representatives densely for the next iteration.
\item Reset state when a row has zero segments.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Entirely zero rows; entirely one rows.
\item Single row or single segment spanning whole row.
\item Rows with adjacent segments touching at endpoints but not overlapping.
\item Checkerboard patterns with no vertical connections.
\item Very wide rows ($m$ large) with few segments.
\item Alternating hex like \texttt{AAAA...} vs \texttt{5555...}.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Reading bits LSB-first; must be MSB-first within each hex digit.
\item Off-by-one in segment end indices; use inclusive $[\ell,r]$.
\item Forgetting to increment answer before unions.
\item Double-counting unions; DSU handles this but ensure union return value guards decrement.
\item Carrying previous segments' indices instead of their compact class ids.
\item Not resetting previous state when current row has zero segments (keep $k=0$).
\end{bullets}
}
\FAILMODES{Materializing the full grid can exceed memory on worst cases; naive per-cell DSU across entire grid wastes memory and time; row-local DSU avoids both.}
\ELI{Treat each horizontal run of ones as a tentative island, then glue islands together only when the row below overlaps them. You only ever need the last row’s runs to know how to glue the next row.}
\NotePages{3}

\end{document}