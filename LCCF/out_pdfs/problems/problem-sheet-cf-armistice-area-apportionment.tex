% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Armistice Area Apportionment}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/645/G}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{After a drawn-out mooclear arms race, Farmer John and the Mischievous Mess Makers have finally agreed to establish peace. They plan to divide the territory of Bovinia with a line passing through at least two of the $n$ outposts scattered throughout the land. These outposts, remnants of the conflict, are located at the points $(x_1, y_1)$, $(x_2, y_2)$, \ldots, $(x_n, y_n)$.

In order to find the optimal dividing line, Farmer John and Elsie have plotted a map of Bovinia on the coordinate plane. Farmer John's farm and the Mischievous Mess Makers' base are located at the points $P=(a,0)$ and $Q=(-a,0)$, respectively. Because they seek a lasting peace, Farmer John and Elsie would like to minimize the maximum difference between the distances from any point on the line to $P$ and $Q$.

Formally, define the difference of a line $e$ relative to two points $P$ and $Q$ as the smallest real number $d$ so that for all points $X$ on line $e$, $\lvert PX - QX \rvert \le d$. (It is guaranteed that $d$ exists and is unique.) They wish to find the line $e$ passing through two distinct outposts $(x_i, y_i)$ and $(x_j, y_j)$ such that the difference of $e$ relative to $P$ and $Q$ is minimized.

Input:
The first line of the input contains two integers $n$ and $a$ ($2 \le n \le 100\,000$, $1 \le a \le 10\,000$) — the number of outposts and the coordinates of the farm and the base, respectively.

The following $n$ lines describe the locations of the outposts as pairs of integers $(x_i, y_i)$ ($\lvert x_i \rvert, \lvert y_i \rvert \le 10\,000$). These points are distinct from each other as well as from $P$ and $Q$.

Output:
Print a single real number — the difference of the optimal dividing line. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.

Namely: let's assume that your answer is $a$, and the answer of the jury is $b$. The checker program will consider your answer correct, if $\tfrac{\lvert a-b\rvert}{\max(1,b)} \le 10^{-6}$.

Note:
In the first sample case, the only possible line $e$ is $y=x-1$. It can be shown that the point $X$ which maximizes $\lvert PX - QX \rvert$ is $(13,12)$, with $\lvert PX - QX \rvert = \lvert \sqrt{(13-5)^2 + (12-0)^2} - \sqrt{(13-(-5))^2 + (12-0)^2} \rvert$, which is $2\sqrt{13} \approx 7.211025509$.

In the second sample case, if we pick the points $(0,1)$ and $(0,-3)$, we get $e$ as $x=0$. Because $PX = QX$ on this line, the minimum possible difference is $0$.}
\BREAKDOWN{We must pick a line through two given points to minimize the supremum, over all points on that line, of the absolute difference of distances to $P=(a,0)$ and $Q=(-a,0)$. Show that for any line, this ``difference'' depends only on the line's direction: it equals $2a$ times the absolute cosine of the line's angle with the $x$-axis. Hence we need the line through the set of points whose direction is as close to vertical as possible.}
\ELI{Among all lines determined by point pairs, choose the one most nearly vertical; its maximum $|PX-QX|$ is smallest, and equals $2a$ times the line's horizontal direction cosine.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$ and $a$ with $2 \le n \le 100\,000$, $1 \le a \le 10\,000$. Then $n$ distinct points $(x_i,y_i)$ where $\lvert x_i\rvert,\lvert y_i\rvert \le 10\,000$. Points are distinct and different from $P=(a,0)$ and $Q=(-a,0)$.}
\OUTPUTS{One real number: the minimum possible line difference. Answers within absolute or relative error $\le 10^{-6}$ are accepted.}
\SAMPLES{Example 1: $n=2$, $a=5$, points $(0,1)$, $(0,-3)$. A vertical line exists, so the answer is $0$.

Example 2: $n=2$, $a=5$, points $(0,0)$, $(1,0)$. The only line is horizontal, so the answer is $2a=10$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let a line $\ell$ have unit direction $u=(\cos\varphi,\sin\varphi)$. For $P=(a,0)$ and $Q=(-a,0)$, define the line difference
\begin{BreakableEquation*}
D(\ell)=\sup_{X\in \ell}\,\bigl|\lvert XP\rvert-\lvert XQ\rvert\bigr|.
\end{BreakableEquation*}
Among all lines $\ell$ passing through two of the given points, minimize $D(\ell)$.}
\varmapStart
\var{a}{half-distance between $P$ and $Q$ on the $x$-axis}
\var{(x_i,y_i)}{coordinates of outpost $i$}
\var{\varphi}{angle of line with the $x$-axis; $u=(\cos\varphi,\sin\varphi)$}
\var{S_{\max}}{maximum absolute slope $\max_{i<j,\,x_i\ne x_j}\tfrac{|y_i-y_j|}{|x_i-x_j|}$ over chosen point pairs}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
D(\ell) &= 2a\,|\cos\varphi|, \\
D^* &= \min_{\text{allowed }\ell}D(\ell)
     = 2a \min_{i<j}\frac{|x_i-x_j|}{\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}}
     = \frac{2a}{\sqrt{1+S_{\max}^2}}.
\end{aligned}
\]
}
\ASSUMPTIONS{Lines are infinite; the supremum exists and equals a finite maximum. If any two points share the same $x$-coordinate, a vertical line is available and $D^*=0$.}
\INVARIANTS{For fixed $P,Q$, $|\,|XP|-|XQ|\,|\le |PQ|=2a$ for all $X$ (reverse triangle inequality). For a line with direction $u$, $\lim_{\|X\|\to\infty,\,X\in\ell} |\,|XP|-|XQ|\,|=2a\,|u_x|=2a\,|\cos\varphi|$.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use $D(\ell)=2a\,|\cos\varphi|$ with $\cos\varphi=\dfrac{\Delta x}{\sqrt{(\Delta x)^2+(\Delta y)^2}}$ for the line through a pair. Enumerate all $\binom{n}{2}$ pairs, track the minimum.}
\ASSUMPTIONS{Direct enumeration; early exit if a vertical pair $(\Delta x=0)$ appears (then answer is $0$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pair of points, compute $(\Delta x,\Delta y)$.
\item If $\Delta x=0$, return $0$.
\item Otherwise, compute $c=\dfrac{|\Delta x|}{\sqrt{(\Delta x)^2+(\Delta y)^2}}$ and keep the minimum $c$; answer is $2a\cdot c_{\min}$.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n^2)$, Space $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n-1} k \\
     &= \frac{n(n-1)}{2} = \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Follows from the closed form of $D(\ell)$ by direction and checking all candidate directions induced by pairs.}
\EDGECASES{Duplicate $x$ gives $0$. Two points only: the unique line decides the answer. Colinear sets: still fine.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); a = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, a, pts

def solve_case_bruteforce(points, a):
    n = len(points)
    xs = [p[0] for p in points]
    if len(set(xs)) < n:
        return 0.0
    best_c = 1.0  # |cos phi| in [0,1]
    for i in range(n):
        x1, y1 = points[i]
        for j in range(i + 1, n):
            x2, y2 = points[j]
            dx = x2 - x1
            dy = y2 - y1
            if dx == 0:
                return 0.0
            denom = math.hypot(dx, dy)
            c = abs(dx) / denom
            if c < best_c:
                best_c = c
    return 2.0 * a * best_c

def solve_all_bruteforce():
    n, a, pts = read_input()
    if n == 0:
        return
    ans = solve_case_bruteforce(pts, a)
    print("{:.15f}".format(ans))

def main():
    solve_all_bruteforce()

if __name__ == "__main__":
    # Simple internal tests (not executed on CF)
    def _approx(x, y, eps=1e-9): return abs(x - y) <= eps * max(1.0, abs(y))
    assert _approx(solve_case_bruteforce([(0,1),(0,-3)], 5), 0.0)
    assert _approx(solve_case_bruteforce([(0,0),(1,0)], 5), 10.0)
    s = solve_case_bruteforce([(1,0),(2,100)], 5)
    expect = 2.0 * 5 / math.sqrt(1 + (100.0)**2)
    assert _approx(s, expect)
    # main()
\end{minted}
\VALIDATION{Checked: vertical pair gives $0$; horizontal-only pair gives $2a$; steep slope yields small value $\approx 2a/\sqrt{1+s^2}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Convex Hull Reduction}
\WHICHFORMULA{The maximal absolute slope $\max_{i<j}\dfrac{|y_i-y_j|}{|x_i-x_j|}$ across all pairs is attained by two vertices of the convex hull, and in fact by an edge on the upper or lower monotone chain. Therefore we only need hull edges.}
\ASSUMPTIONS{No two points share the same $x$-coordinate implies finite slope; otherwise answer is $0$. Use Andrew's monotone chain to get upper and lower chains in $O(n\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If any two points share the same $x$, print $0$.
\item Compute the convex hull via Andrew's algorithm, obtaining lower and upper chains from leftmost to rightmost.
\item For every consecutive pair on each chain, compute $|dy/dx|$ and track the maximum $S_{\max}$.
\item Output $2a/\sqrt{1+S_{\max}^2}$.
\end{algosteps}
\COMPLEXITY{Dominated by hull construction: $T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\log n) \text{ (sort)} + O(n) \text{ (chains)}.
\end{aligned}
\]
\CORRECTNESS{On a convex (upper/lower) $x$-monotone chain, edge slopes are monotone; any secant slope between two vertices lies between the extreme edge slopes on that subchain. Thus the global maximum absolute secant slope is achieved by some chain edge.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); a = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, a, pts

def cross(o, a, b):
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def convex_chains(points):
    pts = sorted(points)
    lower = []
    for p in pts:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    return lower, upper  # each from leftmost to rightmost

def solve_case(points, a):
    n = len(points)
    xs = [p[0] for p in points]
    if len(set(xs)) < n:
        return 0.0
    lower, upper = convex_chains(points)
    smax = 0.0
    for chain in (lower, upper):
        for i in range(len(chain) - 1):
            x1, y1 = chain[i]
            x2, y2 = chain[i + 1]
            dx = x2 - x1
            dy = y2 - y1
            s = abs(dy / dx)
            if s > smax:
                smax = s
    return 2.0 * a / math.sqrt(1.0 + smax * smax)

def solve_all():
    n, a, pts = read_input()
    if n == 0:
        return
    ans = solve_case(pts, a)
    print("{:.15f}".format(ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Internal checks (not executed on CF by default)
    def _approx(x, y, eps=1e-9): return abs(x - y) <= eps * max(1.0, abs(y))
    assert _approx(solve_case([(0,1),(0,-3)], 5), 0.0)
    assert _approx(solve_case([(0,0),(1,0)], 5), 10.0)
    s = solve_case([(1,0),(2,100)], 5)
    expect = 2.0 * 5 / math.sqrt(1 + (100.0)**2)
    assert _approx(s, expect)
    # main()
\end{minted}
\VALIDATION{Valid on small crafted cases: vertical pair, horizontal pair, and a steep pair.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Direction-Only Formula + Convex Hull Edges}
\WHICHFORMULA{Prove $D(\ell)=2a|\cos\varphi|$ is offset-independent: reflect $Q$ across $\ell$ to $Q'$, then for $X\in\ell$, $|XP|-|XQ|=|XP|-|XQ'|$. As $X\to\infty$ along $\ell$, this tends to $|(P-Q')\cdot u|=|(P-Q)\cdot u|=2a|u_x|$. The supremum on $\ell$ equals this limit. Minimize over admissible directions, realized by an edge on upper/lower hull.}
\ASSUMPTIONS{Use Andrew's monotone chain; hull edge $x$-coordinates are strictly increasing if inputs' $x$ are distinct. If any duplicate $x$, answer is $0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n,a$ and the points. If any duplicate $x$ exists, print $0$.
\item Build lower and upper chains via Andrew's monotone chain.
\item Compute $S_{\max}=\max\limits_{\text{adjacent on chains}} |dy/dx|$.
\item Output $2a/\sqrt{1+S_{\max}^2}$ with sufficient precision.
\end{algosteps}
\OPTIMALITY{Among all pair directions, the maximum absolute slope is achieved on a convex hull chain edge; any secant slope between chain vertices lies between edge slopes by convexity/monotonicity of slopes along the chain. Hence no interior pair beats a hull edge.}
\COMPLEXITY{$O(n\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n)&=O(n\log n)\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); a = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, a, pts

def cross(o, a, b):
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def convex_chains(points):
    pts = sorted(points)
    lower = []
    for p in pts:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    return lower, upper  # leftmost->rightmost on each chain

def solve_case(points, a):
    n = len(points)
    xs = [p[0] for p in points]
    if len(set(xs)) < n:
        return 0.0
    lower, upper = convex_chains(points)
    smax = 0.0
    for chain in (lower, upper):
        for i in range(len(chain) - 1):
            x1, y1 = chain[i]
            x2, y2 = chain[i + 1]
            dx = x2 - x1
            dy = y2 - y1
            # dx != 0 because no duplicate x in inputs in this branch
            s = abs(dy / dx)
            if s > smax:
                smax = s
    return 2.0 * a / math.sqrt(1.0 + smax * smax)

def solve_all():
    n, a, pts = read_input()
    if n == 0:
        return
    ans = solve_case(pts, a)
    print("{:.15f}".format(ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts (not executed on CF unless invoked manually)
    def _approx(x, y, eps=1e-9): return abs(x - y) <= eps * max(1.0, abs(y))
    assert _approx(solve_case([(0,1),(0,-3)], 5), 0.0)
    assert _approx(solve_case([(0,0),(1,0)], 5), 10.0)
    val = solve_case([(1,0),(2,100)], 7)
    exp = 2.0 * 7 / math.sqrt(1 + 100.0**2)
    assert _approx(val, exp)
    # main()
\end{minted}
\VALIDATION{Three asserts: vertical pair gives $0$; horizontal pair gives $2a$; steep pair matches $2a/\sqrt{1+s^2}$.}
\RESULT{Print the minimum difference $D^*=\dfrac{2a}{\sqrt{1+S_{\max}^2}}$; if any two points share $x$, print $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for trivial geometries: vertical pair $\Rightarrow 0$; horizontal-only $\Rightarrow 2a$; random clouds where hull edges provide extreme slopes. Property: removing interior points leaves answer unchanged.}
\LINE{CROSS-CHECKS}{Compare brute force (Approach A) vs hull-based (Approach C) on small random $n\le 200$.}
\LINE{EDGE-CASE GENERATOR}{Generate: many points with same $x$; all points with strictly increasing $x$; colinear sets; two points only; clustered points plus far outlier.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import math, random

def gen_vertical(n=5, a=3):
    pts = [(0, i) for i in range(n)]
    return a, pts

def gen_horizontal(n=5, a=4):
    pts = [(i, 0) for i in range(n)]
    return a, pts

def gen_random(n=50, a=7, seed=0):
    rng = random.Random(seed)
    pts = []
    used = set()
    while len(pts) < n:
        x = rng.randint(-10, 10)
        y = rng.randint(-10, 10)
        if (x, y) not in used and (x, y) != (a, 0) and (x, y) != (-a, 0):
            used.add((x, y))
            pts.append((x, y))
    return a, pts
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); a = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, a, pts

def cross(o, a, b):
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def convex_chains(points):
    pts = sorted(points)
    lower = []
    for p in pts:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    return lower, upper

def solve_case(points, a):
    xs = [p[0] for p in points]
    if len(set(xs)) < len(points):
        return 0.0
    lower, upper = convex_chains(points)
    smax = 0.0
    for chain in (lower, upper):
        for i in range(len(chain) - 1):
            x1, y1 = chain[i]
            x2, y2 = chain[i + 1]
            dx = x2 - x1
            dy = y2 - y1
            s = abs(dy / dx)
            if s > smax:
                smax = s
    return 2.0 * a / math.sqrt(1.0 + smax * smax)

def solve_all():
    n, a, pts = read_input()
    if n == 0:
        return
    print("{:.15f}".format(solve_case(pts, a)))

def main():
    solve_all()

if __name__ == "__main__":
    # Minimal sanity asserts
    def _approx(x, y, eps=1e-9): return abs(x - y) <= eps * max(1.0, abs(y))
    assert _approx(solve_case([(0,1),(0,-3)], 5), 0.0)
    assert _approx(solve_case([(0,0),(1,0)], 5), 10.0)
    val = solve_case([(1,0),(2,100)], 7)
    exp = 2.0 * 7 / math.sqrt(1 + 100.0**2)
    assert _approx(val, exp)
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize $2a|\cos\varphi|$ over directions of lines determined by point pairs; equivalently maximize $|dy/dx|$ across those pairs.}
\WHY{Direction-only objective plus convex hull reduction is a classic geometry trick; it appears in hard interview/contest problems.}
\CHECKLIST{
- Reflect-and-limit argument to derive $D(\ell)=2a|\cos\varphi|$.
- Check duplicate $x$ early $\Rightarrow$ answer $0$.
- Compute convex hull (upper/lower chains).
- Scan adjacent hull edges to get $S_{\max}$.
- Output $2a/\sqrt{1+S_{\max}^2}$ with high precision.
}
\EDGECASES{
- Any two points share $x$ (vertical line) $\Rightarrow 0$.
- Only two points.
- All points colinear but not vertical.
- Very steep edges (avoid overflow; use \texttt{hypot} or ratio carefully).
- Large $n$ with many colinear points on hull edges.
- Points close in $x$ but far in $y$ (precision).
}
\PITFALLS{
- Forgetting that $D(\ell)$ is offset-independent (depends only on direction).
- Using $O(n^2)$ on $n=10^5$.
- Mishandling colinearity in hull (keep only extreme endpoints).
- Dividing by $dx=0$ without early vertical check.
- Precision loss when computing slopes; use float carefully.
- Printing insufficient precision.
}
\FAILMODES{Brute force times out; naive scanning by $x$ can miss pairs. The hull-edge method is robust and runs in $O(n\log n)$.}
\ELI{The farther along any line you go, the difference in distances to $P$ and $Q$ tends to a constant determined only by the line's tilt: $2a$ times how horizontal it is. So pick the line through two points that's most vertical; convex hull edges suffice to find that direction efficiently.}
\NotePages{3}

\end{document}