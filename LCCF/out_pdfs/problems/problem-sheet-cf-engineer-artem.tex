% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Engineer Artem}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1438/C}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{Artem is building a new robot. He has a matrix $a$ consisting of $n$ rows and $m$ columns. The cell located on the $i$-th row from the top and the $j$-th column from the left has a value $a_{i,j}$ written in it.

If two adjacent cells contain the same value, the robot will break. A matrix is called good if no two adjacent cells contain the same value, where two cells are called adjacent if they share a side.

Artem wants to increment the values in some cells by one to make $a$ good.

More formally, find a good matrix $b$ that satisfies the following condition —
\begin{bullets}
\item For all valid $(i,j)$, either $b_{i,j}=a_{i,j}$ or $b_{i,j}=a_{i,j}+1$.
\end{bullets}
For the constraints of this problem, it can be shown that such a matrix $b$ always exists. If there are several such tables, you can output any of them. Please note that you do not have to minimize the number of increments.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10$). Description of the test cases follows.

The first line of each test case contains two integers $n,m$ ($1 \le n \le 100$, $1 \le m \le 100$) — the number of rows and columns, respectively.

The following $n$ lines each contain $m$ integers. The $j$-th integer in the $i$-th line is $a_{i,j}$ ($1 \le a_{i,j} \le 10^9$).

Output: For each case, output $n$ lines each containing $m$ integers. The $j$-th integer in the $i$-th line is $b_{i,j}$.

Note: In all the cases, you can verify that no two adjacent cells have the same value and that $b$ is the same as $a$ with some values incremented by one.}
\BREAKDOWN{Pick for each cell either $a_{i,j}$ or $a_{i,j}+1$ so that adjacent cells differ. A checkerboard parity assignment guarantees that neighbors cannot be equal: force $b_{i,j}$ to have parity equal to $(i+j) \bmod 2$.}
\ELI{Color the grid like a chessboard and make all black cells even and white cells odd by optionally adding $1$; neighbors then always differ.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
\begin{bullets}
\item Integer $t$ ($1 \le t \le 10$): number of test cases.
\item For each test case:
\begin{bullets}
\item Integers $n,m$ ($1 \le n \le 100$, $1 \le m \le 100$).
\item Matrix $a$ of size $n \times m$ with $1 \le a_{i,j} \le 10^9$.
\end{bullets}
\end{bullets}
}
\OUTPUTS{For each test case, output an $n \times m$ matrix $b$ such that $b_{i,j} \in \{a_{i,j}, a_{i,j}+1\}$ and no two side-adjacent cells of $b$ are equal.}
\SAMPLES{
Example 1

Input
\[
\begin{aligned}
1\\
2~2\\
1~1\\
1~1
\end{aligned}
\]

Output
\[
\begin{aligned}
2~1\\
1~2
\end{aligned}
\]

Example 2

Input
\[
\begin{aligned}
1\\
1~3\\
5~6~7
\end{aligned}
\]

Output
\[
\begin{aligned}
6~7~8
\end{aligned}
\]
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a \in \mathbb{Z}^{n \times m}$, find $b \in \mathbb{Z}^{n \times m}$ with $b_{i,j} \in \{a_{i,j}, a_{i,j}+1\}$ and $b_{i,j} \ne b_{i',j'}$ for all side-adjacent pairs $(i,j)$ and $(i',j')$. A sufficient construction is to enforce alternating parity across the bipartite grid.}
\varmapStart
\var{n,m}{dimensions of the grid}
\var{a_{i,j}}{original cell values}
\var{b_{i,j}}{constructed values, each either $a_{i,j}$ or $a_{i,j}+1$}
\var{p_{i,j}}{target parity: $p_{i,j}=(i+j) \bmod 2$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&b_{i,j} \in \{a_{i,j}, a_{i,j}+1\} \quad \forall~i,j,\\
&b_{i,j} \bmod 2 \;=\; (i+j) \bmod 2 \quad \forall~i,j.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based in the statement; any consistent parity pattern on the bipartition works. Grid adjacency is by shared side only.}
\INVARIANTS{
\begin{bullets}
\item Adjacent cells $(i,j)$ and $(i',j')$ have $(i+j) \not\equiv (i'+j') \pmod{2}$, hence $b_{i,j}$ and $b_{i',j'}$ differ in parity and cannot be equal.
\item Each $b_{i,j}$ differs from $a_{i,j}$ by either $0$ or $1$, so feasibility per-cell is maintained.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use a fixed checkerboard parity: force $b_{i,j}$ to be even on cells with $(i+j)$ even and odd otherwise.}
\ASSUMPTIONS{Using $0$-based indices in code, the target parity is $(i+j) \bmod 2$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell $(i,j)$, compute target parity $t=(i+j)\bmod 2$.
\item If $a_{i,j} \bmod 2 = t$, set $b_{i,j}=a_{i,j}$; else set $b_{i,j}=a_{i,j}+1$.
\item Output $b$.
\end{algosteps}
\COMPLEXITY{Linear in the number of cells: $T(n,m)=\Theta(nm)$, $S(n,m)=\Theta(1)$ extra.}
\[
\begin{aligned}
T(n,m) &= \sum_{i=1}^{n}\sum_{j=1}^{m} O(1) \;=\; O(nm).
\end{aligned}
\]
\CORRECTNESS{Neighbors have opposite $(i+j) \bmod 2$, thus opposite parity in $b$, hence cannot be equal. Each $b_{i,j}$ differs from $a_{i,j}$ by at most $1$ by construction.}
\EDGECASES{Single cell; single row or column; all equal $a_{i,j}$; very large $a_{i,j}$ values; already-good matrices.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple
import sys

def read_input(data: str = None) -> List[Tuple[int, int, List[List[int]]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    toks = list(it)
    if not toks:
        return []
    it = iter(toks)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a))
    return cases

def solve_case(n: int, m: int, a: List[List[int]]) -> List[List[int]]:
    b = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            target = (i + j) & 1  # 0 for even, 1 for odd
            add = (a[i][j] ^ target) & 1  # add 1 iff parity mismatches target
            b[i][j] = a[i][j] + add
    return b

def solve_all(cases):
    out_lines = []
    for (n, m, a) in cases:
        b = solve_case(n, m, a)
        for row in b:
            out_lines.append(" ".join(map(str, row)))
    return "\n".join(out_lines)

def _is_good(b: List[List[int]]) -> bool:
    n = len(b); m = len(b[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if i+1 < n and b[i][j] == b[i+1][j]:
                return False
            if j+1 < m and b[i][j] == b[i][j+1]:
                return False
    return True

def _within_allowed(a: List[List[int]], b: List[List[int]]) -> bool:
    n = len(a); m = len(a[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if not (b[i][j] == a[i][j] or b[i][j] == a[i][j] + 1):
                return False
    return True

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    if cases:
        print(solve_all(cases))
    else:
        # Self-checks (no output unless assertions fail)
        a = [[1,1],[1,1]]
        b = solve_case(2,2,a)
        assert _is_good(b) and _within_allowed(a,b)
        a2 = [[5,6,7]]
        b2 = solve_case(1,3,a2)
        assert _is_good(b2) and _within_allowed(a2,b2)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Two asserts check goodness and allowed increments on tiny cases, including a uniform matrix and a single-row matrix.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same checkerboard idea but compute the increment with a single bit expression: $b_{i,j}=a_{i,j}+((a_{i,j} \oplus ((i+j)\&1))\&1)$.}
\ASSUMPTIONS{We use zero-based indices in code; parity targets alternate across the grid.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell, compute $t=(i+j)\&1$.
\item Set $b_{i,j}=a_{i,j}+((a_{i,j}\oplus t)\&1)$.
\item Output the matrix.
\end{algosteps}
\COMPLEXITY{Still $O(nm)$ time and $O(1)$ extra space; fewer branches in practice.}
\[
\begin{aligned}
T(n,m) &= O(nm).
\end{aligned}
\]
\CORRECTNESS{The bit formula adds $1$ iff the parity of $a_{i,j}$ mismatches the target parity, ensuring $b_{i,j}\bmod 2=(i+j)\bmod 2$. Neighbors then differ in parity.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a))
    return cases

def solve_case(n: int, m: int, a: List[List[int]]) -> List[List[int]]:
    b = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            t = (i + j) & 1
            b[i][j] = a[i][j] + ((a[i][j] ^ t) & 1)
    return b

def solve_all(cases):
    out = []
    for n,m,a in cases:
        b = solve_case(n,m,a)
        for row in b:
            out.append(" ".join(map(str,row)))
    return "\n".join(out)

def _is_good(b: List[List[int]]) -> bool:
    n = len(b); m = len(b[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if i+1<n and b[i][j]==b[i+1][j]: return False
            if j+1<m and b[i][j]==b[i][j+1]: return False
    return True

def _within_allowed(a: List[List[int]], b: List[List[int]]) -> bool:
    n = len(a); m = len(a[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if b[i][j] != a[i][j] and b[i][j] != a[i][j]+1:
                return False
    return True

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    if cases:
        print(solve_all(cases))
    else:
        a = [[2]]
        b = solve_case(1,1,a)
        assert _is_good(b) and _within_allowed(a,b)
        a2 = [[10,10,10,10]]
        b2 = solve_case(1,4,a2)
        assert _is_good(b2) and _within_allowed(a2,b2)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts cover single-cell and uniform-row cases, ensuring both the adjacency property and the per-cell constraint.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the bipartite parity assignment: $b_{i,j} = a_{i,j} + ((a_{i,j} \oplus ((i+j)\&1))\&1)$. This meets constraints with minimal per-cell change (at most $1$) and guarantees adjacency inequality by parity.}
\ASSUMPTIONS{Grid is bipartite under side-adjacency. Any fixed parity pattern on the two parts suffices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell $(i,j)$, compute $t=(i+j)\&1$.
\item Compute $b_{i,j}=a_{i,j}+((a_{i,j}\oplus t)\&1)$.
\item Print the matrix for each test.
\end{algosteps}
\OPTIMALITY{No method can do better than $O(nm)$ because every cell must be considered at least once. The construction is tight: it changes a cell only if necessary to match its partition parity.}
\COMPLEXITY{$T(n,m)=\Theta(nm)$ time and $S(n,m)=\Theta(1)$ extra space beyond the output.}
\[
\begin{aligned}
T(n,m) &= \sum_{i=1}^{n}\sum_{j=1}^{m} O(1) \;=\; \Theta(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import sys

def read_input(data: str = None) -> List[Tuple[int,int,List[List[int]]]]:
    if data is None:
        data = sys.stdin.read()
    s = data.strip().split()
    if not s:
        return []
    it = iter(s)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n,m,a))
    return cases

def solve_case(n: int, m: int, a: List[List[int]]) -> List[List[int]]:
    b = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            t = (i + j) & 1
            b[i][j] = a[i][j] + ((a[i][j] ^ t) & 1)
    return b

def solve_all(cases: List[Tuple[int,int,List[List[int]]]]) -> str:
    out = []
    for n,m,a in cases:
        b = solve_case(n,m,a)
        for row in b:
            out.append(" ".join(map(str,row)))
    return "\n".join(out)

def _is_good(b: List[List[int]]) -> bool:
    n = len(b); m = len(b[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if i+1<n and b[i][j]==b[i+1][j]: return False
            if j+1<m and b[i][j]==b[i][j+1]: return False
    return True

def _within_allowed(a: List[List[int]], b: List[List[int]]) -> bool:
    n = len(a); m = len(a[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if b[i][j] != a[i][j] and b[i][j] != a[i][j] + 1:
                return False
    return True

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    if cases:
        print(solve_all(cases))
    else:
        # Exactly 3 asserts
        a1 = [[1,1],[1,1]]
        b1 = solve_case(2,2,a1)
        assert _is_good(b1) and _within_allowed(a1,b1)
        a2 = [[5,6,7]]
        b2 = solve_case(1,3,a2)
        assert _is_good(b2) and _within_allowed(a2,b2)
        a3 = [[10],[11],[10]]
        b3 = solve_case(3,1,a3)
        assert _is_good(b3) and _within_allowed(a3,b3)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts on: a uniform $2\times 2$, a single row of length $3$, and a single column of length $3$.}
\RESULT{Any $b$ produced by the parity construction is accepted. No tie-breaking beyond the parity rule is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests validate: adjacency inequality; allowed increments; behavior on $1\times 1$, $1\times m$, $n\times 1$, and uniform matrices.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on randomly generated tiny matrices to ensure identical outputs or at least both satisfy validity checks.}
\LINE{EDGE-CASE GENERATOR}{Deterministically generate small matrices including extremes and patterns to stress adjacency.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_cases() -> List[List[List[int]]]:
    random.seed(12345)
    cases = []
    # Single cell extremes
    cases.append([[1]])
    cases.append([[10**9]])
    # Single row and column
    cases.append([[7,7,7,7,7]])
    cases.append([[3],[3],[3],[3]])
    # Checker patterns and random small
    cases.append([[1,2],[2,1]])
    for _ in range(5):
        n = random.randint(1,4)
        m = random.randint(1,4)
        a = [[random.randint(1,10) for _ in range(m)] for __ in range(n)]
        cases.append(a)
    return cases

def parity_solve(a: List[List[int]]) -> List[List[int]]:
    n = len(a); m = len(a[0]) if n else 0
    b = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            t = (i + j) & 1
            b[i][j] = a[i][j] + ((a[i][j] ^ t) & 1)
    return b

def is_good(a: List[List[int]], b: List[List[int]]) -> bool:
    n = len(b); m = len(b[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if b[i][j] != a[i][j] and b[i][j] != a[i][j]+1:
                return False
            if i+1<n and b[i][j]==b[i+1][j]: return False
            if j+1<m and b[i][j]==b[i][j+1]: return False
    return True

def self_test():
    for a in gen_cases():
        b = parity_solve(a)
        assert is_good(a,b)

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
import sys

def read_input(data: str = None) -> List[Tuple[int,int,List[List[int]]]]:
    if data is None:
        data = sys.stdin.read()
    parts = data.strip().split()
    if not parts:
        return []
    it = iter(parts)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n,m,a))
    return cases

def solve_case(n: int, m: int, a: List[List[int]]) -> List[List[int]]:
    b = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            t = (i + j) & 1
            b[i][j] = a[i][j] + ((a[i][j] ^ t) & 1)
    return b

def solve_all(cases: List[Tuple[int,int,List[List[int]]]]) -> str:
    out = []
    for n,m,a in cases:
        b = solve_case(n,m,a)
        for row in b:
            out.append(" ".join(map(str,row)))
    return "\n".join(out)

def _is_good(b: List[List[int]]) -> bool:
    n = len(b); m = len(b[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if i+1<n and b[i][j]==b[i+1][j]: return False
            if j+1<m and b[i][j]==b[i][j+1]: return False
    return True

def _within_allowed(a: List[List[int]], b: List[List[int]]) -> bool:
    n = len(a); m = len(a[0]) if n else 0
    for i in range(n):
        for j in range(m):
            if b[i][j] != a[i][j] and b[i][j] != a[i][j] + 1:
                return False
    return True

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    if cases:
        print(solve_all(cases))
    else:
        # Self-checks
        a = [[1,1],[1,1]]
        b = solve_case(2,2,a)
        assert _is_good(b) and _within_allowed(a,b)
        a2 = [[5,6,7]]
        b2 = solve_case(1,3,a2)
        assert _is_good(b2) and _within_allowed(a2,b2)
        a3 = [[10],[11],[10]]
        b3 = solve_case(3,1,a3)
        assert _is_good(b3) and _within_allowed(a3,b3)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Make the grid good by forcing alternating parity via optional $+1$ increments.}
\WHY{Bipartite parity tricks appear frequently in grid problems on CF and in interviews to avoid adjacency conflicts.}
\CHECKLIST{
\begin{bullets}
\item Recognize bipartite structure of the grid.
\item Pick a fixed parity for each partition.
\item For each cell, add $1$ iff its parity mismatches the target.
\item Print the result; no need to minimize increments further.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $1\times 1$ grid.
\item Single row or single column.
\item All entries identical.
\item Already alternating input.
\item Very large values near $10^9$.
\item Non-square rectangles with odd or even dimensions.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mixing $1$-based vs $0$-based parity; be consistent.
\item Forgetting to handle multiple test cases.
\item Printing extra blank lines between test cases.
\item Using addition parity formula incorrectly (off-by-one in the bit).
\item Accidentally modifying the input matrix while constructing output.
\item Assuming diagonals are adjacent (they are not).
\end{bullets}
}
\FAILMODES{Greedy local fixes without global parity can oscillate or require backtracking; the parity construction avoids conflicts globally in one pass.}
\ELI{Color the board like a chessboard. Make black squares even and white squares odd by increasing some numbers by $1$. Since neighbors are opposite colors, they can never be equal.}
\NotePages{3}

\end{document}