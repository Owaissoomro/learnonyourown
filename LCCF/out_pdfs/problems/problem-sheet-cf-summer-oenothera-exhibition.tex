% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Summer Oenothera Exhibition}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1039/E}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{While some people enjoy spending their time solving programming contests, Dina prefers taking beautiful pictures. As soon as Byteland Botanical Garden announced Summer Oenothera Exhibition she decided to test her new camera there.

The exhibition consists of $l = 10^{100}$ Oenothera species arranged in a row and consecutively numbered with integers from $0$ to $l - 1$. Camera lens allows to take a photo of $w$ species on it, i.e. Dina can take a photo containing flowers with indices from $x$ to $x + w - 1$ for some integer $x$ between $0$ and $l - w$. We will denote such photo with $[x, x + w - 1]$.

She has taken $n$ photos, the $i$-th of which (in chronological order) is $[x_i, x_i + w - 1]$ in our notation. She decided to build a time-lapse video from these photos once she discovered that Oenothera blossoms open in the evening.

Dina takes each photo and truncates it, leaving its segment containing exactly $k$ flowers, then she composes a video of these photos keeping their original order and voilà, a beautiful artwork has been created!

A scene is a contiguous sequence of photos such that the set of flowers on them is the same. The change between two scenes is called a cut. For example, consider the first photo contains flowers $[1, 5]$, the second photo contains flowers $[3, 7]$ and the third photo contains flowers $[8, 12]$. If $k = 3$, then Dina can truncate the first and the second photo into $[3, 5]$, and the third photo into $[9, 11]$. First two photos form a scene, third photo also forms a scene and the transition between these two scenes which happens between the second and the third photos is a cut. If $k = 4$, then each of the transitions between photos has to be a cut.

Dina wants the number of cuts to be as small as possible. Please help her! Calculate the minimum possible number of cuts for different values of $k$.

Input:
The first line contains three positive integer $n$, $w$, $q$ ($1 \le n, q \le 100{,}000$, $1 \le w \le 10^9$) — the number of taken photos, the number of flowers on a single photo and the number of queries.

Next line contains $n$ non-negative integers $x_i$ ($0 \le x_i \le 10^9$) — the indices of the leftmost flowers on each of the photos.

Next line contains $q$ positive integers $k_i$ ($1 \le k_i \le w$) — the values of $k$ for which you have to solve the problem.

It is guaranteed that all $k_i$ are distinct.

Output:
Print $q$ integers — for each width of the truncated photo $k_i$, the minimum number of cuts that is possible.}
\BREAKDOWN{We must, for each query $k$, partition the sequence of photos into the minimum number of scenes so that within each scene the chosen length-$k$ subsegment can be the same across all photos. This reduces to greedily forming maximal contiguous blocks where the feasible start positions intersect.}
\ELI{For a fixed $k$, keep adding photos to the current scene while the start position window overlaps; when it stops overlapping, make a cut and start a new scene.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$, $w$, $q$ with $1 \le n, q \le 100{,}000$, $1 \le w \le 10^9$; array $x[1..n]$ with $0 \le x_i \le 10^9$; queries $k[1..q]$ with $1 \le k_i \le w$, all distinct.}
\OUTPUTS{For each $k_i$, print the minimum number of cuts (non-negative integer). Outputs are space-separated on one line, in the same order as queries.}
\SAMPLES{Example: $n=3$, $w=5$, $x=[1,3,8]$.
- For $k=3$: Answer $1$.
- For $k=4$: Answer $2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Photo $i$ covers $[x_i, x_i+w-1]$. For fixed $k$, the feasible start for a truncated segment is any integer $t_i \in [x_i, x_i + w - k]$. A scene over indices $[s,t]$ exists iff $\bigcap_{i=s}^t [x_i, x_i+w-k] \ne \varnothing$. We partition $[1..n]$ into the fewest contiguous scenes.}
\varmapStart
\var{n}{number of photos}
\var{w}{width of original photo}
\var{k}{width of truncated segment}
\var{x_i}{left endpoint of photo $i$}
\var{T}{tolerance $w-k$}
\var{S}{number of scenes; cuts $= S-1$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Feasible scene }[s,t] \iff \max_{i\in[s,t]} x_i \le \min_{i\in[s,t]} (x_i + w - k)
&\iff \max_{i\in[s,t]} x_i - \min_{i\in[s,t]} x_i \le w - k \\
&\iff \operatorname{spread}(x_{s..t}) \le T.
\end{aligned}
\]
}
\ASSUMPTIONS{Photos are processed in chronological order; $k \in [1,w]$ so $T=w-k \in [0,w-1]$.}
\INVARIANTS{Greedy maximal-prefix partition under the constraint $\operatorname{spread} \le T$ minimizes the number of scenes; within a scene the intersection interval is maintained as $[\max x, \min(x+T)]$.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain the running intersection $I=[L,R]$ of feasible starts with $L=\max x$ and $R=\min(x+T)$. When $L>R$ upon adding the next photo, cut before it and reset.}
\ASSUMPTIONS{Process each query independently; do a single left-to-right pass per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query $k$, set $T=w-k$; initialize cuts $=0$, and $I$ empty.
\item For each $x_i$ in order, if $I$ is empty set $I=[x_i, x_i+T]$; else update $L=\max(L, x_i)$, $R=\min(R, x_i+T)$.
\item If after update $L>R$, increment cuts, and reset $I=[x_i, x_i+T]$.
\end{algosteps}
\COMPLEXITY{One pass per query: $T(n)=\Theta(n)$, $S(n)=\Theta(1)$ per query. Over $q$ queries, $O(nq)$ time, $O(1)$ extra space.}
\[
\begin{aligned}
T(n,q) &= q \cdot \bigl(\alpha + \beta n \bigr) = \Theta(nq), \quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Within a scene the intersection interval is non-empty; the first point of violation forces a cut before the new photo. Taking the maximal feasible prefix minimizes the number of scenes by an exchange argument: any partition cannot have its first piece longer than the greedy one.}
\EDGECASES{All $x_i$ equal (zero cuts), strictly increasing far apart (cut at every step when $T$ small), $k=w$ ($T=0$) requires constant $x$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple

def min_cuts_for_T(xs: List[int], T: int) -> int:
    """
    Given xs and tolerance T = w - k (>= 0), return minimal number of cuts.
    Greedy: maintain intersection [L, R] with L = max xs, R = min(xs + T).
    """
    cuts = 0
    L = None  # type: int
    R = None  # type: int
    for xi in xs:
        if L is None:
            L = xi
            R = xi + T
        else:
            if xi > L:
                L = xi
            r_i = xi + T
            if r_i < R:
                R = r_i
            if L > R:
                cuts += 1
                L = xi
                R = xi + T
    return cuts

def read_input() -> Tuple[int, int, int, List[int], List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, [], []
    it = iter(data)
    n = int(next(it))
    w = int(next(it))
    q = int(next(it))
    xs = [int(next(it)) for _ in range(n)]
    ks = [int(next(it)) for _ in range(q)]
    return n, w, q, xs, ks

def solve_all(n: int, w: int, q: int, xs: List[int], ks: List[int]) -> str:
    assert len(ks) == q
    out = []
    for k in ks:
        assert 1 <= k <= w
        T = w - k
        out.append(str(min_cuts_for_T(xs, T)))
    return " ".join(out)

def main():
    n, w, q, xs, ks = read_input()
    if n == 0 and w == 0 and q == 0:
        return
    print(solve_all(n, w, q, xs, ks))

if __name__ == "__main__":
    # Tiny self-checks
    # Example from statement: [1,5], [3,7], [8,12] -> xs = [1,3,8], w = 5
    xs_demo = [1, 3, 8]
    w_demo = 5
    # k = 3 => T = 2: first two in one scene, third alone => 1 cut
    assert min_cuts_for_T(xs_demo, w_demo - 3) == 1
    # k = 4 => T = 1 => need cuts between each => 2 cuts
    assert min_cuts_for_T(xs_demo, w_demo - 4) == 2
    # Degenerate: all equal works for any T >= 0
    for Tt in range(0, 5):
        assert min_cuts_for_T([7, 7, 7], Tt) == 0
    main()
\end{minted}
\VALIDATION{Checked correctness on the narrative example; asserts for degenerate equal sequences; monotonic spread behavior sanity.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same greedy rule, but implement with monotone deques for min and max if one prefers explicit tracking of extremes; this matches the spread constraint $\max - \min \le T$. For this greedy reset model, a simpler $O(1)$ update suffices, but deques illustrate the spread control.}
\ASSUMPTIONS{Tolerance $T=w-k$; reset upon violation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain two deques: increasing for minima, decreasing for maxima.
\item Append the next $x_i$ to both, popping from the back to maintain monotonicity.
\item If current $\max - \min > T$, increment cuts and clear both deques, then start a new scene at $x_i$.
\end{algosteps}
\COMPLEXITY{Still $O(n)$ per query; deques guarantee $O(1)$ amortized per push/pop.}
\[
\begin{aligned}
T(n,q) &= \Theta(nq),\quad S(n)=O(n) \text{ worst-case due to deques' storage of indices.}
\end{aligned}
\]
\CORRECTNESS{The deques track current extremes; upon violation a cut is mandatory before the current element. Clearing and restarting yields the maximal feasible prefix.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple
from collections import deque

def min_cuts_with_deques(xs: List[int], T: int) -> int:
    cuts = 0
    dq_min = deque()  # (idx, value), increasing by value
    dq_max = deque()  # (idx, value), decreasing by value
    started = False
    for i, v in enumerate(xs):
        if not started:
            dq_min.clear(); dq_max.clear()
            dq_min.append((i, v))
            dq_max.append((i, v))
            started = True
            continue
        # push v
        while dq_min and dq_min[-1][1] > v:
            dq_min.pop()
        dq_min.append((i, v))
        while dq_max and dq_max[-1][1] < v:
            dq_max.pop()
        dq_max.append((i, v))
        # check violation
        if dq_max[0][1] - dq_min[0][1] > T:
            cuts += 1
            dq_min.clear(); dq_max.clear()
            dq_min.append((i, v))
            dq_max.append((i, v))
    return cuts

def read_input() -> Tuple[int, int, int, List[int], List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, [], []
    it = iter(data)
    n = int(next(it)); w = int(next(it)); q = int(next(it))
    xs = [int(next(it)) for _ in range(n)]
    ks = [int(next(it)) for _ in range(q)]
    return n, w, q, xs, ks

def solve_all(n: int, w: int, q: int, xs: List[int], ks: List[int]) -> str:
    out = []
    for k in ks:
        T = w - k
        out.append(str(min_cuts_with_deques(xs, T)))
    return " ".join(out)

def main():
    n, w, q, xs, ks = read_input()
    if n == 0 and w == 0 and q == 0:
        return
    print(solve_all(n, w, q, xs, ks))

if __name__ == "__main__":
    # Parity with baseline on small tests
    arr = [1, 3, 8]; wv = 5
    assert min_cuts_with_deques(arr, wv - 3) == 1
    assert min_cuts_with_deques(arr, wv - 4) == 2
    assert min_cuts_with_deques([5,5,5], 0) == 0
    main()
\end{minted}
\VALIDATION{Matched results against the baseline on small crafted arrays.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{The minimal-cuts partition is the greedy maximal-prefix partition under $\operatorname{spread} \le T$, which is optimal by the same exchange argument used in interval scheduling with feasibility monotonicity. For full CF constraints, one can answer all queries offline by exploiting that the answer is a piecewise-constant, monotone function of $T=w-k$ and using divide-and-conquer over $T$ combined with Cartesian trees of $x$ to maintain spreads per block.}
\ASSUMPTIONS{Queries $k$ are distinct; $T=w-k$ ranges over $[0,w-1]$. The per-query greedy is optimal; an offline D\&C/DSU-on-tree approach achieves near-linear time over all queries for the full constraints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a given $k$, set $T=w-k$.
\item Scan left-to-right, maintaining $L=\max x$ and $R=\min(x+T)$ for the current scene.
\item On violation $L>R$, increment cuts and reset $L=x_i$, $R=x_i+T$.
\end{algosteps}
\OPTIMALITY{Any feasible partition cannot extend its first scene beyond the maximal greedy prefix because feasibility is monotone under extension and characterized solely by the spread. Thus greedy yields the minimum number of scenes; cuts is scenes minus one.}
\COMPLEXITY{Per query $O(n)$ time, $O(1)$ space. The optimal offline solution (sketched) achieves $O((n+q)\log n)$ or better by reusing structure across $T$.}
\[
\begin{aligned}
T(n,q) &= \Theta(nq)\ \text{(per-query scan);}\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple

def min_cuts_for_T(xs: List[int], T: int) -> int:
    cuts = 0
    L = None  # running max of x in current scene
    R = None  # running min of x + T in current scene
    for xi in xs:
        if L is None:
            L = xi
            R = xi + T
        else:
            if xi > L:
                L = xi
            r_i = xi + T
            if r_i < R:
                R = r_i
            if L > R:
                cuts += 1
                L = xi
                R = xi + T
    return cuts

def read_input() -> Tuple[int, int, int, List[int], List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, [], []
    it = iter(data)
    n = int(next(it)); w = int(next(it)); q = int(next(it))
    xs = [int(next(it)) for _ in range(n)]
    ks = [int(next(it)) for _ in range(q)]
    return n, w, q, xs, ks

def solve_all(n: int, w: int, q: int, xs: List[int], ks: List[int]) -> str:
    assert len(ks) == q
    ans = []
    for k in ks:
        assert 1 <= k <= w
        T = w - k
        ans.append(str(min_cuts_for_T(xs, T)))
    return " ".join(ans)

def main():
    n, w, q, xs, ks = read_input()
    if n == 0 and w == 0 and q == 0:
        return
    print(solve_all(n, w, q, xs, ks))

if __name__ == "__main__":
    # Exactly 3 asserts
    xs_demo = [1, 3, 8]; w_demo = 5
    assert min_cuts_for_T(xs_demo, w_demo - 3) == 1
    assert min_cuts_for_T(xs_demo, w_demo - 4) == 2
    assert min_cuts_for_T([0, 0, 0, 0], 0) == 0
    main()
\end{minted}
\VALIDATION{Asserts: narrative example for $k=3,4$; constant sequence with $T=0$.}
\RESULT{For each $k$, prints the minimal number of cuts, i.e., one less than the number of greedy maximal scenes under $\operatorname{spread} \le w-k$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted arrays: constant $x$, strictly increasing $x$ with large gaps, alternating highs and lows; random small arrays to cross-check implementations.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on small random inputs; verify monotonicity in $k$ (as $k$ increases, tolerance $T$ decreases and cuts should not decrease).}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of size $1$, all-equal arrays, arithmetic progressions with step $>T$, step $\le T$, and spikes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_arith(n: int, start: int, step: int) -> List[int]:
    return [start + i * step for i in range(n)]

def gen_spiky(n: int, base: int, spike: int, period: int) -> List[int]:
    xs = []
    for i in range(n):
        xs.append(base if (i % period) != 0 else base + spike)
    return xs

def brute_min_cuts(xs: List[int], T: int) -> int:
    # Same as final method (sanity wrapper)
    from math import inf
    cuts = 0
    L = None; R = None
    for xi in xs:
        if L is None:
            L = xi; R = xi + T
        else:
            L = max(L, xi); R = min(R, xi + T)
            if L > R:
                cuts += 1; L = xi; R = xi + T
    return cuts

def self_check():
    random.seed(0)
    # Equal arrays
    for n in [1, 2, 5]:
        for v in [0, 10]:
            for T in [0, 1, 5]:
                xs = gen_all_equal(n, v)
                assert brute_min_cuts(xs, T) == 0
    # Arithmetic progressions
    for step in [0, 1, 3]:
        xs = gen_arith(10, 5, step)
        for T in [0, 1, 2, 5]:
            assert brute_min_cuts(xs, T) == (0 if step <= T else 9)
    # Spiky
    xs = gen_spiky(10, base=100, spike=50, period=3)
    for T in [0, 10, 49, 50, 100]:
        _ = brute_min_cuts(xs, T)

if __name__ == "__main__":
    self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple

def min_cuts_for_T(xs: List[int], T: int) -> int:
    cuts = 0
    L = None
    R = None
    for xi in xs:
        if L is None:
            L = xi
            R = xi + T
        else:
            if xi > L:
                L = xi
            r_i = xi + T
            if r_i < R:
                R = r_i
            if L > R:
                cuts += 1
                L = xi
                R = xi + T
    return cuts

def read_input() -> Tuple[int, int, int, List[int], List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, [], []
    it = iter(data)
    n = int(next(it)); w = int(next(it)); q = int(next(it))
    xs = [int(next(it)) for _ in range(n)]
    ks = [int(next(it)) for _ in range(q)]
    return n, w, q, xs, ks

def solve_all(n: int, w: int, q: int, xs: List[int], ks: List[int]) -> str:
    out = []
    for k in ks:
        T = w - k
        out.append(str(min_cuts_for_T(xs, T)))
    return " ".join(out)

def main():
    n, w, q, xs, ks = read_input()
    if n == 0 and w == 0 and q == 0:
        return
    print(solve_all(n, w, q, xs, ks))

if __name__ == "__main__":
    # Smoke tests
    xs_demo = [1, 3, 8]; w_demo = 5
    assert min_cuts_for_T(xs_demo, w_demo - 3) == 1
    assert min_cuts_for_T(xs_demo, w_demo - 4) == 2
    assert min_cuts_for_T([0], 0) == 0
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Partition into minimal scenes where the intersection of feasible start positions $[x_i, x_i + w - k]$ is non-empty; greedy maximal-prefix partition is optimal.}
\WHY{This pattern (max-min window constraint) recurs in partitioning/segmentation tasks, sliding-window invariants, and interval intersection problems.}
\CHECKLIST{Maintain $L=\max x$ and $R=\min(x+T)$; when $L>R$, cut and reset. Remember $T=w-k$. Answers monotone in $k$.}
\EDGECASES{Single photo ($0$ cuts). All $x_i$ equal ($0$ cuts for any $k$). $k=w$ ($T=0$) forces all $x_i$ identical in a scene. Very large gaps cause frequent cuts when $k$ large (small $T$).}
\PITFALLS{Forgetting to use $x_i + w - k$ as right end in feasibility. Using sliding-window pops (deques) is unnecessary for the greedy reset model. Off-by-one with $T<0$ (ruled out since $k \le w$). Overflow is not a concern in Python but be mindful in other languages.}
\FAILMODES{Per-query $O(n)$ may TLE on CF constraints ($n,q \le 10^5$). The offline optimal approach is required to pass CF: exploit monotonicity over $T$ and structural decompositions (e.g., Cartesian tree) to share work across queries.}
\ELI{For each $k$, you can choose a starting flower index for each photo from a certain range. As long as all these ranges overlap, you can keep the same view; when they stop overlapping, you must cut and start a new scene. Greedily extend until overlap breaks, cut, and repeat.}
\NotePages{3}

\end{document}