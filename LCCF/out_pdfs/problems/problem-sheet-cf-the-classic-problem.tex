% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Classic Problem}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/464/E}}
\LINE{DIFFICULTY / RATING}{CF: 464/E, Rating: 3000}
\STATEMENT{You are given a weighted undirected graph on $n$ vertices and $m$ edges. Find the shortest path from vertex $s$ to vertex $t$ or else state that such path does not exist.

Input:

The first line of the input contains two space-separated integers — $n$ and $m$ ($1 \le n \le 10^5$; $0 \le m \le 10^5$).

Next $m$ lines contain the description of the graph edges. The $i$-th line contains three space-separated integers — $u_i$, $v_i$, $x_i$ ($1 \le u_i, v_i \le n$; $0 \le x_i \le 10^5$). That means that vertices with numbers $u_i$ and $v_i$ are connected by an edge of length $2^{x_i}$ (two to the power of $x_i$).

The last line contains two space-separated integers — the numbers of vertices $s$ and $t$.

The vertices are numbered from $1$ to $n$. The graph contains no multiple edges and self-loops.

Output:

In the first line print the remainder after dividing the length of the shortest path by $1{,}000{,}000{,}007$ ($10^9 + 7$) if the path exists, and $-1$ if the path does not exist.

If the path exists, print in the second line integer $k$ — the number of vertices in the shortest path from vertex $s$ to vertex $t$; in the third line print $k$ space-separated integers — the vertices of the shortest path in the visiting order. The first vertex should be vertex $s$, the last vertex should be vertex $t$. If there are multiple shortest paths, print any of them.

Note:

A path from vertex $s$ to vertex $t$ is a sequence $v_0, \ldots, v_k$, such that $v_0 = s$, $v_k = t$, and for any $i$ from $0$ to $k - 1$ vertices $v_i$ and $v_{i + 1}$ are connected by an edge.

The length of the path is the sum of weights of edges between $v_i$ and $v_{i + 1}$ for all $i$ from $0$ to $k - 1$.

The shortest path from $s$ to $t$ is the path whose length is minimum among all possible paths from $s$ to $t$.}
\BREAKDOWN{We need to compute a shortest path in an undirected graph where each edge weight is $2^{x}$. Use Dijkstra's algorithm since all weights are positive, compare exact integers, and finally output the distance modulo $1{,}000{,}000{,}007$ with a valid path reconstruction.}
\ELI{Run Dijkstra with exact big integers (Python supports arbitrary precision), then print the distance mod $10^9+7$ and the traced path from parents.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case:
\begin{bullets}
\item Integers $n$, $m$ with $1 \le n \le 10^5$, $0 \le m \le 10^5$.
\item For each edge $i$: integers $u_i$, $v_i$, $x_i$ with $1 \le u_i, v_i \le n$, $0 \le x_i \le 10^5$. Edge weight is $2^{x_i}$.
\item Integers $s$, $t$ with $1 \le s, t \le n$.
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item If no path from $s$ to $t$: print a single line with $-1$.
\item Else:
\begin{bullets}
\item Line 1: $d \bmod 1{,}000{,}000{,}007$ where $d$ is the exact shortest-path length.
\item Line 2: $k$ — number of vertices on the path.
\item Line 3: the $k$ vertices from $s$ to $t$.
\end{bullets}
\end{bullets}}
\SAMPLES{
Example 1:

Input:
\begin{BreakableEquation*}
\begin{aligned}
3~3\\
1~2~0\\
2~3~1\\
1~3~2\\
1~3
\end{aligned}
\end{BreakableEquation*}
Output:
\begin{BreakableEquation*}
\begin{aligned}
3\\
3\\
1~2~3
\end{aligned}
\end{BreakableEquation*}

Example 2:

Input:
\begin{BreakableEquation*}
\begin{aligned}
2~0\\
1~2
\end{aligned}
\end{BreakableEquation*}
Output:
\begin{BreakableEquation*}
\begin{aligned}
-1
\end{aligned}
\end{BreakableEquation*}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be an undirected graph with $V=\{1,\ldots,n\}$. Each edge $e=\{u,v\}\in E$ has an associated exponent $x_e\in\mathbb{Z}_{\ge 0}$ and weight $w(e)=2^{x_e}$. We seek a path $P=(v_0=s,\ldots,v_k=t)$ minimizing $\sum_{i=0}^{k-1} w(\{v_i,v_{i+1}\})$.}
\varmapStart
\var{n}{number of vertices}
\var{m}{number of edges}
\var{s,t}{source and target vertices}
\var{w(e)}{edge weight, $2^{x_e}$}
\var{d(v)}{current shortest known distance to $v$}
\var{\pi(v)}{parent of $v$ on a shortest path tree}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Minimize } \sum_{i=0}^{k-1} 2^{x_{\{v_i,v_{i+1}\}}} \\
&\text{Subject to } v_0=s,\ v_k=t,\ \{v_i,v_{i+1}\}\in E\ \text{ for } i=0,\ldots,k-1.
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item All weights are strictly positive, so Dijkstra's algorithm applies.
\item The graph has no multi-edges or self-loops.
\item Vertices are labeled $1$ to $n$.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item In Dijkstra, when a vertex $u$ is extracted from the heap, $d(u)$ is finalized (minimum possible).
\item Parent pointers $\pi$ form a tree rooted at $s$ over finalized vertices.
\item Distances are exact integers; comparing big integers is exact and transitive.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use Dijkstra's algorithm with a binary heap. Since edge weights are powers of two, the distances can be very large, but Python's arbitrary-precision integers allow exact accumulation and comparison.}
\ASSUMPTIONS{All weights are positive; the graph is sparse enough for $O(m\log n)$ heap operations to be acceptable for demonstration and testing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency lists with edge exponents $x$; interpret edge weight as $1 \ll x$.
\item Run Dijkstra from $s$ using a min-heap of pairs $(d,u)$ with $d$ as a big integer.
\item Maintain parent pointers for path reconstruction. After finishing, if $t$ is unreachable, print $-1$; otherwise print $d(t) \bmod 1{,}000{,}000{,}007$ and the reconstructed path.
\end{algosteps}
\COMPLEXITY{Let $B$ be the maximum number of bits in any intermediate distance (at most the largest exponent visited plus $\log_2$ of path length). Big-integer addition/comparison costs $O(B)$.}
\[
\begin{aligned}
T(n) &\in O\big((n+m)\log n \cdot B\big), \\
S(n) &\in O(n + m + n\cdot B)\ \text{bits for distances and parents}.
\end{aligned}
\]
\CORRECTNESS{Dijkstra is correct for nonnegative weights. Using exact big integers preserves the ordering by true path lengths, hence the final distances and chosen parents form a shortest-path tree.}
\EDGECASES{Single-vertex graph ($s=t$), no edges, disconnected graph, multiple paths with equal length, large exponents (e.g., $x=10^5$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
import heapq
from typing import List, Tuple, Optional

MOD = 1_000_000_007

def read_input(stream=None):
    """
    Reads the CF-style single test case.
    Returns: n, adj, s, t
    adj is 1-indexed: adj[u] = list of (v, x) where weight = 1 << x
    """
    if stream is None:
        data = sys.stdin.buffer.read().split()
    else:
        data = stream.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [[]], 0, 0
    m = int(next(it))
    adj = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); x = int(next(it))
        adj[u].append((v, x))
        adj[v].append((u, x))
    s = int(next(it)); t = int(next(it))
    return n, adj, s, t

def dijkstra_bigint(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int):
    """Dijkstra with big integers. Returns (dist_mod, path_list) or (-1, [])."""
    INF = None
    dist: List[Optional[int]] = [INF] * (n + 1)
    parent: List[int] = [-1] * (n + 1)
    dist[s] = 0
    pq: List[Tuple[int, int]] = [(0, s)]
    while pq:
        d, u = heapq.heappop(pq)
        if dist[u] is None or d != dist[u]:
            continue
        if u == t:
            break
        for v, x in adj[u]:
            w = 1 << x
            nd = d + w
            if dist[v] is None or nd < dist[v]:
                dist[v] = nd
                parent[v] = u
                heapq.heappush(pq, (nd, v))
    if dist[t] is None:
        return -1, []
    # Reconstruct path
    path = []
    cur = t
    while cur != -1:
        path.append(cur)
        if cur == s:
            break
        cur = parent[cur]
        if cur == -1:
            # Should not happen if dist[t] is not None
            return -1, []
    path.reverse()
    return dist[t] % MOD, path

def solve_case(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int) -> str:
    dmod, path = dijkstra_bigint(n, adj, s, t)
    if dmod == -1:
        return "-1\n"
    out_lines = []
    out_lines.append(str(dmod))
    out_lines.append(str(len(path)))
    out_lines.append(" ".join(map(str, path)))
    return "\n".join(out_lines) + "\n"

def solve_all():
    n, adj, s, t = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case(n, adj, s, t))

def main():
    solve_all()

if __name__ == "__main__":
    # Basic asserts (not executed unless called explicitly)
    def _tests():
        # Test 1: simple triangle
        n = 3
        edges = [(1, 2, 0), (2, 3, 1), (1, 3, 2)]  # weights: 1, 2, 4
        adj = [[] for _ in range(n + 1)]
        for u, v, x in edges:
            adj[u].append((v, x))
            adj[v].append((u, x))
        dmod, path = dijkstra_bigint(n, adj, 1, 3)
        assert dmod == 3 and path[0] == 1 and path[-1] == 3

        # Test 2: no path
        n = 2
        adj = [[] for _ in range(n + 1)]
        dmod, path = dijkstra_bigint(n, adj, 1, 2)
        assert dmod == -1 and path == []

        # Test 3: tie-breaking not fixed; just verify distance
        n = 4
        adj = [[] for _ in range(n + 1)]
        # Path A: 1-2-4 with weights 2^2 + 2^0 = 4 + 1 = 5
        # Path B: 1-3-4 with weights 2^1 + 2^1 = 2 + 2 = 4 (shorter)
        for (u, v, x) in [(1, 2, 2), (2, 4, 0), (1, 3, 1), (3, 4, 1)]:
            adj[u].append((v, x))
            adj[v].append((u, x))
        dmod, path = dijkstra_bigint(n, adj, 1, 4)
        assert dmod == 4 and path[0] == 1 and path[-1] == 4
    # Uncomment to run local tests:
    # _tests()
    main()
\end{minted}
\VALIDATION{Checked small handcrafted graphs:
\begin{bullets}
\item Triangle with competing direct vs. two-edge path.
\item Disconnected case.
\item Equal-length or tie-like constructions.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Cache powers of two on demand and avoid repeated big-integer shifts by reusing $1 \ll x$. Also short-circuit when popping target $t$ from the heap because its distance is finalized.}
\ASSUMPTIONS{Same as baseline. Improvement focuses on constant factors (reduced recomputation, early exit) while maintaining exactness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a small cache dict for $2^x$ values encountered to reuse big ints.
\item Use Dijkstra with a standard min-heap; when $t$ is extracted, stop.
\item Keep parents to reconstruct one shortest path.
\end{algosteps}
\COMPLEXITY{Asymptotically same as baseline; practically fewer big-int allocations.}
\[
\begin{aligned}
T(n) &\in O\big((n+m)\log n \cdot B\big).
\end{aligned}
\]
\CORRECTNESS{Identical to baseline; caching does not affect the order of relaxations or comparisons.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import heapq
from typing import List, Tuple, Optional, Dict

MOD = 1_000_000_007

def read_input(stream=None):
    if stream is None:
        data = sys.stdin.buffer.read().split()
    else:
        data = stream.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [[]], 0, 0
    m = int(next(it))
    adj = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); x = int(next(it))
        adj[u].append((v, x))
        adj[v].append((u, x))
    s = int(next(it)); t = int(next(it))
    return n, adj, s, t

def dijkstra_bigint_cached(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int):
    INF = None
    dist: List[Optional[int]] = [INF] * (n + 1)
    parent: List[int] = [-1] * (n + 1)
    dist[s] = 0
    pq: List[Tuple[int, int]] = [(0, s)]
    cache: Dict[int, int] = {}

    def pow2(x: int) -> int:
        v = cache.get(x)
        if v is None:
            v = 1 << x
            cache[x] = v
        return v

    while pq:
        d, u = heapq.heappop(pq)
        if dist[u] is None or d != dist[u]:
            continue
        if u == t:
            break
        for v, x in adj[u]:
            nd = d + pow2(x)
            if dist[v] is None or nd < dist[v]:
                dist[v] = nd
                parent[v] = u
                heapq.heappush(pq, (nd, v))

    if dist[t] is None:
        return -1, []
    # Build path
    path = []
    cur = t
    while cur != -1:
        path.append(cur)
        if cur == s:
            break
        cur = parent[cur]
        if cur == -1:
            return -1, []
    path.reverse()
    return dist[t] % MOD, path

def solve_case(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int) -> str:
    dmod, path = dijkstra_bigint_cached(n, adj, s, t)
    if dmod == -1:
        return "-1\n"
    return f"{dmod}\n{len(path)}\n{' '.join(map(str, path))}\n"

def solve_all():
    n, adj, s, t = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case(n, adj, s, t))

def main():
    # Edge-input checks
    def _edge_checks():
        # Large exponent single edge
        n = 2
        adj = [[] for _ in range(n + 1)]
        adj[1].append((2, 100000))
        adj[2].append((1, 100000))
        dmod, path = dijkstra_bigint_cached(n, adj, 1, 2)
        assert dmod == (1 << 100000) % MOD and path == [1, 2]
        # s == t
        n = 1
        adj = [[] for _ in range(n + 1)]
        dmod, path = dijkstra_bigint_cached(n, adj, 1, 1)
        assert dmod == 0 and path == [1]
    # _edge_checks()  # keep disabled by default
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on:
\begin{bullets}
\item Large exponent edge ($x=100{,}000$) to ensure correctness of big integers.
\item Trivial $s=t$ case.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use Dijkstra's algorithm but represent distances as functional binary vectors (e.g., persistent segment trees with lazy carry) for $O(\log M)$ comparison and updates where $M$ is the max exponent, as in the editorial. For this reference, we retain exact big integers for simplicity; the algorithmic outline is the same.}
\ASSUMPTIONS{All edge weights are powers of two; comparisons of binary numbers can be reduced to most significant differing bit. A persistent structure supports addition of $2^x$ and lexicographic comparison in $O(\log M)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain distance labels as immutable binary trees storing highest set bit, segment hash, and parity; addition of $2^x$ triggers a carry-propagation along a path.
\item Priority queue orders labels by most significant bit, then segment hashes to compare subranges.
\item Parent pointers as usual; early terminate at $t$.
\end{algosteps}
\OPTIMALITY{Among comparison-based algorithms for SSSP with positive weights, Dijkstra is optimal up to heap factors. The persistent-bitset trick reduces per-relaxation label operations from $O(B)$ to $O(\log M)$, which is asymptotically optimal for this weight structure.}
\COMPLEXITY{With a balanced persistent structure:
\[
\begin{aligned}
T(n) &\in O\big((n+m)\log n \cdot \log M\big),\quad M=\max x_i+1,\\
S(n) &\in O\big(n\log M + m\log M\big)\ \text{nodes due to persistence}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For clarity and robustness, we keep the exact big-int implementation,
# which is correct and simple, though not CF-optimized.
import sys
import heapq
from typing import List, Tuple, Optional

MOD = 1_000_000_007

def read_input(stream=None):
    if stream is None:
        data = sys.stdin.buffer.read().split()
    else:
        data = stream.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [[]], 0, 0
    m = int(next(it))
    adj = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); x = int(next(it))
        adj[u].append((v, x))
        adj[v].append((u, x))
    s = int(next(it)); t = int(next(it))
    return n, adj, s, t

def dijkstra_exact(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int):
    INF = None
    dist: List[Optional[int]] = [INF] * (n + 1)
    parent: List[int] = [-1] * (n + 1)
    dist[s] = 0
    pq: List[Tuple[int, int]] = [(0, s)]
    while pq:
        d, u = heapq.heappop(pq)
        if dist[u] is None or d != dist[u]:
            continue
        if u == t:
            break
        for v, x in adj[u]:
            nd = d + (1 << x)
            if dist[v] is None or nd < dist[v]:
                dist[v] = nd
                parent[v] = u
                heapq.heappush(pq, (nd, v))
    if dist[t] is None:
        return -1, []
    # Reconstruct path
    path = []
    cur = t
    while cur != -1:
        path.append(cur)
        if cur == s:
            break
        cur = parent[cur]
        if cur == -1:
            return -1, []
    path.reverse()
    return dist[t] % MOD, path

def solve_case(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int) -> str:
    dmod, path = dijkstra_exact(n, adj, s, t)
    if dmod == -1:
        return "-1\n"
    return f"{dmod}\n{len(path)}\n{' '.join(map(str, path))}\n"

def solve_all():
    n, adj, s, t = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case(n, adj, s, t))

def main():
    # Exactly 3 asserts
    def _self_tests():
        # 1) Simple path
        n = 3
        adj = [[] for _ in range(n + 1)]
        for (u, v, x) in [(1, 2, 0), (2, 3, 1)]:
            adj[u].append((v, x)); adj[v].append((u, x))
        dmod, path = dijkstra_exact(n, adj, 1, 3)
        assert dmod == 3 and path == [1, 2, 3]
        # 2) Direct vs longer
        n = 3
        adj = [[] for _ in range(n + 1)]
        for (u, v, x) in [(1, 2, 3), (2, 3, 3), (1, 3, 0)]:
            adj[u].append((v, x)); adj[v].append((u, x))
        dmod, path = dijkstra_exact(n, adj, 1, 3)
        assert dmod == 1 and path == [1, 3]
        # 3) No path
        n = 2
        adj = [[] for _ in range(n + 1)]
        dmod, path = dijkstra_exact(n, adj, 1, 2)
        assert dmod == -1 and path == []
    # _self_tests()  # disabled by default
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts cover: straightforward chain, competing paths, and unreachable target.}
\RESULT{Print $-1$ if unreachable; otherwise print distance modulo $1{,}000{,}000{,}007$, then the number of vertices and the path from $s$ to $t$. Any shortest path is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for small graphs with known answers; property checks such as symmetry of undirected edges and correctness when $s=t$; adversarial large exponents to exercise big-int handling.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on the same small inputs to ensure identical distances and valid paths.}
\LINE{EDGE-CASE GENERATOR}{Generate random sparse graphs on $n\le 8$ nodes, random $x\le 12$, and verify the solver against brute-force enumeration of all simple paths (for tiny $n$).}
\begin{minted}{python}
import random
from typing import List, Tuple

MOD = 1_000_000_007

def brute_force(n: int, edges: List[Tuple[int,int,int]], s: int, t: int):
    # Enumerate simple paths with pruning; for tiny n only.
    adj = [[] for _ in range(n + 1)]
    for u, v, x in edges:
        adj[u].append((v, x)); adj[v].append((u, x))
    best = None
    best_path = []
    def dfs(u, seen, acc, path):
        nonlocal best, best_path
        if best is not None and acc >= best:
            return
        if u == t:
            best = acc
            best_path = path[:]
            return
        for v, x in adj[u]:
            if v in seen:
                continue
            dfs(v, seen | {v}, acc + (1 << x), path + [v])
    dfs(s, {s}, 0, [s])
    if best is None:
        return -1, []
    return best % MOD, best_path

def gen_random_case(n=7, m=10, xmax=12):
    g_edges = set()
    while len(g_edges) < m:
        u = random.randint(1, n)
        v = random.randint(1, n)
        if u == v:
            continue
        if u > v:
            u, v = v, u
        g_edges.add((u, v))
    edges = []
    for (u, v) in g_edges:
        x = random.randint(0, xmax)
        edges.append((u, v, x))
    s = random.randint(1, n)
    t = random.randint(1, n)
    return n, edges, s, t

def build_adj(n, edges):
    adj = [[] for _ in range(n + 1)]
    for u, v, x in edges:
        adj[u].append((v, x)); adj[v].append((u, x))
    return adj

def reference_solve(n, edges, s, t):
    # Use Approach C's dijkstra_exact
    adj = build_adj(n, edges)
    from collections import deque
    import heapq
    INF = None
    dist = [INF] * (n + 1)
    par = [-1] * (n + 1)
    pq = []
    dist[s] = 0
    heapq.heappush(pq, (0, s))
    while pq:
        d, u = heapq.heappop(pq)
        if dist[u] is None or d != dist[u]:
            continue
        if u == t:
            break
        for v, x in adj[u]:
            nd = d + (1 << x)
            if dist[v] is None or nd < dist[v]:
                dist[v] = nd
                par[v] = u
                heapq.heappush(pq, (nd, v))
    if dist[t] is None:
        return -1, []
    path = []
    cur = t
    while cur != -1:
        path.append(cur)
        if cur == s:
            break
        cur = par[cur]
        if cur == -1:
            return -1, []
    path.reverse()
    return dist[t] % MOD, path

def run_property_tests(trials=50):
    random.seed(0)
    for _ in range(trials):
        n, edges, s, t = gen_random_case()
        ref_d, ref_p = reference_solve(n, edges, s, t)
        bf_d, bf_p = brute_force(n, edges, s, t)
        assert (ref_d == -1 and bf_d == -1) or ref_d == bf_d
    print("All property tests passed.")

if __name__ == "__main__":
    run_property_tests(10)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (Approach C implementation: exact big-int Dijkstra)
import sys
import heapq
from typing import List, Tuple, Optional

MOD = 1_000_000_007

def read_input(stream=None):
    if stream is None:
        data = sys.stdin.buffer.read().split()
    else:
        data = stream.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [[]], 0, 0
    m = int(next(it))
    adj = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); x = int(next(it))
        adj[u].append((v, x))
        adj[v].append((u, x))
    s = int(next(it)); t = int(next(it))
    return n, adj, s, t

def dijkstra_exact(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int):
    INF = None
    dist: List[Optional[int]] = [INF] * (n + 1)
    parent: List[int] = [-1] * (n + 1)
    dist[s] = 0
    pq: List[Tuple[int, int]] = [(0, s)]
    while pq:
        d, u = heapq.heappop(pq)
        if dist[u] is None or d != dist[u]:
            continue
        if u == t:
            break
        for v, x in adj[u]:
            nd = d + (1 << x)
            if dist[v] is None or nd < dist[v]:
                dist[v] = nd
                parent[v] = u
                heapq.heappush(pq, (nd, v))
    if dist[t] is None:
        return -1, []
    path = []
    cur = t
    while cur != -1:
        path.append(cur)
        if cur == s:
            break
        cur = parent[cur]
        if cur == -1:
            return -1, []
    path.reverse()
    return dist[t] % MOD, path

def solve_case(n: int, adj: List[List[Tuple[int, int]]], s: int, t: int) -> str:
    dmod, path = dijkstra_exact(n, adj, s, t)
    if dmod == -1:
        return "-1\n"
    return f"{dmod}\n{len(path)}\n{' '.join(map(str, path))}\n"

def solve_all():
    n, adj, s, t = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case(n, adj, s, t))

def main():
    # Self-checks (not executed by default)
    def _asserts():
        # 1) Single node
        n = 1; adj = [[] for _ in range(2)]
        dmod, path = dijkstra_exact(n, adj, 1, 1)
        assert dmod == 0 and path == [1]
        # 2) Simple graph
        n = 3; adj = [[] for _ in range(n + 1)]
        edges = [(1, 2, 0), (2, 3, 1), (1, 3, 2)]
        for u, v, x in edges:
            adj[u].append((v, x)); adj[v].append((u, x))
        dmod, path = dijkstra_exact(n, adj, 1, 3)
        assert dmod == 3 and path[0] == 1 and path[-1] == 3
        # 3) No path
        n = 2; adj = [[] for _ in range(n + 1)]
        dmod, path = dijkstra_exact(n, adj, 1, 2)
        assert dmod == -1 and path == []
    # _asserts()
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shortest path with edge weights $2^{x}$; compute exact minimum, print modulo $1{,}000{,}000{,}007$, along with any shortest path.}
\WHY{Tests handling of huge numeric magnitudes, custom weight structures, and robust path reconstruction under pressure.}
\CHECKLIST{
\begin{bullets}
\item Parse input correctly; build undirected adjacency.
\item Run Dijkstra (positive weights).
\item Keep parents for path reconstruction.
\item If $t$ unreachable, print $-1$.
\item Else print $d(t) \bmod 1{,}000{,}000{,}007$, $k$, and the path.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $s=t$ (distance $0$, path length $1$).
\item No edges.
\item Disconnected components.
\item Multiple shortest paths (any is fine).
\item Very large $x$ (e.g., $10^5$).
\item Graph with $m=0$ and $n>1$.
\item Star graphs where direct edge dominates.
\item Chains where exponents increase/decrease.
\item Ties where different bit patterns sum to same integer.
\item Self-consistency when parent reconstruction meets $-1$ (guarded).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting undirected insertion (need both $(u,v)$ and $(v,u)$).
\item Using 32/64-bit integers and overflowing; use big ints.
\item Comparing modulo values instead of exact distances.
\item Not stopping early when $t$ is popped (optional optimization).
\item Missing path reconstruction when $t$ is unreachable.
\item Off-by-one in 1-indexed vertices.
\item Building path in forward order without reversing.
\item Accidentally using $2 \times x$ instead of $2^x$.
\end{bullets}}
\FAILMODES{Any approach that compares distances modulo $1{,}000{,}000{,}007$ will fail because modulo does not preserve order. Greedy choices by exponent alone can fail due to carries. The presented method uses exact comparisons, avoiding such traps.}
\ELI{Treat each edge as a huge power of two. Python can add and compare such big numbers exactly. Dijkstra finds the shortest total, and at the end we just take the remainder for printing and reconstruct the path by following parents.}
\NotePages{3}

\end{document}