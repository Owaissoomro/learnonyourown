% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sagheer and Kindergarten}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/812/D}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Sagheer is working at a kindergarten. There are $n$ children and $m$ different toys. These children use well-defined protocols for playing with the toys:

\begin{bullets}
\item Each child has a lovely set of toys that he loves to play with. He requests the toys one after another at distinct moments of time. A child starts playing if and only if he is granted all the toys in his lovely set.
\item If a child starts playing, then sooner or later he gives the toys back. No child keeps the toys forever.
\item Children request toys at distinct moments of time. No two children request a toy at the same time.
\item If a child is granted a toy, he never gives it back until he finishes playing with his lovely set.
\item If a child is not granted a toy, he waits until he is granted this toy. He can't request another toy while waiting.
\item If two children are waiting for the same toy, then the child who requested it first will take the toy first.
\end{bullets}

Children do not like to play with each other. They never share toys. When a child requests a toy, granting the toy to this child depends on whether the toy is free or not. If the toy is free, Sagheer will give it to the child. Otherwise, the child has to wait for it and cannot request another toy.

Children are smart and can detect if they have to wait forever before they get the toys they want. In such case they start crying. In other words, a \emph{crying set} is a set of children in which each child is waiting for a toy that is kept by another child in the set.

Now, we have reached a scenario where all the children made all the requests for their lovely sets, except for one child $x$ that still has one last request for his lovely set. Some children are playing while others are waiting for a toy, but no child is crying, and no one has yet finished playing. If the child $x$ is currently waiting for some toy, he makes his last request just after getting that toy. Otherwise, he makes the request right away. When child $x$ will make his last request, how many children will start crying?

You will be given the scenario and $q$ independent queries. Each query will be of the form $x~y$ meaning that the last request of the child $x$ is for the toy $y$. Your task is to help Sagheer find the size of the maximal crying set when child $x$ makes his last request.

Input:

The first line contains four integers $n, m, k, q$ ($1 \le n, m, k, q \le 10^5$) — the number of children, toys, scenario requests and queries.

Each of the next $k$ lines contains two integers $a, b$ ($1 \le a \le n$ and $1 \le b \le m$) — a scenario request meaning child $a$ requests toy $b$. The requests are given in the order they are made by children.

Each of the next $q$ lines contains two integers $x, y$ ($1 \le x \le n$ and $1 \le y \le m$) — the request to be added to the scenario meaning child $x$ will request toy $y$ just after getting the toy he is waiting for (if any).

It is guaranteed that the scenario requests are consistent and no child is initially crying. All the scenario requests are distinct and no query coincides with a scenario request.

Output:

For each query, print on a single line the number of children who will start crying when child $x$ makes his last request for toy $y$. Please answer all queries independent of each other.

Note:

In the first example, child $1$ is waiting for toy $2$, which child $2$ has, while child $2$ is waiting for toy $3$, which child $3$ has. When child $3$ makes his last request, the toy he requests is held by child $1$. Each of the three children is waiting for a toy held by another child and no one is playing, so all the three will start crying.

In the second example, at the beginning, child $i$ is holding toy $i$ for $1 \le i \le 4$. Children $1$ and $3$ have completed their lovely sets. After they finish playing, toy $3$ will be free while toy $1$ will be taken by child $2$ who has just completed his lovely set. After he finishes, toys $1$ and $2$ will be free and child $5$ will take toy $1$. Now:

\begin{bullets}
\item In the first query, child $5$ will take toy $3$ and after he finishes playing, child $4$ can play.
\item In the second query, child $5$ will request toy $4$ which is held by child $4$. At the same time, child $4$ is waiting for toy $1$ which is now held by child $5$. None of them can play and they will start crying.
\end{bullets}
}
\BREAKDOWN{Model the scenario as a directed forest on children: an edge from a child to the child currently blocking his last request. Adding the last request of $x$ to toy $y$ creates a wait edge from $x$ to the current holder of $y$ at that time; a crying set is exactly a directed cycle. Show that the cycle, if any, equals the path from that holder up to $x$. Reduce each query to a deepest-requester-in-subtree query.}
\ELI{Build a tree of who is waiting on whom. For each toy, keep the chain of requesters. When $x$ asks for $y$, the holder is the deepest requester of $y$ inside $x$'s subtree; if present and below $x$, this closes a cycle whose size is the depth gap plus one.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m, k, q$; then $k$ pairs $(a, b)$ of scenario requests in time order; then $q$ pairs $(x, y)$ queries. Ranges: $1 \le n, m, k, q \le 10^5$ and $1 \le a, x \le n$, $1 \le b, y \le m$.}
\OUTPUTS{For each query $(x, y)$, output a single integer: the size of the maximal crying set that appears at the moment child $x$ makes the last request for toy $y$.}
\SAMPLES{
Example sketch (not full platform sample):

$n=3, m=3, k=4, q=2$.

Requests:
$(2,2),(3,3),(1,1),(1,2)$.

Queries:
$(3,1)$ $\to 3$,
$(1,1)$ $\to 0$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let children be vertices $V=\{1,\ldots,n\}$. Scan scenario requests in order. For each toy $t$, maintain the last requester $L(t)$ seen. For each request $(u,t)$:
if $L(t)=0$, then toy is granted; else $u$ is blocked by $L(t)$. Let $\mathrm{par}[u]$ be the blocker of $u$ at \emph{its last scenario request that blocks it}, or $0$ if never blocked. This yields a directed forest $u \to \mathrm{par}[u]$ with out-degree $\le 1$.}
\varmapStart
\var{n,m,k,q}{counts of children, toys, scenario requests, queries}
\var{L(t)}{previous requester of toy $t$ during the scan}
\var{\mathrm{par}[u]}{parent (blocker) of child $u$; $0$ if none}
\var{\mathrm{tin}[u], \mathrm{tout}[u]}{Euler tour times in the forest (roots: $\mathrm{par}=0$)}
\var{\mathrm{depth}[u]}{depth in the forest (roots have depth $0$)}
\var{R_t}{list of children who requested toy $t$ in the scenario}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\mathrm{par}[u] &=
\begin{cases}
L(t), & \text{at $u$'s first blocking request $(u,t)$;}\\
0, & \text{if all its scenario requests were granted.}
\end{cases}\\
\text{For query }(x,y):~
\text{let } D &= \{u \in R_y : \mathrm{tin}[x] \le \mathrm{tin}[u] \le \mathrm{tout}[x]\},\\
\text{if } D=\varnothing &\Rightarrow \text{answer }0;\\
u^\star &:= \arg\max_{u \in D}~\mathrm{depth}[u],\\
\text{if } u^\star = x &\Rightarrow \text{answer }0;\\
\text{else answer }~&\mathrm{depth}[u^\star]-\mathrm{depth}[x]+1.
\end{aligned}
\]
}
\ASSUMPTIONS{Scenario is consistent: scanning requests yields a forest (no directed cycles) because a child cannot issue a request after being blocked; all requests happen at distinct times. No one finishes before the scenario ends, so holders never release yet.}
\INVARIANTS{
\begin{bullets}
\item Each node has out-degree $0$ or $1$ in the wait forest $u \to \mathrm{par}[u]$.
\item For each toy $t$, the requesters $R_t$ form a simple chain along the forest (consecutive requesters are parent/child).
\item Adding $(x,y)$ creates a cycle iff some requester of $y$ lies strictly below $x$ in the forest; the cycle is exactly the path from that requester up to $x$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively simulate the forest creation by scanning the $k$ requests. For each query $(x,y)$, linearly scan all requesters of $y$ and pick those inside the subtree of $x$, then compute the deepest depth.}
\ASSUMPTIONS{We can precompute Euler tour times to test subtree membership via $\mathrm{tin}/\mathrm{tout}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan the $k$ requests, maintain $L(t)$ and $\mathrm{par}[u]$ as the blocker of $u$ at its first blocking request.
\item Build children lists, run DFS to get $\mathrm{tin}, \mathrm{tout}, \mathrm{depth}$.
\item For each query $(x,y)$, iterate all $u \in R_y$, keep those with $\mathrm{tin}[x] \le \mathrm{tin}[u] \le \mathrm{tout}[x]$, track maximum depth; answer is $0$ if none or if the maximum equals $\mathrm{depth}[x]$, else $\max\_u \mathrm{depth}[u]-\mathrm{depth}[x]+1$.
\end{algosteps}
\COMPLEXITY{Let $S=\sum\_t |R_t| = k$. The preprocessing is $O(n+k)$. Each query scans $|R_y|$, so worst-case $O(k)$ per query and $O(kq)$ total, too slow for $q \le 10^5$.}
\[
\begin{aligned}
T(n) &= O(n + k) + \sum\_{i=1}^q O(|R_{y_i}|) \\
     &\le O(n + k + kq) \\
\end{aligned}
\]
\CORRECTNESS{Follows from the invariants: subtree membership via Euler tour is exact; the deepest requester of $y$ inside $x$'s subtree is the current holder at the moment $x$ can request $y$. If that deepest is $x$ itself, then no waiting edge is formed.}
\EDGECASES{
\begin{bullets}
\item Toy $y$ never requested in the scenario $\Rightarrow$ answer $0$.
\item No requester of $y$ in subtree of $x$ $\Rightarrow$ answer $0$.
\item $x$ requested $y$ earlier and no deeper requester in subtree $\Rightarrow$ answer $0$ (holder is $x$).
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys
import bisect

def build_forest(n: int, m: int, reqs: List[Tuple[int, int]]):
    last = [0] * (m + 1)
    par = [0] * (n + 1)
    toy_requesters = [[] for _ in range(m + 1)]
    for a, b in reqs:
        toy_requesters[b].append(a)
        if par[a] == 0 and last[b] != 0:
            par[a] = last[b]
        last[b] = a
    children = [[] for _ in range(n + 1)]
    for v in range(1, n + 1):
        if par[v] != 0:
            children[par[v]].append(v)
    # iterative DFS for tin/tout/depth
    tin = [0] * (n + 1)
    tout = [0] * (n + 1)
    depth = [0] * (n + 1)
    time = 0
    for root in range(1, n + 1):
        if par[root] == 0:
            stack = [(root, 0, 0)]  # (node, idx, state 0 enter / 1 exit)
            while stack:
                v, idx, state = stack.pop()
                if state == 0:
                    time += 1
                    tin[v] = time
                    # push exit marker
                    stack.append((v, 0, 1))
                    # push children
                    for u in reversed(children[v]):
                        depth[u] = depth[v] + 1
                        stack.append((u, 0, 0))
                else:
                    tout[v] = time
    return par, children, tin, tout, depth, toy_requesters

def solve_baseline(n: int, m: int, reqs: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]:
    par, children, tin, tout, depth, toy_requesters = build_forest(n, m, reqs)
    ans = []
    for x, y in queries:
        best = -1
        if toy_requesters[y]:
            for u in toy_requesters[y]:
                if tin[x] <= tin[u] <= tout[x]:
                    if depth[u] > best:
                        best = depth[u]
        if best < 0 or best == depth[x]:
            ans.append(0)
        else:
            ans.append(best - depth[x] + 1)
    return ans

# basic asserts
def _test_baseline():
    # Construct the chain 1->2->3 with holders: 1 holds toy1, 2 holds toy2, 3 holds toy3.
    n, m = 3, 3
    reqs = [(2,2),(3,3),(1,1),(1,2),(2,3)]
    # Queries:
    # (3,1): deepest requester of toy1 in subtree(3) is 1 (depth 2): answer 3
    # (1,1): holder is 1 himself at request time: answer 0
    queries = [(3,1),(1,1)]
    out = solve_baseline(n, m, reqs, queries)
    assert out == [3, 0]
_test_baseline()
\end{minted}
\VALIDATION{Checked the classic 3-cycle scenario and a self-holder case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-Toy Range-Max over Euler Order}
\WHICHFORMULA{Precompute Euler tour of the forest. For each toy $y$, sort its requesters by $\mathrm{tin}$, store their depths, and build a segment tree to answer range maximum queries over $\mathrm{tin}$ intervals. Query $(x,y)$ reduces to a range maximum over indices with $\mathrm{tin}$ inside $[\mathrm{tin}[x], \mathrm{tout}[x]]$.}
\ASSUMPTIONS{Total number of scenario requests $k$ bounds $\sum\_y |R_y|$. Building one segment tree per toy uses $O(k)$ memory overall.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $\mathrm{par}$, children, and compute $\mathrm{tin}, \mathrm{tout}, \mathrm{depth}$ as in Approach A.
\item For each toy $y$, build arrays:
tins$_y$ = sorted $\mathrm{tin}[u]$ for $u \in R_y$,
depths$_y$ = corresponding $\mathrm{depth}[u]$,
and a segment tree over depths$_y$.
\item For a query $(x,y)$: binary search tins$_y$ for $[L,R) = [\mathrm{tin}[x], \mathrm{tout}[x]+1)$.
If $L \ge R$, print $0$.
Else let $d^\star$ be the range maximum; if $d^\star = \mathrm{depth}[x]$, print $0$, else print $d^\star - \mathrm{depth}[x] + 1$.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n + k + \sum\_y |R_y| \log |R_y|)$; total segment tree storage $O(k)$. Each query is $O(\log |R_y|)$ for two binary searches plus $O(\log |R_y|)$ for the segment-tree RMQ.}
\[
\begin{aligned}
T(n) &= O(n + k \log k) + \sum\_{i=1}^q O(\log |R_{y_i}|) \\
\end{aligned}
\]
\CORRECTNESS{Follows from the chain property of $R_y$ and Euler-tour subtree characterization. The deepest requester inside the subtree of $x$ is exactly the holder of $y$ when $x$ becomes free to request; adding the edge closes a unique directed cycle along the path to $x$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import sys
import bisect

class SegTree:
    def __init__(self, arr: List[int]):
        n = len(arr)
        self.n = 1
        while self.n < n:
            self.n <<= 1
        self.seg = [0] * (2 * self.n)
        for i in range(n):
            self.seg[self.n + i] = arr[i]
        for i in range(self.n - 1, 0, -1):
            self.seg[i] = self.seg[2*i] if self.seg[2*i] >= self.seg[2*i+1] else self.seg[2*i+1]
    def range_max(self, l: int, r: int) -> int:
        # inclusive indices [l, r]
        if l > r:
            return -10**9
        l += self.n
        r += self.n
        res = -10**9
        while l <= r:
            if (l & 1) == 1:
                if self.seg[l] > res: res = self.seg[l]
                l += 1
            if (r & 1) == 0:
                if self.seg[r] > res: res = self.seg[r]
                r -= 1
            l >>= 1
            r >>= 1
        return res

def build_forest(n: int, m: int, reqs: List[Tuple[int, int]]):
    last = [0] * (m + 1)
    par = [0] * (n + 1)
    toy_requesters = [[] for _ in range(m + 1)]
    for a, b in reqs:
        toy_requesters[b].append(a)
        if par[a] == 0 and last[b] != 0:
            par[a] = last[b]
        last[b] = a
    children = [[] for _ in range(n + 1)]
    for v in range(1, n + 1):
        if par[v] != 0:
            children[par[v]].append(v)
    tin = [0] * (n + 1)
    tout = [0] * (n + 1)
    depth = [0] * (n + 1)
    time = 0
    for root in range(1, n + 1):
        if par[root] == 0:
            stack = [(root, 0)]
            while stack:
                v, state = stack.pop()
                if state == 0:
                    time += 1
                    tin[v] = time
                    stack.append((v, 1))
                    for u in reversed(children[v]):
                        depth[u] = depth[v] + 1
                        stack.append((u, 0))
                else:
                    tout[v] = time
    return par, children, tin, tout, depth, toy_requesters

def preprocess(n: int, m: int, reqs: List[Tuple[int, int]]):
    par, children, tin, tout, depth, toy_requesters = build_forest(n, m, reqs)
    toy_data = [None] * (m + 1)
    for y in range(1, m + 1):
        if not toy_requesters[y]:
            toy_data[y] = None
            continue
        # sort by tin
        vec = sorted(toy_requesters[y], key=lambda u: tin[u])
        tins = [tin[u] for u in vec]
        depths = [depth[u] for u in vec]
        seg = SegTree(depths)
        toy_data[y] = (tins, depths, seg)
    return tin, tout, depth, toy_data

def answer_queries(n: int, m: int, reqs: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]:
    tin, tout, depth, toy_data = preprocess(n, m, reqs)
    out = []
    for x, y in queries:
        data = toy_data[y]
        if data is None:
            out.append(0)
            continue
        tins, depths, seg = data
        L = bisect.bisect_left(tins, tin[x])
        R = bisect.bisect_right(tins, tout[x]) - 1
        if L > R:
            out.append(0)
            continue
        dstar = seg.range_max(L, R)
        if dstar == depth[x]:
            out.append(0)
        else:
            out.append(dstar - depth[x] + 1)
    return out

def _test_improved():
    # Same as baseline test
    n, m = 3, 3
    reqs = [(2,2),(3,3),(1,1),(1,2),(2,3)]
    queries = [(3,1),(1,1)]
    out = answer_queries(n, m, reqs, queries)
    assert out == [3, 0]
    # Another test: 1 is root, 2 waits for 1 on toy A; ask x=1 for toy requested by 2 -> cycle size 2
    n2, m2 = 2, 1
    reqs2 = [(1,1),(2,1)]
    queries2 = [(1,1)]
    out2 = answer_queries(n2, m2, reqs2, queries2)
    assert out2 == [2]
_test_improved()
\end{minted}
\VALIDATION{Unit tests cover the 3-cycle scenario and a 2-cycle case; also self-holder yields $0$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Forest + Per-Toy Segment Trees}
\WHICHFORMULA{Use the parent-forest induced by the first blocking request per child and Euler tour indices. For each toy $y$, sort its requesters by $\mathrm{tin}$ and build a segment tree for range maximum over depths. Query $(x,y)$ becomes a range-maximum on $[\mathrm{tin}[x], \mathrm{tout}[x]]$.}
\ASSUMPTIONS{Scenario consistency implies each toy's requester list forms a chain in the forest; thus the deepest requester inside a subtree is unique and sufficient to derive the cycle size.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Single pass to compute $\mathrm{par}$ and collect $R_y$.
\item DFS to compute $\mathrm{tin}, \mathrm{tout}, \mathrm{depth}$.
\item For each $y$, build sorted tins and a segment tree over depths.
\item For each query, binary search the tins range and query the segment tree; emit $0$ if empty or if the maximum depth equals $\mathrm{depth}[x]$, else depth gap $+1$.
\end{algosteps}
\OPTIMALITY{Asymptotically near-optimal: any solution must at least distinguish which requesters of toy $y$ fall inside the subtree of $x$, requiring $\Omega(\log |R_y|)$ in the comparison model if data are preprocessed. Total memory/time scale with $k$ and $q$.}
\COMPLEXITY{Preprocessing $O(n + k \log k)$; per-query $O(\log |R_y|)$.}
\[
\begin{aligned}
T(n, m, k, q) &= O(n + k \log k + q \log k), \quad S(n,m,k) = O(n + k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import sys, bisect

class SegTree:
    __slots__ = ("n","seg")
    def __init__(self, arr: List[int]):
        n = len(arr)
        self.n = 1
        while self.n < n:
            self.n <<= 1
        self.seg = [0] * (2 * self.n)
        for i in range(n):
            self.seg[self.n + i] = arr[i]
        for i in range(self.n - 1, 0, -1):
            a = self.seg[2*i]; b = self.seg[2*i+1]
            self.seg[i] = a if a >= b else b
    def range_max(self, l: int, r: int) -> int:
        if l > r:
            return -10**9
        l += self.n; r += self.n
        res = -10**9
        while l <= r:
            if (l & 1) == 1:
                if self.seg[l] > res: res = self.seg[l]
                l += 1
            if (r & 1) == 0:
                if self.seg[r] > res: res = self.seg[r]
                r -= 1
            l >>= 1; r >>= 1
        return res

def build_forest(n: int, m: int, reqs: List[Tuple[int,int]]):
    last = [0] * (m + 1)
    par = [0] * (n + 1)
    toy_requesters = [[] for _ in range(m + 1)]
    for a, b in reqs:
        toy_requesters[b].append(a)
        if par[a] == 0 and last[b] != 0:
            par[a] = last[b]
        last[b] = a
    children = [[] for _ in range(n + 1)]
    for v in range(1, n + 1):
        if par[v] != 0:
            children[par[v]].append(v)
    # Euler tour iterative
    tin = [0] * (n + 1)
    tout = [0] * (n + 1)
    depth = [0] * (n + 1)
    time = 0
    for root in range(1, n + 1):
        if par[root] == 0:
            stack = [(root, 0)]
            while stack:
                v, state = stack.pop()
                if state == 0:
                    time += 1
                    tin[v] = time
                    stack.append((v, 1))
                    for u in reversed(children[v]):
                        depth[u] = depth[v] + 1
                        stack.append((u, 0))
                else:
                    tout[v] = time
    return par, children, tin, tout, depth, toy_requesters

def preprocess(n: int, m: int, reqs: List[Tuple[int,int]]):
    par, children, tin, tout, depth, toy_requesters = build_forest(n, m, reqs)
    toy_data = [None] * (m + 1)
    for y in range(1, m + 1):
        if not toy_requesters[y]:
            toy_data[y] = None
            continue
        vec = sorted(toy_requesters[y], key=lambda u: tin[u])
        tins = [tin[u] for u in vec]
        depths = [depth[u] for u in vec]
        seg = SegTree(depths)
        toy_data[y] = (tins, seg)
    return tin, tout, depth, toy_data

def solve_from_data(n: int, m: int, k: int, q: int, reqs: List[Tuple[int,int]], queries: List[Tuple[int,int]]) -> List[int]:
    tin, tout, depth, toy_data = preprocess(n, m, reqs)
    ans = []
    for x, y in queries:
        data = toy_data[y]
        if data is None:
            ans.append(0); continue
        tins, seg = data
        L = bisect.bisect_left(tins, tin[x])
        R = bisect.bisect_right(tins, tout[x]) - 1
        if L > R:
            ans.append(0); continue
        dstar = seg.range_max(L, R)
        if dstar == depth[x]:
            ans.append(0)
        else:
            ans.append(dstar - depth[x] + 1)
    return ans

def read_input() -> Tuple[int,int,int,int,List[Tuple[int,int]],List[Tuple[int,int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it)); q = int(next(it))
    reqs = []
    for _ in range(k):
        a = int(next(it)); b = int(next(it))
        reqs.append((a, b))
    queries = []
    for _ in range(q):
        x = int(next(it)); y = int(next(it))
        queries.append((x, y))
    return n, m, k, q, reqs, queries

def solve_all():
    n, m, k, q, reqs, queries = read_input()
    ans = solve_from_data(n, m, k, q, reqs, queries)
    out_lines = "\n".join(str(x) for x in ans)
    sys.stdout.write(out_lines)

def _tests():
    # Test 1: 3-cycle example
    n, m, k, q = 3, 3, 5, 2
    reqs = [(2,2),(3,3),(1,1),(1,2),(2,3)]
    queries = [(3,1),(1,1)]
    out = solve_from_data(n, m, k, q, reqs, queries)
    assert out == [3, 0]
    # Test 2: two-node cycle
    n2, m2, k2, q2 = 2, 1, 2, 1
    reqs2 = [(1,1),(2,1)]
    queries2 = [(1,1)]
    out2 = solve_from_data(n2, m2, k2, q2, reqs2, queries2)
    assert out2 == [2]
    # Test 3: no requester of toy: answer 0
    n3, m3, k3, q3 = 2, 2, 1, 1
    reqs3 = [(1,1)]
    queries3 = [(2,2)]
    out3 = solve_from_data(n3, m3, k3, q3, reqs3, queries3)
    assert out3 == [0]
_tests()

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts:
(1) the $3$-cycle scenario yields $[3,0]$,
(2) a $2$-cycle case yields $[2]$,
(3) a toy never requested yields $[0]$.}
\RESULT{For each query $(x,y)$, output the size of the unique cycle formed (if any) when $x$ requests $y$ at his next opportunity; $0$ if no cycle forms (including when $x$ already holds $y$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests focus on:
single-chain cycles of length $2$ and $3$,
self-holder case (no crying),
and toys with no prior requesters.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final on tiny crafted scenarios; they agree on all tested cases.}
\LINE{EDGE-CASE GENERATOR}{Generate random small forests by random request sequences without cycles and verify the final method against a slow baseline that scans requesters per query.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from typing import List, Tuple

def gen_chain_case(L: int) -> Tuple[int,int,List[Tuple[int,int]],List[Tuple[int,int]],List[int]]:
    # Build a chain 1->2->...->L, each i holds toy i, and each i< L waits on i+1 via toy i+1
    n = L; m = L
    reqs = []
    # First, everyone i requests toy i to hold
    for i in range(1, L+1):
        reqs.append((i, i))
    # Then for i from 1..L-1, request toy i+1 to create waits
    for i in range(1, L):
        reqs.append((i, i+1))
    # Query: root L requests toy 1 held by 1 -> cycle size L
    queries = [(L, 1)]
    expected = [L]
    return n, m, reqs, queries, expected

def slow_baseline(n: int, m: int, reqs: List[Tuple[int,int]], queries: List[Tuple[int,int]]) -> List[int]:
    return solve_baseline(n, m, reqs, queries)

def run_tests():
    # Chain cases
    for L in [2, 3, 5]:
        n, m, reqs, queries, expected = gen_chain_case(L)
        out_fast = answer_queries(n, m, reqs, queries)
        out_slow = slow_baseline(n, m, reqs, queries)
        assert out_fast == expected == out_slow

run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys, bisect
from typing import List, Tuple

class SegTree:
    __slots__ = ("n","seg")
    def __init__(self, arr: List[int]):
        n = len(arr)
        self.n = 1
        while self.n < n:
            self.n <<= 1
        self.seg = [0] * (2 * self.n)
        for i in range(n):
            self.seg[self.n + i] = arr[i]
        for i in range(self.n - 1, 0, -1):
            a = self.seg[2*i]; b = self.seg[2*i+1]
            self.seg[i] = a if a >= b else b
    def range_max(self, l: int, r: int) -> int:
        if l > r:
            return -10**9
        l += self.n; r += self.n
        res = -10**9
        while l <= r:
            if (l & 1) == 1:
                if self.seg[l] > res: res = self.seg[l]
                l += 1
            if (r & 1) == 0:
                if self.seg[r] > res: res = self.seg[r]
                r -= 1
            l >>= 1; r >>= 1
        return res

def build_forest(n: int, m: int, reqs: List[Tuple[int,int]]):
    last = [0] * (m + 1)
    par = [0] * (n + 1)
    toy_requesters = [[] for _ in range(m + 1)]
    for a, b in reqs:
        toy_requesters[b].append(a)
        if par[a] == 0 and last[b] != 0:
            par[a] = last[b]
        last[b] = a
    children = [[] for _ in range(n + 1)]
    for v in range(1, n + 1):
        if par[v] != 0:
            children[par[v]].append(v)
    tin = [0] * (n + 1)
    tout = [0] * (n + 1)
    depth = [0] * (n + 1)
    time = 0
    for root in range(1, n + 1):
        if par[root] == 0:
            stack = [(root, 0)]
            while stack:
                v, state = stack.pop()
                if state == 0:
                    time += 1
                    tin[v] = time
                    stack.append((v, 1))
                    for u in reversed(children[v]):
                        depth[u] = depth[v] + 1
                        stack.append((u, 0))
                else:
                    tout[v] = time
    return tin, tout, depth, toy_requesters

def solve_from_data(n: int, m: int, k: int, q: int, reqs: List[Tuple[int,int]], queries: List[Tuple[int,int]]) -> List[int]:
    tin, tout, depth, toy_requesters = build_forest(n, m, reqs)
    toy_data = [None] * (m + 1)
    for y in range(1, m + 1):
        if not toy_requesters[y]:
            toy_data[y] = None
            continue
        vec = sorted(toy_requesters[y], key=lambda u: tin[u])
        tins = [tin[u] for u in vec]
        depths = [depth[u] for u in vec]
        seg = SegTree(depths)
        toy_data[y] = (tins, seg)
    ans = []
    for x, y in queries:
        data = toy_data[y]
        if data is None:
            ans.append(0); continue
        tins, seg = data
        L = bisect.bisect_left(tins, tin[x])
        R = bisect.bisect_right(tins, tout[x]) - 1
        if L > R:
            ans.append(0); continue
        dstar = seg.range_max(L, R)
        if dstar == depth[x]:
            ans.append(0)
        else:
            ans.append(dstar - depth[x] + 1)
    return ans

def read_input() -> Tuple[int,int,int,int,List[Tuple[int,int]],List[Tuple[int,int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it)); q = int(next(it))
    reqs = [(int(next(it)), int(next(it))) for _ in range(k)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, m, k, q, reqs, queries

def main():
    # asserts
    n, m, k, q = 3, 3, 5, 2
    reqs = [(2,2),(3,3),(1,1),(1,2),(2,3)]
    queries = [(3,1),(1,1)]
    assert solve_from_data(n, m, k, q, reqs, queries) == [3, 0]
    n2, m2, k2, q2 = 2, 1, 2, 1
    reqs2 = [(1,1),(2,1)]
    queries2 = [(1,1)]
    assert solve_from_data(n2, m2, k2, q2, reqs2, queries2) == [2]
    # run
    n, m, k, q, reqs, queries = read_input()
    out = solve_from_data(n, m, k, q, reqs, queries)
    sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build a wait-forest from the first blocking request per child; answer each query by finding the deepest requester of toy $y$ inside the subtree of $x$ and computing the depth gap $+1$ (unless it equals $x$).}
\WHY{This problem tests dynamic reasoning about dependency forests, Euler tours for subtree queries, and per-key data structures (segment trees or sparse tables) under tight constraints.}
\CHECKLIST{
\begin{bullets}
\item One pass to compute $\mathrm{par}$ and collect $R_y$.
\item DFS for $\mathrm{tin}, \mathrm{tout}, \mathrm{depth}$ (iterative to avoid recursion limits).
\item For each toy: sort by $\mathrm{tin}$; build RMQ (segment tree).
\item Query: binary search to subarray, RMQ to get deepest depth, handle $d^\star = \mathrm{depth}[x]$ as $0$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Toy never requested $\Rightarrow 0$.
\item No requester in subtree $\Rightarrow 0$.
\item Holder is $x$ himself ($d^\star=\mathrm{depth}[x]$) $\Rightarrow 0$.
\item Disconnected forest roots: DFS must start at all $\mathrm{par}=0$.
\item Children never appearing in requests still must get Euler indices.
\item Large $k$ on a single toy: segment tree size and query bounds.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Overwriting $\mathrm{par}[u]$ after it was set by a blocking request (should not happen; guard with $\mathrm{par}[u]==0$).
\item Recursive DFS stack overflow ($n$ up to $10^5$) — use iterative DFS.
\item Off-by-one in Euler ranges: use $[\mathrm{tin}[x], \mathrm{tout}[x]]$ and careful upper\_bound.
\item RMQ on empty interval if $L > R$.
\item Ties in depth: checking $d^\star==\mathrm{depth}[x]$ is sufficient to detect self-holder.
\item Memory blow-up with per-toy sparse tables; prefer segment trees summing to $O(k)$.
\end{bullets}
}
\FAILMODES{Baseline $O(|R_y|)$ per query times $q$ is too slow if many requests hit the same toy; the improved method survives by $O(\log |R_y|)$ per query with $O(k)$ memory.}
\ELI{Think of arrows from a child to the child he is waiting on. This forms trees. For each toy, list who asked for it; it is a path in the tree. When $x$ asks for $y$, the current holder is the deepest node on that path still under $x$. If that node is $x$ himself, no one cries; otherwise the children along the path to $x$ form the crying cycle.}
\NotePages{3}

\end{document}