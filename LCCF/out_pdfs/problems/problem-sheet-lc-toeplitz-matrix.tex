% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Toeplitz Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/toeplitz-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given an $m \times n$ \texttt{matrix}, return \emph{true} if the matrix is Toeplitz. Otherwise, return \emph{false}. A matrix is \textbf{Toeplitz} if every diagonal from top-left to bottom-right has the same elements.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]}

\quad \textbf{Output:} \texttt{true}

\quad \textbf{Explanation:} In the above grid, the diagonals are: \texttt{"[9]"}, \texttt{"[5, 5]"}, \texttt{"[1, 1, 1]"}, \texttt{"[2, 2, 2]"}, \texttt{"[3, 3]"}, \texttt{"[4]"}. In each diagonal all elements are the same, so the answer is \texttt{True}.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{matrix = [[1,2],[2,2]]}

\quad \textbf{Output:} \texttt{false}

\quad \textbf{Explanation:} The diagonal \texttt{"[1, 2]"} has different elements.

\textbf{Constraints:}
\begin{bullets}
\item \texttt{m == matrix.length}
\item \texttt{n == matrix[i].length}
\item \texttt{1 <= m, n <= 20}
\item \texttt{0 <= matrix[i][j] <= 99}
\end{bullets}

\textbf{Follow up:}
\begin{bullets}
\item What if the \texttt{matrix} is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
\item What if the \texttt{matrix} is so large that you can only load up a partial row into the memory at once?
\end{bullets}
}
\BREAKDOWN{Check equality along all top-left to bottom-right diagonals. Minimal condition: for every $i>0$ and $j>0$, verify $A_{i,j} = A_{i-1,j-1}$. For streaming follow-up, compare each new row with the previous row shifted by one.}
\ELI{Every cell must match the one up-left from it; if all such matches hold, the matrix is Toeplitz.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer matrix $A$ with $m$ rows and $n$ columns, where $1 \le m,n \le 20$ and $0 \le A[i][j] \le 99$.}
\OUTPUTS{A boolean: \texttt{True} if $A$ is Toeplitz, else \texttt{False}. LeetCode method signature: \texttt{def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool}.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[[1,2,3,4],[5,1,2,3],[9,5,1,2]]} $\to$ Output: \texttt{True}.
\item Input: \texttt{[[1,2],[2,2]]} $\to$ Output: \texttt{False}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \mathbb{Z}^{m \times n}$. Define the predicate Toeplitz$(A)$ to hold iff all entries on each diagonal parallel to the main diagonal are equal.}
\varmapStart
\var{A}{input matrix in $\mathbb{Z}^{m \times n}$}
\var{m,n}{matrix dimensions; $1 \le m,n \le 20$}
\var{i,j}{row and column indices with zero-based indexing}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Toeplitz}(A) \iff \forall~i,j~\text{with}~1 \le i \le m-1,~1 \le j \le n-1:\; A[i,j] = A[i-1,j-1].
\end{BreakableEquation*}
}
\ASSUMPTIONS{Zero-based indices; rectangular matrix; entries are integers but only equality matters.}
\INVARIANTS{
\begin{bullets}
\item If a single violation $A[i,j] \ne A[i-1,j-1]$ exists, the matrix is not Toeplitz.
\item Equality check is local: no need to traverse diagonals explicitly beyond neighbor comparisons.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Verify constant-value property along each diagonal starting from the first row and first column.}
\ASSUMPTIONS{Traverse all $m+n-1$ diagonals; stop early on first mismatch.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each start cell $(r,0)$ with $0 \le r < m$, walk down-right while in-bounds and check equality to the first element of that diagonal.
\item For each start cell $(0,c)$ with $1 \le c < n$, similarly walk down-right and check equality to the first element of that diagonal.
\item If any mismatch is found, return \texttt{False}; else return \texttt{True}.
\end{algosteps}
\COMPLEXITY{Each cell is visited $O(1)$ times across all diagonals. Time $T(m,n)=\Theta(mn)$; space $S(m,n)=\Theta(1)$.}
\[
\begin{aligned}
T(m,n) &= \sum_{\text{diagonals}} \text{length} = mn, \\
S(m,n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Every element belongs to exactly one top-left to bottom-right diagonal. Checking every diagonal for uniformity is equivalent to the Toeplitz predicate.}
\EDGECASES{Single row or column is always Toeplitz. Mixed values allowed as long as each diagonal is constant.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m, n = len(matrix), len(matrix[0])
        # Check diagonals starting from first column
        for r in range(m):
            val = matrix[r][0]
            i, j = r + 1, 1
            while i < m and j < n:
                if matrix[i][j] != val:
                    return False
                i += 1
                j += 1
        # Check diagonals starting from first row (skip [0,0] which already covered)
        for c in range(1, n):
            val = matrix[0][c]
            i, j = 1, c + 1
            while i < m and j < n:
                if matrix[i][j] != val:
                    return False
                i += 1
                j += 1
        return True

# Tests (LeetCode-style quick checks)
assert Solution().isToeplitzMatrix([[1,2,3,4],[5,1,2,3],[9,5,1,2]]) is True
assert Solution().isToeplitzMatrix([[1,2],[2,2]]) is False
assert Solution().isToeplitzMatrix([[7]]) is True
assert Solution().isToeplitzMatrix([[1,2,3]]) is True
assert Solution().isToeplitzMatrix([[1],[1],[1]]) is True
\end{minted}
\VALIDATION{Covers examples, single-cell, single-row, single-column cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single-Pass Neighbor Check}
\WHICHFORMULA{Use the local condition $A[i,j]=A[i-1,j-1]$ for $i>0,j>0$, scanning once.}
\ASSUMPTIONS{Sequential row-major pass; early exit on first mismatch.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i$ from $1$ to $m-1$ and $j$ from $1$ to $n-1$, compare $A[i][j]$ to $A[i-1][j-1]$.
\item If any comparison fails, return \texttt{False}.
\item If the loop completes, return \texttt{True}.
\end{algosteps}
\COMPLEXITY{Still $\Theta(mn)$ time, but minimal overhead; $\Theta(1)$ space.}
\[
\begin{aligned}
T(m,n) &= (m-1)(n-1) = \Theta(mn).
\end{aligned}
\]
\CORRECTNESS{The definition of Toeplitz is exactly the neighbor-equality condition for all valid indices.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m, n = len(matrix), len(matrix[0])
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] != matrix[i-1][j-1]:
                    return False
        return True

# Tests
assert Solution().isToeplitzMatrix([[1,2,3,4],[5,1,2,3],[9,5,1,2]]) is True
assert Solution().isToeplitzMatrix([[1,2],[2,2]]) is False
assert Solution().isToeplitzMatrix([[3,4,5],[2,3,4],[1,2,3]]) is True
\end{minted}
\VALIDATION{Checks example, a negative case, and a constructed positive Toeplitz matrix.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Streaming-Friendly Check}
\WHICHFORMULA{Row-by-row streaming: for each new row $r$, compare $r[1:]$ with previous row's prefix $prev[:n-1]$.}
\ASSUMPTIONS{Only the previous row must be retained. With partial-row loading, retain the last seen element of the previous row's prefix to compare chunk-wise.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain \texttt{prev} as the previous row. Initialize \texttt{prev} to the first row.
\item For each subsequent row \texttt{cur}, check \texttt{cur[j]} equals \texttt{prev[j-1]} for all $j \in [1,n-1]$.
\item Update \texttt{prev = cur} and continue; return \texttt{False} on first mismatch, else \texttt{True} at end.
\end{algosteps}
\OPTIMALITY{Asymptotically optimal $\Theta(mn)$ time with $\Theta(n)$ memory; with a disk-backed or chunked row source, the memory can be reduced to $O(1)$ beyond the chunk by streaming and comparing overlapping indices.}
\COMPLEXITY{Time $\Theta(mn)$; memory $O(n)$ for previous row or $O(1)$ extra for chunked comparison buffers.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m, n = len(matrix), len(matrix[0])
        prev = matrix[0]
        for i in range(1, m):
            cur = matrix[i]
            for j in range(1, n):
                if cur[j] != prev[j-1]:
                    return False
            prev = cur
        return True

# Streaming variant illustration (not required by LC runner):
def is_toeplitz_stream(rows: List[List[int]]) -> bool:
    # rows may be produced by a generator that yields one row at a time
    it = iter(rows)
    try:
        prev = next(it)
    except StopIteration:
        return True
    n = len(prev)
    for cur in it:
        assert len(cur) == n
        for j in range(1, n):
            if cur[j] != prev[j-1]:
                return False
        prev = cur
    return True

# Tests
assert Solution().isToeplitzMatrix([[1,2,3],[4,1,2],[7,4,1]]) is True
assert Solution().isToeplitzMatrix([[1,2],[2,2]]) is False
assert is_toeplitz_stream([[1,2,3],[4,1,2],[7,4,1]]) is True
\end{minted}
\VALIDATION{Exactly three asserts: two for the class method (one True, one False) and one for the streaming helper.}
\RESULT{Return \texttt{True} iff every top-left to bottom-right diagonal is constant. No tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover positives, negatives, boundaries (single row/column), and random Toeplitz/non-Toeplitz matrices. Property: shifting a Toeplitz matrix by one row and one column preserves diagonal equality pattern.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on small random cases to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Create matrices with $m=1$ or $n=1$, and inject single-point violations $A[i][j] \leftarrow A[i][j]+1$ at random interior positions.}
\begin{minted}{python}
from typing import List
import random

def gen_toeplitz(m: int, n: int, lo: int = 0, hi: int = 9) -> List[List[int]]:
    # Construct by choosing first row and first column, then fill by diagonals
    first_row = [random.randint(lo, hi) for _ in range(n)]
    first_col = [random.randint(lo, hi) for _ in range(m)]
    mat = [[0]*n for _ in range(m)]
    for j in range(n):
        mat[0][j] = first_row[j]
    for i in range(m):
        mat[i][0] = first_col[i]
    mat[0][0] = first_row[0]  # consistent intersection
    for i in range(1, m):
        for j in range(1, n):
            mat[i][j] = mat[i-1][j-1]
    return mat

def break_one(mat: List[List[int]]) -> List[List[int]]:
    m, n = len(mat), len(mat[0])
    i = random.randrange(1, m) if m > 1 else 0
    j = random.randrange(1, n) if n > 1 else 0
    mat2 = [row[:] for row in mat]
    mat2[i][j] ^= 1  # flip parity to create a mismatch safely within [0,99]
    return mat2

# Cross-check A vs B vs C implementations
class A:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m, n = len(matrix), len(matrix[0])
        for r in range(m):
            val = matrix[r][0]
            i, j = r + 1, 1
            while i < m and j < n:
                if matrix[i][j] != val:
                    return False
                i += 1
                j += 1
        for c in range(1, n):
            val = matrix[0][c]
            i, j = 1, c + 1
            while i < m and j < n:
                if matrix[i][j] != val:
                    return False
                i += 1
                j += 1
        return True

class B:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m, n = len(matrix), len(matrix[0])
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] != matrix[i-1][j-1]:
                    return False
        return True

class C:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        prev = matrix[0]
        for i in range(1, len(matrix)):
            cur = matrix[i]
            for j in range(1, len(cur)):
                if cur[j] != prev[j-1]:
                    return False
            prev = cur
        return True

def self_test():
    random.seed(0)
    for m in range(1, 6):
        for n in range(1, 6):
            for _ in range(50):
                T = gen_toeplitz(m, n)
                F = break_one([row[:] for row in T]) if m > 1 and n > 1 else T
                a, b, c = A(), B(), C()
                assert a.isToeplitzMatrix(T) == b.isToeplitzMatrix(T) == c.isToeplitzMatrix(T) == True
                if m > 1 and n > 1:
                    assert a.isToeplitzMatrix(F) == b.isToeplitzMatrix(F) == c.isToeplitzMatrix(F) == False
    print("All cross-checks passed.")

self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        # Single-pass neighbor check; O(mn) time, O(1) extra space.
        m, n = len(matrix), len(matrix[0])
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] != matrix[i-1][j-1]:
                    return False
        return True

# Basic asserts (deterministic)
assert Solution().isToeplitzMatrix([[1,2,3,4],[5,1,2,3],[9,5,1,2]]) is True
assert Solution().isToeplitzMatrix([[1,2],[2,2]]) is False
assert Solution().isToeplitzMatrix([[5]]) is True
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Toeplitz means every element equals its up-left neighbor when both exist.}
\WHY{Common array invariant check; tests local reasoning and ability to adapt to streaming constraints.}
\CHECKLIST{
\begin{bullets}
\item Confirm bounds: only compare when $i>0$ and $j>0$.
\item Early exit on mismatch.
\item Handle $m=1$ or $n=1$ quickly.
\item For streaming: compare current row slice $[1:]$ vs previous $[:-1]$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $1 \times 1$ matrix.
\item Single row or single column.
\item Diagonal mismatch at the last cell.
\item Non-square matrices (wide or tall).
\item Repeated constant matrix.
\item Large values at edges within allowed range.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Accessing $A[i-1][j-1]$ when $i=0$ or $j=0$.
\item Mixing up directions (using right or down neighbor instead of up-left).
\item Not updating the previous row in streaming variant.
\item Assuming square matrices only.
\item Off-by-one in diagonal start loops (baseline).
\item Forgetting early return on first mismatch.
\end{bullets}
}
\FAILMODES{Diagonal-by-diagonal scans with wrong start ranges may skip diagonals; neighbor-only check avoids this if indices are guarded. Streaming errors arise if chunk boundaries do not compare overlapping elements.}
\ELI{Just check each number against the one up-left of it. If all such pairs match, every diagonal is constant, so the matrix is Toeplitz. With streaming, keep only the last row and compare shifted slices.}
\NotePages{3}

\end{document}