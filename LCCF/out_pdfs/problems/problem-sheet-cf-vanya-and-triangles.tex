% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Vanya and Triangles}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/552/D}}
\LINE{DIFFICULTY / RATING}{CF: 552/D \quad Rating: 1900}
\STATEMENT{Vanya got bored and he painted $n$ distinct points on the plane. After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points. He asks you to count the number of the formed triangles with the non-zero area.

Input: The first line contains integer $n$ ($1 \le n \le 2000$) --- the number of the points painted on the plane.

Next $n$ lines contain two integers each $x_i, y_i$ ($-100 \le x_i, y_i \le 100$) --- the coordinates of the $i$-th point. It is guaranteed that no two given points coincide.

Output: In the first line print an integer --- the number of triangles with the non-zero area among the painted points.

Note: Note to the first sample test. There are $3$ triangles formed: $(0, 0)$ --- $(1, 1)$ --- $(2, 0)$; $(0, 0)$ --- $(2, 2)$ --- $(2, 0)$; $(1, 1)$ --- $(2, 2)$ --- $(2, 0)$.

Note to the second sample test. There is $1$ triangle formed: $(0, 0)$ --- $(1, 1)$ --- $(2, 0)$.

Note to the third sample test. A single point does not form a single triangle.}
\BREAKDOWN{Compute the total number of triples of points and subtract those that are collinear (area zero). Efficiently count collinear triples by grouping points with identical reduced direction vectors from a pivot.}
\ELI{All triangles are triples of points; remove the triples that lie on a straight line.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test.\\
- $n$ (integer): number of points, $1 \le n \le 2000$.\\
- $n$ lines of integers $x_i, y_i$ with $-100 \le x_i, y_i \le 100$, and all points distinct.}
\OUTPUTS{One integer: the number of triples of points that form a triangle with non-zero area.}
\SAMPLES{Example 1:\\
Input:
\begin{minipage}[t]{0.48\textwidth}
\begin{lstlisting}[style=crisp]
4
0 0
1 1
2 0
2 2
\end{lstlisting}
\end{minipage}
Output:
\begin{minipage}[t]{0.48\textwidth}
\begin{lstlisting}[style=crisp]
3
\end{lstlisting}
\end{minipage}

Example 2:\\
Input:
\begin{minipage}[t]{0.48\textwidth}
\begin{lstlisting}[style=crisp]
3
0 0
1 1
2 2
\end{lstlisting}
\end{minipage}
Output:
\begin{minipage}[t]{0.48\textwidth}
\begin{lstlisting}[style=crisp]
0
\end{lstlisting}
\end{minipage}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite set $P=\{p_1,\ldots,p_n\}\subset\mathbb{Z}^2$, count triples $\{i,j,k\}$ with $i<j<k$ such that $p_i,p_j,p_k$ are not collinear.}
\varmapStart
\var{n}{number of points}
\var{p_i=(x_i,y_i)}{coordinates of point $i$}
\var{\binom{n}{3}}{total number of unordered triples}
\var{Z}{number of collinear unordered triples}
\var{A}{answer, number of non-degenerate triangles}
\varmapEnd
\GOVERN{
\[
A \;=\; \binom{n}{3} - Z,\qquad
Z \;=\; \frac{1}{3}\sum_{i=1}^{n}\;\sum_{\ell}\binom{c_{i,\ell}}{2},
\]
where for pivot $i$, the inner sum is over distinct lines $\ell$ through $p_i$ and $c_{i,\ell}$ is the number of other points lying on $\ell$ with $p_i$.
}
\ASSUMPTIONS{No two points coincide; coordinates fit in 32-bit signed integers; arithmetic uses exact integers.}
\INVARIANTS{For each pivot $i$, points sharing the same reduced direction vector from $p_i$ lie on the same line through $p_i$. Each collinear triple is counted exactly three times across the $n$ pivots.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Check each triple $(i,j,k)$ and test if the signed area (cross product) is zero. Count non-zero area triples.}
\ASSUMPTIONS{Works for small $n$; cubic time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all triples $i<j<k$.
\item Compute $(x_j-x_i)(y_k-y_i)-(y_j-y_i)(x_k-x_i)$.
\item If non-zero, increment the answer.
\end{algosteps}
\COMPLEXITY{Triple loop over $n$ points.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(\binom{n}{3}\big) = \Theta(n^3), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{A triangle has non-zero area iff the three points are not collinear; the cross product test is exact over integers. The loop covers all unordered triples.}
\EDGECASES{$n<3$ yields $0$. All collinear set yields $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    n = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return pts

def area2(a: Tuple[int, int], b: Tuple[int, int], c: Tuple[int, int]) -> int:
    (x1, y1), (x2, y2), (x3, y3) = a, b, c
    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)

def solve_case_bruteforce(points: List[Tuple[int, int]]) -> int:
    n = len(points)
    if n < 3:
        return 0
    ans = 0
    for i in range(n):
        xi, yi = points[i]
        for j in range(i + 1, n):
            xj, yj = points[j]
            for k in range(j + 1, n):
                if area2(points[i], points[j], points[k]) != 0:
                    ans += 1
    return ans

def solve_all() -> None:
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        assert solve_case_bruteforce([]) == 0
        assert solve_case_bruteforce([(0,0)]) == 0
        assert solve_case_bruteforce([(0,0),(1,1)]) == 0
        assert solve_case_bruteforce([(0,0),(1,1),(2,2)]) == 0
        assert solve_case_bruteforce([(0,0),(1,1),(2,0)]) == 1
        assert solve_case_bruteforce([(0,0),(1,1),(2,0),(2,2)]) == 3
        print("OK")
        return
    pts = read_input(data)
    print(solve_case_bruteforce(pts))

def main():
    if __name__ == "__main__":
        solve_all()

main()
# Minimal isolated asserts (do not execute on judge input)
assert area2((0,0),(1,0),(0,1)) == 1
assert area2((0,0),(1,1),(2,2)) == 0
\end{minted}
\VALIDATION{Checked degenerate cases ($n<3$), all-collinear triple, simple non-collinear triangle, and a 4-point set with one collinear triple.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Counting Collinear Triples via Direction Grouping}
\WHICHFORMULA{Use $A=\binom{n}{3}-Z$ and compute $Z$ by pivoting at each point and grouping other points by reduced direction vectors.}
\ASSUMPTIONS{Normalize $(\Delta x,\Delta y)$ by $\gcd$ and a sign convention: ensure $(dx,dy)$ has $dx>0$ or $dx=0$ and $dy>0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pivot $i$, build a map from reduced direction $(dx,dy)$ to count $c$.
\item Add $\binom{c}{2}$ to a running sum $S$ over all groups for this pivot.
\item After all pivots, $Z=S/3$. Answer is $\binom{n}{3}-Z$.
\end{algosteps}
\COMPLEXITY{For each pivot, process $n-1$ vectors, each with $\gcd$ and a dict insertion.}
\[
\begin{aligned}
T(n) &= \Theta(n^2 \log C) \quad \text{(the $\log C$ is for $\gcd$ on small ints; here constant)},\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Points sharing the same reduced direction vector from $i$ lie on the same line through $p_i$, so pairs within a bucket are exactly the pairs that with $i$ make collinear triples. Each triple is counted once per pivot, hence $/3$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import gcd
from typing import List, Tuple, Dict

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    n = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return pts

def normalize(dx: int, dy: int) -> Tuple[int, int]:
    if dx == 0 and dy == 0:
        return (0, 0)
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    # Fix sign: make dx > 0, or dx == 0 and dy > 0
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def count_collinear_triples(points: List[Tuple[int, int]]) -> int:
    n = len(points)
    if n < 3:
        return 0
    S = 0
    for i in range(n):
        xi, yi = points[i]
        buckets: Dict[Tuple[int, int], int] = {}
        for j in range(n):
            if i == j:
                continue
            xj, yj = points[j]
            dx, dy = xj - xi, yj - yi
            key = normalize(dx, dy)
            buckets[key] = buckets.get(key, 0) + 1
        for c in buckets.values():
            if c >= 2:
                S += c * (c - 1) // 2
    return S // 3

def solve_case(points: List[Tuple[int, int]]) -> int:
    n = len(points)
    if n < 3:
        return 0
    total = n * (n - 1) * (n - 2) // 6
    Z = count_collinear_triples(points)
    return total - Z

def solve_all() -> None:
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        pts = [(0,0),(1,1),(2,0),(2,2)]
        assert solve_case(pts) == 3
        assert solve_case([(0,0),(1,1),(2,2)]) == 0
        assert solve_case([(0,0),(1,1),(2,0)]) == 1
        assert solve_case([]) == 0 and solve_case([(0,0)]) == 0 and solve_case([(0,0),(1,1)]) == 0
        # random-ish small
        grid = [(0,0),(1,0),(0,1),(1,1)]
        # total 4C3=4; no three collinear in 2x2 grid => 4
        assert solve_case(grid) == 4
        print("OK")
        return
    pts = read_input(data)
    print(solve_case(pts))

def main():
    if __name__ == "__main__":
        solve_all()

main()
# Local invariants
assert normalize(2, 2) == (1, 1)
assert normalize(-2, -2) == (1, 1)
assert normalize(0, -5) == (0, 1)
\end{minted}
\VALIDATION{Covered small empty/degenerate inputs, collinear-only set, simple triangle, and a 2x2 grid (no three collinear).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Slope Bucketing per Pivot with Integer Normalization}
\WHICHFORMULA{Same as Approach B, implemented carefully with integer-only normalization and single pass per pivot.}
\ASSUMPTIONS{Coordinate bounds are small, so 64-bit intermediates suffice; Python integers are arbitrary precision.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute total $\binom{n}{3}$.
\item For each pivot, map reduced directions to counts; add $\binom{c}{2}$ to $S$.
\item Answer is $\binom{n}{3} - S/3$.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect at least $\Theta(n^2)$ point pairs to detect collinearity structure; this achieves $O(n^2)$ up to normalization costs, which is tight.}
\COMPLEXITY{Two nested loops over points plus hash map ops; $\Theta(n^2)$.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n) = \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import gcd
from typing import List, Tuple, Dict

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    n = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return pts

def normalize(dx: int, dy: int) -> Tuple[int, int]:
    if dx == 0 and dy == 0:
        return (0, 0)
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def count_triangles(points: List[Tuple[int, int]]) -> int:
    n = len(points)
    if n < 3:
        return 0
    total = n * (n - 1) * (n - 2) // 6
    S = 0
    for i in range(n):
        xi, yi = points[i]
        buckets: Dict[Tuple[int, int], int] = {}
        for j in range(n):
            if i == j:
                continue
            dx = points[j][0] - xi
            dy = points[j][1] - yi
            key = normalize(dx, dy)
            buckets[key] = buckets.get(key, 0) + 1
        for c in buckets.values():
            if c >= 2:
                S += c * (c - 1) // 2
    degenerates = S // 3
    return total - degenerates

def solve_all() -> None:
    data = sys.stdin.read()
    if not data.strip():
        # Unit tests (run only when no input is provided)
        assert count_triangles([]) == 0
        assert count_triangles([(0,0)]) == 0
        assert count_triangles([(0,0),(1,1)]) == 0
        assert count_triangles([(0,0),(1,1),(2,2)]) == 0
        assert count_triangles([(0,0),(1,1),(2,0)]) == 1
        assert count_triangles([(0,0),(1,1),(2,0),(2,2)]) == 3
        print("OK")
        return
    pts = read_input(data)
    print(count_triangles(pts))

def main():
    if __name__ == "__main__":
        solve_all()

main()
# Additional deterministic asserts
assert normalize(3, -6) == (1, -2)
assert normalize(-3, 6) == (1, -2)
assert normalize(0, -7) == (0, 1)
\end{minted}
\VALIDATION{Exactly three asserts on core helpers and end-to-end counts ensure correctness on edge and representative cases.}
\RESULT{Print a single integer: the number of non-degenerate triangles determined by the input points.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Combine property-style checks (symmetry under translation/scaling), degenerate lines, grids without 3-collinear points, and random small sets cross-checked against the brute force.}
\LINE{CROSS-CHECKS}{For $n\le 12$, compare the improved/optimal solution with the brute-force baseline on many random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate: $n<3$; all points on one line; two lines crossing; small grids; duplicate slopes through a pivot.}
\begin{minted}{python}
import random
from typing import List, Tuple

def gen_line(n: int, a: int, b: int) -> List[Tuple[int,int]]:
    return [(t, a*t + b) for t in range(n)]

def gen_grid(w: int, h: int) -> List[Tuple[int,int]]:
    return [(x, y) for x in range(w) for y in range(h)]

def translate(points: List[Tuple[int,int]], dx: int, dy: int) -> List[Tuple[int,int]]:
    return [(x+dx, y+dy) for (x,y) in points]

def scale(points: List[Tuple[int,int]], k: int) -> List[Tuple[int,int]]:
    return [(x*k, y*k) for (x,y) in points]

# Deterministic seeds for reproducibility
random.seed(0)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from math import gcd
from typing import List, Tuple, Dict

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    n = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(n)]
    return pts

def normalize(dx: int, dy: int) -> Tuple[int, int]:
    if dx == 0 and dy == 0:
        return (0, 0)
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def count_triangles(points: List[Tuple[int, int]]) -> int:
    n = len(points)
    if n < 3:
        return 0
    total = n * (n - 1) * (n - 2) // 6
    S = 0
    for i in range(n):
        xi, yi = points[i]
        buckets: Dict[Tuple[int, int], int] = {}
        for j in range(n):
            if i == j:
                continue
            dx = points[j][0] - xi
            dy = points[j][1] - yi
            key = normalize(dx, dy)
            buckets[key] = buckets.get(key, 0) + 1
        for c in buckets.values():
            if c >= 2:
                S += c * (c - 1) // 2
    degenerates = S // 3
    return total - degenerates

def solve_all() -> None:
    data = sys.stdin.read()
    if not data.strip():
        # Run asserts only when no input is given
        assert count_triangles([]) == 0
        assert count_triangles([(0,0)]) == 0
        assert count_triangles([(0,0),(1,1)]) == 0
        assert count_triangles([(0,0),(1,1),(2,2)]) == 0
        assert count_triangles([(0,0),(1,1),(2,0)]) == 1
        assert count_triangles([(0,0),(1,1),(2,0),(2,2)]) == 3
        print("OK")
        return
    pts = read_input(data)
    print(count_triangles(pts))

def main():
    if __name__ == "__main__":
        solve_all()

main()
# Helper asserts (deterministic)
assert normalize(2, 4) == (1, 2)
assert normalize(-2, -4) == (1, 2)
assert normalize(0, -3) == (0, 1)
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count all triples and subtract collinear triples via slope bucketing per pivot.}
\WHY{Common motif: count structures by inclusion-exclusion or complement, and exploit hashing of normalized geometric directions.}
\CHECKLIST{%
- Compute $n$ and read all points.\\
- If $n<3$, print $0$.\\
- Precompute $\binom{n}{3}$.\\
- For each pivot, hash reduced directions, sum $\binom{c}{2}$.\\
- Divide the sum by $3$ and subtract from total.\\
- Print the answer as an integer.
}
\EDGECASES{%
- $n=1,2 \Rightarrow 0$.\\
- All points collinear $\Rightarrow 0$.\\
- Many duplicates on same line through a pivot.\\
- Vertical lines ($dx=0$).\\
- Horizontal lines ($dy=0$).\\
- Opposite directions must unify (e.g., $(1,1)$ and $(-1,-1)$).\\
- Small coordinate ranges but large $n$.\\
- Integer overflow in other languages (use 64-bit).
}
\PITFALLS{%
- Forgetting to normalize sign leads to splitting a line into two buckets.\\
- Dividing by $3$ at the wrong time (must sum all pivots first).\\
- Using floats for slopes (precision bugs); use integer reduced pairs.\\
- Not handling $dx=0$ in normalization.\\
- Off-by-one in combinations.\\
- Reusing a mutable map across pivots without clearing.\\
- Reading input partially (must read all $2n$ integers).\\
- Negative zeros from normalization if using floats (avoid floats).
}
\FAILMODES{Brute force $O(n^3)$ times out for $n=2000$. The optimal $O(n^2)$ method remains fast due to small constant factors and integer math.}
\ELI{We list all triples, but instead of checking each one, we find lines: for each point, group other points that lie in the same direction, count pairs in each group, and adjust for triple counting. Subtract these degenerate triples from the total number of triples.}
\NotePages{3}

\end{document}