% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Narrower Passageway}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2045/E}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{You are a strategist of The ICPC Kingdom. You received an intel that there will be monster attacks on a narrow passageway near the kingdom. The narrow passageway can be represented as a grid with $2$ rows (numbered from $1$ to $2$) and $N$ columns (numbered from $1$ to $N$). Denote $(r, c)$ as the cell in row $r$ and column $c$. A soldier with a power of $P_{r, c}$ is assigned to protect $(r, c)$ every single day.

It is known that the passageway is very foggy. Within a day, each column in the passageway has a $50\%$ chance of being covered in fog. If a column is covered in fog, the two soldiers assigned to that column are not deployed that day. Otherwise, the assigned soldiers will be deployed.

Define a connected area $[u, v]$ ($u \le v$) as a maximal set of consecutive columns from $u$ to $v$ (inclusive) such that each column in the set is not covered in fog. The following illustration is an example of connected areas. The grayed cells are cells covered in fog. There are $4$ connected areas: $[1, 2]$, $[4, 6]$, $[9, 9]$, and $[11, 11]$.

The strength of a connected area $[u, v]$ can be calculated as follows. Let $m_1$ and $m_2$ be the maximum power of the soldiers in the first and second rows of the connected area, respectively. Formally, $m_r = \max (P_{r, u}, P_{r, u + 1}, \dots, P_{r, v})$ for $r \in \{ 1, 2\}$. If $m_1 = m_2$, then the strength is $0$. Otherwise, the strength is $\min (m_1, m_2)$.

The total strength of the deployment is the sum of the strengths for all connected areas. Determine the expected total strength of the deployment on any single day.

Input:\\
The first line consists of an integer $N$ ($1 \le N \le 100{,}000$).

Each of the next two lines consists of $N$ integers $P_{r, c}$ ($1 \le P_{r, c} \le 200{,}000$).

Output:\\
Let $M = 998{,}244{,}353$. It can be shown that the expected total strength can be expressed as an irreducible fraction $\tfrac{x}{y}$ such that $x$ and $y$ are integers and $y \not\equiv 0 \pmod{M}$. Output an integer $k$ in a single line such that $0 \le k < M$ and $k \cdot y \equiv x \pmod{M}$.

Note:\\
Explanation for the sample input/output \#1

There are $8$ possible scenarios for the passageway.

Each scenario is equally likely to happen. Therefore, the expected total strength is $(0 + 5 + 10 + 5 + 5 + 0 + 5 + 0) / 8 = \tfrac{15}{4}$. Since $249{,}561{,}092 \cdot 4 \equiv 15 \pmod{998{,}244{,}353}$, the output of this sample is $249{,}561{,}092$.

Explanation for the sample input/output \#2

The expected total strength is $\tfrac{67}{16}$.}
\BREAKDOWN{Linearity of expectation lets us sum contributions from all possible uncovered blocks $[u,v]$ with probability weight depending only on $u$, $v$. We reduce the expectation to weighted counts of intervals satisfying value-threshold predicates over the two rows. These weighted counts over unions of runs can be maintained by a disjoint-set structure using a closed-form for the sum of weights of all subintervals inside any fixed segment.}
\ELI{Turn the fog randomness into interval weights; then count how many intervals (by weight) contain certain values in both rows.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.\\
- $N$ (int), $1 \le N \le 100{,}000$.\\
- Two arrays $P_{1,\cdot}$ and $P_{2,\cdot}$ of length $N$ with $1 \le P_{r,c} \le 200{,}000$.}
\OUTPUTS{A single integer $k$ modulo $998{,}244{,}353$ representing the expected total strength mapped via modular inverse of the denominator.}
\SAMPLES{Example style (illustrative):\\
- $N=1$, $P_1=[5]$, $P_2=[5]$ $\Rightarrow$ expected $0$ (always equal maxima).\\
- $N=1$, $P_1=[2]$, $P_2=[7]$ $\Rightarrow$ with probability $1/2$ the single column appears and contributes $\min(2,7)=2$, else $0$; expected $1$. Output $1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Columns independently appear with probability $1/2$. A connected area (run of consecutive present columns) $[u,v]$ occurs with probability $2^{-(v-u+1)} \cdot \alpha_u \alpha_v$ where $\alpha_u=1$ if $u=1$ else $\tfrac{1}{2}$, and $\alpha_v=1$ if $v=N$ else $\tfrac{1}{2}$. The strength of $[u,v]$ is $g(m_1,m_2)$ with $g(a,b)=0$ if $a=b$ else $\min(a,b)$. We seek $\mathbb{E}\big[\sum_{[u,v]} g(m_1,m_2)\big]$.}
\varmapStart
\var{N}{number of columns}
\var{P_{1,c},P_{2,c}}{values at column $c$ in rows 1 and 2}
\var{\alpha_i}{boundary factor: $1$ if $i \in \{1,N\}$ else $\tfrac{1}{2}$}
\var{w(u,v)}{probability weight of interval $[u,v]$: $2^{-(v-u+1)}\alpha_u\alpha_v$}
\var{m_r([u,v])}{row-$r$ maximum on $[u,v]$}
\var{g(a,b)}{interval strength: $0$ if $a=b$ else $\min(a,b)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\mathbb{E} = \sum_{1\le u\le v\le N} w(u,v)\, g\big(m_1([u,v]),m_2([u,v])\big).
\end{BreakableEquation*}
Using $g(a,b)=\sum_{x\ge 1}\mathbf{1}\{\min(a,b)\ge x\}-\sum_{x\ge 1}\mathbf{1}\{a=b\ge x\}$,
\begin{BreakableEquation*}
\mathbb{E}=\sum_{x\ge 1}\Big(\!\!\sum_{u\le v} w(u,v)\,\mathbf{1}\{m_1\!\ge x,\,m_2\!\ge x\}\!\Big)-\sum_{y\ge 1} y\cdot \Big(\!\!\sum_{u\le v} w(u,v)\,\mathbf{1}\{m_1=m_2=y\}\!\Big).
\end{BreakableEquation*}
\]
}
\ASSUMPTIONS{Values are integers in $[1,200{,}000]$. Columns are independent Bernoulli-$\tfrac{1}{2}$; linearity of expectation applies.}
\INVARIANTS{Weights $w(u,v)$ depend only on $u$, $v$ and not on values; counts are additive over disjoint unions of runs. For any fixed set of indices $S$, the weighted sum over all subintervals contained in $S$ equals the sum over its maximal runs.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all fog patterns (subsets of columns). For each pattern, split into connected runs, compute maxima per row per run, add $g(m_1,m_2)$. Average over $2^N$ equally likely patterns.}
\ASSUMPTIONS{Feasible only for very small $N$ (e.g., $N \le 20$) due to $O(N2^N)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate mask from $0$ to $2^N-1$; column $c$ appears iff bit $c$ is $1$.
\item Decompose appeared columns into runs $[u,v]$.
\item For each run, compute $m_1$, $m_2$, add $\min(m_1,m_2)$ unless equal (then add $0$).
\item Sum over masks and multiply by $(2^{-N} \bmod M)$.
\end{algosteps}
\COMPLEXITY{Exponential in $N$.}
\[
\begin{aligned}
T(N) &= \Theta(N\,2^N),\quad S(N)=\Theta(N).
\end{aligned}
\]
\CORRECTNESS{By definition each pattern is equally likely. Summing contributions and dividing by $2^N$ yields the expectation; mapping to modulo uses modular inverse of $2^N \bmod M$.}
\EDGECASES{All equal values (answer $0$); $N=1$; strictly increasing rows; duplicate peaks at different columns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force for very small N; includes read_input / solve_all / main + asserts
MOD = 998244353

def inv_mod(x):
    return pow(x, MOD - 2, MOD)

def brute_expected(P1, P2):
    n = len(P1)
    tot = 0
    for mask in range(1 << n):
        s = 0
        c = 0
        while c < n:
            if (mask >> c) & 1:
                u = c
                while c + 1 < n and ((mask >> (c + 1)) & 1):
                    c += 1
                v = c
                m1 = max(P1[u:v+1])
                m2 = max(P2[u:v+1])
                if m1 != m2:
                    s += min(m1, m2)
            c += 1
        tot = (tot + s) % MOD
    return tot * inv_mod(pow(2, n, MOD)) % MOD

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p1 = [int(next(it)) for _ in range(n)]
    p2 = [int(next(it)) for _ in range(n)]
    return n, p1, p2

def solve_all():
    # Baseline delegates to brute (only safe for tiny inputs)
    I = read_input()
    if I is None:
        return
    n, p1, p2 = I
    # If too large, still compute brute for demonstration (may TLE in real judge)
    ans = brute_expected(p1, p2) if n <= 20 else brute_expected(p1[:15], p2[:15])  # placeholder safety
    print(ans)

def _test_baseline_small():
    # Tiny sanity checks
    assert brute_expected([5], [5]) == 0
    # N=1, different values: expected is min * 1/2 => min * inv2
    inv2 = inv_mod(2)
    assert brute_expected([2], [7]) == (2 * inv2) % MOD

if __name__ == "__main__":
    _test_baseline_small()
    # Do not actually run solve_all() here to avoid long brute work
    # But keep API presence per contract
\end{minted}
\VALIDATION{Verified on $N=1$ trivial cases; structurally correct for any $N$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Weighted Interval Counts via Inclusion--Exclusion}
\WHICHFORMULA{Use linearity: replace $g$ by threshold sums. For each threshold $x$, intervals with both $m_1,m_2\ge x$ equal total intervals minus those entirely in $\{P_1<x\}$ or $\{P_2<x\}$ plus those in $\{\max(P_1,P_2)<x\}$.}
\ASSUMPTIONS{We can compute, for any subset of columns $S$, the weighted sum of all subintervals contained in $S$ by summing over runs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute a closed-form $W([L,R])$ that sums weights $w(u,v)$ over all $L \le u \le v \le R$.
\item For each threshold $x$, form sets $A_x=\{c:P_1[c]\le x-1\}$, $B_x=\{c:P_2[c]\le x-1\}$, $C_x=\{c:\max(P_1,P_2)\le x-1\}$.
\item Accumulate $S_1=\sum_x \big(T - W(A_x) - W(B_x) + W(C_x)\big)$ where $T=W([1,N])$.
\end{algosteps}
\COMPLEXITY{Still $O(VN)$ if recomputed naively.}
\[
\begin{aligned}
T(n) &= O(V\cdot N)\ \text{naive},\ \text{where }V=\max P.\\
\end{aligned}
\]
\CORRECTNESS{Inclusion--exclusion converts a two-set coverage condition into subtracting intervals completely inside complements.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Skeleton computing W([L,R]) in O(1) and summing over runs given explicitly.
MOD = 998244353

class WeightedSegments:
    def __init__(self, n):
        self.n = n
        self.inv2 = (MOD + 1) // 2
        self.inv8 = pow(8, MOD - 2, MOD)
        self.r = self.inv2
        # alpha factors: a_i for left end, b_j for right end
        self.a = [0] * (n + 1)
        self.b = [0] * (n + 1)
        for i in range(1, n + 1):
            self.a[i] = 2 if i == 1 else 1
            self.b[i] = 2 if i == n else 1
        self.rpow = [1] * (n + 2)
        for i in range(1, n + 2):
            self.rpow[i] = self.rpow[i - 1] * self.r % MOD
        self.pow2 = [1] * (n + 2)
        for i in range(1, n + 2):
            self.pow2[i] = (self.pow2[i - 1] * 2) % MOD
        # SUF[k] = sum_{j=k..n} b_j * r^j
        self.SUF = [0] * (n + 3)
        for k in range(n, 0, -1):
            self.SUF[k] = (self.b[k] * self.rpow[k] + self.SUF[k + 1]) % MOD
        # Pref sums:
        self.P1 = [0] * (n + 1)  # sum a_i * r^{-i} * SUF[i]
        self.P2 = [0] * (n + 1)  # sum a_i * r^{-i}
        for i in range(1, n + 1):
            Acoeff = self.a[i] * self.pow2[i] % MOD  # r^{-i} = 2^i
            self.P1[i] = (self.P1[i - 1] + Acoeff * self.SUF[i]) % MOD
            self.P2[i] = (self.P2[i - 1] + Acoeff) % MOD

    def seg_sum(self, L, R):
        if L > R:
            return 0
        s1 = (self.P1[R] - self.P1[L - 1]) % MOD
        s2 = (self.P2[R] - self.P2[L - 1]) % MOD
        term = (s1 - self.SUF[R + 1] * s2) % MOD
        return (self.inv8 * term) % MOD

def runs_weight_sum(ws: WeightedSegments, active):
    # active is a boolean list of len n (1-based index expected)
    n = ws.n
    ans = 0
    i = 1
    while i <= n:
        if active[i]:
            j = i
            while j + 1 <= n and active[j + 1]:
                j += 1
            ans = (ans + ws.seg_sum(i, j)) % MOD
            i = j + 1
        else:
            i += 1
    return ans

def _demo_improved():
    # Demonstrate W over runs
    n = 5
    ws = WeightedSegments(n)
    # All active
    act = [False] + [True] * n
    tot = runs_weight_sum(ws, act)
    assert tot == ws.seg_sum(1, n)
\end{minted}
\VALIDATION{Checked that summing over a single full run equals $W([1,N])$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Threshold Sweep + DSU over Columns}
\WHICHFORMULA{Reduce $\mathbb{E}$ to weighted counts of intervals for four monotone sets as thresholds increase:
- $S_1(t)=\{P_1\le t\}$, $S_2(t)=\{P_2\le t\}$, $S_{\max}(t)=\{\max(P_1,P_2)\le t\}$;
- Mixed sets $M_1(t)=\{P_1\le t-1,\ P_2\le t\}$ and $M_2(t)=\{P_1\le t,\ P_2\le t-1\}$.\\
Maintain for each set the total weighted sum of subintervals using a DSU that merges adjacent active indices and updates with $W([L,R])$ in $O(1)$.}
\ASSUMPTIONS{Monotone activation times per column per set; each column joins each set at most once, so total $O(N)$ DSU operations per set.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $W([L,R])$ in $O(1)$ via prefix/suffix sums of geometric weights.
\item Build event lists by value $t$: when a column activates into each set ($P_1=t$, $P_2=t$, $\max=t$, $\max(P_2, P_1{+}1)=t$, $\max(P_1, P_2{+}1)=t$).
\item Sweep $t=0\ldots V$ where $V=\max P$. Update five DSUs and record:
$A_t=W(S_1(t))$, $B_t=W(S_2(t))$, $C_t=W(S_{\max}(t))$, $D_t=W(M_1(t))$, $E_t=W(M_2(t))$.
\item Compute
\begin{BreakableEquation*}
S_1 = V\cdot W([1,N]) - \sum_{t=0}^{V-1} A_t - \sum_{t=0}^{V-1} B_t + \sum_{t=0}^{V-1} C_t,
\end{BreakableEquation*}
\begin{BreakableEquation*}
S_2 = \sum_{y=1}^{V} y\cdot\big(C_y - D_y - E_y + C_{y-1}\big),\quad \mathbb{E}=S_1 - S_2 \pmod{M}.
\end{BreakableEquation*}
\end{algosteps}
\OPTIMALITY{Each column is added to each DSU at most once; merges are $O(1)$ amortized. Overall $O((V+N)\alpha(N))$ time and $O(N)$ memory. This is tight up to constants for value-sweep methods.}
\COMPLEXITY{Time $O((N+V)\alpha(N))$, space $O(N)$.}
\[
\begin{aligned}
T(n) &= O(N + V),\ \text{with near-constant inverse Ackermann factor},\\
S(n) &= O(N).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final CF-ready solution: read_input(), solve_all(), main()+guard + asserts
MOD = 998244353

def inv_mod(x):
    return pow(x, MOD - 2, MOD)

class WeightedSegments:
    def __init__(self, n):
        self.n = n
        self.inv2 = (MOD + 1) // 2
        self.inv8 = pow(8, MOD - 2, MOD)  # (1/8) mod MOD
        self.r = self.inv2                # r = 1/2
        # alpha multipliers encoded via a (left) and b (right)
        self.a = [0] * (n + 1)
        self.b = [0] * (n + 1)
        for i in range(1, n + 1):
            self.a[i] = 2 if i == 1 else 1
            self.b[i] = 2 if i == n else 1
        # r^k and (1/r)^k = 2^k
        self.rpow = [1] * (n + 2)
        for i in range(1, n + 2):
            self.rpow[i] = self.rpow[i - 1] * self.r % MOD
        self.pow2 = [1] * (n + 2)
        for i in range(1, n + 2):
            self.pow2[i] = (self.pow2[i - 1] * 2) % MOD
        # SUF[k] = sum_{j=k..n} b_j * r^j
        self.SUF = [0] * (n + 3)
        for k in range(n, 0, -1):
            self.SUF[k] = (self.b[k] * self.rpow[k] + self.SUF[k + 1]) % MOD
        # Prefix sums:
        self.P1 = [0] * (n + 1)  # sum a_i * r^{-i} * SUF[i]
        self.P2 = [0] * (n + 1)  # sum a_i * r^{-i}
        for i in range(1, n + 1):
            Acoeff = self.a[i] * self.pow2[i] % MOD  # r^{-i} = 2^i
            self.P1[i] = (self.P1[i - 1] + Acoeff * self.SUF[i]) % MOD
            self.P2[i] = (self.P2[i - 1] + Acoeff) % MOD

    def seg_sum(self, L, R):
        if L > R:
            return 0
        s1 = (self.P1[R] - self.P1[L - 1]) % MOD
        s2 = (self.P2[R] - self.P2[L - 1]) % MOD
        term = (s1 - self.SUF[R + 1] * s2) % MOD
        return (self.inv8 * term) % MOD

class DSURuns:
    def __init__(self, n, seg_sum_func):
        self.n = n
        self.seg_sum = seg_sum_func
        self.parent = [-1] * (n + 2)
        self.L = [0] * (n + 2)
        self.R = [0] * (n + 2)
        self.active = [False] * (n + 2)
        self.total = 0

    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def _add_single(self, pos):
        self.parent[pos] = pos
        self.L[pos] = pos
        self.R[pos] = pos
        self.active[pos] = True
        self.total = (self.total + self.seg_sum(pos, pos)) % MOD

    def _unite_roots(self, rx, ry):
        # Assumes rx != ry, both roots
        lx, rxr = self.L[rx], self.R[rx]
        ly, ryr = self.L[ry], self.R[ry]
        self.total = (self.total - self.seg_sum(lx, rxr)) % MOD
        self.total = (self.total - self.seg_sum(ly, ryr)) % MOD
        if lx > ly:
            lx, ly = ly, lx
        if rxr < ryr:
            rxr, ryr = ryr, rxr
        # Now new segment is [min(L), max(R)]
        Lnew = lx
        Rnew = rxr
        self.parent[ry] = rx
        self.L[rx] = Lnew
        self.R[rx] = Rnew
        self.total = (self.total + self.seg_sum(Lnew, Rnew)) % MOD

    def add(self, pos):
        if self.active[pos]:
            return
        self._add_single(pos)
        # merge with left
        if pos - 1 >= 1 and self.active[pos - 1]:
            rx = self.find(pos - 1)
            ry = self.find(pos)
            if rx != ry:
                self._unite_roots(rx, ry)
        # merge with right
        if pos + 1 <= self.n and self.active[pos + 1]:
            rx = self.find(pos)
            ry = self.find(pos + 1)
            if rx != ry:
                self._unite_roots(rx, ry)

def solve_expected(n, p1, p2):
    V = 0
    for x in p1:
        if x > V: V = x
    for x in p2:
        if x > V: V = x
    ws = WeightedSegments(n)
    totalW = ws.seg_sum(1, n)

    # Event lists
    top_at = [[] for _ in range(V + 2)]
    bot_at = [[] for _ in range(V + 2)]
    mx_at  = [[] for _ in range(V + 2)]
    mix1_at = [[] for _ in range(V + 2)]
    mix2_at = [[] for _ in range(V + 2)]
    for i in range(n):
        t1 = p1[i]
        t2 = p2[i]
        top_at[t1].append(i + 1)
        bot_at[t2].append(i + 1)
        mx_at[max(t1, t2)].append(i + 1)
        t_mix1 = max(t2, t1 + 1)
        t_mix2 = max(t1, t2 + 1)
        if 1 <= t_mix1 <= V:
            mix1_at[t_mix1].append(i + 1)
        if 1 <= t_mix2 <= V:
            mix2_at[t_mix2].append(i + 1)

    dsu_top = DSURuns(n, ws.seg_sum)
    dsu_bot = DSURuns(n, ws.seg_sum)
    dsu_max = DSURuns(n, ws.seg_sum)
    dsu_m1  = DSURuns(n, ws.seg_sum)
    dsu_m2  = DSURuns(n, ws.seg_sum)
    A = [0] * (V + 1)  # W(S1(t))
    B = [0] * (V + 1)  # W(S2(t))
    C = [0] * (V + 1)  # W(Smax(t))
    D = [0] * (V + 1)  # W(M1(t))
    E = [0] * (V + 1)  # W(M2(t))
    # t = 0 are zeros
    for t in range(1, V + 1):
        for pos in top_at[t]:
            dsu_top.add(pos)
        for pos in bot_at[t]:
            dsu_bot.add(pos)
        for pos in mx_at[t]:
            dsu_max.add(pos)
        for pos in mix1_at[t]:
            dsu_m1.add(pos)
        for pos in mix2_at[t]:
            dsu_m2.add(pos)
        A[t] = dsu_top.total
        B[t] = dsu_bot.total
        C[t] = dsu_max.total
        D[t] = dsu_m1.total
        E[t] = dsu_m2.total

    # Compute S1
    sumA = 0
    sumB = 0
    sumC = 0
    for t in range(0, V):
        sumA = (sumA + A[t]) % MOD
        sumB = (sumB + B[t]) % MOD
        sumC = (sumC + C[t]) % MOD
    S1 = (V * totalW - sumA - sumB + sumC) % MOD

    # Compute S2
    S2 = 0
    for y in range(1, V + 1):
        term = (C[y] - D[y] - E[y] + C[y - 1]) % MOD
        S2 = (S2 + y * term) % MOD

    ans = (S1 - S2) % MOD
    return ans

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p1 = [int(next(it)) for _ in range(n)]
    p2 = [int(next(it)) for _ in range(n)]
    return n, p1, p2

def solve_all():
    I = read_input()
    if I is None:
        return
    n, p1, p2 = I
    print(solve_expected(n, p1, p2))

def _brute_expected(P1, P2):
    # For cross-checks only (small N)
    n = len(P1)
    tot = 0
    for mask in range(1 << n):
        s = 0
        c = 0
        while c < n:
            if (mask >> c) & 1:
                u = c
                while c + 1 < n and ((mask >> (c + 1)) & 1):
                    c += 1
                v = c
                m1 = max(P1[u:v+1])
                m2 = max(P2[u:v+1])
                if m1 != m2:
                    s += min(m1, m2)
            c += 1
        tot = (tot + s) % MOD
    return tot * inv_mod(pow(2, n, MOD)) % MOD

def _self_test():
    # Deterministic small tests
    assert solve_expected(1, [5], [5]) == 0
    inv2 = inv_mod(2)
    assert solve_expected(1, [2], [7]) == (2 * inv2) % MOD
    # Randomized small cross-checks
    import random
    random.seed(0)
    for n in range(1, 7):
        for _ in range(12):
            p1 = [random.randint(1, 5) for _ in range(n)]
            p2 = [random.randint(1, 5) for _ in range(n)]
            a = solve_expected(n, p1, p2)
            b = _brute_expected(p1, p2)
            assert a == b, (n, p1, p2, a, b)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Three asserts: $N=1$ equal-values case, $N=1$ unequal-values case, and randomized cross-checks for $N\le 6$ against brute force.}
\RESULT{Outputs $\mathbb{E}$ mapped to $\bmod~998{,}244{,}353$ via the implicit denominator inverse.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for the $W([L,R])$ formula; small $N$ brute-force cross-checks; edge cases $N=1$, identical rows, strictly increasing/decreasing.}
\LINE{CROSS-CHECKS}{Compare brute vs. optimal on random arrays of length up to $6$ with values up to $5$.}
\LINE{EDGE-CASE GENERATOR}{Generates arrays with equal rows, single peak mismatches, and alternating dominance to stress the mixed-set logic.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_equal(n, val=3):
    return [val]*n, [val]*n

def gen_alt(n, a=1, b=5):
    p1 = []
    p2 = []
    for i in range(n):
        if i % 2 == 0:
            p1.append(a); p2.append(b)
        else:
            p1.append(b); p2.append(a)
    return p1, p2

def gen_ramp(n):
    p1 = list(range(1, n+1))
    p2 = list(range(n, 0, -1))
    return p1, p2
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution
MOD = 998244353

def inv_mod(x):
    return pow(x, MOD - 2, MOD)

class WeightedSegments:
    def __init__(self, n):
        self.n = n
        self.inv2 = (MOD + 1) // 2
        self.inv8 = pow(8, MOD - 2, MOD)
        self.r = self.inv2
        self.a = [0] * (n + 1)
        self.b = [0] * (n + 1)
        for i in range(1, n + 1):
            self.a[i] = 2 if i == 1 else 1
            self.b[i] = 2 if i == n else 1
        self.rpow = [1] * (n + 2)
        for i in range(1, n + 2):
            self.rpow[i] = self.rpow[i - 1] * self.r % MOD
        self.pow2 = [1] * (n + 2)
        for i in range(1, n + 2):
            self.pow2[i] = (self.pow2[i - 1] * 2) % MOD
        self.SUF = [0] * (n + 3)
        for k in range(n, 0, -1):
            self.SUF[k] = (self.b[k] * self.rpow[k] + self.SUF[k + 1]) % MOD
        self.P1 = [0] * (n + 1)
        self.P2 = [0] * (n + 1)
        for i in range(1, n + 1):
            Acoeff = self.a[i] * self.pow2[i] % MOD
            self.P1[i] = (self.P1[i - 1] + Acoeff * self.SUF[i]) % MOD
            self.P2[i] = (self.P2[i - 1] + Acoeff) % MOD

    def seg_sum(self, L, R):
        if L > R:
            return 0
        s1 = (self.P1[R] - self.P1[L - 1]) % MOD
        s2 = (self.P2[R] - self.P2[L - 1]) % MOD
        term = (s1 - self.SUF[R + 1] * s2) % MOD
        return (self.inv8 * term) % MOD

class DSURuns:
    def __init__(self, n, seg_sum_func):
        self.n = n
        self.seg_sum = seg_sum_func
        self.parent = [-1] * (n + 2)
        self.L = [0] * (n + 2)
        self.R = [0] * (n + 2)
        self.active = [False] * (n + 2)
        self.total = 0

    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def _add_single(self, pos):
        self.parent[pos] = pos
        self.L[pos] = pos
        self.R[pos] = pos
        self.active[pos] = True
        self.total = (self.total + self.seg_sum(pos, pos)) % MOD

    def _unite_roots(self, rx, ry):
        lx, rxr = self.L[rx], self.R[rx]
        ly, ryr = self.L[ry], self.R[ry]
        self.total = (self.total - self.seg_sum(lx, rxr)) % MOD
        self.total = (self.total - self.seg_sum(ly, ryr)) % MOD
        Lnew = min(lx, ly)
        Rnew = max(rxr, ryr)
        self.parent[ry] = rx
        self.L[rx] = Lnew
        self.R[rx] = Rnew
        self.total = (self.total + self.seg_sum(Lnew, Rnew)) % MOD

    def add(self, pos):
        if self.active[pos]:
            return
        self._add_single(pos)
        if pos - 1 >= 1 and self.active[pos - 1]:
            rx = self.find(pos - 1)
            ry = self.find(pos)
            if rx != ry:
                self._unite_roots(rx, ry)
        if pos + 1 <= self.n and self.active[pos + 1]:
            rx = self.find(pos)
            ry = self.find(pos + 1)
            if rx != ry:
                self._unite_roots(rx, ry)

def solve_expected(n, p1, p2):
    V = max(max(p1), max(p2))
    ws = WeightedSegments(n)
    totalW = ws.seg_sum(1, n)
    top_at = [[] for _ in range(V + 2)]
    bot_at = [[] for _ in range(V + 2)]
    mx_at  = [[] for _ in range(V + 2)]
    mix1_at = [[]for _ in range(V + 2)]
    mix2_at = [[]for _ in range(V + 2)]
    for i in range(n):
        t1 = p1[i]; t2 = p2[i]
        top_at[t1].append(i + 1)
        bot_at[t2].append(i + 1)
        mx_at[max(t1, t2)].append(i + 1)
        t_mix1 = max(t2, t1 + 1)
        t_mix2 = max(t1, t2 + 1)
        if 1 <= t_mix1 <= V:
            mix1_at[t_mix1].append(i + 1)
        if 1 <= t_mix2 <= V:
            mix2_at[t_mix2].append(i + 1)
    dsu_top = DSURuns(n, ws.seg_sum)
    dsu_bot = DSURuns(n, ws.seg_sum)
    dsu_max = DSURuns(n, ws.seg_sum)
    dsu_m1  = DSURuns(n, ws.seg_sum)
    dsu_m2  = DSURuns(n, ws.seg_sum)
    A = [0] * (V + 1)
    B = [0] * (V + 1)
    C = [0] * (V + 1)
    D = [0] * (V + 1)
    E = [0] * (V + 1)
    for t in range(1, V + 1):
        for pos in top_at[t]:
            dsu_top.add(pos)
        for pos in bot_at[t]:
            dsu_bot.add(pos)
        for pos in mx_at[t]:
            dsu_max.add(pos)
        for pos in mix1_at[t]:
            dsu_m1.add(pos)
        for pos in mix2_at[t]:
            dsu_m2.add(pos)
        A[t] = dsu_top.total
        B[t] = dsu_bot.total
        C[t] = dsu_max.total
        D[t] = dsu_m1.total
        E[t] = dsu_m2.total
    sumA = sum(A[0:V]) % MOD
    sumB = sum(B[0:V]) % MOD
    sumC = sum(C[0:V]) % MOD
    S1 = (V * totalW - sumA - sumB + sumC) % MOD
    S2 = 0
    for y in range(1, V + 1):
        term = (C[y] - D[y] - E[y] + C[y - 1]) % MOD
        S2 = (S2 + y * term) % MOD
    return (S1 - S2) % MOD

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p1 = [int(next(it)) for _ in range(n)]
    p2 = [int(next(it)) for _ in range(n)]
    return n, p1, p2

def solve_all():
    I = read_input()
    if I is None:
        return
    n, p1, p2 = I
    print(solve_expected(n, p1, p2))

def _brute_expected(P1, P2):
    n = len(P1)
    tot = 0
    for mask in range(1 << n):
        s = 0
        c = 0
        while c < n:
            if (mask >> c) & 1:
                u = c
                while c + 1 < n and ((mask >> (c + 1)) & 1):
                    c += 1
                v = c
                m1 = max(P1[u:v+1])
                m2 = max(P2[u:v+1])
                if m1 != m2:
                    s += min(m1, m2)
            c += 1
        tot = (tot + s) % MOD
    return tot * inv_mod(pow(2, n, MOD)) % MOD

def _tests():
    assert solve_expected(1, [5], [5]) == 0
    inv2 = inv_mod(2)
    assert solve_expected(1, [2], [7]) == (2 * inv2) % MOD
    import random
    random.seed(1)
    for n in range(1, 7):
        for _ in range(10):
            p1 = [random.randint(1, 5) for _ in range(n)]
            p2 = [random.randint(1, 5) for _ in range(n)]
            assert solve_expected(n, p1, p2) == _brute_expected(p1, p2)

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute an expectation over random runs by turning it into weighted counts of value-threshold-satisfying intervals.}
\WHY{Appears in interviews testing probabilistic linearity tricks and interval counting under weights.}
\CHECKLIST{%
\begin{bullets}
\item Express expectation as sum over intervals with weight $w(u,v)$.
\item Convert $\min$ and equality into threshold sums.
\item Derive closed-form $W([L,R])$ for weights of all subintervals.
\item Sweep thresholds; maintain five monotone sets via DSU of runs.
\item Combine sums $S_1$ and $S_2$ carefully modulo $M$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $N=1$.
\item All values identical $\Rightarrow$ answer $0$.
\item One row dominates everywhere.
\item Alternating dominance per column.
\item Max value $V$ appearing at boundaries.
\item Columns where $P_1$ or $P_2$ equals $1$ (early activations).
\item Large $V$ with sparse high values.
\item Very large $N$ (ensure $O(N)$ memory).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting boundary multipliers $\alpha_1=\alpha_N=1$ vs. $\tfrac{1}{2}$ interior.
\item Off-by-one in $M_1(t)=\{P_1\le t-1, P_2\le t\}$ and $M_2(t)$ activation times.
\item Using $2^{-L}$ incorrectly (never use raw \% in math without escaping).
\item Not handling negative mods after subtractions.
\item DSU merges double-counting or missing removal of old segment weights.
\item Precompute powers limited to $N$ only (not $V$), but that suffices.
\end{bullets}
}
\FAILMODES{Inputs with clustered equal high values can break implementations that do not correctly handle the equality subtraction term $S_2$. Using only $S_1$ overcounts; mixed-set corrections are required.}
\ELI{We assign each possible interval a probability weight that it becomes a run. Then we just need to count, by weight, how many intervals have big-enough numbers in both rows, and subtract those where the top and bottom have the same maximum. A union-find over indexes keeps track of current allowed positions as thresholds rise.}
\NotePages{3}

\end{document}