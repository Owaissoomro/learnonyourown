% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nim}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2043/F}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Recall the rules of the game Nim. There are $n$ piles of stones, where the $i$-th pile initially contains some number of stones. Two players take turns choosing a non-empty pile and removing any positive (strictly greater than $0$) number of stones from it. The player unable to make a move loses the game.

You are given an array $a$, consisting of $n$ integers. Artem and Ruslan decided to play Nim on segments of this array. Each of the $q$ rounds is defined by a segment $(l_i, r_i)$, where the elements $a_{l_i}, a_{l_i+1}, \dots, a_{r_i}$ represent the sizes of the piles of stones.

Before the game starts, Ruslan can remove any number of piles from the chosen segment. However, at least one pile must remain, so in a single round he can remove at most $(r_i - l_i)$ piles. He is allowed to remove $0$ piles. After the removal, the game is played on the remaining piles within the segment.

All rounds are independent: the changes made in one round do not affect the original array or any other rounds.

Ruslan wants to remove as many piles as possible so that Artem, who always makes the first move, loses.

For each round, determine:
\begin{bullets}
\item the maximum number of piles Ruslan can remove;
\item the number of ways to choose the maximum number of piles for removal.
\end{bullets}
Two ways are considered different if there exists an index $i$ such that the pile at index $i$ is removed in one way but not in the other. Since the number of ways can be large, output it modulo $998{,}244{,}353$.

If Ruslan cannot ensure Artem's loss in a particular round, output $-1$ for that round.

Input: The first line contains two integers $n$ and $q$ ($1 \le n, q \le 10^5$) — the size of the array and the number of segments. The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($0 \le a_i \le 50$). Each of the next $q$ lines contains two integers $l_i, r_i$ ($1 \le l_i \le r_i \le n$).

Output: For each round:
\begin{bullets}
\item if Ruslan can win, print two integers — the maximum number of piles that can be removed, and the number of ways to remove the maximum number of piles, modulo $998{,}244{,}353$;
\item otherwise print $-1$.
\end{bullets}}
\BREAKDOWN{For each segment, Ruslan chooses a nonempty subset of piles whose XOR is $0$ (a losing Nim position for the first player), maximizing the number removed, i.e., minimizing the kept subset size. Count how many such minimum-size subsets exist.}
\ELI{We need the smallest nonempty subset of the segment with XOR $0$ and how many such subsets there are; if none, answer $-1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
- $n$ — integer, $1 \le n \le 10^5$.
- $q$ — integer, $1 \le q \le 10^5$.
- Array $a$ of length $n$, each $a_i \in [0,50]$.
- $q$ queries $(l, r)$ with $1 \le l \le r \le n$.
}
\OUTPUTS{
For each query:
- If possible to force Artem's loss, output: $\text{max\_removed}$ and $\text{ways} \bmod 998{,}244{,}353$.
- Else output $-1$.
}
\SAMPLES{
Example 1: $a=[0,5,7]$, query $(1,3)$. Keep one zero; answer: $2~1$.

Example 2: $a=[1,1,2]$, query $(1,3)$. Keep the pair of $1$'s; answer: $1~1$.

Example 3: $a=[1,2,4]$, query $(1,3)$. No nonempty subset XORs to $0$; answer: $-1$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For a query segment, let $c_v$ be the multiplicity of value $v \in \{0,1,\dots,50\}$. Ruslan chooses nonnegative integers $x_v \le c_v$ with $\sum_v x_v \ge 1$ such that the XOR of the multiset containing $x_v$ copies of $v$ is $0$. Maximize removed piles $\implies$ minimize kept piles $k = \sum_v x_v$.}
\varmapStart
\var{c_v}{count of value $v$ on the segment}
\var{x_v}{chosen count of value $v$ to keep ($0 \le x_v \le c_v$)}
\var{k}{kept size $k=\sum_v x_v$}
\var{M}{modulus $998{,}244{,}353$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\bigoplus_{\substack{v=0\\ x_v \equiv 1 \ (\mathrm{mod}\ 2)}}^{50} v \;=\; 0, \qquad k=\sum_{v=0}^{50} x_v \ge 1, \qquad 0 \le x_v \le c_v.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All piles are independent; Nim's losing state is exactly zero XOR of pile sizes.}
\INVARIANTS{
- XOR depends only on parities $y_v \equiv x_v \bmod 2$.
- If any $c_0 \ge 1$, then $k_{\min}=1$ (keep a single zero).
- Else if any $c_v \ge 2$, then $k_{\min}=2$ (keep two equal nonzero values).
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all nonempty subsets of the segment, compute their XOR and size, track the smallest size with XOR $0$ and count such subsets.}
\ASSUMPTIONS{Feasible only for tiny segments; used here for validation and small tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract segment $a[l..r]$.
\item For every nonempty subset, compute XOR and size.
\item Record minimal $k$ with XOR $0$ and count; report $(m-k,\text{count})$ or $-1$.
\end{algosteps}
\COMPLEXITY{Exponential in segment length $m$:}
\[
\begin{aligned}
T(m) &= O(m \cdot 2^m), \\
S(m) &= O(1) \text{ (beyond input)}.
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration covers all subsets, so minimality and count are exact.}
\EDGECASES{Single zero; single nonzero; duplicates; all distinct nonzeros with no zero-XOR subset.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force for tiny segments (validation only)
from typing import List, Tuple

MOD = 998244353

def brute_segment_min_xor_zero(arr: List[int]) -> Tuple[int, int]:
    n = len(arr)
    best = None
    ways = 0
    for mask in range(1, 1 << n):
        x = 0
        k = 0
        for i in range(n):
            if mask >> i & 1:
                x ^= arr[i]
                k += 1
        if x == 0:
            if best is None or k < best:
                best = k
                ways = 1
            elif k == best:
                ways += 1
    if best is None:
        return (-1, 0)
    return (best, ways % MOD)

# Tiny sanity checks
assert brute_segment_min_xor_zero([0, 5, 7]) == (1, 1)  # pick [0]
assert brute_segment_min_xor_zero([1, 1, 2]) == (2, 1)  # pick [1,1]
assert brute_segment_min_xor_zero([1]) == (-1, 0)
assert brute_segment_min_xor_zero([1, 2, 4]) == (-1, 0)
\end{minted}
\VALIDATION{Use the asserts above and compare with improved approaches on random tiny arrays.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Early Rules + Per-Element DP per Target}
\WHICHFORMULA{Exploit small value domain ($\le 50$) and XOR properties: handle $k_{\min}=1$ with zeros; $k_{\min}=2$ with duplicates. Otherwise all values are distinct nonzero; compute $k_{\min} = 1 + \min_e w_e$, where $w_e$ is the minimum size of a subset of the remaining values that XORs to $e$.}
\ASSUMPTIONS{Values live in at most 6 bits; DP over $64$ XOR states is cheap.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute prefix counts per value $v\in[0,50]$.
\item For each query, get multiplicities $c_v$ in $O(51)$.
\item If $c_0>0$: $k_{\min}=1$, ways $=c_0$.
\item Else if any $c_v\ge 2$: $k_{\min}=2$, ways $=\sum_v \binom{c_v}{2} \bmod M$.
\item Else: let $S=\{v\in[1,50]\mid c_v=1\}$. For each $e\in S$, run a $64$-state DP over $S\setminus\{e\}$ to find minimal $w_e$ and number of ways; take $k_{\min}=1+\min w_e$ and sum counts for minimizers.
\end{algosteps}
\COMPLEXITY{Beats brute force by using $64$-state DPs.}
\[
\begin{aligned}
T(\text{query}) &= O(51) + O(|S| \cdot 64 \cdot |S|) = O(64\,|S|^2), \\
S(\text{query}) &= O(64).
\end{aligned}
\]
\CORRECTNESS{Any zero-XOR subset contains some distinguished element $e$; the rest XOR to $e$. Taking the minimum over all $e$ finds the smallest circuit size. Counts add over independent minimizers.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
from array import array

MOD = 998244353

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    qs = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, qs

def build_prefix_counts(a: List[int]) -> List[array]:
    n = len(a)
    pref = [array('I', [0]) * (n + 1) for _ in range(51)]  # placeholder
    pref = [array('I', [0] * (n + 1)) for _ in range(51)]
    for v in range(51):
        cnt = pref[v]
        c = 0
        for i, x in enumerate(a, start=1):
            if x == v:
                c += 1
            cnt[i] = c
    return pref

def get_counts(pref: List[array], l: int, r: int) -> List[int]:
    # l, r are 1-based
    return [pref[v][r] - pref[v][l - 1] for v in range(51)]

def dp_min_size_and_count_to_target(vals: List[int], target: int) -> Tuple[int, int]:
    # minimal size to xor to 'target' using each val at most once, and count ways
    INF = 10 ** 9
    dp = [INF] * 64
    cnt = [0] * 64
    dp[0] = 0
    cnt[0] = 1
    for v in vals:
        ndp = dp[:]
        ncnt = cnt[:]
        for x in range(64):
            if dp[x] != INF:
                y = x ^ v
                cand = dp[x] + 1
                if cand < ndp[y]:
                    ndp[y] = cand
                    ncnt[y] = cnt[x]
                elif cand == ndp[y]:
                    ncnt[y] = (ncnt[y] + cnt[x]) % MOD
        dp, cnt = ndp, ncnt
    if dp[target] >= 10 ** 9:
        return (10 ** 9, 0)
    return (dp[target], cnt[target] % MOD)

def solve_all(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[str]:
    pref = build_prefix_counts(a)
    out = []
    for l, r in queries:
        m = r - l + 1
        c = get_counts(pref, l, r)
        c0 = c[0]
        if c0 > 0:
            out.append(f"{m - 1} {c0 % MOD}")
            continue
        sum_pairs = 0
        dup = False
        S = []
        for v in range(1, 51):
            if c[v] >= 2:
                dup = True
                sum_pairs = (sum_pairs + (c[v] * (c[v] - 1) // 2)) % MOD
            elif c[v] == 1:
                S.append(v)
        if dup:
            out.append(f"{m - 2} {sum_pairs % MOD}")
            continue
        # Distinct nonzero values only
        if not S:
            out.append("-1")
            continue
        best = 10 ** 9
        ways = 0
        for i, e in enumerate(S):
            others = S[:i] + S[i + 1:]
            w, cnt = dp_min_size_and_count_to_target(others, e)
            if w < best:
                best = w
                ways = cnt
            elif w == best:
                ways = (ways + cnt) % MOD
        if best >= 10 ** 9:
            out.append("-1")
        else:
            kmin = 1 + best
            out.append(f"{m - kmin} {ways % MOD}")
    return out

# Tiny tests for the improved approach
def _test_improved():
    n, q = 3, 3
    a = [0, 5, 7]
    queries = [(1, 3), (2, 3), (2, 2)]
    ans = solve_all(n, q, a, queries)
    assert ans[0].split()[0] == "2"  # keep 1 zero
    assert ans[2] == "-1"

_test_improved()
\end{minted}
\VALIDATION{Random small arrays ($n\le 12$) compared against brute force; hand-checked cases with zeros, duplicates, and all-distinct nonzeros.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Early Rules + Single-Pass 64-State DP}
\WHICHFORMULA{After early rules ($k_{\min}=1$ via any zero; $k_{\min}=2$ via any duplicate), in the remaining case all present values are distinct and nonzero. Then compute, over the set $S$ of present values, the minimal size and count of nonempty subsets achieving XOR $0$ using a single $64$-state DP that tracks minimal cardinality and ways for each XOR value, restricted to nonempty subsets.}
\ASSUMPTIONS{Values are in $[1,50]$, so they fit in 6 bits. DP over $64$ states is cheap; counting is modulo $M=998{,}244{,}353$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute per-value prefix counts to get multiplicities $c_v$ in $O(51)$ per query.
\item If $c_0>0$: answer $(m-1, c_0)$.
\item Else if any $c_v\ge 2$: answer $(m-2, \sum_v \binom{c_v}{2})$.
\item Else: let $S=\{v\in[1,50]\mid c_v=1\}$. Initialize arrays for nonempty subsets only: $\text{len}[x]=+\infty$, $\text{cnt}[x]=0$ for all $x\in[0,63]$.
\item For each $v\in S$:
\begin{bullets}
\item Transition from existing subsets: for every $x$ with $\text{len}[x]<\infty$, update $y=x\oplus v$ with candidate length $\text{len}[x]+1$ and inherit counts (with min-tie sum).
\item Add singleton $v$: update state $v$ with length $1$, count $1$ (min-tie sum).
\end{bullets}
\item At the end, if $\text{len}[0]=+\infty$, output $-1$; else $k_{\min}=\text{len}[0]$ and ways $=\text{cnt}[0]$, result $(m-k_{\min}, \text{cnt}[0])$.
\end{algosteps}
\OPTIMALITY{This DP enumerates all and only nonempty subsets of $S$ by inclusion/exclusion of each value once. The $64$ states capture all possible XORs; taking minima on cardinalities yields the smallest $k$, and counting under min-ties gives the number of minimum-size subsets. Early rules are provably optimal by Nim theory and parity arguments.}
\COMPLEXITY{Per query:}
\[
\begin{aligned}
T(\text{query}) &= O(51) + O(64\cdot |S|), \\
S(\text{query}) &= O(64).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
from array import array

MOD = 998244353

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    qs = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, qs

def build_prefix_counts(a: List[int]) -> List[array]:
    n = len(a)
    pref = [array('I', [0] * (n + 1)) for _ in range(51)]
    for v in range(51):
        cnt = pref[v]
        c = 0
        for i, x in enumerate(a, start=1):
            if x == v:
                c += 1
            cnt[i] = c
    return pref

def solve_all(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[str]:
    pref = build_prefix_counts(a)
    out = []
    for l, r in queries:
        m = r - l + 1
        c0 = pref[0][r] - pref[0][l - 1]
        if c0 > 0:
            out.append(f"{m - 1} {c0 % MOD}")
            continue
        sum_pairs = 0
        dup = False
        S = []
        for v in range(1, 51):
            cv = pref[v][r] - pref[v][l - 1]
            if cv >= 2:
                dup = True
                sum_pairs = (sum_pairs + (cv * (cv - 1) // 2)) % MOD
            elif cv == 1:
                S.append(v)
        if dup:
            out.append(f"{m - 2} {sum_pairs % MOD}")
            continue
        if not S:
            out.append("-1")
            continue
        INF = 10 ** 9
        dp_len = [INF] * 64
        dp_cnt = [0] * 64
        for v in S:
            new_len = dp_len[:]
            new_cnt = dp_cnt[:]
            # combine with existing nonempty subsets
            for x in range(64):
                if dp_len[x] != INF:
                    y = x ^ v
                    cand = dp_len[x] + 1
                    if cand < new_len[y]:
                        new_len[y] = cand
                        new_cnt[y] = dp_cnt[x]
                    elif cand == new_len[y]:
                        new_cnt[y] = (new_cnt[y] + dp_cnt[x]) % MOD
            # singleton {v}
            if 1 < new_len[v]:
                new_len[v] = 1
                new_cnt[v] = 1
            elif 1 == new_len[v]:
                new_cnt[v] = (new_cnt[v] + 1) % MOD
            dp_len, dp_cnt = new_len, new_cnt
        if dp_len[0] >= INF:
            out.append("-1")
        else:
            kmin = dp_len[0]
            out.append(f"{m - kmin} {dp_cnt[0] % MOD}")
    return out

def main():
    n, q, a, qs = read_input()
    ans = solve_all(n, q, a, qs)
    print("\n".join(ans))

if __name__ == "__main__":
    # Self-checks
    # 1) Simple zero present
    n, q = 3, 1
    a = [0, 5, 7]
    qs = [(1, 3)]
    assert solve_all(n, q, a, qs)[0] == "2 1"
    # 2) Duplicate pair
    a = [1, 1, 2]
    qs = [(1, 3)]
    assert solve_all(3, 1, a, qs)[0] == "1 1"
    # 3) No solution
    a = [1, 2, 4]
    qs = [(1, 3)]
    assert solve_all(3, 1, a, qs)[0] == "-1"
    # Ready for judge input
    main()
\end{minted}
\VALIDATION{Exactly three asserts included. They cover: (1) zero present $\Rightarrow k_{\min}=1$; (2) duplicate $\Rightarrow k_{\min}=2$; (3) all distinct nonzeros with no zero-XOR subset $\Rightarrow -1$.}
\RESULT{For each query, the first number is $m-k_{\min}$ (maximum removable), the second is the number of minimum-size zero-XOR subsets modulo $998{,}244{,}353$. Ties are naturally counted by the DP.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{
- Unit DP tests on tiny $S$ against brute force.
- Segment cases: only zeros; only one nonzero; one duplicate; many distinct nonzeros.
- Randomized small arrays ($n\le 12$) comparing Approach A vs C.}
\LINE{CROSS-CHECKS}{On tiny instances, verify that Approach A (brute) and Approach C (DP) produce identical outputs per query.}
\LINE{EDGE-CASE GENERATOR}{Generate segments with: (i) $c_0>0$; (ii) some $c_v\ge 2$; (iii) all distinct with/without a triple $a\oplus b=c$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import combinations
MOD = 998244353

def gen_all_distinct_nonzero_values(maxv=10):
    vals = list(range(1, maxv+1))
    return vals

def brute_min_k_and_ways(values):
    best = None
    ways = 0
    m = len(values)
    for mask in range(1, 1 << m):
        x = 0
        k = 0
        for i in range(m):
            if mask >> i & 1:
                x ^= values[i]
                k += 1
        if x == 0:
            if best is None or k < best:
                best = k
                ways = 1
            elif k == best:
                ways += 1
    if best is None:
        return (-1, 0)
    return (best, ways % MOD)

def dp_min_k_and_ways(values):
    INF = 10**9
    dp_len = [INF]*64
    dp_cnt = [0]*64
    for v in values:
        new_len = dp_len[:]
        new_cnt = dp_cnt[:]
        for x in range(64):
            if dp_len[x] != INF:
                y = x ^ v
                cand = dp_len[x] + 1
                if cand < new_len[y]:
                    new_len[y] = cand
                    new_cnt[y] = dp_cnt[x]
                elif cand == new_len[y]:
                    new_cnt[y] = (new_cnt[y] + dp_cnt[x]) % MOD
        if 1 < new_len[v]:
            new_len[v] = 1
            new_cnt[v] = 1
        elif 1 == new_len[v]:
            new_cnt[v] = (new_cnt[v] + 1) % MOD
        dp_len, dp_cnt = new_len, new_cnt
    if dp_len[0] >= INF:
        return (-1, 0)
    return (dp_len[0], dp_cnt[0] % MOD)

# Cross-check on small sets
vals = [1,2,3,4]
b = brute_min_k_and_ways(vals)
d = dp_min_k_and_ways(vals)
assert b == d
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
from array import array

MOD = 998244353

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    qs = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, qs

def build_prefix_counts(a: List[int]) -> List[array]:
    n = len(a)
    pref = [array('I', [0] * (n + 1)) for _ in range(51)]
    for v in range(51):
        cnt = pref[v]
        c = 0
        for i, x in enumerate(a, start=1):
            if x == v:
                c += 1
            cnt[i] = c
    return pref

def solve_all(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[str]:
    pref = build_prefix_counts(a)
    out = []
    for l, r in queries:
        m = r - l + 1
        c0 = pref[0][r] - pref[0][l - 1]
        if c0 > 0:
            out.append(f"{m - 1} {c0 % MOD}")
            continue
        sum_pairs = 0
        dup = False
        S = []
        for v in range(1, 51):
            cv = pref[v][r] - pref[v][l - 1]
            if cv >= 2:
                dup = True
                sum_pairs = (sum_pairs + (cv * (cv - 1) // 2)) % MOD
            elif cv == 1:
                S.append(v)
        if dup:
            out.append(f"{m - 2} {sum_pairs % MOD}")
            continue
        if not S:
            out.append("-1")
            continue
        INF = 10 ** 9
        dp_len = [INF] * 64
        dp_cnt = [0] * 64
        for v in S:
            new_len = dp_len[:]
            new_cnt = dp_cnt[:]
            for x in range(64):
                if dp_len[x] != INF:
                    y = x ^ v
                    cand = dp_len[x] + 1
                    if cand < new_len[y]:
                        new_len[y] = cand
                        new_cnt[y] = dp_cnt[x]
                    elif cand == new_len[y]:
                        new_cnt[y] = (new_cnt[y] + dp_cnt[x]) % MOD
            if 1 < new_len[v]:
                new_len[v] = 1
                new_cnt[v] = 1
            elif 1 == new_len[v]:
                new_cnt[v] = (new_cnt[v] + 1) % MOD
            dp_len, dp_cnt = new_len, new_cnt
        if dp_len[0] >= INF:
            out.append("-1")
        else:
            kmin = dp_len[0]
            out.append(f"{m - kmin} {dp_cnt[0] % MOD}")
    return out

def main():
    n, q, a, qs = read_input()
    ans = solve_all(n, q, a, qs)
    print("\n".join(ans))

if __name__ == "__main__":
    # Minimal asserts
    assert solve_all(3, 1, [0,5,7], [(1,3)])[0] == "2 1"
    assert solve_all(3, 1, [1,1,2], [(1,3)])[0] == "1 1"
    assert solve_all(3, 1, [1,2,4], [(1,3)])[0] == "-1"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the smallest nonempty subset on each segment whose XOR is $0$ and count how many such subsets exist.}
\WHY{This tests XOR linearity, parity arguments, and small-state DP — common in advanced interview and contest problems.}
\CHECKLIST{
- Compute per-value counts on the segment.
- If any zero exists: $k_{\min}=1$, ways $=c_0$.
- Else if any duplicate: $k_{\min}=2$, ways $=\sum \binom{c_v}{2}$.
- Else run $64$-state DP over distinct nonzero values to get $(k_{\min}, \text{ways})$.
- Output $(m-k_{\min}, \text{ways})$ or $-1$.}
\EDGECASES{
- Single-element segment $[0] \Rightarrow (0,1)$.
- Single-element segment $[x>0] \Rightarrow -1$.
- Multiple zeros: still $k_{\min}=1$; ways $=c_0$.
- Many duplicates but also distinct values: still $k_{\min}=2$ by picking any equal pair.
- All distinct nonzeros, but XOR of all is $0$: $k_{\min}$ could be large; DP finds it.
- No solution when set is linearly independent (size $\le 6$ but independent).}
\PITFALLS{
- Forgetting that a single $0$ is already losing for the first player.
- Counting pairs incorrectly: must be only equal-value pairs for XOR $0$.
- Double-counting in DP when updating in-place; always use a copy per iteration.
- Accidentally allowing the empty subset to influence the answer (keep DP over nonempty subsets).
- Overflow of counts if not modulo $998{,}244{,}353$.}
\FAILMODES{
- Brute force times out quickly.
- Per-target DP ($O(|S|^2)$) is slower than a single-pass $64$-state DP.
- Prefix memory in Python can be large; use compact arrays if needed.}
\ELI{First look for trivial wins: keep a $0$ or a duplicate pair. If none exist, there are only distinct nonzero values — then check all XORs up to $63$ with a small DP to find the shortest way to get XOR $0$, and count how many such shortest subsets there are.}
\NotePages{3}

\end{document}