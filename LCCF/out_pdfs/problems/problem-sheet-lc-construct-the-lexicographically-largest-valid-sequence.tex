% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Construct the Lexicographically Largest Valid Sequence}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an integer $n$, find a sequence with elements in the range $[1,n]$ that satisfies all of the following:
\begin{bullets}
\item The integer $1$ occurs once in the sequence.
\item Each integer between $2$ and $n$ occurs twice in the sequence.
\item For every integer $i$ between $2$ and $n$, the distance between the two occurrences of $i$ is exactly $i$.
\end{bullets}
The distance between two numbers in the sequence, $a[i]$ and $a[j]$, is the absolute difference of their indices, $|j-i|$.
Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.
A sequence $a$ is lexicographically larger than a sequence $b$ (of the same length) if, at the first position where $a$ and $b$ differ, $a$ has a number greater than the corresponding number in $b$. For example, $[0,1,9,0]$ is lexicographically larger than $[0,1,5,6]$ because the first position they differ is at the third number, and $9$ is greater than $5$.

Observations:
\begin{bullets}
\item The sequence length is $2n-1$ because the numbers $2,\ldots,n$ each appear twice and $1$ appears once.
\item Indices are $0$-based in the definition above.
\end{bullets}

Examples:
\begin{bullets}
\item Input: $n=3$; Output: $[3,1,2,3,2]$. Explanation: $[2,3,2,1,3]$ is also valid, but $[3,1,2,3,2]$ is lexicographically larger.
\item Input: $n=5$; Output: $[5,3,1,4,3,5,2,4,2]$.
\end{bullets}

Constraints: $1 \le n \le 20$.}
\BREAKDOWN{We must place numbers in a length-$2n-1$ array so that each $i \ge 2$ occupies two positions at distance exactly $i$, and $1$ occupies a single position, maximizing lexicographic order. Backtracking with pruning is natural: fill from left to right; at each empty index, try values in descending order if they fit.}
\ELI{Fill the array from left to right, always trying the biggest number you can legally place; backtrack when a choice blocks completion.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $1 \le n \le 20$.}
\OUTPUTS{A list of length $2n-1$ containing integers in $[1,n]$ that satisfies: $1$ appears once; each $2 \le i \le n$ appears twice; when $i \ge 2$, its two positions differ by exactly $i$. Among all valid lists, return the lexicographically largest one.}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input: $n=3$
\item Output: $[3,1,2,3,2]$
\end{bullets}
Example 2:
\begin{bullets}
\item Input: $n=5$
\item Output: $[5,3,1,4,3,5,2,4,2]$
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $m=2n-1$. Find $a \in [1,n]^m$ and a placement function such that:
\begin{bullets}
\item Exactly one index $p$ has $a_p=1$.
\item For each $i \in \{2,\ldots,n\}$, there exist indices $u_i,v_i$ with $0 \le u_i < v_i \le m-1$ such that $a_{u_i}=a_{v_i}=i$ and $v_i-u_i=i$.
\end{bullets}
Maximize $a$ in lexicographic order.}
\varmapStart
\var{n}{maximum label to place}
\var{m}{sequence length $2n-1$}
\var{a}{array of length $m$ to construct}
\var{u_i,v_i}{pair of positions for $i$ with $v_i-u_i=i$ for $i \ge 2$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
& a \in [1,n]^m,\quad m=2n-1,\\
& \#\{p: a_p=1\}=1,\\
& \forall i\in\{2,\ldots,n\}\ \exists u_i: 0\le u_i \le m-1-i,\ a_{u_i}=a_{u_i+i}=i,\\
& \text{Lexicographic maximality: } a \text{ is maximal under dictionary order among feasible arrays.}
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based. Feasibility is guaranteed for all $n$ in range. For $i \ge 2$, the pair placement consumes two slots at distance $i$.}
\INVARIANTS{
\begin{bullets}
\item While filling left to right, earlier fixed positions never change relative order; backtracking only undoes from the first unresolved index.
\item If a number $i>1$ is placed at index $p$, then index $p+i$ is also occupied immediately to preserve the distance constraint.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use depth-first backtracking from the first empty index; try numbers in ascending order $1,\ldots,n$ that legally fit. This explores the feasible space and yields a valid sequence but not necessarily the lexicographically largest.}
\ASSUMPTIONS{Pick the leftmost empty position each step. For $i>1$, placing $i$ at $p$ also places $i$ at $p+i$ if in-bounds and empty; for $i=1$, place a single $1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a$ with zeros of length $2n-1$; an array $used[1\ldots n]$ of booleans marking whether a number has been fully placed ($1$ once; $i\ge 2$ twice).
\item Recursively find the first index $p$ with $a[p]=0$. Try $x$ from $1$ to $n$:
  \begin{bullets}
  \item If $x=1$ and not $used[1]$, place $a[p]=1$.
  \item If $x\ge 2$, not $used[x]$, and $p+x<m$ with $a[p]=a[p+x]=0$, place $a[p]=a[p+x]=x$.
  \end{bullets}
\item Recurse; if success, propagate true; otherwise undo and try next $x$.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in the worst case due to combinatorial placements. Space $O(n)$ recursion depth plus $O(n)$ arrays.}
\[
\begin{aligned}
T(n) &\text{ is exponential; a crude bound is } T(n)=O(\alpha^n) \text{ for some } \alpha>1, \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Backtracking enumerates feasible placements and enforces the distance constraint at placement-time for $i\ge 2$. It stops at the first full assignment found.}
\EDGECASES{$n=1$ produces $[1]$. Ensure bounds for $p+i<m$ before pair placement.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2 * n - 1
        a = [0] * m
        used = [False] * (n + 1)

        def next_empty(idx: int) -> int:
            while idx < m and a[idx] != 0:
                idx += 1
            return idx

        def dfs(start_idx: int) -> bool:
            p = next_empty(start_idx)
            if p == m:
                return True
            for x in range(1, n + 1):  # ascending (baseline)
                if x == 1:
                    if not used[1]:
                        used[1] = True
                        a[p] = 1
                        if dfs(p + 1):
                            return True
                        a[p] = 0
                        used[1] = False
                else:
                    q = p + x
                    if not used[x] and q < m and a[p] == 0 and a[q] == 0:
                        used[x] = True
                        a[p] = a[q] = x
                        if dfs(p + 1):
                            return True
                        a[p] = a[q] = 0
                        used[x] = False
            return False

        ok = dfs(0)
        assert ok, "Feasibility guaranteed by problem statement."
        return a

# Tiny checks (baseline is valid but not lexicographically maximal)
b = Solution().constructDistancedSequence(3)
# Check validity constraints
def is_valid(arr: List[int], n: int) -> bool:
    from collections import Counter
    m = len(arr)
    if m != 2 * n - 1: return False
    if any(x < 1 or x > n for x in arr): return False
    c = Counter(arr)
    if c[1] != 1: return False
    for i in range(2, n + 1):
        if c[i] != 2: return False
        pos = [k for k, v in enumerate(arr) if v == i]
        if len(pos) != 2 or abs(pos[1] - pos[0]) != i: return False
    return True

assert is_valid(b, 3)
assert len(Solution().constructDistancedSequence(1)) == 1
\end{minted}
\VALIDATION{Checked length and constraints for $n=1$ and $n=3$. The baseline may produce a valid but not lexicographically largest sequence.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{To maximize lexicographic order and prune early, at each first empty index try candidates in descending order $n,n-1,\ldots,1$. For $x\ge 2$, place both positions at once; for $x=1$, place a single position. This greedy choice with backtracking yields the lexicographically largest solution.}
\ASSUMPTIONS{Always expand the leftmost empty index. When multiple placements are possible, larger $x$ dominates lexicographically if it can lead to a full solution.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Same state as baseline: array $a$ and boolean $used$.
\item At the first empty index $p$, iterate $x$ from $n$ down to $1$:
\begin{bullets}
\item If $x\ge 2$, require $p+x<m$ and $a[p]=a[p+x]=0$.
\item If $x=1$, require $\lnot used[1]$ and $a[p]=0$.
\end{bullets}
\item Place, recurse, and backtrack if needed. Return the first full solution encountered.
\end{algosteps}
\COMPLEXITY{Backtracking remains exponential in the worst case, but descending order plus pair placement prunes aggressively. Space remains $O(n)$.}
\[
\begin{aligned}
T(n) &\text{ is exponential but much smaller in practice due to greedy-first pruning,} \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Among all completions starting from position $p$, trying a larger feasible $x$ first yields lexicographically larger prefixes. Since we return the first successful completion, the final array is lexicographically maximal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2 * n - 1
        a = [0] * m
        used = [False] * (n + 1)

        def next_empty(idx: int) -> int:
            while idx < m and a[idx] != 0:
                idx += 1
            return idx

        def dfs(start_idx: int) -> bool:
            p = next_empty(start_idx)
            if p == m:
                return True
            # Try larger numbers first for lexicographic maximality
            for x in range(n, 0, -1):
                if x == 1:
                    if not used[1] and a[p] == 0:
                        used[1] = True
                        a[p] = 1
                        if dfs(p + 1):
                            return True
                        a[p] = 0
                        used[1] = False
                else:
                    q = p + x
                    if not used[x] and q < m and a[p] == 0 and a[q] == 0:
                        used[x] = True
                        a[p] = a[q] = x
                        if dfs(p + 1):
                            return True
                        a[p] = a[q] = 0
                        used[x] = False
            return False

        ok = dfs(0)
        assert ok, "Feasibility guaranteed"
        return a

# Checks: matches known outputs
s = Solution()
assert s.constructDistancedSequence(3) == [3, 1, 2, 3, 2]
assert s.constructDistancedSequence(1) == [1]
\end{minted}
\VALIDATION{Validated exact outputs for $n=1$ and $n=3$. For $n=5$, spot-check prefix and length:}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the same greedy-first backtracking but streamline state: a bitmask for used labels $2\ldots n$ and a separate flag for $1$; always expand the leftmost empty index and try $n\rightarrow 1$. This yields the lexicographically largest valid sequence and runs fast for $n \le 20$.}
\ASSUMPTIONS{Feasible for all $n$ in range; leftmost-first plus descending trials ensures the returned solution is the lexicographically maximum.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $m=2n-1$, $a=[0]^m$, $mask=0$ marking numbers $2\ldots n$ used, and $used1=False$.
\item Find the first empty index $p$.
\item For $x$ from $n$ down to $1$:
\begin{bullets}
\item If $x=1$ and not $used1$, place $a[p]=1$, set $used1=True$, recurse, then backtrack if needed.
\item If $x\ge 2$, require $p+x<m$ and $a[p]=a[p+x]=0$ and bit $x$ not in $mask$. Place both, set bit, recurse, and backtrack if needed.
\end{bullets}
\item Return upon first full assignment found.
\end{algosteps}
\OPTIMALITY{At each decision point, choosing the largest feasible $x$ yields the lexicographically largest prefix; any later deviation cannot improve earlier positions. Thus the first full solution encountered is globally optimal under lex order.}
\COMPLEXITY{Backtracking with strong pruning. Space $O(n)$, time exponential in worst case but efficient for $n \le 20$.}
\[
\begin{aligned}
T(n) &\approx \text{exponential with strong pruning; } S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2 * n - 1
        a = [0] * m
        used_mask = 0  # bits for 2..n
        used1 = False

        def is_used(x: int) -> bool:
            if x == 1:
                return used1
            return (used_mask >> x) & 1 == 1

        def set_used(x: int):
            nonlocal used_mask, used1
            if x == 1:
                used1 = True
            else:
                used_mask |= (1 << x)

        def unset_used(x: int):
            nonlocal used_mask, used1
            if x == 1:
                used1 = False
            else:
                used_mask &= ~(1 << x)

        def next_empty(idx: int) -> int:
            while idx < m and a[idx] != 0:
                idx += 1
            return idx

        def dfs(start_idx: int) -> bool:
            p = next_empty(start_idx)
            if p == m:
                return True
            for x in range(n, 0, -1):  # try larger first
                if x == 1:
                    if not is_used(1) and a[p] == 0:
                        a[p] = 1
                        set_used(1)
                        if dfs(p + 1):
                            return True
                        unset_used(1)
                        a[p] = 0
                else:
                    q = p + x
                    if not is_used(x) and q < m and a[p] == 0 and a[q] == 0:
                        a[p] = a[q] = x
                        set_used(x)
                        if dfs(p + 1):
                            return True
                        unset_used(x)
                        a[p] = a[q] = 0
            return False

        ok = dfs(0)
        assert ok
        return a

# Exactly 3 asserts (I/O mini-tests)
sol = Solution()
assert sol.constructDistancedSequence(3) == [3, 1, 2, 3, 2]
assert sol.constructDistancedSequence(1) == [1]
assert sol.constructDistancedSequence(5) == [5, 3, 1, 4, 3, 5, 2, 4, 2]
\end{minted}
\VALIDATION{Validated for $n \in \{1,3,5\}$ with exact sequences known from the statement.}
\RESULT{Returns the unique lexicographically largest valid sequence of length $2n-1$. Ties are broken implicitly by descending trial order; the first full completion is optimal.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on boundary $n=1$, small $n=2,3,4,5$, and random cross-checks. Validate constraints: counts per label and exact distances.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline (ascending DFS) and Optimal (descending DFS) for validity; confirm Optimal is lexicographically greater-or-equal and valid; on small $n$, both are valid and Optimal dominates.}
\LINE{EDGE-CASE GENERATOR}{Enumerate $n$ in $[1,8]$; verify validity predicate and lexicographic maximality by local swaps failing.}
\begin{minted}{python}
from typing import List
from collections import Counter

def is_valid(arr: List[int], n: int) -> bool:
    m = 2 * n - 1
    if len(arr) != m: return False
    if any(x < 1 or x > n for x in arr): return False
    c = Counter(arr)
    if c[1] != 1: return False
    for i in range(2, n + 1):
        if c[i] != 2: return False
        pos = [k for k, v in enumerate(arr) if v == i]
        if len(pos) != 2 or abs(pos[1] - pos[0]) != i: return False
    return True

class Baseline:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2 * n - 1
        a = [0] * m
        used = [False] * (n + 1)
        def next_empty(i: int) -> int:
            while i < m and a[i] != 0: i += 1
            return i
        def dfs(i: int) -> bool:
            p = next_empty(i)
            if p == m: return True
            for x in range(1, n + 1):
                if x == 1:
                    if not used[1]:
                        used[1] = True; a[p] = 1
                        if dfs(p + 1): return True
                        a[p] = 0; used[1] = False
                else:
                    q = p + x
                    if not used[x] and q < m and a[p] == 0 and a[q] == 0:
                        used[x] = True; a[p] = a[q] = x
                        if dfs(p + 1): return True
                        a[p] = a[q] = 0; used[x] = False
            return False
        assert dfs(0)
        return a

class Optimal:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2 * n - 1
        a = [0] * m
        used_mask, used1 = 0, False
        def is_used(x: int) -> bool:
            return used1 if x == 1 else ((used_mask >> x) & 1) == 1
        def set_used(x: int):
            nonlocal used_mask, used1
            if x == 1: used1 = True
            else: used_mask |= (1 << x)
        def unset_used(x: int):
            nonlocal used_mask, used1
            if x == 1: used1 = False
            else: used_mask &= ~(1 << x)
        def next_empty(i: int) -> int:
            while i < m and a[i] != 0: i += 1
            return i
        def dfs(i: int) -> bool:
            p = next_empty(i)
            if p == m: return True
            for x in range(n, 0, -1):
                if x == 1:
                    if not is_used(1) and a[p] == 0:
                        a[p] = 1; set_used(1)
                        if dfs(p + 1): return True
                        unset_used(1); a[p] = 0
                else:
                    q = p + x
                    if not is_used(x) and q < m and a[p] == 0 and a[q] == 0:
                        a[p] = a[q] = x; set_used(x)
                        if dfs(p + 1): return True
                        unset_used(x); a[p] = a[q] = 0
            return False
        assert dfs(0)
        return a

for n in range(1, 9):
    b = Baseline().constructDistancedSequence(n)
    o = Optimal().constructDistancedSequence(n)
    assert is_valid(b, n)
    assert is_valid(o, n)
    # Optimal must be lexicographically >= Baseline at first difference
    if b != o:
        i = next(i for i, (x, y) in enumerate(zip(b, o)) if x != y)
        assert o[i] > b[i]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2 * n - 1
        a = [0] * m
        used_mask = 0  # bits for 2..n
        used1 = False

        def is_used(x: int) -> bool:
            if x == 1:
                return used1
            return (used_mask >> x) & 1 == 1

        def set_used(x: int):
            nonlocal used_mask, used1
            if x == 1:
                used1 = True
            else:
                used_mask |= (1 << x)

        def unset_used(x: int):
            nonlocal used_mask, used1
            if x == 1:
                used1 = False
            else:
                used_mask &= ~(1 << x)

        def next_empty(idx: int) -> int:
            while idx < m and a[idx] != 0:
                idx += 1
            return idx

        def dfs(start_idx: int) -> bool:
            p = next_empty(start_idx)
            if p == m:
                return True
            for x in range(n, 0, -1):  # try larger labels first
                if x == 1:
                    if not is_used(1) and a[p] == 0:
                        a[p] = 1
                        set_used(1)
                        if dfs(p + 1):
                            return True
                        unset_used(1)
                        a[p] = 0
                else:
                    q = p + x
                    if not is_used(x) and q < m and a[p] == 0 and a[q] == 0:
                        a[p] = a[q] = x
                        set_used(x)
                        if dfs(p + 1):
                            return True
                        unset_used(x)
                        a[p] = a[q] = 0
            return False

        ok = dfs(0)
        assert ok
        return a

# Deterministic asserts
sol = Solution()
assert sol.constructDistancedSequence(1) == [1]
assert sol.constructDistancedSequence(3) == [3, 1, 2, 3, 2]
assert sol.constructDistancedSequence(5) == [5, 3, 1, 4, 3, 5, 2, 4, 2]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Place pairs at exact distances and a single $1$ to form the lexicographically largest array. Use descending-try backtracking from the leftmost empty slot.}
\WHY{Classic constraint placement with lexicographic optimization; tests pruning and recursion control common in interviews.}
\CHECKLIST{
\begin{bullets}
\item Compute $m=2n-1$ length.
\item At first empty index, try $n \rightarrow 1$.
\item For $x\ge 2$, ensure $p+x<m$ and both slots empty.
\item Place both slots for $x\ge 2$; single slot for $x=1$.
\item Recurse and backtrack cleanly.
\item Stop at first full fill.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ should return $[1]$.
\item Tight boundaries where $p+x=m-1$.
\item Long runs of filled cells; ensure next-empty scan works.
\item Avoid placing $1$ too early if a larger feasible number exists.
\item Ensure two occurrences for $i\ge 2$ exactly at distance $i$.
\item No out-of-bounds when computing $p+x$.
\item Distinguish between used once vs.\ twice: pairs must be placed simultaneously.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to place the paired position $p+i$ for $i\ge 2$.
\item Not undoing both positions or the used-flag on backtrack.
\item Trying ascending order, which may return a valid but not maximal sequence.
\item Off-by-one when checking $p+i<m$.
\item Searching next index incorrectly; must skip already-filled positions.
\item Sharing state across recursion without proper backtracking.
\item Treating $1$ like a pair and requiring a partner position.
\end{bullets}
}
\FAILMODES{Ascending trial order returns lexicographically smaller arrays. Greedy without backtracking can dead-end and miss feasibility. The descending-backtracking approach avoids these by exploring largest-first but backtracking when necessary.}
\ELI{Keep placing the biggest number you can at the first empty spot, putting its twin exactly $i$ positions away for $i\ge 2$. If you get stuck, undo and try the next biggest. This ensures the first full solution you find is the lexicographically largest.}
\NotePages{3}

\end{document}