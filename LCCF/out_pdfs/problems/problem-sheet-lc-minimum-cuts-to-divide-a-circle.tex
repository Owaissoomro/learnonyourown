% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Cuts to Divide a Circle}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-cuts-to-divide-a-circle/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{A \textbf{valid cut} in a circle can be:
\begin{bullets}
\item A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center (a diameter cut), or
\item A cut that is represented by a straight line that touches one point on the edge of the circle and its center (a radius cut).
\end{bullets}
Some valid and invalid cuts are shown in the figures below. Given the integer \texttt{n}, return the \emph{minimum} number of cuts needed to divide a circle into \texttt{n} equal slices.

\textbf{Example 1:}
\begin{verbatim}
Input: n = 4
Output: 2
Explanation:
The above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.
\end{verbatim}

\textbf{Example 2:}
\begin{verbatim}
Input: n = 3
Output: 3
Explanation:
At least 3 cuts are needed to divide the circle into 3 equal slices.
It can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.
Also note that the first cut will not divide the circle into distinct parts.
\end{verbatim}

\textbf{Constraints:}
\begin{bullets}
\item \(1 \le n \le 100\).
\end{bullets}}
\BREAKDOWN{Classify by parity of \(n\): a diameter cut yields two equal slices, while a radius cut yields one. Determine the least number of such cuts to form exactly \(n\) equal slices, considering the special case \(n=1\).}
\ELI{Diameters give slices two at a time, so odd \(n\) needs all \(n\) radius cuts; even \(n\) needs \(n/2\) diameters; and \(n=1\) needs no cut.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer \(n\) with \(1 \le n \le 100\).}
\OUTPUTS{A single integer: the minimum number of valid cuts needed to divide the circle into \(n\) equal slices.}
\SAMPLES{\begin{verbatim}
Input: n = 1
Output: 0
\end{verbatim}
\begin{verbatim}
Input: n = 6
Output: 3
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(f:\mathbb{Z}_{\ge 1}\to\mathbb{Z}_{\ge 0}\) map the number of equal slices \(n\) to the minimum number of valid cuts required. A valid cut is either a diameter (producing two equal slices) or a radius (producing one slice increment, with all slices equal by symmetry when evenly spaced).}
\varmapStart
\var{n}{target number of equal slices}
\var{f(n)}{minimum number of valid cuts needed}
\var{D}{count of diameter cuts used}
\var{R}{count of radius cuts used}
\varmapEnd
\GOVERN{
\[
f(n)=
\begin{cases}
0, & n=1,\\[2pt]
\tfrac{n}{2}, & n \text{ is even},\\[2pt]
n, & n \text{ is odd}.
\end{cases}
\]
}
\ASSUMPTIONS{Cuts are ideal straight lines through the center; all cuts can be positioned to produce equal angles. Mixing cut types is allowed; the objective is to minimize the total number of cuts while achieving exactly \(n\) equal sectors.}
\INVARIANTS{
\begin{bullets}
\item Any set of only diameter cuts yields an even number of equal slices.
\item One radius cut increases the number of equal slices by exactly 1 when evenly spaced around the center.
\item For \(n>1\), at least one cut is required; for odd \(n\), at least \(n\) radius-aligned cuts are necessary since diameters alone cannot realize odd \(n\).
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Iteratively reason by what each cut can produce: use diameters to gain slices in steps of 2; if \(n\) is odd, diameters cannot reach an odd total, so use \(n\) radius cuts instead; handle \(n=1\) as a zero-cut special case.}
\ASSUMPTIONS{We can always place cuts to evenly partition the circle as desired.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If \(n=1\), return \(0\).
\item If \(n\) is even, return \(n/2\) (use \(n/2\) diameters).
\item Otherwise, return \(n\) (use \(n\) radius cuts).
\end{algosteps}
\COMPLEXITY{Constant time and space.}
\[
\begin{aligned}
T(n) &= \Theta(1),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Diameters produce two equal sectors per cut, so \(n\) even is minimized by \(n/2\) diameters. Odd \(n\) cannot be achieved by any number of diameters; equally spaced radius cuts yield \(n\) equal slices and cannot be fewer than \(n\).}
\EDGECASES{\(n=1\) returns \(0\). Small even and odd \(n\) such as \(n=2,3\) behave as expected.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode 2481: Minimum Cuts to Divide a Circle
# Baseline direct logic with simple branching.

class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        if n % 2 == 0:
            return n // 2
        return n

# Basic asserts (deterministic; no I/O)
if __name__ == "__main__":
    s = Solution()
    assert s.numberOfCuts(1) == 0
    assert s.numberOfCuts(2) == 1
    assert s.numberOfCuts(3) == 3
    assert s.numberOfCuts(4) == 2
    assert s.numberOfCuts(6) == 3
    assert s.numberOfCuts(100) == 50
\end{minted}
\VALIDATION{Checked representative odd/even and boundary \(n=1\), \(n=100\).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use parity-based closed form directly derived from the governing piecewise definition; no loops or simulation.}
\ASSUMPTIONS{The minimality follows from the invariant that diameters contribute in twos and cannot realize odd counts, while radii can realize any \(n\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Return \(0\) if \(n=1\).
\item Return \(n/2\) if \(n\) is even.
\item Return \(n\) otherwise.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline but expressed in a single expression; still optimal.}
\[
\begin{aligned}
T(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Directly matches the proven piecewise function \(f(n)\).}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same signature; condensed conditional.

class Solution:
    def numberOfCuts(self, n: int) -> int:
        return 0 if n == 1 else (n // 2 if n % 2 == 0 else n)

# Asserts to verify correctness on diverse inputs
if __name__ == "__main__":
    s = Solution()
    for n, exp in [(1,0),(2,1),(3,3),(4,2),(5,5),(8,4),(9,9),(10,5)]:
        assert s.numberOfCuts(n) == exp
\end{minted}
\VALIDATION{Covers \(n=1\), small odds/evens, and larger evens/odds to ensure parity logic holds.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Closed-form parity-based piecewise: \(f(1)=0\); if \(n\) even, \(f(n)=n/2\); else \(f(n)=n\).}
\ASSUMPTIONS{All cuts are through the center; placements can be evenly spaced to guarantee equal slices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle \(n=1\) as a special case.
\item Use parity of \(n\) to select between \(n/2\) and \(n\).
\item Return the result.
\end{algosteps}
\OPTIMALITY{A cut adds at most two equal slices (diameter) or one (radius). For even \(n\), \(n/2\) diameters achieve the lower bound \(\lceil n/2\rceil\). For odd \(n\), each cut increases the slice count by at most 1 in odd states, so at least \(n\) cuts are required and sufficient via radii.}
\COMPLEXITY{Constant time and space.}
\[
\begin{aligned}
T(n) &= \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final reference submission for LC 2481.

class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        return n // 2 if n % 2 == 0 else n

# Exactly 3 asserts / mini-tests
if __name__ == "__main__":
    s = Solution()
    assert s.numberOfCuts(1) == 0
    assert s.numberOfCuts(4) == 2
    assert s.numberOfCuts(7) == 7
\end{minted}
\VALIDATION{Three spot checks: base case \(n=1\), even \(n=4\), odd \(n=7\).}
\RESULT{Return the minimal number of cuts as a non-negative integer, following the parity-based rule.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify the base case \(n=1\), small odds/evens, and upper bound \(n=100\). Additionally, cross-check that even \(n\) maps to \(n/2\) and odd \(n\) maps to \(n\).}
\LINE{CROSS-CHECKS}{Compare outputs across implementations (A/B/C) on a sweep \(n=1\) to \(100\); ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate values at boundaries and mixed parity to validate the piecewise mapping and guard against off-by-one errors.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

def generate_tests():
    # boundaries
    yield 1
    yield 2
    yield 3
    yield 100
    # mixed parity
    for n in [4,5,6,7,8,9,10,11,12,13]:
        yield n

def reference(n: int) -> int:
    if n == 1:
        return 0
    return n // 2 if n % 2 == 0 else n

class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        return n // 2 if n % 2 == 0 else n

if __name__ == "__main__":
    sol = Solution()
    for n in generate_tests():
        got = sol.numberOfCuts(n)
        exp = reference(n)
        assert got == exp, (n, got, exp)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final, self-contained solution with asserts (no external libs).

class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        return n // 2 if n % 2 == 0 else n

if __name__ == "__main__":
    s = Solution()
    # Sanity sweep for a few values
    for n, exp in [(1,0),(2,1),(3,3),(4,2),(6,3),(9,9),(10,5),(100,50)]:
        assert s.numberOfCuts(n) == exp
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Use parity: return \(0\) if \(n=1\); else \(n/2\) if even; else \(n\).}
\WHY{It tests recognizing constraints of allowed cuts and translating them into a tight piecewise function quickly.}
\CHECKLIST{
\begin{bullets}
\item Check \(n=1\) separately.
\item Check parity of \(n\).
\item Even \(n \Rightarrow n/2\) diameters.
\item Odd \(n \Rightarrow n\) radii.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item \(n=1\): no cut needed.
\item \(n=2\): one diameter cut.
\item \(n=3\): three radius cuts.
\item \(n=100\): fifty diameters.
\item Small odd \(n\) like \(5,7\): answer is \(n\).
\item Small even \(n\) like \(4,6\): answer is \(n/2\).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the \(n=1\) special case.
\item Assuming a diameter can contribute an odd slice increment.
\item Overcomplicating with simulation or geometry.
\item Returning \(\lceil n/2\rceil\) universally (fails at \(n=1\)).
\item Misinterpreting ``touches one point and its center'' as a chord not through the center.
\item Integer division mistakes for even \(n\).
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Approaches that only use diameters fail for odd \(n\).
\item Heuristics that use \(\lceil n/2\rceil\) without the base case yield \(1\) for \(n=1\) incorrectly.
\end{bullets}
}
\ELI{Diameters split the pie into pairs of slices; to get an odd number of equal slices you must cut along each slice, which takes \(n\) cuts. If you only want one slice (\(n=1\)), you do nothing.}
\NotePages{3}

\end{document}