% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Bitwise AND of Numbers Range}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/bitwise-and-of-numbers-range/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given two integers \texttt{left} and \texttt{right} that represent the range $[\texttt{left}, \texttt{right}]$, return the bitwise AND of all numbers in this range, inclusive.

Examples:

Input: \texttt{left = 5}, \texttt{right = 7}. Output: \texttt{4}.

Input: \texttt{left = 0}, \texttt{right = 0}. Output: \texttt{0}.

Input: \texttt{left = 1}, \texttt{right = 2147483647}. Output: \texttt{0}.

Constraints: $0 \le \texttt{left} \le \texttt{right} \le 2^{31}-1$.}
\BREAKDOWN{Compute $\bigwedge_{x=\texttt{left}}^{\texttt{right}} x$ efficiently. The key is that any bit that changes within the range becomes $0$ in the final AND; only the common high-order prefix of \texttt{left} and \texttt{right} survives.}
\ELI{Find the longest common prefix of \texttt{left} and \texttt{right} in binary and pad the rest with zeros.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: \texttt{left}, \texttt{right} with $0 \le \texttt{left} \le \texttt{right} \le 2^{31}-1$.}
\OUTPUTS{An integer equal to the bitwise AND of all integers from \texttt{left} to \texttt{right}, inclusive.}
\SAMPLES{Example A: \texttt{left=5}, \texttt{right=7} $\to 4$. Example B: \texttt{left=0}, \texttt{right=0} $\to 0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Define $f(\ell,r)=\bigwedge_{x=\ell}^{r} x$ for integers $0 \le \ell \le r \le 2^{31}-1$. This is the bitwise intersection across the range.}
\varmapStart
\var{\ell}{left endpoint (\texttt{left})}
\var{r}{right endpoint (\texttt{right})}
\var{k}{number of trailing bits that differ between $\ell$ and $r$}
\var{p}{the common prefix bits (as an integer) of $\ell$ and $r$}
\varmapEnd
\GOVERN{
\[
f(\ell,r)=
\begin{cases}
\ell, & \text{if } \ell=r,\\
p \ll k, & \text{where } p=\text{common\_prefix}(\ell,r)\ \text{and}\ k=\text{number of shifted steps until }\ell=r,\\
\end{cases}
\]
equivalently,
\begin{BreakableEquation*}
f(\ell,r)=\ell \mathbin{\&} r \text{ with all bits strictly below the highest differing bit cleared to }0.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Standard 32-bit non-negative integers; bitwise operations use two's complement but values are non-negative here.}
\INVARIANTS{If $\ell<r$, then at least one trailing bit flips within $[\ell,r]$, so the least significant set bit position of $r-\ell$ and below are zeroed in $f(\ell,r)$. Shifting both $\ell$ and $r$ right by one while $\ell<r$ preserves the common prefix above the least significant bit.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $\bigwedge_{x=\ell}^{r} x$ by iterating through every integer in the range and accumulating with bitwise AND.}
\ASSUMPTIONS{Range width $r-\ell$ is small enough to iterate without timeouts; suitable only for thought or tiny tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans \leftarrow \ell$.
\item For $x$ from $\ell+1$ to $r$: set $ans \leftarrow ans \mathbin{\&} x$.
\item Return $ans$.
\end{algosteps}
\COMPLEXITY{Time $T(n)=O(r-\ell+1)$, Space $S(n)=O(1)$.}
\[
\begin{aligned}
T &= (r-\ell) \text{ ANDs} = O(r-\ell+1),\\
S &= O(1).
\end{aligned}
\]
\CORRECTNESS{Bitwise AND is associative and commutative, so folding from left to right yields $\bigwedge_{x=\ell}^{r} x$.}
\EDGECASES{$\ell=r$ returns $\ell$. If $\ell=0$ the result is $0$. Early stopping optimization: if $ans$ ever becomes $0$, it remains $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        # Brute-force accumulation; correct but potentially slow for large ranges.
        ans = left
        x = left + 1
        while x <= right and ans != 0:
            ans &= x
            x += 1
        return ans

# Tiny sanity checks (baseline)
if __name__ == "__main__":
    s = Solution()
    assert s.rangeBitwiseAnd(5, 7) == 4
    assert s.rangeBitwiseAnd(0, 0) == 0
    assert s.rangeBitwiseAnd(1, 2147483647) == 0
\end{minted}
\VALIDATION{Checked the three examples from the statement. Add a small random-like check: for \texttt{left=6}, \texttt{right=11}, brute force equals 0.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Clear Bits by Shrinking Right (Brian Kernighan Idea)}
\WHICHFORMULA{While $r>\ell$, clear the least significant set bit of $r$ via $r \leftarrow r \mathbin{\&} (r-1)$. Any bit that toggles within $[\ell,r]$ cannot survive the range AND. Finally return $\ell \mathbin{\&} r$.}
\ASSUMPTIONS{Integers are non-negative; loop runs at most the number of set bits we need to clear until $r \le \ell$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item While $r>\ell$, set $r \leftarrow r \mathbin{\&} (r-1)$.
\item Return $\ell \mathbin{\&} r$.
\end{algosteps}
\COMPLEXITY{Runs in $O(b)$ where $b$ is the number of cleared set bits, bounded by word size (e.g., at most 31 for $2^{31}-1$). Space $O(1)$.}
\[
\begin{aligned}
T(n) &\le \text{number of bit positions} = O(\log V), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Each iteration removes a set bit in $r$ at or below the highest differing bit from $\ell$. When $r \le \ell$, all differing low bits are cleared. The AND with $\ell$ then equals the common prefix padded with zeros.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        # Shrink right by clearing its lowest set bits until it is <= left.
        r = right
        while r > left:
            r &= (r - 1)
        return left & r

# Checks (improved)
if __name__ == "__main__":
    s = Solution()
    assert s.rangeBitwiseAnd(5, 7) == 4
    assert s.rangeBitwiseAnd(0, 0) == 0
    assert s.rangeBitwiseAnd(1, 2147483647) == 0
\end{minted}
\VALIDATION{Edge-focused checks: \texttt{left=8}, \texttt{right=15} $\to 8$; \texttt{left=8}, \texttt{right=8} $\to 8$; \texttt{left=0}, any \texttt{right} $\to 0$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Shift Until Equal (Common Prefix Extraction)}
\WHICHFORMULA{Repeatedly right-shift both $\ell$ and $r$ until $\ell=r$, counting shifts $k$. The remaining value is the common prefix. Answer is $(\ell \gg k) \ll k$ which is simply $\ell \ll k$ after they match.}
\ASSUMPTIONS{Non-negative integers; the loop runs at most the bit-length of the numbers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $k \leftarrow 0$.
\item While $\ell<r$: set $\ell \leftarrow \ell \gg 1$, $r \leftarrow r \gg 1$, and increment $k$.
\item Return $\ell \ll k$.
\end{algosteps}
\OPTIMALITY{Each shift discards a bit known to be zero in the final result. We do at most the number of bits in the inputs, which is asymptotically optimal for word-RAM bit operations.}
\COMPLEXITY{Time $O(\log V)$ where $V$ is the max value (at most 31 iterations for $2^{31}-1$). Space $O(1)$.}
\[
\begin{aligned}
T(n) &\le \lfloor \log_2(V) \rfloor + 1, \\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        # Extract common prefix by shifting both ends until they are equal.
        shift = 0
        l, r = left, right
        while l < r:
            l >>= 1
            r >>= 1
            shift += 1
        return l << shift

# Exact 3 asserts (final)
if __name__ == "__main__":
    s = Solution()
    assert s.rangeBitwiseAnd(5, 7) == 4
    assert s.rangeBitwiseAnd(0, 0) == 0
    assert s.rangeBitwiseAnd(1, 2147483647) == 0
\end{minted}
\VALIDATION{Covers the given examples exactly.}
\RESULT{Return the integer equal to the common binary prefix of \texttt{left} and \texttt{right}, followed by zeros in all lower positions.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify examples; boundary cases like identical endpoints, power-of-two boundaries, fully covering an interval $[0, r]$; cross-validate multiple correct implementations.}
\LINE{CROSS-CHECKS}{Compare outputs of baseline, improved, and optimal on a small curated set and several random small ranges.}
\LINE{EDGE-CASE GENERATOR}{Generate tiny ranges within a small cap (e.g., up to 1024) and compare brute force vs. optimal; ensure coverage for ranges straddling powers of two and ranges of size one.}
\begin{minted}{python}
def brute_force(left: int, right: int) -> int:
    ans = left
    x = left + 1
    while x <= right and ans != 0:
        ans &= x
        x += 1
    return ans

def shrink_right(left: int, right: int) -> int:
    r = right
    while r > left:
        r &= (r - 1)
    return left & r

def shift_prefix(left: int, right: int) -> int:
    shift = 0
    l, r = left, right
    while l < r:
        l >>= 1
        r >>= 1
        shift += 1
    return l << shift

# Cross-checks
if __name__ == "__main__":
    tests = [
        (5, 7), (0, 0), (1, 2147483647), (8, 15), (8, 8), (9, 10), (6, 11),
        (0, 123), (123, 123), (1023, 2047), (2**16, 2**16 + 123)
    ]
    for L, R in tests:
        b = brute_force(L, min(R, L + 500)) if R - L <= 500 else shift_prefix(L, R)
        s1 = shrink_right(L, R)
        s2 = shift_prefix(L, R)
        if R - L <= 500:
            assert b == s1 == s2
        else:
            assert s1 == s2

class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        # Final reference: shift-until-equal (common prefix).
        shift = 0
        l, r = left, right
        while l < r:
            l >>= 1
            r >>= 1
            shift += 1
        return l << shift

# Reference asserts
if __name__ == "__main__":
    s = Solution()
    assert s.rangeBitwiseAnd(5, 7) == 4
    assert s.rangeBitwiseAnd(0, 0) == 0
    assert s.rangeBitwiseAnd(8, 15) == 8
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        shift = 0
        l, r = left, right
        while l < r:
            l >>= 1
            r >>= 1
            shift += 1
        return l << shift

if __name__ == "__main__":
    s = Solution()
    # Core examples
    assert s.rangeBitwiseAnd(5, 7) == 4
    assert s.rangeBitwiseAnd(0, 0) == 0
    assert s.rangeBitwiseAnd(1, 2147483647) == 0
    # Extra sanity
    assert s.rangeBitwiseAnd(8, 15) == 8
    assert s.rangeBitwiseAnd(9, 10) == 8
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the bitwise AND over an inclusive range by keeping only the common binary prefix of endpoints.}
\WHY{This is a canonical bit-manipulation task testing understanding of bit ranges, prefixes, and how toggling bits across a range zeroes them out in an AND.}
\CHECKLIST{Understand that any bit that flips in the range becomes $0$. Find highest differing bit, zero out below. Implement via right-shift loop or via clearing bits of \texttt{right}.}
\EDGECASES{Identical endpoints; \texttt{left}=0; wide ranges spanning powers of two; ranges just below a power of two; large upper bound near $2^{31}-1$; minimal range of length one.}
\PITFALLS{Iterating the full range causing timeouts; forgetting early stop when accumulator hits $0$ in brute force; off-by-one in loop bounds; mixing signed/unsigned in other languages; not handling \texttt{left=right}; shifting direction mistakes or not counting shifts properly.}
\FAILMODES{Baseline fails on huge spans; improved/optimal survive due to $O(\log V)$ iterations independent of span length.}
\ELI{Bits that change anywhere in the interval cannot survive the AND. Strip away changing low bits until only the shared high bits remain, then paste zeros back where we stripped.}
\NotePages{3}

\end{document}