% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Relative Ranks}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/relative-ranks/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an integer array \texttt{score} of size \texttt{n}, where \texttt{score[i]} is the score of the \texttt{ith} athlete in a competition. All the scores are guaranteed to be \textbf{unique}.

The athletes are \textbf{placed} based on their scores, where the \texttt{1st} place athlete has the highest score, the \texttt{2nd} place athlete has the \texttt{2nd} highest score, and so on. The placement of each athlete determines their rank:
\begin{bullets}
\item The \texttt{1st} place athlete's rank is \texttt{"Gold Medal"}.
\item The \texttt{2nd} place athlete's rank is \texttt{"Silver Medal"}.
\item The \texttt{3rd} place athlete's rank is \texttt{"Bronze Medal"}.
\item For the \texttt{4th} place to the \texttt{nth} place athlete, their rank is their placement number (i.e., the \texttt{xth} place athlete's rank is \texttt{"x"}).
\end{bullets}
Return an array \texttt{answer} of size \texttt{n} where \texttt{answer[i]} is the \textbf{rank} of the \texttt{ith} athlete.

Example 1:

\quad \textbf{Input:} \texttt{score = [5,4,3,2,1]}

\quad \textbf{Output:} \texttt{["Gold Medal","Silver Medal","Bronze Medal","4","5"]}

\quad \textbf{Explanation:} The placements are \texttt{[1st, 2nd, 3rd, 4th, 5th]}.

Example 2:

\quad \textbf{Input:} \texttt{score = [10,3,8,9,4]}

\quad \textbf{Output:} \texttt{["Gold Medal","5","Bronze Medal","Silver Medal","4"]}

\quad \textbf{Explanation:} The placements are \texttt{[1st, 5th, 3rd, 2nd, 4th]}.

Constraints:
\begin{bullets}
\item \texttt{n == score.length}
\item \texttt{1 \le n \le 10^4}
\item \texttt{0 \le score[i] \le 10^6}
\item All the values in \texttt{score} are \textbf{unique}.
\end{bullets}}
\BREAKDOWN{Map each athlete index to its placement when scores are sorted in descending order, then translate placements to medal strings for the top three and numeric strings for the rest.}
\ELI{Sort scores descending, give top three medals, others get their place number as a string, then put ranks back to original order.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer list \texttt{score} of length \texttt{n} with unique values, where \texttt{1 \le n \le 10^4} and \texttt{0 \le score[i] \le 10^6}.}
\OUTPUTS{A list of strings \texttt{answer} of length \texttt{n} where \texttt{answer[i]} is the rank string for the \texttt{ith} athlete in the original order. The top three ranks are exactly \texttt{"Gold Medal"}, \texttt{"Silver Medal"}, \texttt{"Bronze Medal"}; all others are the decimal placement number as a string.}
\SAMPLES{Example A: \texttt{score = [1]} produces \texttt{["Gold Medal"]}. Example B: \texttt{score = [7,7+3,7-2]} that is \texttt{[7,10,5]} produces \texttt{["Silver Medal","Gold Medal","Bronze Medal"]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n \in \mathbb{N}$ and scores $s_0,s_1,\ldots,s_{n-1} \in \mathbb{Z}$ be pairwise distinct. Define a strict total order on indices by $i \prec j$ iff $s_i > s_j$. Let $\pi$ be the permutation of indices sorting by decreasing score, i.e., $s_{\pi(0)} > s_{\pi(1)} > \cdots > s_{\pi(n-1)}$. Define rank position $p(i)$ as the unique $k$ with $\pi(k)=i$. The output string $r(i)$ is:
\[
r(i)=\begin{cases}
\text{"Gold Medal"}, & p(i)=0,\\
\text{"Silver Medal"}, & p(i)=1,\\
\text{"Bronze Medal"}, & p(i)=2,\\
\text{str}(p(i)+1), & \text{otherwise.}
\end{cases}
\]}
\varmapStart
\var{n}{number of athletes}
\var{s_i}{score of athlete $i$}
\var{\pi}{permutation of indices in descending score order}
\var{p(i)}{zero-based placement of athlete $i$}
\var{r(i)}{rank string assigned to athlete $i$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Find }\pi \text{ such that } s_{\pi(0)} > s_{\pi(1)} > \cdots > s_{\pi(n-1)},\quad p(\pi(k))=k,\quad r(i)\text{ as above.}
\end{BreakableEquation*}
}
\ASSUMPTIONS{All scores are unique, ensuring a strict total order and eliminating ties. Indices are $0$-based.}
\INVARIANTS{Scores remain unchanged; the permutation $\pi$ is a bijection on $\{0,\ldots,n-1\}$. If $s_i > s_j$ then $p(i) < p(j)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Repeatedly select the current maximum unassigned score by linear scan, assign the next placement, and mark it used.}
\ASSUMPTIONS{Uniqueness allows a well-defined maximum at every step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{ans} with empty strings; maintain a boolean array \texttt{used} of size \texttt{n}.
\item For placement from \texttt{1} to \texttt{n}, scan all indices to find the unused index with maximum score, assign its rank string, and mark it used.
\item Return \texttt{ans}.
\end{algosteps}
\COMPLEXITY{Each of the $n$ placements scans $n$ entries, so $T(n)=\Theta(n^2)$; extra space $S(n)=\Theta(n)$ for the output and flags.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} \Theta(n) \\
     &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{At each iteration, the unique maximum among unused indices is assigned the next placement; by induction, placements strictly follow descending scores.}
\EDGECASES{Single element; already sorted descending or ascending; large $n$ with strictly increasing values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        n = len(score)
        ans = [""] * n
        used = [False] * n

        def rank_str(place: int) -> str:
            if place == 1:
                return "Gold Medal"
            if place == 2:
                return "Silver Medal"
            if place == 3:
                return "Bronze Medal"
            return str(place)

        for place in range(1, n + 1):
            best_idx = -1
            best_val = -1
            for i, s in enumerate(score):
                if not used[i] and s > best_val:
                    best_val = s
                    best_idx = i
            used[best_idx] = True
            ans[best_idx] = rank_str(place)
        return ans

# Basic asserts (LC-style)
assert Solution().findRelativeRanks([5,4,3,2,1]) == ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
assert Solution().findRelativeRanks([10,3,8,9,4]) == ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
assert Solution().findRelativeRanks([1]) == ["Gold Medal"]
\end{minted}
\VALIDATION{Checked the two official examples and a singleton case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sort Indices by Score}
\WHICHFORMULA{Sort the indices once by descending score, then assign ranks in that order. This removes the repeated scanning.}
\ASSUMPTIONS{Python's Timsort runs in $O(n \log n)$ and is stable; uniqueness of scores means stability is not required.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a list of pairs \texttt{(score[i], i)} for all indices.
\item Sort the list in descending order by score.
\item Iterate the sorted list; at position \texttt{k} assign the corresponding medal or \texttt{str(k+1)} to \texttt{answer[i]}.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $T(n)=\Theta(n \log n)$, $S(n)=\Theta(n)$ for the pairs and output.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n).
\end{aligned}
\]
\CORRECTNESS{The sort produces exactly the permutation $\pi$ that orders by decreasing scores; assigning by index in that order yields the required ranks.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        n = len(score)
        order = sorted(range(n), key=lambda i: score[i], reverse=True)
        ans = [""] * n
        for k, i in enumerate(order, start=1):
            if k == 1:
                ans[i] = "Gold Medal"
            elif k == 2:
                ans[i] = "Silver Medal"
            elif k == 3:
                ans[i] = "Bronze Medal"
            else:
                ans[i] = str(k)
        return ans

# Checks on edge inputs
assert Solution().findRelativeRanks([1]) == ["Gold Medal"]
assert Solution().findRelativeRanks([2,1]) == ["Gold Medal","Silver Medal"]
assert Solution().findRelativeRanks([1,3,2]) == ["Bronze Medal","Gold Medal","Silver Medal"]
\end{minted}
\VALIDATION{Validated singleton, two items, and a small mixed case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Counting Buckets by Score Value}
\WHICHFORMULA{Exploit the bounded score range \texttt{0 \le score[i] \le 10^6}: map each possible score to its index, then sweep scores from max to min assigning placements in $O(U+n)$ time where $U$ is the maximum score plus one.}
\ASSUMPTIONS{Score bounds are moderate, so an array of length at most $10^6{+}1$ fits memory comfortably.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let \texttt{mx = max(score)}; allocate \texttt{pos = [-1] * (mx + 1)}.
\item For each index \texttt{i}, set \texttt{pos[score[i]] = i}.
\item Initialize \texttt{place = 1}. For \texttt{s} from \texttt{mx} down to \texttt{0}, if \texttt{pos[s] != -1}, assign the current \texttt{place} to that index's answer string, then increment \texttt{place}.
\end{algosteps}
\OPTIMALITY{Given the constraint bound on scores, the sweep is linear in the score universe size and visits exactly $n$ filled buckets. This yields optimal $O(n)$ in terms of comparisons and avoids sorting.}
\COMPLEXITY{$T(n)=\Theta(mx + n)$ and $S(n)=\Theta(mx + n)$, where \texttt{mx = max(score)}. With \texttt{mx \le 10^6}, both are practical.}
\[
\begin{aligned}
T(n) &= \Theta(\max(\text{score}) + 1) + \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        n = len(score)
        if n == 0:
            return []
        mx = max(score)
        pos = [-1] * (mx + 1)
        for i, s in enumerate(score):
            pos[s] = i
        ans = [""] * n
        place = 1
        for s in range(mx, -1, -1):
            i = pos[s]
            if i != -1:
                if place == 1:
                    ans[i] = "Gold Medal"
                elif place == 2:
                    ans[i] = "Silver Medal"
                elif place == 3:
                    ans[i] = "Bronze Medal"
                else:
                    ans[i] = str(place)
                place += 1
                if place > n:
                    break
        return ans

# Exactly 3 asserts
assert Solution().findRelativeRanks([5,4,3,2,1]) == ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
assert Solution().findRelativeRanks([10,3,8,9,4]) == ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
assert Solution().findRelativeRanks([100]) == ["Gold Medal"]
\end{minted}
\VALIDATION{Ran the two official examples and a singleton to verify medal mapping and placement assignment.}
\RESULT{Produces a list of rank strings in the original athlete order, with the exact medal labels for the top three and decimal strings otherwise.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: singleton, small arrays with distinct orderings, and the provided examples. Property checks: top three labels appear at most once and correspond to the three largest scores; numeric ranks are strictly increasing when following descending scores.}
\LINE{CROSS-CHECKS}{Compare outputs from Approaches A, B, and C on random arrays of small $n$ to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Create arrays of length $1$, $2$, $3$, and a few random cases with values near $0$ and near $10^6$ to ensure bucket boundaries are exercised.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_cases() -> List[List[int]]:
    random.seed(12345)
    cases = []
    cases.append([1])
    cases.append([2, 1])
    cases.append([1, 3, 2])
    cases.append([10, 3, 8, 9, 4])
    cases.append([5, 4, 3, 2, 1])
    # near bounds
    cases.append([0, 10**6, 500_000])
    # random small
    arr = list(range(1, 8))
    random.shuffle(arr)
    cases.append(arr)
    return cases

def solve_baseline(score: List[int]) -> List[str]:
    n = len(score)
    ans = [""] * n
    used = [False] * n
    def rs(p: int) -> str:
        return "Gold Medal" if p == 1 else "Silver Medal" if p == 2 else "Bronze Medal" if p == 3 else str(p)
    for place in range(1, n + 1):
        best = -1
        idx = -1
        for i, s in enumerate(score):
            if not used[i] and s > best:
                best = s; idx = i
        used[idx] = True
        ans[idx] = rs(place)
    return ans

def solve_sorted(score: List[int]) -> List[str]:
    n = len(score)
    ans = [""] * n
    order = sorted(range(n), key=lambda i: score[i], reverse=True)
    for k, i in enumerate(order, start=1):
        ans[i] = "Gold Medal" if k == 1 else "Silver Medal" if k == 2 else "Bronze Medal" if k == 3 else str(k)
    return ans

def solve_bucket(score: List[int]) -> List[str]:
    n = len(score)
    if n == 0:
        return []
    mx = max(score)
    pos = [-1] * (mx + 1)
    for i, s in enumerate(score):
        pos[s] = i
    ans = [""] * n
    place = 1
    for s in range(mx, -1, -1):
        i = pos[s]
        if i != -1:
            ans[i] = "Gold Medal" if place == 1 else "Silver Medal" if place == 2 else "Bronze Medal" if place == 3 else str(place)
            place += 1
            if place > n:
                break
    return ans

# Cross-check approaches on generated cases
for case in gen_cases():
    a = solve_baseline(case)
    b = solve_sorted(case)
    c = solve_bucket(case)
    assert a == b == c
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        # O(n log n) approach suitable for submission
        n = len(score)
        order = sorted(range(n), key=lambda i: score[i], reverse=True)
        ans = [""] * n
        for k, i in enumerate(order, start=1):
            if k == 1:
                ans[i] = "Gold Medal"
            elif k == 2:
                ans[i] = "Silver Medal"
            elif k == 3:
                ans[i] = "Bronze Medal"
            else:
                ans[i] = str(k)
        return ans

# Submission sanity asserts
assert Solution().findRelativeRanks([5,4,3,2,1]) == ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
assert Solution().findRelativeRanks([10,3,8,9,4]) == ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
assert Solution().findRelativeRanks([1]) == ["Gold Medal"]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort indices by score descending and assign medals for top three, numeric strings thereafter.}
\WHY{A classic mapping of order statistics to labels; tests sorting, indexing, and output formatting under time pressure.}
\CHECKLIST{%
\begin{bullets}
\item Pair or index the scores to preserve original positions.
\item Sort descending once.
\item Map positions 1, 2, 3 to medal strings.
\item Convert later positions to decimal strings.
\item Place results back into original index slots.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item \texttt{n = 1} should yield \texttt{["Gold Medal"]}.
\item \texttt{n = 2} should yield gold and silver only.
\item \texttt{n = 3} should yield all three medals.
\item Already descending scores.
\item Already ascending scores.
\item Scores with extreme values \texttt{0} and \texttt{10^6}.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to put ranks back to original indices.
\item Using $0$-based ranks without adding $1$ for numeric labels.
\item Misspelling medal strings or wrong capitalization.
\item Converting numbers to strings incorrectly for placements beyond three.
\item Assuming non-unique scores; ties do not occur here.
\item Using ascending instead of descending order by mistake.
\end{bullets}
}
\FAILMODES{Brute-force repeated max scans time out for large $n$; sorting or bucket sweep avoids quadratic behavior. Using heaps needs care to maintain index association.}
\ELI{Sort athletes by their scores from highest to lowest. Give the first three special medal names, and everyone else gets their place number as text. Put each person's label back where they started.}
\NotePages{3}

\end{document}