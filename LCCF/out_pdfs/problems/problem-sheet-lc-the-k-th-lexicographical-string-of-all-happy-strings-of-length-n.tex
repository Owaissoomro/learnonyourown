% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The k-th Lexicographical String of All Happy Strings of Length n}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{A happy string is a string that:
\begin{itemize}
\item consists only of letters of the set \texttt{['a', 'b', 'c']}.
\item $s[i] \ne s[i+1]$ for all values of $i$ from $1$ to $s.\text{length} - 1$ (string is 1-indexed).
\end{itemize}
For example, strings \texttt{"abc"}, \texttt{"ac"}, \texttt{"b"} and \texttt{"abcbabcbcb"} are all happy strings, and strings \texttt{"aa"}, \texttt{"baa"} and \texttt{"ababbc"} are not happy strings.

Given two integers $n$ and $k$, consider a list of all happy strings of length $n$ sorted in lexicographical order. Return the $k$th string of this list or return an empty string if there are fewer than $k$ happy strings of length $n$.

Examples:
\begin{itemize}
\item Input: $n=1$, $k=3$; Output: \texttt{"c"}. The list \texttt{["a","b","c"]} contains all happy strings of length $1$.
\item Input: $n=1$, $k=4$; Output: \texttt{""}. There are only $3$ happy strings of length $1$.
\item Input: $n=3$, $k=9$; Output: \texttt{"cab"}. There are $12$ happy strings of length $3$: \texttt{["aba","abc","aca","acb","bab","bac","bca","bcb","cab","cac","cba","cbc"]}. The $9$th is \texttt{"cab"}.
\end{itemize}
Constraints: $1 \le n \le 10$, $1 \le k \le 100$.}
\BREAKDOWN{Count how many happy strings start with each prefix and index into the lexicographically sorted set. If $k$ exceeds the total count $3 \cdot 2^{n-1}$, return the empty string. Otherwise, build the answer greedily by choosing each next character using subtree counts.}
\ELI{Treat the strings like a lex-ordered tree where each step has $2$ valid choices different from the previous character; jump to the $k$th leaf by counting how many leaves each branch has.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$ and $k$.
\begin{itemize}
\item $n$: desired length of the happy string; $1 \le n \le 10$.
\item $k$: 1-indexed position in lexicographic order; $1 \le k \le 100$.
\end{itemize}}
\OUTPUTS{A string over the alphabet $\{a,b,c\}$ of length $n$ with no equal adjacent characters, which is the $k$th in lexicographic order among all such strings; or the empty string \texttt{""} if fewer than $k$ exist.}
\SAMPLES{
\begin{itemize}
\item $n=1$, $k=3 \Rightarrow$ \texttt{"c"}.
\item $n=3$, $k=13 \Rightarrow$ \texttt{""} because there are only $3 \cdot 2^{2} = 12$ such strings.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{a,b,c\}$ and $H_n=\{s\in \Sigma^n: \forall i\in\{1,\ldots,n-1\},\, s_i\ne s_{i+1}\}$. Order $H_n$ lexicographically. Given $(n,k)$, return the $k$th element of $H_n$ if $k\le |H_n|$, otherwise return the empty string.}
\varmapStart
\var{n}{target length}
\var{k}{1-indexed rank}
\var{s}{answer string}
\var{\Sigma}{alphabet $\{a,b,c\}$}
\var{P}{current prefix during construction}
\var{T(n)}{total number of happy strings of length $n$}
\var{R}{remaining positions to fill}
\var{C}{count of strings under a branch}
\varmapEnd
\GOVERN{
\[
T(n)=\begin{cases}
0,& n=0 \\
3,& n=1 \\
3\cdot 2^{\,n-1},& n\ge 1
\end{cases}
\]
For any fixed last character, each next position has exactly $2$ choices (any letter in $\Sigma$ except the last one). For a prefix $P$ of length $\ell<n$, the number of completions is
\[
C(P)=
\begin{cases}
2^{\,n-\ell-1},& \ell\ge 1 \\
2^{\,n-1},& \ell=0 \text{ and we choose a specific first letter}
\end{cases}
\]
The greedy selection at position $\ell+1$ iterates allowed next letters in lexicographic order and subtracts block sizes $C(P)$ from $k$ until the block containing the target is found.
}
\ASSUMPTIONS{Lexicographic order uses the usual character order $a<b<c$. $k$ is 1-indexed. If $k>|H_n|$, the answer is the empty string.}
\INVARIANTS{
\begin{itemize}
\item At step $\ell$, the remaining search rank $k'$ is always within the total number of completions of the chosen prefix $P$.
\item The chosen next letter never equals the previous letter, maintaining happiness.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all happy strings in lexicographic order via DFS and stop at the $k$th. This follows directly from the definition and ordering.}
\ASSUMPTIONS{Since $n\le 10$, the worst-case number of strings is $3\cdot 2^{9}=1536$, which is small enough to generate straightforwardly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Depth-first search building strings from left to right, always appending the smallest valid next character first to respect lexicographic order.
\item Count how many complete strings of length $n$ have been produced; when the counter reaches $k$, return the current string.
\item If DFS ends before reaching $k$, return the empty string.
\end{algosteps}
\COMPLEXITY{In the worst case, generation visits all happy strings:
\[
\begin{aligned}
T(n) &= \Theta\!\left(3\cdot 2^{n-1}\right), \\
S(n) &= O(n) \text{ recursion depth}.
\end{aligned}
\]
}
\CORRECTNESS{Lexicographic DFS yields strings in sorted order because children are expanded in sorted character order. The counter ensures the $k$th yielded string is returned. The adjacency constraint is enforced at each step, so only happy strings are generated.}
\EDGECASES{When $k$ exceeds the total count, DFS finishes with no return; output is \texttt{""}. For $n=1$, it simply picks \texttt{a}, \texttt{b}, \texttt{c}.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        letters = ['a', 'b', 'c']
        self.count = 0
        self.ans = ""

        def dfs(curr: list):
            if self.ans:
                return  # early stop once found
            if len(curr) == n:
                self.count += 1
                if self.count == k:
                    self.ans = "".join(curr)
                return
            for ch in letters:
                if curr and ch == curr[-1]:
                    continue
                curr.append(ch)
                dfs(curr)
                curr.pop()

        dfs([])
        return self.ans

# Baseline asserts (LC-style)
if __name__ == "__main__":
    S = Solution()
    assert S.getHappyString(1, 3) == "c"
    assert S.getHappyString(1, 4) == ""
    assert S.getHappyString(3, 9) == "cab"
    # small sweep checks
    assert S.getHappyString(2, 1) == "ab"
    assert S.getHappyString(2, 6) == "cb"
\end{minted}
\VALIDATION{Checked against the provided examples and quick boundary sweeps for $n=2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy by Counting Subtree Sizes}
\WHICHFORMULA{Use counts of completions under each next-letter choice to jump directly to the $k$th string without enumerating all. Each branch at position $\ell$ has exactly $2^{n-\ell-1}$ leaves.}
\ASSUMPTIONS{Alphabet is fixed as $\{a,b,c\}$. Lexicographic order is $a<b<c$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $T=3\cdot 2^{n-1}$. If $k>T$, return \texttt{""}.
\item Convert to zero-based index $r=k-1$.
\item For position $0$ (first character), iterate $c\in[a,b,c]$; each has block size $B_0=2^{n-1}$. Choose the letter where $r<B_0$; otherwise set $r\leftarrow r-B_0$ and continue.
\item For each subsequent position $\ell\in[1,n-1]$, the allowed letters are $\Sigma\setminus\{s_{\ell-1}\}$ in lex order. Each candidate has block size $B_\ell=2^{n-\ell-1}$. Pick the first where $r<B_\ell$; otherwise decrement $r$ by $B_\ell$ and take the next.
\item Return the constructed string.
\end{algosteps}
\COMPLEXITY{Each of $n$ positions considers at most $3$ letters, so $O(n)$ time and $O(1)$ extra space. This asymptotically beats enumeration $O(2^n)$.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{By invariant, $r$ always points to the correct rank within the remaining subtree. Because blocks partition the lex order contiguously and have equal size at a fixed depth, subtracting full block sizes accurately identifies the next character.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        if n <= 0:
            return ""
        total = 3 * (1 << (n - 1))
        if k > total:
            return ""
        letters = ['a', 'b', 'c']
        r = k - 1  # zero-based rank
        ans = []

        # First position: three branches, each of size 2^(n-1)
        block = 1 << (n - 1)
        for ch in letters:
            if r < block:
                ans.append(ch)
                break
            r -= block

        # Subsequent positions: two branches (excluding previous char), each size 2^(remaining-1)
        for pos in range(1, n):
            block >>= 1  # each deeper level halves branch size
            prev = ans[-1]
            # order the two allowed letters lexicographically
            choices = [c for c in letters if c != prev]
            for ch in choices:
                if r < block:
                    ans.append(ch)
                    break
                r -= block

        return "".join(ans)

# Improved asserts
if __name__ == "__main__":
    S = Solution()
    assert S.getHappyString(1, 3) == "c"
    assert S.getHappyString(1, 4) == ""
    assert S.getHappyString(3, 9) == "cab"
    assert S.getHappyString(2, 1) == "ab"
    assert S.getHappyString(2, 6) == "cb"
    # full sweep for n=3 (12 items)
    expected = ["aba","abc","aca","acb","bab","bac","bca","bcb","cab","cac","cba","cbc"]
    for i, s in enumerate(expected, 1):
        assert S.getHappyString(3, i) == s
\end{minted}
\VALIDATION{Matched all examples and full spectrum for $n=3$ across all $12$ outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Bitwise Greedy with Precomputed Powers}
\WHICHFORMULA{Same greedy counting, using bit shifts for powers of $2$ and avoiding any list allocations in the inner loop. This is time- and space-optimal for the given constraints.}
\ASSUMPTIONS{Fixed small alphabet and $n\le 10$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k>3\cdot 2^{n-1}$, return \texttt{""}.
\item Use $r=k-1$ and a mutable array of chars sized $n$.
\item Maintain a bit-shifted block size starting at $1\ll(n-1)$ and halving per step.
\item At each position, iterate at most $3$ letters but skip the previous letter; choose by block subtraction.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must read $n$ to produce an $n$-length string, implying $\Omega(n)$ time. This approach achieves $O(n)$ time and $O(1)$ extra space, which is tight.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        total = 3 * (1 << (n - 1)) if n > 0 else 0
        if k > total or n <= 0:
            return ""
        letters = ('a', 'b', 'c')
        r = k - 1
        res = []

        block = 1 << (n - 1)
        # Choose first character
        for ch in letters:
            if r < block:
                res.append(ch)
                break
            r -= block

        # Choose remaining characters
        for pos in range(1, n):
            block >>= 1
            prev = res[-1]
            # iterate lex order skipping prev
            for ch in letters:
                if ch == prev:
                    continue
                if r < block:
                    res.append(ch)
                    break
                r -= block

        return "".join(res)

# Exactly 3 asserts
if __name__ == "__main__":
    S = Solution()
    assert S.getHappyString(3, 9) == "cab"
    assert S.getHappyString(1, 4) == ""
    assert S.getHappyString(4, 24) == "cbab"  # last among 3*2^3 = 24
\end{minted}
\VALIDATION{Covers example success, failure when $k$ exceeds total, and the maximal rank case for $n=4$.}
\RESULT{Returns the exact $k$th lexicographic happy string or \texttt{""} if $k>3\cdot 2^{n-1}$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test samples; sweep all $k$ for small $n$ to ensure ordering; cross-check greedy vs. brute force for $n\le 4$; verify boundary $k=1$ and $k=3\cdot 2^{n-1}$.}
\LINE{CROSS-CHECKS}{Generate all happy strings by DFS and compare each to the greedy output for every $k$; also verify total counts match $3\cdot 2^{n-1}$.}
\LINE{EDGE-CASE GENERATOR}{Cover $n=1$, smallest and largest $k$, and transitions across branches (e.g., from \texttt{"acb"} to \texttt{"bab"}).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def all_happy(n: int):
    res = []
    def dfs(cur):
        if len(cur) == n:
            res.append("".join(cur))
            return
        for ch in ['a', 'b', 'c']:
            if cur and ch == cur[-1]:
                continue
            cur.append(ch)
            dfs(cur)
            cur.pop()
    dfs([])
    return res

def kth_greedy(n: int, k: int) -> str:
    # mirror of the final solution
    total = 3 * (1 << (n - 1)) if n > 0 else 0
    if k > total or n <= 0:
        return ""
    letters = ('a','b','c')
    r = k - 1
    ans = []
    block = 1 << (n - 1)
    for ch in letters:
        if r < block:
            ans.append(ch)
            break
        r -= block
    for _ in range(1, n):
        block >>= 1
        prev = ans[-1]
        for ch in letters:
            if ch == prev:
                continue
            if r < block:
                ans.append(ch)
                break
            r -= block
    return "".join(ans)

if __name__ == "__main__":
    # Cross-check for n up to 4
    for n in range(1, 5):
        all_strings = all_happy(n)
        assert len(all_strings) == 3 * (1 << (n - 1))
        for k in range(1, len(all_strings) + 1):
            assert kth_greedy(n, k) == all_strings[k - 1]
    # Boundary checks
    assert kth_greedy(1, 1) == "a"
    assert kth_greedy(1, 3) == "c"
    assert kth_greedy(1, 4) == ""
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        total = 3 * (1 << (n - 1)) if n > 0 else 0
        if k > total or n <= 0:
            return ""
        letters = ('a', 'b', 'c')
        r = k - 1
        res = []
        block = 1 << (n - 1)
        for ch in letters:
            if r < block:
                res.append(ch)
                break
            r -= block
        for _ in range(1, n):
            block >>= 1
            prev = res[-1]
            for ch in letters:
                if ch == prev:
                    continue
                if r < block:
                    res.append(ch)
                    break
                r -= block
        return "".join(res)

if __name__ == "__main__":
    S = Solution()
    # Sanity suite
    assert S.getHappyString(3, 9) == "cab"
    assert S.getHappyString(1, 4) == ""
    assert S.getHappyString(4, 24) == "cbab"
    # Random-free exhaustive check for n=3
    expected = ["aba","abc","aca","acb","bab","bac","bca","bcb","cab","cac","cba","cbc"]
    for i, s in enumerate(expected, 1):
        assert S.getHappyString(3, i) == s
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Index into the lex-ordered tree of happy strings by subtracting equal-size blocks $2^{\text{remaining}-1}$ at each step.}
\WHY{Classic pattern: kth sequence under constraints with small alphabet and adjacency rules; appears in ranking/unranking problems and combinatorial generation.}
\CHECKLIST{
\begin{itemize}
\item Compute total $3\cdot 2^{n-1}$; early return if $k$ is too large.
\item Use zero-based rank $r=k-1$.
\item Maintain block size with shifts: start $1\ll(n-1)$ and halve each step.
\item Skip repeating the previous character.
\item Iterate allowed letters in lexicographic order.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $n=1$ with $k=1,2,3,4$.
\item Maximum $k=3\cdot 2^{n-1}$ should return the lexicographically last string.
\item Transition when previous is \texttt{'b'}: allowed are \texttt{'a'}, \texttt{'c'}.
\item Ensure empty string when $k$ is out of range.
\item Verify correctness for $n=2$ and all $6$ outputs.
\item Confirm stability for $n=10$ near upper bound $k=100$.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to convert $k$ to zero-based rank.
\item Using an incorrect block size at the first position (still $2^{n-1}$).
\item Iterating the two allowed letters in the wrong order.
\item Accidentally allowing the previous letter again.
\item Not halving the block size each step.
\item Overflow is not a concern here, but off-by-one in shifts is.
\end{itemize}
}
\FAILMODES{Brute-force approaches will still pass within constraints but do unnecessary work; incorrect ordering or block sizes will return the wrong string or raise index errors. The greedy counting method avoids both by construction.}
\ELI{All happy strings form a tidy tree: first choose \texttt{a}/\texttt{b}/\texttt{c}, then each time choose one of the two letters not equal to the last. Each branch has the same number of completions, so you can jump to the $k$th by skipping whole blocks at a time.}
\NotePages{3}

\end{document}