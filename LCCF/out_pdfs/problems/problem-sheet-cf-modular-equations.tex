% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Modular Equations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/495/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Last week, Hamed learned about a new type of equations in his math class called Modular Equations. Lets define $i \bmod j$ as the remainder of division of $i$ by $j$ and denote it by $i \bmod j$. A Modular Equation, as Hamed's teacher described, is an equation of the form $a \bmod x = b$ in which $a$ and $b$ are two non-negative integers and $x$ is a variable. We call a positive integer $x$ for which $a \bmod x = b$ a solution of our equation.

Hamed did not pay much attention to the class since he was watching a movie. He only managed to understand the definitions of these equations.

Now he wants to write his math exercises but since he has no idea how to do that, he asked you for help. He has told you all he knows about Modular Equations and asked you to write a program which given two numbers $a$ and $b$ determines how many answers the Modular Equation $a \bmod x = b$ has.

Input:
In the only line of the input two space-separated integers $a$ and $b$ ($0 \le a, b \le 10^9$) are given.

Output:
If there is an infinite number of answers to our equation, print \texttt{infinity}. Otherwise print the number of solutions of the Modular Equation $a \bmod x = b$.

Note:
In the first sample the answers of the Modular Equation are $8$ and $16$ since $21 \bmod 8 = 21 \bmod 16 = 5$.}
\BREAKDOWN{Reduce the congruence to a divisibility condition and a strict bound on $x$. Handle three cases: $a=b$ (infinite), $a<b$ (zero), and $a>b$ (count divisors of $a-b$ that exceed $b$.}
\ELI{The remainder equals $b$ exactly when $x$ divides $a-b$ and $x$ is bigger than $b$; count such $x$, with special-case $a=b$ as infinite and $a<b$ as impossible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single line with two integers $a, b$ such that $0 \le a, b \le 10^9$.}
\OUTPUTS{Print \texttt{infinity} if there are infinitely many positive integers $x$ with $a \bmod x = b$; otherwise print the finite count as a single integer.}
\SAMPLES{Example 1:
Input
21 5
Output
2

Example 2:
Input
10 10
Output
infinity}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a,b \in \mathbb{Z}_{\ge 0}$, count the number of $x \in \mathbb{Z}_{>0}$ such that $a \equiv b \pmod{x}$ and $0 \le b < x$.}
\varmapStart
\var{a}{given non-negative integer}
\var{b}{given non-negative integer}
\var{x}{positive integer variable}
\var{d}{difference $d=a-b$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
a \bmod x &= b \quad \Longleftrightarrow \quad
\begin{cases}
x \mid (a-b),\\
b < x.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Standard integer arithmetic; modulus is the non-negative remainder; $x$ is a positive integer.}
\INVARIANTS{
- If $a=b$, then for all $x>a$ we have $a \bmod x = a=b$ (infinitely many $x$).\\
- If $a<b$, then no $x$ exists because $a \bmod x \le a < b$.\\
- If $a>b$, writing $d=a-b>0$, every solution $x$ must be a divisor of $d$ and must satisfy $x>b$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the definition: try all $x$ and check $a \bmod x = b$. Bounds: if $a>b$, any valid $x$ must satisfy $x \le a$; if $a=b$, infinitely many; if $a<b$, none.}
\ASSUMPTIONS{Iterate $x$ from $b+1$ to $a$ when $a>b$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $a=b$, return \texttt{infinity}.
\item If $a<b$, return $0$.
\item Initialize count $c=0$. For each integer $x$ from $b+1$ to $a$ inclusive, increment $c$ if $a \bmod x = b$.
\end{algosteps}
\COMPLEXITY{In the worst case, iterates over $a-b$ values of $x$: $T(n)=\mathcal{O}(a-b)$, $S(n)=\mathcal{O}(1)$.}
\[
\begin{aligned}
T(a,b) &= \begin{cases}
\mathcal{O}(1), & a=b,\\
\mathcal{O}(1), & a<b,\\
\mathcal{O}(a-b), & a>b.
\end{cases}
\end{aligned}
\]
\CORRECTNESS{The loop checks all feasible $x$ because for $a>b$ any solution must have $x\le a$; filtering by $a \bmod x=b$ yields exactly the valid $x$.}
\EDGECASES{Handle $a=b$ as infinite, $a<b$ as zero; ensure $b=0$ counts divisors of $a$ correctly.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    parts = data.strip().split()
    if not parts:
        return None
    a, b = map(int, parts[:2])
    return a, b

def brute_count(a: int, b: int) -> str:
    if a == b:
        return "infinity"
    if a < b:
        return "0"
    c = 0
    # For a > b, any valid x must satisfy x <= a; also x > b.
    for x in range(b + 1, a + 1):
        if a % x == b:
            c += 1
    return str(c)

def solve_case(a: int, b: int) -> str:
    return brute_count(a, b)

def solve_all(data: str) -> str:
    inp = read_input(data)
    if inp is None:
        return ""
    a, b = inp
    return solve_case(a, b)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests for the baseline
        assert solve_all("21 5\n") == "2"
        assert solve_all("10 10\n") == "infinity"
        assert solve_all("5 7\n") == "0"
        assert solve_all("0 0\n") == "infinity"
        assert solve_all("0 1\n") == "0"
        print("OK")
    else:
        out = solve_all(data)
        sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Spot-checks: $(a,b)=(21,5)\to 2$, $(10,10)\to \texttt{infinity}$, $(5,7)\to 0$, $(0,0)\to \texttt{infinity}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized via Divisor Enumeration}
\WHICHFORMULA{From $a \bmod x = b$ derive $x \mid (a-b)$ and $x>b$. Count divisors of $d=a-b$ that are strictly greater than $b$ by iterating up to $\lfloor \sqrt{d} \rfloor$.}
\ASSUMPTIONS{For $a>b$, $d>0$. For each $i \mid d$, consider the pair $(i, d/i)$ and add those exceeding $b$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $a=b$, return \texttt{infinity}. If $a<b$, return $0$.
\item Set $d=a-b$. Initialize $c=0$.
\item For $i$ from $1$ to $\lfloor\sqrt{d}\rfloor$: if $i \mid d$, then:
  add $1$ if $i>b$; let $j=d//i$; if $j\ne i$ and $j>b$, add $1$.
\item Return $c$.
\end{algosteps}
\COMPLEXITY{Enumerating divisors up to $\sqrt{d}$ yields $T=\mathcal{O}(\sqrt{a-b})$, $S=\mathcal{O}(1)$, strictly better than the baseline when $a-b$ is large.}
\[
\begin{aligned}
T(a,b) &= \mathcal{O}\big(\sqrt{\max(1,a-b)}\big), \quad S(a,b)=\mathcal{O}(1).
\end{aligned}
\]
\CORRECTNESS{Equivalence $a \bmod x=b \Leftrightarrow x\mid (a-b)$ with $x>b$ ensures counting exactly the admissible divisors. Pairing $(i, d/i)$ avoids omission and double-counting.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import math

def read_input(data: str):
    parts = data.strip().split()
    if not parts:
        return None
    a, b = map(int, parts[:2])
    return a, b

def count_by_divisors(a: int, b: int) -> str:
    if a == b:
        return "infinity"
    if a < b:
        return "0"
    d = a - b
    c = 0
    r = int(math.isqrt(d))
    for i in range(1, r + 1):
        if d % i == 0:
            j = d // i
            if i > b:
                c += 1
            if j != i and j > b:
                c += 1
    return str(c)

def solve_case(a: int, b: int) -> str:
    return count_by_divisors(a, b)

def solve_all(data: str) -> str:
    inp = read_input(data)
    if inp is None:
        return ""
    a, b = inp
    return solve_case(a, b)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests for the improved version
        assert solve_all("21 5\n") == "2"       # divisors of 16 greater than 5: {8,16}
        assert solve_all("10 10\n") == "infinity"
        assert solve_all("5 7\n") == "0"
        assert solve_all("0 0\n") == "infinity"
        assert solve_all("0 1\n") == "0"
        assert solve_all("100 0\n") == "9"      # all divisors of 100
        assert solve_all("20 10\n") == "0"      # d=10; no divisor > 10
        print("OK")
    else:
        out = solve_all(data)
        sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge inputs: $a=b=0 \Rightarrow \texttt{infinity}$; $a=0,b>0 \Rightarrow 0$; $b=0$ counts all positive divisors of $a$; large $a-b$ handled in $\mathcal{O}(\sqrt{a-b})$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Tight Divisor Counting with Early Guards}
\WHICHFORMULA{Same divisor characterization with constant-time guards: if $a=b$ then \texttt{infinity}; if $a<b$ then $0$; else count divisors of $d=a-b$ that exceed $b$.}
\ASSUMPTIONS{Standard integer arithmetic; use integer square root to avoid floating error; handle perfect squares carefully.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $a=b$, print \texttt{infinity}. If $a<b$, print $0$.
\item Let $d=a-b>0$. For $i=1$ to $\lfloor \sqrt{d} \rfloor$:
  if $i \mid d$, consider $i$ and $j=d/i$ and add those strictly $>b$.
\item Output the total count.
\end{algosteps}
\OPTIMALITY{Any algorithm must at least inspect the prime-power structure of $d$ to count its divisors; iterating to $\lfloor\sqrt{d}\rfloor$ is optimal up to constant factors without precomputation.}
\COMPLEXITY{$T(a,b)=\mathcal{O}(\sqrt{a-b})$, $S(a,b)=\mathcal{O}(1)$.}
\[
\begin{aligned}
T(a,b) &= \Theta\!\big(\sqrt{a-b}\big)\ \text{in the worst case},\qquad S(a,b)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import math

def read_input(data: str):
    parts = data.strip().split()
    if not parts:
        return None
    a, b = map(int, parts[:2])
    return a, b

def solve_case(a: int, b: int) -> str:
    if a == b:
        return "infinity"
    if a < b:
        return "0"
    d = a - b
    ans = 0
    r = int(math.isqrt(d))
    for i in range(1, r + 1):
        if d % i == 0:
            j = d // i
            if i > b:
                ans += 1
            if j != i and j > b:
                ans += 1
    return str(ans)

def solve_all(data: str) -> str:
    inp = read_input(data)
    if inp is None:
        return ""
    a, b = inp
    return solve_case(a, b)

def _self_test():
    # Exactly 3 asserts as requested
    assert solve_all("21 5\n") == "2"
    assert solve_all("10 10\n") == "infinity"
    assert solve_all("5 7\n") == "0"

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        print("OK")
    else:
        out = solve_all(data)
        sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three mini-tests: 21 5 -> 2; 10 10 -> infinity; 5 7 -> 0.}
\RESULT{Print \texttt{infinity} if $a=b$; otherwise count divisors $x$ of $a-b$ with $x>b$ and print that integer.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover special cases ($a=b$, $a<b$, $b=0$) and typical cases. Property: for $b=0$, result equals the divisor count of $a$.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final for random small pairs $(a,b)$ with $0\le a,b\le 200$ by brute force agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate $(a,b)$ over boundaries: $(0,0)$, $(0,1)$, $(1,0)$, $(b,b)$, $(b-1,b)$, primes/composites for $a-b$.}
\begin{minted}{python}
import random
import math

def brute_count(a: int, b: int) -> str:
    if a == b:
        return "infinity"
    if a < b:
        return "0"
    c = 0
    for x in range(b + 1, a + 1):
        if a % x == b:
            c += 1
    return str(c)

def fast_count(a: int, b: int) -> str:
    if a == b:
        return "infinity"
    if a < b:
        return "0"
    d = a - b
    ans = 0
    r = int(math.isqrt(d))
    for i in range(1, r + 1):
        if d % i == 0:
            j = d // i
            if i > b:
                ans += 1
            if j != i and j > b:
                ans += 1
    return str(ans)

def property_tests():
    # Deterministic seed
    random.seed(0)
    # Boundaries
    cases = [(0,0),(0,1),(1,0),(10,10),(21,5),(100,0),(20,10)]
    for a,b in cases:
        assert fast_count(a,b) == brute_count(a,b)
    # Random small cases
    for a in range(0, 201):
        for b in range(0, 201):
            assert fast_count(a,b) == brute_count(a,b)
    return "OK"

if __name__ == "__main__":
    print(property_tests())
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
import math

def read_input(data: str):
    parts = data.strip().split()
    if not parts:
        return None
    a, b = map(int, parts[:2])
    return a, b

def solve_case(a: int, b: int) -> str:
    if a == b:
        return "infinity"
    if a < b:
        return "0"
    d = a - b
    ans = 0
    r = int(math.isqrt(d))
    for i in range(1, r + 1):
        if d % i == 0:
            j = d // i
            if i > b:
                ans += 1
            if j != i and j > b:
                ans += 1
    return str(ans)

def solve_all(data: str) -> str:
    inp = read_input(data)
    if inp is None:
        return ""
    a, b = inp
    return solve_case(a, b)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Sanity self-checks
        assert solve_all("21 5\n") == "2"
        assert solve_all("10 10\n") == "infinity"
        assert solve_all("5 7\n") == "0"
        print("OK")
    else:
        sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count divisors of $a-b$ that are strictly greater than $b$, with $a=b$ giving infinite and $a<b$ giving zero.}
\WHY{A classic modular-arithmetic reduction; appears often in number theory counting and CF Div.~2 C/D tasks.}
\CHECKLIST{
- Check guards: $a=b \Rightarrow \texttt{infinity}$, $a<b \Rightarrow 0$.
- Set $d=a-b$ and iterate up to $\lfloor\sqrt{d}\rfloor$.
- For each divisor pair $(i,d/i)$, add those $>b$.
- Handle perfect square without double-counting.
- Ensure strict inequality $x>b$.}
\EDGECASES{
- $a=b=0$.
- $a=0$, $b>0$.
- $b=0$ (count all positive divisors of $a$).
- $a=b+1$ (small $d$).
- $d$ is a perfect square.
- $b$ very large relative to $d$ (often zero solutions).
- $a$ prime and $b=0$.}
\PITFALLS{
- Forgetting the strict $x>b$ condition (e.g., counting $x=b$).
- Double-counting when $d$ is a perfect square.
- Using floating sqrt and off-by-one; prefer integer square root.
- Missing the $a=b$ infinite case.
- Assuming $x$ can exceed $a$ when $a>b$ (it cannot).
- Overflow is not an issue in Python, but be careful in other languages.}
\FAILMODES{Brute force over $x$ up to $a$ times out when $a$ is large; the divisor method remains fast for $a-b$ up to $10^9$.}
\ELI{We just look at the difference $d=a-b$: every valid modulus $x$ must divide $d$ and be bigger than $b$. Count those divisors, with a special infinite case when $a=b$ and a zero case when $a<b$.}
\NotePages{3}

\end{document}