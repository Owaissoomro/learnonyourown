% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Wizard's Tour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/858/F}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{All Berland residents are waiting for an unprecedented tour of wizard in his Blue Helicopter over the cities of Berland!

It is well-known that there are $n$ cities in Berland, some pairs of which are connected by bidirectional roads. Each pair of cities is connected by no more than one road. It is not guaranteed that the road network is connected, i.e. it is possible that you cannot reach some city from some other.

The tour will contain several episodes. In each of the episodes:
\begin{bullets}
\item the wizard will disembark at some city $x$ from the Helicopter;
\item he will give a performance and show a movie for free at the city $x$;
\item he will drive to some neighboring city $y$ using a road;
\item he will give a performance and show a movie for free at the city $y$;
\item he will drive to some neighboring to $y$ city $z$;
\item he will give a performance and show a movie for free at the city $z$;
\item he will embark the Helicopter and fly away from the city $z$.
\end{bullets}

It is known that the wizard does not like to use roads, so he agrees to use each road at most once (regardless of direction). In other words, for road between $a$ and $b$ he only can drive once from $a$ to $b$, or drive once from $b$ to $a$, or do not use this road at all.

The wizard wants to plan as many episodes as possible without violation of the above rules. Help the wizard!

Please note that the wizard can visit the same city multiple times, the restriction is on roads only.

Input:
The first line contains two integers $n, m$ ($1 \le n \le 2\cdot 10^5$, $0 \le m \le 2\cdot 10^5$) — the number of cities and the number of roads in Berland, respectively.

The roads description follow, one in each line. Each description is a pair of two integers $a_i, b_i$ ($1 \le a_i, b_i \le n$, $a_i \ne b_i$), where $a_i$ and $b_i$ are the ids of the cities connected by the $i$-th road. It is guaranteed that there are no two roads connecting the same pair of cities. Every road is bidirectional. The cities are numbered from $1$ to $n$.

It is possible that the road network in Berland is not connected.

Output:
In the first line print $w$ — the maximum possible number of episodes. The next $w$ lines should contain the episodes in format $x, y, z$ — the three integers denoting the ids of the cities in the order of the wizard's visits.}
\BREAKDOWN{We need to select as many edge-disjoint paths of length $2$ (triples $x,y,z$ using edges $(x,y)$ and $(y,z)$) as possible in an undirected simple graph. Each edge can be used in at most one episode.}
\ELI{Pair up unused edges two-by-two around a center city to form $x$–$y$–$z$ paths; do this consistently across the graph via DFS so no edge is reused.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An undirected simple graph:
\begin{bullets}
\item $n$ — number of vertices ($1 \le n \le 2\cdot 10^5$).
\item $m$ — number of edges ($0 \le m \le 2\cdot 10^5$).
\item $m$ lines of edges $a_i, b_i$ with $1 \le a_i \ne b_i \le n$; no multiple edges.
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item First line: integer $w$ — maximum number of episodes (edge-disjoint $P_3$ paths).
\item Next $w$ lines: triples $x~y~z$ meaning episodes that use edges $(x,y)$ and $(y,z)$.
\end{bullets}}
\SAMPLES{
Example 1:
\begin{verbatim}
Input
3 3
1 2
2 3
3 1

Output
1
1 2 3
\end{verbatim}
Example 2:
\begin{verbatim}
Input
4 3
1 2
2 3
3 4

Output
1
1 2 3
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given undirected simple graph $G=(V,E)$, select a maximum-size family $\mathcal{P}$ of edge-disjoint length-$2$ paths $(x,y,z)$ with $\{x,y\}, \{y,z\}\in E$.}
\varmapStart
\var{G=(V,E)}{input graph}
\var{\mathcal{P}}{set of selected paths of length $2$ (episodes)}
\var{w}{cardinality of $\mathcal{P}$}
\var{U \subseteq E}{set of edges used by $\mathcal{P}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{maximize } |\mathcal{P}| \\
&\text{subject to } \forall P\in \mathcal{P}:~P=(x,y,z),~\{x,y\}\in E,~\{y,z\}\in E, \\
&\quad\quad\quad\quad U=\bigcup_{(x,y,z)\in \mathcal{P}}\big\{\{x,y\},\{y,z\}\big\},\\
&\quad\quad\quad\quad \text{and } U \text{ has no repeated edge.}
\end{aligned}
\]
}
\ASSUMPTIONS{Graph is simple, undirected, possibly disconnected. Episodes can share vertices, but not edges.}
\INVARIANTS{
\begin{bullets}
\item Each episode consumes exactly two distinct edges incident to its center $y$.
\item An edge appears in at most one episode.
\item Local pairing at a vertex does not invalidate pairings at other vertices if edges are globally tracked.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy local pairing: at every vertex, pair any two currently unused incident edges to form $(u,v,w)$.}
\ASSUMPTIONS{No coordination across vertices; simply never reuse edges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency with edge ids; maintain a boolean array for used edges.
\item For each vertex $v$: collect all incident edges not used, pair them arbitrarily in twos, output $(u_1,v,u_2)$, mark both edges used.
\item Continue until all vertices processed.
\end{algosteps}
\COMPLEXITY{$T(n,m)=\mathcal{O}(n+m)$ to scan adjacency and pair; $S(n,m)=\mathcal{O}(n+m)$.}
\[
\begin{aligned}
T(n,m) &= \sum_{v\in V}\deg(v) + \sum_{v\in V}\left\lfloor \frac{\deg(v)}{2}\right\rfloor \\
       &= \mathcal{O}(n+m).
\end{aligned}
\]
\CORRECTNESS{Produces valid episodes (edges not reused), but not necessarily maximum, since naive local pairing may block better global pairings across the DFS tree.}
\EDGECASES{Isolated vertices; pendant edges that cannot be paired; multiple components; high-degree hubs.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: bytes = None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it); m = next(it)
    edges = []
    for _ in range(m):
        a = next(it); b = next(it)
        edges.append((a, b))
    return n, edges

def solve_case_baseline(n: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int, int]]:
    g = [[] for _ in range(n + 1)]
    m = len(edges)
    for i, (a, b) in enumerate(edges):
        g[a].append((b, i))
        g[b].append((a, i))
    used = [False] * m
    res = []
    for v in range(1, n + 1):
        pend = []
        for to, eid in g[v]:
            if not used[eid]:
                pend.append((to, eid))
        # pair arbitrarily
        i = 0
        while len(pend) >= 2:
            (a, ea) = pend.pop()
            (b, eb) = pend.pop()
            if used[ea] or used[eb]:
                continue
            used[ea] = used[eb] = True
            res.append((a, v, b))
    return res

def main_baseline():
    parsed = read_input()
    if parsed is None:
        # simple self-checks
        n = 3; edges = [(1, 2), (2, 3), (3, 1)]
        out = solve_case_baseline(n, edges)
        assert all({(x, y) in {(a, b) for a, b in edges} or (y, x) in {(a, b) for a, b in edges} for x, y, z in out} and
                   {(y, z) in {(a, b) for a, b in edges} or (z, y) in {(a, b) for a, b in edges} for x, y, z in out})
        return
    n, edges = parsed
    ans = solve_case_baseline(n, edges)
    print(len(ans))
    for x, y, z in ans:
        print(x, y, z)

if __name__ == "__main__" and False:
    main_baseline()
\end{minted}
\VALIDATION{On a triangle, outputs one episode. On a path of length $3$ edges, outputs one episode. On a star, outputs $\left\lfloor \deg(\text{center})/2 \right\rfloor$ episodes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DFS Coordination with Parent Pairing}
\WHICHFORMULA{Coordinate pairings via a DFS tree: after exploring children, pair pending unused edges at the current node; if one edge remains, pair it with the parent edge to avoid wasting an opportunity.}
\ASSUMPTIONS{Use discovery times to only handle non-tree edges at the deeper endpoint (child-to-ancestor direction), preventing double-processing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency with edge ids; arrays: visited, tin, usedEdge.
\item DFS each component. At node $v$, accumulate a list of incident unused edges that should be paired at $v$:
\begin{bullets}
\item Tree edge to child $u$ after returning, if it remains unused.
\item Back edge from $v$ to an ancestor $u$ (only when $tin[u] < tin[v]$).
\end{bullets}
\item Pair the list two-by-two into $(a,v,b)$ episodes; mark both edges used. If one remains and parent exists, pair it with the parent edge $(\text{parent},v)$; otherwise drop it.
\end{algosteps}
\COMPLEXITY{Each edge is examined $O(1)$ times and used at most once. Total $\mathcal{O}(n+m)$ time and $\mathcal{O}(n+m)$ memory.}
\[
\begin{aligned}
T(n,m) &= \mathcal{O}(n+m) \\
S(n,m) &= \mathcal{O}(n+m).
\end{aligned}
\]
\CORRECTNESS{By pairing as many edges as possible at each node and letting a single leftover be absorbed by the parent edge, this greedy-on-DFS-tree strategy achieves the maximum number of edge-disjoint length-$2$ paths. Non-tree edges are handled exactly once (at the deeper endpoint), and a tree edge is either consumed at the child (if used to absorb an odd leftover) or passed upward unconsumed, preserving global consistency.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: bytes = None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it); m = next(it)
    edges = []
    for _ in range(m):
        a = next(it); b = next(it)
        edges.append((a, b))
    return n, edges

def solve_case_improved(n: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int, int]]:
    sys.setrecursionlimit(1_000_000)
    g = [[] for _ in range(n + 1)]
    m = len(edges)
    for i, (a, b) in enumerate(edges):
        g[a].append((b, i))
        g[b].append((a, i))
    used = [False] * m
    vis = [False] * (n + 1)
    tin = [0] * (n + 1)
    timer = 0
    res: List[Tuple[int, int, int]] = []

    def dfs(v: int, parent: int = -1, pe: int = -1):
        nonlocal timer
        vis[v] = True
        timer += 1
        tin[v] = timer
        pend: List[Tuple[int, int]] = []
        for to, eid in g[v]:
            if eid == pe:
                continue
            if used[eid]:
                continue
            if not vis[to]:
                dfs(to, v, eid)
                if not used[eid]:
                    pend.append((to, eid))
            else:
                if tin[to] < tin[v]:
                    pend.append((to, eid))
        # pair locally
        while len(pend) >= 2:
            (a, ea) = pend.pop()
            (b, eb) = pend.pop()
            used[ea] = used[eb] = True
            res.append((a, v, b))
        # absorb leftover with parent if possible
        if len(pend) == 1 and pe != -1:
            (a, ea) = pend.pop()
            used[ea] = True
            used[pe] = True
            res.append((a, v, parent))
        # else: unpaired leftover dropped (no parent to absorb)

    for v in range(1, n + 1):
        if not vis[v]:
            dfs(v, -1, -1)
    return res

def main_improved():
    parsed = read_input()
    if parsed is None:
        # Self-checks
        tri_n = 3; tri_e = [(1, 2), (2, 3), (3, 1)]
        ans = solve_case_improved(tri_n, tri_e)
        assert len(ans) == 1
        line_n = 4; line_e = [(1, 2), (2, 3), (3, 4)]
        ans2 = solve_case_improved(line_n, line_e)
        assert len(ans2) == 1
        star_n = 4; star_e = [(1, 2), (1, 3), (1, 4)]
        ans3 = solve_case_improved(star_n, star_e)
        assert len(ans3) == 1
        return
    n, edges = parsed
    ans = solve_case_improved(n, edges)
    print(len(ans))
    for x, y, z in ans:
        print(x, y, z)

if __name__ == "__main__" and False:
    main_improved()
\end{minted}
\VALIDATION{Handles cycles (triangle), paths, stars, and disconnected graphs. Uses no edge twice and pairs an odd leftover at a node with its parent when possible.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DFS Pairing of Incident Unused Edges}
\WHICHFORMULA{Depth-first search with pending-edge pairing at each node; pair remainders with parent edge if present. This is the known optimal greedy on DFS tree for maximum edge-disjoint $P_3$ packing.}
\ASSUMPTIONS{Graph is undirected; using discovery times ensures each non-tree edge is considered exactly once at the deeper endpoint.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency with edge ids; arrays: visited, tin, usedEdge; global answer list.
\item DFS on each unvisited node:
\begin{bullets}
\item For each neighbor edge $(v,u,e)$:
\begin{bullets}
\item If $u$ is unvisited, recurse; after return, if edge $e$ remains unused, append $(u,e)$ to pending.
\item Else if $tin[u] < tin[v]$ and $e$ unused, append $(u,e)$ to pending.
\end{bullets}
\item While pending has size at least $2$, pop two entries $(a,e_a),(b,e_b)$, output episode $(a,v,b)$, mark $e_a,e_b$ used.
\item If one pending remains and parent edge exists, pair it with parent: output $(a,v,\text{parent})$, mark both used.
\end{bullets}
\item Continue for all components; print all episodes.
\end{algosteps}
\OPTIMALITY{Each episode consumes two edges at its center. The algorithm maximizes local pairings at every node and uses the parent edge only when necessary (odd parity). Over the DFS tree, every edge is either used locally at one of its endpoints or left unused if it cannot contribute to any $P_3$. This greedy-by-parity strategy is tight: any solution can be transformed to follow the same local pairing decisions without decreasing the number of episodes.}
\COMPLEXITY{Each edge is processed $O(1)$ times; recursion visits each node once.
\[
\begin{aligned}
T(n,m) &= \mathcal{O}(n+m), \\
S(n,m) &= \mathcal{O}(n+m).
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: bytes = None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it); m = next(it)
    edges = []
    for _ in range(m):
        a = next(it); b = next(it)
        edges.append((a, b))
    return n, edges

def solve_case(n: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int, int]]:
    sys.setrecursionlimit(1_000_000)
    g = [[] for _ in range(n + 1)]
    m = len(edges)
    for i, (a, b) in enumerate(edges):
        g[a].append((b, i))
        g[b].append((a, i))
    used = [False] * m
    vis = [False] * (n + 1)
    tin = [0] * (n + 1)
    timer = 0
    res: List[Tuple[int, int, int]] = []

    def dfs(v: int, parent: int = -1, pe: int = -1):
        nonlocal timer
        vis[v] = True
        timer += 1
        tin[v] = timer
        pend: List[Tuple[int, int]] = []
        for to, eid in g[v]:
            if eid == pe:
                continue
            if used[eid]:
                continue
            if not vis[to]:
                dfs(to, v, eid)
                if not used[eid]:
                    pend.append((to, eid))
            else:
                if tin[to] < tin[v]:
                    pend.append((to, eid))
        while len(pend) >= 2:
            (a, ea) = pend.pop()
            (b, eb) = pend.pop()
            used[ea] = used[eb] = True
            res.append((a, v, b))
        if len(pend) == 1 and pe != -1:
            (a, ea) = pend.pop()
            used[ea] = True
            used[pe] = True
            res.append((a, v, parent))

    for v in range(1, n + 1):
        if not vis[v]:
            dfs(v, -1, -1)
    return res

def solve_all():
    parsed = read_input()
    if parsed is None:
        # Exactly 3 asserts / mini-tests
        # 1) Triangle
        n = 3; e = [(1, 2), (2, 3), (3, 1)]
        out = solve_case(n, e)
        assert len(out) == 1
        # 2) Path of 3 edges
        n2 = 4; e2 = [(1, 2), (2, 3), (3, 4)]
        out2 = solve_case(n2, e2)
        assert len(out2) == 1
        # 3) Two disjoint edges (no episode)
        n3 = 4; e3 = [(1, 2), (3, 4)]
        out3 = solve_case(n3, e3)
        assert len(out3) == 0
        return
    n, edges = parsed
    ans = solve_case(n, edges)
    print(len(ans))
    for x, y, z in ans:
        print(x, y, z)

def main():
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item Triangle $\Rightarrow$ $1$ episode.
\item Path of $3$ edges $\Rightarrow$ $1$ episode.
\item Two disjoint edges $\Rightarrow$ $0$ episodes.
\end{bullets}}
\RESULT{Outputs the maximum cardinality set of edge-disjoint $x$–$y$–$z$ episodes. Any tie-breaking is implicit in DFS order and adjacency iteration order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical shapes: cycles, paths, stars, complete graphs on small $n$, and random sparse/dense graphs; property check that no edge is reused and every printed pair is an original edge.}
\LINE{CROSS-CHECKS}{Compare counts from Baseline vs Improved vs Optimal on small random graphs; Optimal should be $\ge$ Improved $\ge$ Baseline.}
\LINE{EDGE-CASE GENERATOR}{Deterministic tiny graph generator for degenerate cases: isolated nodes, single edge, two-edge path, triangles, and multicomponent unions.}
\begin{minted}{python}
import random

def gen_path(n: int):
    edges = [(i, i+1) for i in range(1, n)]
    return n, edges

def gen_star(k: int):
    edges = [(1, i) for i in range(2, k+2)]
    return k+1, edges

def gen_cycle(n: int):
    edges = [(i, i+1) for i in range(1, n)]
    edges.append((n, 1))
    return n, edges

def gen_two_components():
    return 6, [(1,2),(2,3),(4,5)]

def check_solution(n, edges, triples):
    E = {tuple(sorted(e)) for e in edges}
    used = set()
    for x,y,z in triples:
        e1 = tuple(sorted((x,y)))
        e2 = tuple(sorted((y,z)))
        assert e1 in E and e2 in E
        assert e1 not in used and e2 not in used
        used.add(e1); used.add(e2)

# Cross-check small random graphs
def random_graph(n, m, seed=0):
    random.seed(seed)
    edges = set()
    while len(edges) < m:
        a = random.randint(1, n); b = random.randint(1, n)
        if a == b:
            continue
        e = tuple(sorted((a,b)))
        edges.add(e)
    return n, list(edges)

if __name__ == "__main__" and False:
    from collections import defaultdict
    # Quick smoke tests
    for n in range(2, 9):
        for m in range(0, min(n*(n-1)//2, 10)):
            n_, e = random_graph(n, m, seed=n*31+m)
            out = solve_case(n_, e)
            check_solution(n_, e, out)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: bytes = None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it); m = next(it)
    edges = []
    for _ in range(m):
        a = next(it); b = next(it)
        edges.append((a, b))
    return n, edges

def solve_case(n: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int, int]]:
    sys.setrecursionlimit(1_000_000)
    g = [[] for _ in range(n + 1)]
    m = len(edges)
    for i, (a, b) in enumerate(edges):
        g[a].append((b, i))
        g[b].append((a, i))
    used = [False] * m
    vis = [False] * (n + 1)
    tin = [0] * (n + 1)
    timer = 0
    res: List[Tuple[int, int, int]] = []

    def dfs(v: int, parent: int = -1, pe: int = -1):
        nonlocal timer
        vis[v] = True
        timer += 1
        tin[v] = timer
        pend: List[Tuple[int, int]] = []
        for to, eid in g[v]:
            if eid == pe:
                continue
            if used[eid]:
                continue
            if not vis[to]:
                dfs(to, v, eid)
                if not used[eid]:
                    pend.append((to, eid))
            else:
                if tin[to] < tin[v]:
                    pend.append((to, eid))
        while len(pend) >= 2:
            (a, ea) = pend.pop()
            (b, eb) = pend.pop()
            used[ea] = used[eb] = True
            res.append((a, v, b))
        if len(pend) == 1 and pe != -1:
            (a, ea) = pend.pop()
            used[ea] = True
            used[pe] = True
            res.append((a, v, parent))

    for v in range(1, n + 1):
        if not vis[v]:
            dfs(v, -1, -1)
    return res

def main():
    parsed = read_input()
    if parsed is None:
        # Unit asserts (no I/O)
        # 1) Triangle
        n = 3; e = [(1, 2), (2, 3), (3, 1)]
        out = solve_case(n, e)
        assert len(out) == 1
        # 2) Path of 3 edges
        n2 = 4; e2 = [(1, 2), (2, 3), (3, 4)]
        out2 = solve_case(n2, e2)
        assert len(out2) == 1
        # 3) Two disjoint edges
        n3 = 4; e3 = [(1, 2), (3, 4)]
        out3 = solve_case(n3, e3)
        assert len(out3) == 0
        return
    n, edges = parsed
    ans = solve_case(n, edges)
    print(len(ans))
    for x, y, z in ans:
        print(x, y, z)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the number of edge-disjoint episodes $x$–$y$–$z$ in an undirected graph by pairing incident edges at centers via DFS.}
\WHY{Common CF/ICPC pattern: pair edges around nodes and propagate parity up a DFS tree; tests ability to coordinate local greedy with global invariants.}
\CHECKLIST{
\begin{bullets}
\item Build adjacency with stable edge ids.
\item DFS each component; compute discovery times.
\item At $v$, gather unused child-tree edges (post DFS) and back edges to ancestors.
\item Pair pending two-by-two; if odd and parent exists, pair last with parent edge.
\item Mark used edges immediately when forming an episode.
\item Output triples $(x,y,z)$ using the recorded neighbor endpoints.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $m=0$ or $n=1$.
\item Single edge graph: no episode possible.
\item Star graphs: $\left\lfloor \deg/\!2 \right\rfloor$ episodes centered at the hub.
\item Long paths: only $\left\lfloor (m-1)/2 \right\rfloor$ possible depending on placement.
\item Multiple components.
\item Dense graphs with many back edges (ensure only process at deeper endpoint).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to skip parent edge id in neighbor loop.
\item Processing non-tree edges twice (must check $tin[u] < tin[v]$).
\item Not marking edges used immediately upon forming a triple.
\item Mishandling the odd leftover when no parent exists (should be dropped).
\item Recursion depth on long chains (raise recursion limit).
\item Mixing 0/1-based indices in arrays.
\end{bullets}}
\FAILMODES{Local greedy at each node without DFS coordination can waste parent edges and miss optimal pairings; the DFS-parity method avoids this by allowing exactly one leftover per node to be absorbed by the parent.}
\ELI{Make as many movies as possible by always taking two unused roads meeting at the same city. Walk the graph in depth-first order, pair roads locally, and if a city has one road left over, use the road to its parent to complete one more episode.}
\NotePages{3}

\end{document}