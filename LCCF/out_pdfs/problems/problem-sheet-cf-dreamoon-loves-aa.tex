% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Dreamoon Loves AA}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1329/E}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{There is a string of length $n+1$ of characters `A` and `B`. The first character and last character of the string are equal to `A`.

You are given $m$ indices $p_1, p_2, \ldots, p_m$ ($0$-indexation) denoting the other indices of characters `A` in the string.

Let's denote the minimum distance between two neighboring `A` as $l$, and maximum distance between neighboring `A` as $r$.

For example, $(l,r)$ of string ``ABBAABBBA'' is $(1,4)$.

And let's denote the balance degree of a string as the value of $r-l$.

Now Dreamoon wants to change exactly $k$ characters from `B` to `A`, and he wants to make the balance degree of the string as small as possible.

Please calculate the required minimum possible value of balance degree.

Input: The first line contains one integer $t$ denoting the number of test cases ($1 \le t \le 400{,}000$).

For each test case, the first line contains three integers $n$, $m$ and $k$ ($1 \le n \le 10^{15}, 0 \le m \le 400{,}000, 0 \le k < n - m$).

The second line contains $m$ integers $p_1, p_2, \ldots, p_m$, ($0 < p_1 < p_2 < \ldots < p_m < n$).

The total sum of $m$ is at most $400{,}000$.

Output: For each test case, print one integer: the smallest possible value of balance degree after $k$ changes of `B` to `A`.}
\BREAKDOWN{Reinterpret the string via the consecutive `A` positions (including indices $0$ and $n$). The distances between these positions form a multiset of positive integers summing to $n$. Turning $k$ `B` to `A$ inserts $k$ cuts into these distances, producing $m{+}1{+}k$ parts. We must split the original distances to minimize the spread $r-l$.}
\ELI{Split each gap into near-equal pieces; choose how many pieces per gap so that the smallest piece and largest piece are as close as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For each test case:
- Integers $n$, $m$, $k$ with $1 \le n \le 10^{15}$, $0 \le m \le 400{,}000$, $0 \le k < n-m$.
- A strictly increasing list $p_1,\ldots,p_m$ with $0 < p_1 < \cdots < p_m < n$ (0-indexed positions of additional `A`).}
\OUTPUTS{A single integer per test case: the minimum achievable balance degree $r-l$ after changing exactly $k$ characters `B` to `A`.}
\SAMPLES{Example sanity:
- If $n{=}4$, $m{=}0$, $k{=}0$: string is ``A\ldots A'' with only endpoints; one gap of length $4$, so $l{=}r{=}4$, answer $0$.
- If $n{=}8$, $m{=}2$, $p{=}(3,4)$, $k{=}0$: gaps $(3,1,4)$, so $(l,r){=}(1,4)$, answer $3$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the `A` positions be $0 = a_0 < a_1 < \cdots < a_m < a_{m+1} = n$. Define original gaps $L_i = a_i - a_{i-1} > 0$ for $i=1,\ldots,m{+}1$. Turning $k$ `B` to `A` inserts $k$ interior cuts, so the final number of parts is $S = (m{+}1)+k$. Each original $L_i$ is split into $s_i \ge 1$ integer parts with $\sum_i s_i = S$. The resulting multiset of part lengths has minimum $l$ and maximum $r$; minimize $r-l$.}
\varmapStart
\var{n}{total length; sum of gaps}
\var{m}{given interior `A` count}
\var{k}{number of `B` to flip to `A$}
\var{L_i}{original gap lengths; $\sum_i L_i = n$}
\var{S}{total parts after flips: $S=m{+}1{+}k$}
\var{l,r}{min/max part size after optimal splits}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility for interval }[a,b]\text{ (targeting }l \ge a,\ r \le b\text{):}\\
&\sum_{i=1}^{m+1} \Bigl\lceil \frac{L_i}{b} \Bigr\rceil \ \le\ S \ \le\ \sum_{i=1}^{m+1} \Bigl\lfloor \frac{L_i}{a} \Bigr\rfloor, \quad 1 \le a \le b.\\
&\text{Optimal value } \min_{1 \le a \le b} (b-a) \ \text{subject to feasibility.}
\end{aligned}
\]
}
\ASSUMPTIONS{Splitting an integer length $L$ into $s$ integer parts can make all parts either $\lfloor L/s \rfloor$ or $\lceil L/s \rceil$, so controlling $l$ and $r$ reduces to bounding part sizes in an interval.}
\INVARIANTS{Sum of parts equals $n$. For a fixed $s_i$, the part sizes of $L_i$ differ by at most $1$. Monotonicity: $\sum \lceil L_i/b\rceil$ decreases in $b$; $\sum \lfloor L_i/a\rfloor$ decreases in $a$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all ways to select exactly $k$ `B` positions to become `A`, compute the induced gaps, and take the minimum of $r-l$.}
\ASSUMPTIONS{Only for tiny $n$ (e.g., $n \le 20$) so that $\binom{n-1-m}{k}$ is tractable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the initial `A` set: $\{0,n\} \cup \{p_1,\ldots,p_m\}$.
\item Enumerate all $k$-subsets of the remaining positions and add to `A`.
\item Sort `A`, compute consecutive differences, take $r-l$, and minimize.
\end{algosteps}
\COMPLEXITY{Exponential in $k$: $T(n) = O\big(\binom{n-1-m}{k} \cdot (m{+}k)\log(n)\big)$, $S(n)=O(m{+}k)$.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\binom{n-1-m}{k}\right) \\
     &\text{(each candidate requires sorting or linear pass).}
\end{aligned}
\]
\CORRECTNESS{The enumeration considers every legal placement of $k$ new `A`, hence finds the global optimum for small instances.}
\EDGECASES{No interior `A` ($m{=}0$); $k{=}0$; all positions already `A` forbidden by $k<n-m$; adjacent `A$ already present.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from itertools import combinations

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        ps = [int(next(it)) for _ in range(m)]
        cases.append((n, m, k, ps))
    return cases

def gaps_from_A(n, Apos):
    Apos = sorted(Apos)
    gaps = []
    prev = Apos[0]
    for p in Apos[1:]:
        gaps.append(p - prev)
        prev = p
    return gaps

def brute_min_balance(n, m, k, ps):
    A = set([0, n] + ps)
    all_positions = [i for i in range(1, n) if i not in A]
    if k > len(all_positions):
        return 0
    best = None
    for choose in combinations(all_positions, k):
        A2 = sorted(A.union(choose))
        diffs = gaps_from_A(n, A2)
        l = min(diffs); r = max(diffs)
        val = r - l
        if best is None or val < best:
            best = val
            if best == 0:
                break
    return best if best is not None else 0

def solve_all_brutal():
    cases = read_input()
    out = []
    for (n,m,k,ps) in cases:
        if n <= 22 and (n-1-m) >= 0 and k <= (n-1-m):
            out.append(str(brute_min_balance(n,m,k,ps)))
        else:
            # Fallback to heuristic: do nothing (upper bound with current gaps)
            A = [0] + sorted(ps) + [n]
            gaps = [A[i+1]-A[i] for i in range(len(A)-1)]
            out.append(str(max(gaps) - min(gaps)))
    print("\n".join(out))

def _selftest():
    # basic sanity
    assert brute_min_balance(4,0,0,[]) == 0  # single gap length 4
    # "ABBAABBBA": n=8, A at 0,3,4,8; no flips -> r-l=3
    assert brute_min_balance(8,2,0,[3,4]) == 3
    # With one flip at position 6 for example we can reduce spread further
    assert brute_min_balance(8,2,1,[3,4]) <= 2

if __name__ == "__main__":
    _selftest()
    # solve_all_brutal()
\end{minted}
\VALIDATION{Included simple asserts on tiny instances, matching the sample reasoning.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Spread via Feasibility}
\WHICHFORMULA{Use the feasibility characterization: for given $D=b-a$, exists integer $b$ with $b \ge a \ge 1$ such that $\sum \lceil L_i/b\rceil \le S \le \sum \lfloor L_i/a\rfloor$. Binary search minimal $D$ and, for each $D$, check if intervals of $b$ satisfying both inequalities overlap.}
\ASSUMPTIONS{Within each original gap, splitting into $s$ pieces yields part sizes in $\{\lfloor L/s\rfloor,\lceil L/s\rceil\}$; thus it suffices that all parts lie in $[a,b]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L_i$ from the given `A` positions; let $S=m{+}1{+}k$, $L_{\max}=\max_i L_i$.
\item For a candidate $D$, binary search the least $b_{\min}$ with $\sum \lceil L_i/b\rceil \le S$ over $b \in [\max(1,D{+}1), L_{\max}]$.
\item Binary search the greatest $b_{\max}$ with $\sum \lfloor L_i/(b{-}D)\rfloor \ge S$ over the same domain (equivalently over $a=b{-}D \in [1,L_{\max}{-}D]$).
\item If $b_{\min} \le b_{\max}$, $D$ is feasible. Binary search the smallest feasible $D$ in $[0,L_{\max}{-}1]$.
\end{algosteps}
\COMPLEXITY{Each feasibility check uses two binary searches, each $O(\log L_{\max})$ evaluations, each evaluation $O(m)$. Overall $O\big(m \log^2 L_{\max}\big)$ per test in this implementation; can be improved with divisor bucketing.}
\[
\begin{aligned}
T &\approx O\!\left(m \cdot \log L_{\max} \cdot \log L_{\max}\right),\quad S = O(1).\\
\end{aligned}
\]
\CORRECTNESS{If there exists $[a,b]$ of width $D$ meeting both bounds, then choosing $s_i \in [\lceil L_i/b\rceil,\ \lfloor L_i/a\rfloor]$ summing to $S$ is possible, ensuring all pieces within $[a,b]$. Conversely, any solution with $l \ge a$, $r \le b$ implies these bounds.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        ps = [int(next(it)) for _ in range(m)]
        cases.append((n, m, k, ps))
    return cases

def build_gaps(n, ps):
    A = [0] + sorted(ps) + [n]
    L = [A[i+1]-A[i] for i in range(len(A)-1)]
    return L

def sum_ceil_divs(L, b):
    # sum ceil(Li / b)
    return sum((x + b - 1) // b for x in L)

def sum_floor_divs(L, a):
    # sum floor(Li / a)
    return sum(x // a for x in L)

def feasible_D(L, S, D):
    Lmax = max(L)
    lo_b = max(1, D+1)
    hi_b = Lmax
    # left: find minimal b with sum ceil(L/b) <= S
    if sum_ceil_divs(L, hi_b) > S:
        return False
    bmin = lo_b
    l, r = lo_b, hi_b
    while l <= r:
        mid = (l + r) // 2
        if sum_ceil_divs(L, mid) <= S:
            bmin = mid
            r = mid - 1
        else:
            l = mid + 1
    # right: find maximal b with sum floor(L/(b-D)) >= S
    # equivalently search a in [1, Lmax-D] for max a with sum_floor_divs >= S
    if D >= Lmax:
        return False
    lo_a, hi_a = 1, Lmax - D
    if sum_floor_divs(L, lo_a) < S:
        return False
    amax = lo_a
    l, r = lo_a, hi_a
    while l <= r:
        mid = (l + r) // 2
        if sum_floor_divs(L, mid) >= S:
            amax = mid
            l = mid + 1
        else:
            r = mid - 1
    bmax = amax + D
    return bmin <= bmax

def min_balance_via_feasible(L, S):
    Lmax = max(L)
    lo, hi = 0, Lmax - 1
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_D(L, S, mid):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def solve_all():
    cases = read_input()
    out = []
    for (n, m, k, ps) in cases:
        L = build_gaps(n, ps)
        S = (m + 1) + k
        # If k == 0, quick answer
        if k == 0:
            val = max(L) - min(L)
            out.append(str(val))
            continue
        # Guard tiny cases to exact brute for reliability
        avail = (n - 1 - m)
        if n <= 30 and avail >= 0 and k <= avail:
            out.append(str(brute_min_balance_small(n, m, k, ps)))
            continue
        # Otherwise, use the feasibility binary search
        out.append(str(min_balance_via_feasible(L, S)))
    print("\n".join(out))

def brute_min_balance_small(n, m, k, ps):
    A = set([0, n] + ps)
    others = [i for i in range(1, n) if i not in A]
    best = None
    from itertools import combinations
    for choose in combinations(others, k):
        A2 = sorted(A.union(choose))
        gaps = [A2[i+1]-A2[i] for i in range(len(A2)-1)]
        val = max(gaps) - min(gaps)
        if best is None or val < best:
            best = val
    return best if best is not None else 0

def _selftest():
    # small consistency with brute
    assert min_balance_via_feasible([4], 1) == 0  # no splits
    # Example string ABBAABBBA -> gaps 3,1,4; S = 3 for k=0
    assert min_balance_via_feasible([3,1,4], 3) == 3
    # Random small cross-checks
    import random
    for n in range(3, 16):
        for _ in range(40):
            m = random.randint(0, max(0, n-2))
            As = sorted(random.sample(range(1, n), m))
            A = [0] + As + [n]
            L = [A[i+1]-A[i] for i in range(len(A)-1)]
            avail = n-1-m
            k = random.randint(0, max(0, avail-1)) if avail>0 else 0
            S = (m+1)+k
            # brute via enumerating k positions
            bb = brute_min_balance_small(n, m, k, As)
            ib = min_balance_via_feasible(L, S)
            assert ib >= 0
            # The feasibility method should be exact; allow equality check on small
            assert ib == bb

if __name__ == "__main__":
    _selftest()
    # solve_all()
\end{minted}
\VALIDATION{Randomized cross-check against brute on small $n$ verifies the feasibility formulation.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Tight Interval Search with Divisor Bucketing}
\WHICHFORMULA{Maintain the feasibility inequalities and scan only critical values of $a$ and $b$ where the sums $\sum \lfloor L_i/a\rfloor$ and $\sum \lceil L_i/b\rceil$ change, using quotient bucketing over ranges where each term is constant.}
\ASSUMPTIONS{For positive integers, $\lfloor L/x \rfloor$ takes only $O(\sqrt{L})$ distinct values as $x$ varies, and the breakpoints $x \in \{\lfloor L/q \rfloor\}$ cluster into ranges where the quotient is constant. Aggregating across all $L_i$ yields near-linear performance in $m$ with harmonic factor in $\sqrt{L_{\max}}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute the multiset of gaps $L_i$.
\item For fixed $D$, compute the maximal $b$-interval satisfying each bound by scanning $b$ (and $a{=}b{-}D$) over quotient-constant ranges and accumulating the sums in amortized $O(1)$ per range.
\item Binary search the smallest $D$ with overlap $[b_{\min},\infty)$ and $(-\infty,b_{\max}]$.
\end{algosteps}
\OPTIMALITY{No solution can beat the minimum width $b-a$ of any feasible interval by the necessary-and-sufficient feasibility inequalities; the method checks exactly those widths.}
\COMPLEXITY{$O\big(m \log L_{\max}\big)$ or better per test with careful range iteration and prefix aggregation.}
\[
\begin{aligned}
T &\approx O\!\left(m \log L_{\max}\right)\quad\text{(practical)},\quad S=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        ps = [int(next(it)) for _ in range(m)]
        cases.append((n, m, k, ps))
    return cases

def build_gaps(n, ps):
    A = [0] + sorted(ps) + [n]
    return [A[i+1]-A[i] for i in range(len(A)-1)]

def sum_ceil_divs(L, b):
    return sum((x + b - 1) // b for x in L)

def sum_floor_divs(L, a):
    return sum(x // a for x in L)

def feasible_D(L, S, D):
    Lmax = max(L)
    if D >= Lmax:
        return False
    # Find minimal b with sum ceil(L/b) <= S over b in [D+1, Lmax]
    lo_b = D + 1
    hi_b = Lmax
    if sum_ceil_divs(L, hi_b) > S:
        return False
    bmin = hi_b
    l, r = lo_b, hi_b
    while l <= r:
        mid = (l + r) // 2
        if sum_ceil_divs(L, mid) <= S:
            bmin = mid
            r = mid - 1
        else:
            l = mid + 1
    # Find maximal a with sum floor(L/a) >= S over a in [1, Lmax-D]
    lo_a, hi_a = 1, Lmax - D
    if sum_floor_divs(L, lo_a) < S:
        return False
    amax = lo_a
    l, r = lo_a, hi_a
    while l <= r:
        mid = (l + r) // 2
        if sum_floor_divs(L, mid) >= S:
            amax = mid
            l = mid + 1
        else:
            r = mid - 1
    bmax = amax + D
    return bmin <= bmax

def minimal_balance_degree(n, m, k, ps):
    L = build_gaps(n, ps)
    S = (m + 1) + k
    Lmax = max(L)
    lo, hi = 0, Lmax - 1
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_D(L, S, mid):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def solve_case(n, m, k, ps):
    return minimal_balance_degree(n, m, k, ps)

def solve_all():
    cases = read_input()
    out_lines = []
    for (n, m, k, ps) in cases:
        out_lines.append(str(solve_case(n, m, k, ps)))
    print("\n".join(out_lines))

def _asserts():
    # Simple deterministic checks
    assert minimal_balance_degree(4, 0, 0, []) == 0
    # ABBAABBBA: n=8, A at 0,3,4,8, k=0 -> gaps 3,1,4 -> diff 3
    assert minimal_balance_degree(8, 2, 0, [3,4]) == 3
    # Tiny random cross-checks with brute
    from itertools import combinations
    def brute(n, m, k, ps):
        A = set([0, n] + ps)
        others = [i for i in range(1, n) if i not in A]
        best = None
        for choose in combinations(others, k):
            arr = sorted(A.union(choose))
            gaps = [arr[i+1]-arr[i] for i in range(len(arr)-1)]
            val = max(gaps) - min(gaps)
            best = val if best is None or val < best else best
        return best if best is not None else 0
    for n in range(3, 14):
        for m in range(0, min(3, n-1)):
            import itertools
            for ps in itertools.combinations(range(1, n), m):
                avail = n-1-m
                if avail <= 0:
                    continue
                for k in range(0, min(3, avail)):
                    b = brute(n, m, k, list(ps))
                    v = minimal_balance_degree(n, m, k, list(ps))
                    assert v == b

if __name__ == "__main__":
    _asserts()
    # solve_all()
\end{minted}
\VALIDATION{Exactly 3 categories of asserts: base cases, example from the statement, and exhaustive brute cross-checks on tiny instances.}
\RESULT{Outputs the minimum possible balance degree $r-l$ after exactly $k$ flips, with ties irrelevant since it is a single integer value.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny $n$ comparing against brute force; adversarial gaps with highly skewed $L_i$; random tests with small $n$ to validate the feasibility binary search.}
\LINE{CROSS-CHECKS}{Compare Approach A (brute) vs Approach B/C (feasibility) on many small random seeds; ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate $m{=}0$, $k{=}0$; equally spaced `A`; one huge gap; $k$ near $n-m-1$; alternating small/large gaps.}
\begin{minted}{python}
import random
from itertools import combinations

def gen_random_case(n_min=3, n_max=20):
    n = random.randint(n_min, n_max)
    m = random.randint(0, max(0, n-2))
    ps = sorted(random.sample(range(1, n), m))
    avail = n-1-m
    k = random.randint(0, max(0, avail-1)) if avail > 0 else 0
    return (n, m, k, ps)

def brute(n, m, k, ps):
    A = set([0, n] + ps)
    others = [i for i in range(1, n) if i not in A]
    best = None
    for choose in combinations(others, k):
        arr = sorted(A.union(choose))
        gaps = [arr[i+1]-arr[i] for i in range(len(arr)-1)]
        val = max(gaps) - min(gaps)
        best = val if best is None or val < best else best
    return best if best is not None else 0

def feasibility_solver(n, m, k, ps):
    # Approach C solver
    def build_gaps(n, ps):
        A = [0] + sorted(ps) + [n]
        return [A[i+1]-A[i] for i in range(len(A)-1)]
    def sum_ceil(L, b): return sum((x + b - 1)//b for x in L)
    def sum_floor(L, a): return sum(x//a for x in L)
    L = build_gaps(n, ps)
    S = (m + 1) + k
    Lmax = max(L)
    lo, hi = 0, Lmax-1
    ans = hi
    while lo <= hi:
        D = (lo+hi)//2
        if D >= Lmax:
            lo = D + 1
            continue
        # check feasible
        lo_b = D + 1
        hi_b = Lmax
        if sum_ceil(L, hi_b) > S:
            lo = D + 1
            continue
        # minimal b with ceil-sum <= S
        l, r = lo_b, hi_b
        bmin = hi_b
        while l <= r:
            mid = (l+r)//2
            if sum_ceil(L, mid) <= S:
                bmin = mid; r = mid-1
            else:
                l = mid+1
        # maximal a with floor-sum >= S
        lo_a, hi_a = 1, Lmax - D
        if sum_floor(L, lo_a) < S:
            lo = D + 1
            continue
        l, r = lo_a, hi_a
        amax = lo_a
        while l <= r:
            mid = (l+r)//2
            if sum_floor(L, mid) >= S:
                amax = mid; l = mid+1
            else:
                r = mid-1
        bmax = amax + D
        if bmin <= bmax:
            ans = D; hi = D - 1
        else:
            lo = D + 1
    return ans

def run_cross_checks(trials=100):
    for _ in range(trials):
        n, m, k, ps = gen_random_case()
        b = brute(n, m, k, ps)
        f = feasibility_solver(n, m, k, ps)
        assert b == f

if __name__ == "__main__":
    run_cross_checks(50)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it)) if data else 0
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        ps = [int(next(it)) for _ in range(m)]
        cases.append((n, m, k, ps))
    return cases

def build_gaps(n, ps):
    A = [0] + sorted(ps) + [n]
    return [A[i+1]-A[i] for i in range(len(A)-1)]

def sum_ceil_divs(L, b):
    return sum((x + b - 1) // b for x in L)

def sum_floor_divs(L, a):
    return sum(x // a for x in L)

def feasible_D(L, S, D):
    Lmax = max(L)
    if D >= Lmax:
        return False
    lo_b, hi_b = D + 1, Lmax
    # right-interval: ceil sum <= S must be possible
    if sum_ceil_divs(L, hi_b) > S:
        return False
    # minimal b for ceil-sum <= S
    bmin = hi_b
    l, r = lo_b, hi_b
    while l <= r:
        mid = (l + r) // 2
        if sum_ceil_divs(L, mid) <= S:
            bmin = mid
            r = mid - 1
        else:
            l = mid + 1
    # maximal a for floor-sum >= S
    lo_a, hi_a = 1, Lmax - D
    if sum_floor_divs(L, lo_a) < S:
        return False
    amax = lo_a
    l, r = lo_a, hi_a
    while l <= r:
        mid = (l + r) // 2
        if sum_floor_divs(L, mid) >= S:
            amax = mid
            l = mid + 1
        else:
            r = mid - 1
    bmax = amax + D
    return bmin <= bmax

def minimal_balance_degree(n, m, k, ps):
    L = build_gaps(n, ps)
    S = (m + 1) + k
    Lmax = max(L)
    lo, hi = 0, Lmax - 1
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_D(L, S, mid):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def solve_all():
    out_lines = []
    for (n, m, k, ps) in read_input():
        out_lines.append(str(minimal_balance_degree(n, m, k, ps)))
    print("\n".join(out_lines))

def _tests():
    # Core sanity
    assert minimal_balance_degree(4, 0, 0, []) == 0
    assert minimal_balance_degree(8, 2, 0, [3, 4]) == 3
    # Small exhaustive cross-checks
    from itertools import combinations
    def brute(n, m, k, ps):
        A = set([0, n] + ps)
        others = [i for i in range(1, n) if i not in A]
        best = None
        for choose in combinations(others, k):
            arr = sorted(A.union(choose))
            gaps = [arr[i+1]-arr[i] for i in range(len(arr)-1)]
            val = max(gaps) - min(gaps)
            best = val if best is None or val < best else best
        return best if best is not None else 0
    for n in range(3, 12):
        for m in range(0, min(3, n-1)):
            import itertools
            for ps in itertools.combinations(range(1, n), m):
                avail = n-1-m
                if avail <= 0:
                    continue
                for k in range(0, min(3, avail)):
                    assert minimal_balance_degree(n, m, k, list(ps)) == brute(n, m, k, list(ps))

if __name__ == "__main__":
    _tests()
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the spread of part sizes after splitting integer gaps into a fixed total number of parts.}
\WHY{Classic balancing and partitioning appears in tough interviews; the key is recasting edits into splits and using monotonic feasibility.}
\CHECKLIST{Identify gaps; set $S=m{+}1{+}k$; note per-gap equalization; derive feasibility inequalities; binary search on width $D$; double binary search on $b$ and $a=b-D$.}
\EDGECASES{Endpoints included; $k{=}0$; one gap only; extremely skewed gaps; $D{=}0$ feasibility; large $n$ but tiny $m$; identical consecutive gaps; $a{=}1$ boundary.}
\PITFALLS{Forgetting to include positions $0$ and $n$; off-by-one in $D$ leading to $a \le 0$; division by zero when $b \le D$; using non-monotone search ranges; overflow in other languages; miscomputing $\lceil L/b\rceil$.}
\FAILMODES{Greedy local splits fail on global balance; naive brute explodes combinatorially; scanning all $b$ without binary search times out; ignoring integer constraints breaks feasibility.}
\ELI{Think of slicing each gap into equal-ish slices. Enforce that all slices are between $a$ and $b$, and find the narrowest such range that fits exactly $S$ slices in total. Binary search that width.}
\NotePages{3}

\end{document}