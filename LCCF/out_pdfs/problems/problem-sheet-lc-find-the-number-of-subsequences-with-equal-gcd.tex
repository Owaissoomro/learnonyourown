% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find the Number of Subsequences With Equal GCD}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-the-number-of-subsequences-with-equal-gcd/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array \texttt{nums}.\\
Your task is to find the number of pairs of \textbf{non-empty} subsequences \texttt{(seq1, seq2)} of \texttt{nums} that satisfy the following conditions:
\begin{bullets}
\item The subsequences \texttt{seq1} and \texttt{seq2} are \textbf{disjoint}, meaning \textbf{no index} of \texttt{nums} is common between them.
\item The GCD of the elements of \texttt{seq1} is equal to the GCD of the elements of \texttt{seq2}.
\end{bullets}
Return the total number of such pairs. Since the answer may be very large, return it \textbf{modulo} $10^9 + 7$.\\[4pt]
\textbf{Example 1:}\\
\textbf{Input:} \texttt{nums = [1,2,3,4]}\\
\textbf{Output:} \texttt{10}\\
\textbf{Explanation:}\\
The subsequence pairs which have the GCD of their elements equal to 1 are:
\begin{bullets}
\item \texttt{([\*\*\_1\_\*\* , 2, 3, 4], [1, \*\*\_2\_\*\* , \*\*\_3\_\*\* , 4])}
\item \texttt{([\*\*\_1\_\*\* , 2, 3, 4], [1, \*\*\_2\_\*\* , \*\*\_3\_\*\* , \*\*\_4\_\*\*])}
\item \texttt{([\*\*\_1\_\*\* , 2, 3, 4], [1, 2, \*\*\_3\_\*\* , \*\*\_4\_\*\*])}
\item \texttt{([\*\*\_1\_\*\* , \*\*\_2\_\*\* , 3, 4], [1, 2, \*\*\_3\_\*\* , \*\*\_4\_\*\*])}
\item \texttt{([\*\*\_1\_\*\* , 2, 3, \*\*\_4\_\*\*], [1, \*\*\_2\_\*\* , \*\*\_3\_\*\* , 4])}
\item \texttt{([1, \*\*\_2\_\*\* , \*\*\_3\_\*\* , 4], [\*\*\_1\_\*\* , 2, 3, 4])}
\item \texttt{([1, \*\*\_2\_\*\* , \*\*\_3\_\*\* , 4], [\*\*\_1\_\*\* , 2, 3, \*\*\_4\_\*\*])}
\item \texttt{([1, \*\*\_2\_\*\* , \*\*\_3\_\*\* , \*\*\_4\_\*\*], [\*\*\_1\_\*\* , 2, 3, 4])}
\item \texttt{([1, 2, \*\*\_3\_\*\* , \*\*\_4\_\*\*], [\*\*\_1\_\*\* , 2, 3, 4])}
\item \texttt{([1, 2, \*\*\_3\_\*\* , \*\*\_4\_\*\*], [\*\*\_1\_\*\* , \*\*\_2\_\*\* , 3, 4])}
\end{bullets}
\textbf{Example 2:}\\
\textbf{Input:} \texttt{nums = [10,20,30]}\\
\textbf{Output:} \texttt{2}\\
\textbf{Explanation:}\\
The subsequence pairs which have the GCD of their elements equal to 10 are:
\begin{bullets}
\item \texttt{([\*\*\_10\_\*\* , 20, 30], [10, \*\*\_20\_\*\* , \*\*\_30\_\*\*])}
\item \texttt{([10, \*\*\_20\_\*\* , \*\*\_30\_\*\*], [\*\*\_10\_\*\* , 20, 30])}
\end{bullets}
\textbf{Example 3:}\\
\textbf{Input:} \texttt{nums = [1,1,1,1]}\\
\textbf{Output:} \texttt{50}\\[2pt]
\textbf{Constraints:}
\begin{bullets}
\item \texttt{1 <= nums.length <= 200}
\item \texttt{1 <= nums[i] <= 200}
\end{bullets}
}
\BREAKDOWN{We must count ordered pairs of disjoint subsequences whose GCDs are equal and both non-empty. A direct enumeration is exponential. The key observation is that membership choices per index are ternary: assign to the first subsequence, to the second, or to none. This suggests a dynamic program over pairs of current GCDs that respects disjointness.}
\ELI{Walk left to right; for each number, choose to put it in the left subsequence, the right one, or skip it, and keep track of the GCDs of both. Count how many end states have equal non-zero GCDs.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One array \texttt{nums} of length $n$ with $1 \le n \le 200$ and $1 \le \texttt{nums}[i] \le 200$.}
\OUTPUTS{Return the count of ordered pairs of disjoint non-empty subsequences \texttt{(seq1, seq2)} of \texttt{nums} whose GCDs are equal, modulo $10^9 + 7$.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[1,2,3,4]} $\rightarrow$ Output: \texttt{10}
\item Input: \texttt{[10,20,30]} $\rightarrow$ Output: \texttt{2}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let indices be $[n] = \{1,\ldots,n\}$. An assignment is a function $f:[n]\to\{0,1,2\}$, where 0 means ``unused'', 1 means ``assigned to seq1'', 2 means ``assigned to seq2''. Let $S_1(f)=\{i\mid f(i)=1\}$ and $S_2(f)=\{i\mid f(i)=2\}$ (clearly disjoint). Define $G(S)=\gcd\{\,\texttt{nums}[i] : i\in S\,\}$ for non-empty $S$ and leave $G(\varnothing)$ undefined. We want the number of assignments $f$ with $S_1,S_2\ne\varnothing$ and $G(S_1)=G(S_2)$. The result is taken modulo $10^9+7$.}
\varmapStart
\var{n}{length of the array}
\var{\texttt{nums}[i]}{value at index $i$}
\var{f(i)}{ternary choice for index $i$}
\var{G(S)}{GCD of the multiset of values indexed by $S$}
\var{V}{maximum value in \texttt{nums}; $1\le V\le 200$}
\varmapEnd
\GOVERN{
\[
\text{Ans} \equiv \left|\left\{\, f:[n]\to\{0,1,2\}\ \middle|\ S_1(f)\ne\varnothing,\ S_2(f)\ne\varnothing,\ G(S_1(f))=G(S_2(f)) \,\right\}\right| \pmod{10^9+7}.
\]
}
\ASSUMPTIONS{All numbers are positive, so for non-empty sets GCD is a positive integer. The pair is ordered: \texttt{(seq1, seq2)} and \texttt{(seq2, seq1)} are counted separately if they differ.}
\INVARIANTS{
\begin{bullets}
\item Disjointness: each index is in at most one of $S_1,S_2$ by construction of $f$.
\item GCD monotonicity: as more elements are added to a subsequence, its running GCD can only stay the same or decrease to a divisor.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $3^n$ assignments $f:[n]\to\{0,1,2\}$; for each, compute the two GCDs and check equality and non-emptiness.}
\ASSUMPTIONS{Only feasible for small $n$ (e.g., $n\le 14$) due to $3^n$ growth.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate $m$ from $0$ to $3^n-1$; interpret $m$ in base-3 as the assignment decisions.
\item Compute $g_1$ and $g_2$ as GCDs of chosen elements; track whether each subsequence is non-empty.
\item If both non-empty and $g_1=g_2$, increment the answer.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n\cdot 3^n)$; space $S(n)=O(1)$ aside from the input.}
\[
\begin{aligned}
T(n) &= \sum_{m=0}^{3^n-1} O(n) \\
     &= O(n\cdot 3^n).
\end{aligned}
\]
\CORRECTNESS{Exhaustively checks every disjoint pair of subsequences encoded by ternary choices, and counts exactly those whose GCDs match and are non-empty.}
\EDGECASES{All ones; all equal numbers; single element; primes vs. composites; repeated values; minimal and maximal values within bounds.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import math

MOD = 1_000_000_007

class Solution:
    # Baseline brute force; intended only for small n (e.g., for validation)
    def subsequencePairCount(self, nums: List[int]) -> int:
        n = len(nums)
        # Safety: forbid running brute on large n in this baseline demo
        if n > 12:
            # Fallback to a safer small-DP for demonstration if accidentally called
            return self._dp_sparse(nums)
        total = pow(3, n)
        ans = 0
        for m in range(total):
            x = m
            g1 = 0
            g2 = 0
            used1 = False
            used2 = False
            for i in range(n):
                trit = x % 3
                x //= 3
                if trit == 1:
                    if not used1:
                        g1 = nums[i]
                        used1 = True
                    else:
                        g1 = math.gcd(g1, nums[i])
                elif trit == 2:
                    if not used2:
                        g2 = nums[i]
                        used2 = True
                    else:
                        g2 = math.gcd(g2, nums[i])
            if used1 and used2 and g1 == g2:
                ans += 1
        return ans % MOD

    # Sparse DP helper (used only as a fallback in this baseline block)
    def _dp_sparse(self, nums: List[int]) -> int:
        V = max(nums) if nums else 0
        # gcd table including gcd(0, x) = x
        gcd = [[0]*(V+1) for _ in range(V+1)]
        for i in range(V+1):
            for j in range(V+1):
                gcd[i][j] = j if i == 0 else (i if j == 0 else math.gcd(i, j))
        dp = {(0, 0): 1}
        for a in nums:
            ndp = {}
            for (g1, g2), cnt in dp.items():
                # skip
                ndp[(g1, g2)] = (ndp.get((g1, g2), 0) + cnt) % MOD
                # put in seq1
                ng1 = gcd[g1][a]
                ndp[(ng1, g2)] = (ndp.get((ng1, g2), 0) + cnt) % MOD
                # put in seq2
                ng2 = gcd[g2][a]
                ndp[(g1, ng2)] = (ndp.get((g1, ng2), 0) + cnt) % MOD
            dp = ndp
        ans = 0
        for g in range(1, V+1):
            ans = (ans + dp.get((g, g), 0)) % MOD
        return ans

# Tiny validations (fits brute)
sol = Solution()
assert sol.subsequencePairCount([1, 2, 3]) == 6  # manual check
assert sol.subsequencePairCount([2, 2]) == 2     # choose different indices for each subseq
assert sol.subsequencePairCount([5]) == 0        # cannot form two non-empty disjoint subsequences
\end{minted}
\VALIDATION{The asserts check small configurations including identical numbers and a singleton.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Dynamic programming over pairs of running GCDs $(g_1,g_2)$ using a sparse map to keep only reachable states. Each element makes three transitions: skip, put into seq1, put into seq2.}
\ASSUMPTIONS{Let $V=\max(\texttt{nums})\le 200$. Precompute a small $\gcd$ table for $[0..V]$ so transitions are $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a map \texttt{dp} with key $(0,0)$ set to 1; $0$ encodes ``empty'' GCD.
\item For each value $a$ in \texttt{nums}, build \texttt{ndp} by:
  \begin{bullets}
  \item skipping $a$: $(g_1,g_2)\to(g_1,g_2)$,
  \item assigning $a$ to seq1: $(g_1,g_2)\to(\gcd(g_1,a),g_2)$ with $\gcd(0,a)=a$,
  \item assigning $a$ to seq2: $(g_1,g_2)\to(g_1,\gcd(g_2,a))$.
  \end{bullets}
\item Replace \texttt{dp} by \texttt{ndp}.
\item Sum \texttt{dp[(g,g)]} for $g\ge 1$.
\end{algosteps}
\COMPLEXITY{In practice, the number of populated states is much less than $(V+1)^2$, so it is often faster than dense DP. Worst-case still $O(n\cdot V^2)$ time, $O(V^2)$ space.}
\[
\begin{aligned}
T(n) &\le 3 \cdot n \cdot (V+1)^2,\quad S(n) \le (V+1)^2.
\end{aligned}
\]
\CORRECTNESS{Ternary assignment ensures disjointness. The DP state exactly captures the running GCDs. By summing states with $g_1=g_2\ge 1$, we count ordered pairs of non-empty subsequences with equal GCD.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import math

MOD = 1_000_000_007

class Solution:
    def subsequencePairCount(self, nums: List[int]) -> int:
        if not nums:
            return 0
        V = max(nums)
        # Precompute gcd table (including gcd(0, x) = x)
        gcd = [[0]*(V+1) for _ in range(V+1)]
        for i in range(V+1):
            for j in range(V+1):
                gcd[i][j] = j if i == 0 else (i if j == 0 else math.gcd(i, j))
        dp = {(0, 0): 1}
        for a in nums:
            ndp = {}
            for (g1, g2), cnt in dp.items():
                # skip
                key = (g1, g2)
                ndp[key] = (ndp.get(key, 0) + cnt) % MOD
                # add to seq1
                ng1 = gcd[g1][a]
                key = (ng1, g2)
                ndp[key] = (ndp.get(key, 0) + cnt) % MOD
                # add to seq2
                ng2 = gcd[g2][a]
                key = (g1, ng2)
                ndp[key] = (ndp.get(key, 0) + cnt) % MOD
            dp = ndp
        ans = 0
        for g in range(1, V+1):
            ans = (ans + dp.get((g, g), 0)) % MOD
        return ans

# Checks against examples
sol = Solution()
assert sol.subsequencePairCount([1, 2, 3, 4]) == 10
assert sol.subsequencePairCount([10, 20, 30]) == 2
assert sol.subsequencePairCount([1, 1, 1, 1]) == 50
\end{minted}
\VALIDATION{Validated on the three examples provided and a few hand-crafted cases in Approach A.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Dense DP over $(g_1,g_2)$ states with a precomputed $[0..V]\times[0..V]$ $\gcd$ table to minimize overhead. This yields tight $O(n\cdot V^2)$ time and $O(V^2)$ space with small constants.}
\ASSUMPTIONS{$V=\max(\texttt{nums})\le 200$; $n\le 200$. The resulting $201^2$ state space is tiny.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mathrm{gcd}[i][j]$ for $0\le i,j\le V$ with the convention $\gcd(0,x)=x$.
\item Initialize a $(V{+}1)\times(V{+}1)$ DP array with \texttt{dp[0][0]}$=1$.
\item For each $a\in\texttt{nums}$, build \texttt{ndp} of the same size with:
\begin{bullets}
\item ndp[$g_1$][$g_2$] $+=$ dp[$g_1$][$g_2$] (skip),
\item ndp[$\gcd(g_1,a)$][$g_2$] $+=$ dp[$g_1$][$g_2$] (to seq1),
\item ndp[$g_1$][$\gcd(g_2,a)$] $+=$ dp[$g_1$][$g_2$] (to seq2),
\end{bullets}
all modulo $10^9{+}7$.
\item Answer is $\sum_{g=1}^{V} \texttt{dp}[g][g] \bmod 10^9{+}7$.
\end{algosteps}
\OPTIMALITY{Any method must, in effect, account for the dependence of both subsequences' GCDs on each value's assignment. The dense $(V{+}1)^2$ DP captures all necessary information with the smallest closed state set; asymptotically optimal under the given bounds.}
\COMPLEXITY{Time $T(n)=\Theta(n\cdot (V{+}1)^2)$; space $S(n)=\Theta((V{+}1)^2)$. With $n,V\le 200$, this is easily within limits.}
\[
\begin{aligned}
T(n) &\approx 3\,n\,(V+1)^2,\quad S(n)=(V+1)^2.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import math

MOD = 1_000_000_007

class Solution:
    def subsequencePairCount(self, nums: List[int]) -> int:
        if not nums:
            return 0
        V = max(nums)
        # Precompute gcd table including gcd(0, x) = x
        gcd = [[0] * (V + 1) for _ in range(V + 1)]
        for i in range(V + 1):
            for j in range(V + 1):
                gcd[i][j] = j if i == 0 else (i if j == 0 else math.gcd(i, j))
        # Dense DP over (g1, g2)
        size = V + 1
        dp = [[0] * size for _ in range(size)]
        dp[0][0] = 1
        for a in nums:
            ndp = [[0] * size for _ in range(size)]
            for g1 in range(size):
                row = dp[g1]
                for g2 in range(size):
                    cnt = row[g2]
                    if cnt == 0:
                        continue
                    # Skip
                    ndp[g1][g2] = (ndp[g1][g2] + cnt) % MOD
                    # Put into seq1
                    ng1 = gcd[g1][a]
                    ndp[ng1][g2] = (ndp[ng1][g2] + cnt) % MOD
                    # Put into seq2
                    ng2 = gcd[g2][a]
                    ndp[g1][ng2] = (ndp[g1][ng2] + cnt) % MOD
            dp = ndp
        ans = 0
        for g in range(1, size):
            ans = (ans + dp[g][g]) % MOD
        return ans

# Exactly 3 asserts (examples)
sol = Solution()
assert sol.subsequencePairCount([1, 2, 3, 4]) == 10
assert sol.subsequencePairCount([10, 20, 30]) == 2
assert sol.subsequencePairCount([1, 1, 1, 1]) == 50
\end{minted}
\VALIDATION{Validated on the three official examples.}
\RESULT{Returns the number of ordered pairs of disjoint non-empty subsequences whose GCDs are equal, modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on examples; cross-check against brute force on random small arrays ($n\le 10$); adversarial structures: all ones, all equal, primes, mixed composites.}
\LINE{CROSS-CHECKS}{For small $n$, compare the DP result with the brute-force enumeration (Approach A). Ensure equality across many seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays like $[x]$, $[x,x]$, all ones, strictly increasing primes, repeated composites.}
\begin{minted}{python}
from typing import List
import math
import itertools

MOD = 1_000_000_007

def brute_count(nums: List[int]) -> int:
    n = len(nums)
    total = pow(3, n)
    ans = 0
    for m in range(total):
        x = m
        g1 = 0
        g2 = 0
        used1 = False
        used2 = False
        for i in range(n):
            trit = x % 3
            x //= 3
            if trit == 1:
                g1 = nums[i] if not used1 else math.gcd(g1, nums[i])
                used1 = True
            elif trit == 2:
                g2 = nums[i] if not used2 else math.gcd(g2, nums[i])
                used2 = True
        if used1 and used2 and g1 == g2:
            ans += 1
    return ans % MOD

class Solution:
    def subsequencePairCount(self, nums: List[int]) -> int:
        if not nums:
            return 0
        V = max(nums)
        gcd = [[0] * (V + 1) for _ in range(V + 1)]
        for i in range(V + 1):
            for j in range(V + 1):
                gcd[i][j] = j if i == 0 else (i if j == 0 else math.gcd(i, j))
        size = V + 1
        dp = [[0] * size for _ in range(size)]
        dp[0][0] = 1
        for a in nums:
            ndp = [[0] * size for _ in range(size)]
            for g1 in range(size):
                row = dp[g1]
                for g2 in range(size):
                    cnt = row[g2]
                    if cnt == 0:
                        continue
                    ndp[g1][g2] = (ndp[g1][g2] + cnt) % MOD
                    ng1 = gcd[g1][a]
                    ndp[ng1][g2] = (ndp[ng1][g2] + cnt) % MOD
                    ng2 = gcd[g2][a]
                    ndp[g1][ng2] = (ndp[g1][ng2] + cnt) % MOD
            dp = ndp
        ans = 0
        for g in range(1, size):
            ans = (ans + dp[g][g]) % MOD
        return ans

# Cross-checks
sol = Solution()
# Examples
assert sol.subsequencePairCount([1, 2, 3, 4]) == 10
assert sol.subsequencePairCount([10, 20, 30]) == 2
assert sol.subsequencePairCount([1, 1, 1, 1]) == 50
# Small brute validations
cases = [
    [],
    [5],
    [2, 2],
    [1, 2, 3],
    [2, 3, 5],
    [2, 4, 6],
    [1, 1, 2],
]
for arr in cases:
    assert sol.subsequencePairCount(arr) == brute_count(arr)

# Deterministic generator for edge stress (n<=8 for brute)
def edge_arrays():
    yield [1]
    yield [2]
    yield [1, 1]
    yield [2, 2]
    yield [1, 2, 3, 4]
    yield [2, 4, 8, 16]
    yield [3, 6, 9, 12]
    yield [2, 3, 4, 5]
    yield [1, 1, 1, 1]
    yield [6, 10, 15]
    yield [7, 7, 7, 7, 7]
    yield [1, 2, 1, 2, 1, 2]

for arr in edge_arrays():
    if len(arr) <= 8:
        assert sol.subsequencePairCount(arr) == brute_count(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import math

MOD = 1_000_000_007

class Solution:
    def subsequencePairCount(self, nums: List[int]) -> int:
        if not nums:
            return 0
        V = max(nums)
        # Precompute gcd table including gcd(0, x) = x
        gcd = [[0] * (V + 1) for _ in range(V + 1)]
        for i in range(V + 1):
            for j in range(V + 1):
                gcd[i][j] = j if i == 0 else (i if j == 0 else math.gcd(i, j))
        size = V + 1
        dp = [[0] * size for _ in range(size)]
        dp[0][0] = 1
        for a in nums:
            ndp = [[0] * size for _ in range(size)]
            for g1 in range(size):
                row = dp[g1]
                for g2 in range(size):
                    cnt = row[g2]
                    if cnt == 0:
                        continue
                    # skip
                    ndp[g1][g2] = (ndp[g1][g2] + cnt) % MOD
                    # to seq1
                    ng1 = gcd[g1][a]
                    ndp[ng1][g2] = (ndp[ng1][g2] + cnt) % MOD
                    # to seq2
                    ng2 = gcd[g2][a]
                    ndp[g1][ng2] = (ndp[g1][ng2] + cnt) % MOD
            dp = ndp
        ans = 0
        for g in range(1, size):
            ans = (ans + dp[g][g]) % MOD
        return ans

# Sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.subsequencePairCount([1, 2, 3, 4]) == 10
    assert sol.subsequencePairCount([10, 20, 30]) == 2
    assert sol.subsequencePairCount([1, 1, 1, 1]) == 50
    assert sol.subsequencePairCount([2, 2]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count ordered pairs of disjoint non-empty subsequences with equal GCD via a ternary-assignment DP over running GCD pairs.}
\WHY{This blends combinatorics and number theory; the ternary DP pattern (assign to A/B/none) is common in hard interview problems involving two disjoint structures with an equality constraint.}
\CHECKLIST{
\begin{bullets}
\item Precompute small $\gcd$ table including $\gcd(0,x)=x$.
\item Initialize dp with dp[0][0]$=1$.
\item For each value: perform 3 transitions (skip, to seq1, to seq2).
\item Sum dp[$g$][$g$] for $g\ge 1$; apply modulo.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ $\Rightarrow$ answer $0$ (cannot form two non-empty disjoint subsequences).
\item All ones: many matches; verify modulo handling.
\item All equal numbers $x$: only ways are picking disjoint index subsets with non-empty both.
\item Prime-only sets vs. composite mixtures.
\item Presence of $1$ drastically increases counts; ensure no overflow before modulo.
\item Mixed small and large values up to 200.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting ordered-pair counting (do not divide by 2).
\item Mishandling the ``empty'' state: $\gcd(0,x)$ must be $x$.
\item Double-counting by allowing an index in both subsequences (disallowed).
\item Modulo omissions on transitions leading to overflow.
\item Using dictionaries without modulo can grow large values and slow down.
\item Incorrectly treating $\gcd$ as increasing; it is non-increasing with more elements.
\end{bullets}
}
\FAILMODES{Brute force fails for moderate $n$ due to $3^n$. Single-subsequence GCD counting (via inclusion--exclusion or Möbius) is insufficient alone because it does not enforce disjointness between two subsequences; the ternary DP does.}
\ELI{At each step, you decide where the current number goes: left, right, or nowhere. Keep track of each side's GCD as you go. In the end, count the ways where both sides are non-empty and their GCDs match.}
\NotePages{3}

\end{document}