% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Egor in the Republic of Dagestan}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1407/E}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{Egor is a famous Russian singer, rapper, actor and blogger, and finally he decided to give a concert in the sunny Republic of Dagestan.

There are $n$ cities in the republic, some of them are connected by $m$ directed roads without any additional conditions. In other words, the road system of Dagestan represents an arbitrary directed graph. Egor will arrive to the city $1$, travel to the city $n$ by roads along some path, give a concert and fly away.

As any famous artist, Egor has lots of haters and too annoying fans, so he can travel only by safe roads. There are two types of the roads in Dagestan, black and white: black roads are safe at night only, and white roads — in the morning. Before the trip Egor's manager is going to make a schedule: for each city he will specify its color, black or white, and then if during the trip they visit some city, the only time they can leave it is determined by the city's color: night, if it is black, and morning, if it is white. After creating the schedule Egor chooses an available path from $1$ to $n$, and for security reasons it has to be the shortest possible.

Egor's manager likes Dagestan very much and wants to stay here as long as possible, so he asks you to make such a schedule that there would be no path from $1$ to $n$ or the shortest path's length would be greatest possible.

A path is one city or a sequence of roads such that for every road (excluding the first one) the city this road goes from is equal to the city the previous road goes into. Egor can move only along paths consisting of safe roads only.

The path length is equal to the number of roads in it. The shortest path in a graph is a path with smallest length.

Input:
The first line contains two integers $n$, $m$ ($1 \le n \le 500000$, $0 \le m \le 500000$) — the number of cities and the number of roads.

The $i$-th of next $m$ lines contains three integers — $u_i$, $v_i$ and $t_i$ ($1 \le u_i, v_i \le n$, $t_i \in \{0, 1\}$) — numbers of cities connected by road and its type, respectively ($0$ — night road, $1$ — morning road).

Output:
In the first line output the length of the desired path (or $-1$, if it is possible to choose such a schedule that there is no path from $1$ to $n$).

In the second line output the desired schedule — a string of $n$ digits, where the $i$-th digit is $0$, if the $i$-th city is a night one, and $1$ if it is a morning one.

If there are multiple answers, print any.

Note:
For the first sample, if we paint city $1$ white, the shortest path is $1 \rightarrow 3$. Otherwise, it is $1 \rightarrow 2 \rightarrow 3$ regardless of other cities' colors.

For the second sample, we should paint city $3$ black, and there are both black and white roads going from $2$ to $4$. Note that there can be a road connecting a city with itself.}
\BREAKDOWN{We choose a binary color for each node; an edge $u \to v$ of type $t$ is usable only if the current node's color equals $t$. After fixing colors, Egor chooses a shortest $1 \leadsto n$ path among usable edges. We must choose colors to maximize that resulting shortest distance, or make it impossible.}
\ELI{Work backward from $n$ and mark which outgoing colors at each city would immediately allow a short step; avoid enabling such colors whenever possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$, $m$; then $m$ lines with integers $u_i$, $v_i$, $t_i$ where $t_i \in \{0,1\}$. Nodes are $1$-indexed.}
\OUTPUTS{First line: the maximum possible length of Egor's shortest path after our coloring, or $-1$ if we can eliminate all paths. Second line: a binary string of length $n$ giving the city colors ($0$ for night, $1$ for morning).}
\SAMPLES{Example 1: $n{=}3$, $m{=}3$, edges $(1,2,0)$, $(2,3,0)$, $(1,3,1)$. Optimal output length $2$ with a coloring starting with city $1$ as $0$.

Example 2: $n{=}2$, $m{=}0$. Output $-1$ and any 2-bit string (e.g., $00$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a directed graph on $V=\{1,\ldots,n\}$ with edges $E \subseteq V \times V \times \{0,1\}$. A coloring vector $c \in \{0,1\}^n$ induces a subgraph $G_c$ keeping exactly edges $(u,v,t)$ with $t=c_u$. Egor's route is a shortest path from $1$ to $n$ in $G_c$, if any. We seek $c$ maximizing that shortest-path length, or reporting $-1$ if a coloring yields no $1 \leadsto n$ path.}
\varmapStart
\var{n}{number of cities}
\var{m}{number of directed roads}
\var{(u,v,t)}{directed edge of type $t \in \{0,1\}$}
\var{c_u}{assigned color of city $u$}
\var{d(u)}{resulting shortest distance from $u$ to $n$ under worst-case coloring choice}
\var{b(u,t)}{indicator that some edge $(u,v,t)$ reaches a node with known distance}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&d(n)=0, \\
&\text{work on the reverse graph. When a node } v \text{ gets } d(v), \text{ for each incoming } (u \to v, t): b(u,t)\leftarrow 1.\\
&\text{If for some } u,~ b(u,0)=b(u,1)=1 \text{ for the first time, then } d(u)=1+\min\{d(v):(u\to v, t)\in E,~d(v)\text{ known}\}.\\
&\text{Finally choose } c_u=\begin{cases}
0,& b(u,0)=0,\\
1,& b(u,0)=1 \wedge b(u,1)=0,\\
0,& b(u,0)=b(u,1)=1~(\text{arbitrary}).
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Graph can have self-loops and parallel edges. All edges are processed; $n$ up to $5\cdot 10^5$, so $O(n{+}m)$ is required.}
\INVARIANTS{From any colored node $u$:
- If $b(u,t)=0$ for some $t$, coloring $u$ as $t$ avoids enabling a one-step move to already discovered closer nodes.
- If $b(u,0)=b(u,1)=1$, any coloring enables at least one step to a discovered node, so $d(u)$ becomes fixed as $1+\min d(v)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $2^n$ colorings $c$, build $G_c$, run BFS from $1$ to compute the shortest distance to $n$, take the maximum over colorings.}
\ASSUMPTIONS{Only feasible for very small $n$ (e.g., $n\le 18$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each coloring $c \in \{0,1\}^n$:
\item Build adjacency using only edges whose type equals the color of the source node.
\item BFS from $1$ to get $\operatorname{dist}_c(1,n)$; maximize it, treating no-path as $-\infty$ (preferable to any finite length).
\end{algosteps}
\COMPLEXITY{Exponential in $n$, linear in $m$ per coloring.}
\[
\begin{aligned}
T(n) &= O\!\left(2^n\cdot (n{+}m)\right), \\
S(n) &= O(n{+}m).
\end{aligned}
\]
\CORRECTNESS{By exhaustive search over all schedules, we exactly maximize the shortest-path length or detect impossibility.}
\EDGECASES{No edges; self-loops; multiple parallel edges; isolated $n$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input() -> str:
    return sys.stdin.read()

def bfs_shortest(n, adj, start, target):
    dist = [-1]*(n+1)
    dq = deque([start])
    dist[start] = 0
    while dq:
        u = dq.popleft()
        if u == target:
            return dist[u]
        for v in adj[u]:
            if dist[v] == -1:
                dist[v] = dist[u] + 1
                dq.append(v)
    return -1

def solve_case_bruteforce(n, edges):
    # edges: list of (u,v,t)
    # Return (best_len, color_string)
    if n > 18:
        # Too big for brute force; fall back to a trivial feasible schedule
        # (All zeros); compute its shortest path length.
        adj = [[] for _ in range(n+1)]
        for u,v,t in edges:
            if t == 0:
                adj[u].append(v)
        d = bfs_shortest(n, adj, 1, n)
        color = "0"*n
        return d, color
    best_len = -1
    best_color = "0"*n
    m = len(edges)
    for mask in range(1<<n):
        # color[u] = (mask>>(u-1))&1
        adj = [[] for _ in range(n+1)]
        ok = False
        for (u,v,t) in edges:
            cu = (mask>>(u-1)) & 1
            if cu == t:
                adj[u].append(v)
                ok = True
        d = bfs_shortest(n, adj, 1, n)
        if d == -1:
            # Preferred over any finite length
            best_len = -1
            best_color = "".join('1' if ((mask>>(i))&1) else '0' for i in range(n))
            break
        else:
            if best_len == -1:
                # keep looking for -1; otherwise track max finite
                pass
            else:
                if d > best_len:
                    best_len = d
                    best_color = "".join('1' if ((mask>>(i))&1) else '0' for i in range(n))
    return best_len, best_color

def format_output(ans_len, color):
    out = []
    out.append(str(ans_len))
    out.append(color)
    return "\n".join(out)

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return ""
    m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); t = int(next(it))
        edges.append((u,v,t))
    ans_len, color = solve_case_bruteforce(n, edges)
    return format_output(ans_len, color)

def main():
    data = read_input()
    print(solve_all(data))

if __name__ == "__main__":
    # Tiny asserts for internal validation
    # Graph: 1-2-3 with type 0, and 1->3 type 1. Best is length 2 by coloring city 1 as 0.
    n = 3
    edges = [(1,2,0),(2,3,0),(1,3,1)]
    d, c = solve_case_bruteforce(n, edges)
    assert d == 2
    # No edges: -1
    n2 = 2
    edges2 = []
    d2, c2 = solve_case_bruteforce(n2, edges2)
    assert d2 == -1
    # Run main for actual input
    main()
\end{minted}
\VALIDATION{Checked on two handcrafted cases; enumerative search confirms outputs for $n\le 18$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Reverse-BFS Forcing with Counters}
\WHICHFORMULA{Propagate from $n$ on the reverse graph. For each node $u$, track whether there exists a discovered neighbor via a type-$0$ or type-$1$ edge. When both types are seen, $u$ becomes forced and gets a distance. Colors prefer a type not yet seen.}
\ASSUMPTIONS{Maintain two booleans per node for types $0$ and $1$; enqueue a node once when it becomes forced.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build reverse adjacency: for each edge $(u\to v, t)$ store $(u,t)$ in list of $v$.
\item Initialize $d[n]=0$, queue $\{n\}$, and $b[u][t]=\text{false}$ for all.
\item While queue nonempty: pop $v$, for each $(u,t)$ in reverse neighbors of $v$, set $b[u][t]\leftarrow\text{true}$; if both types now true and $d[u]$ unset, set $d[u]=d[v]{+}1$ and enqueue $u$.
\item After BFS, set $c_u=0$ if $b[u][0]=0$, else $c_u=1$ if $b[u][1]=0$, else arbitrary (say $0$).
\item Answer length is $d[1]$; if unset, print $-1$.
\end{algosteps}
\COMPLEXITY{Each edge is touched $O(1)$ times; time $O(n{+}m)$, space $O(n{+}m)$.}
\[
\begin{aligned}
T(n,m) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{If only one type has a discovered neighbor, choosing the other type avoids enabling a short move; if both have discovered neighbors, any coloring enables a one-step move to some discovered node, hence $d(u)$ is fixed at $1+\min d(v)$. This matches the optimal adversarial coloring.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input() -> str:
    return sys.stdin.read()

def solve_case(n, edges):
    # Build reverse graph
    rg = [[] for _ in range(n+1)]  # rg[v] contains (u, t) of original edges u->v with type t
    for u,v,t in edges:
        rg[v].append((u,t))
    dist = [-1]*(n+1)
    seen0 = [False]*(n+1)
    seen1 = [False]*(n+1)
    q = deque()
    dist[n] = 0
    q.append(n)
    while q:
        v = q.popleft()
        for (u,t) in rg[v]:
            if t == 0:
                if not seen0[u]:
                    seen0[u] = True
            else:
                if not seen1[u]:
                    seen1[u] = True
            if dist[u] == -1 and seen0[u] and seen1[u]:
                dist[u] = dist[v] + 1
                q.append(u)
    # build coloring: prefer a type not seen
    color = []
    for u in range(1, n+1):
        if not seen0[u]:
            color.append('0')
        elif not seen1[u]:
            color.append('1')
        else:
            color.append('0')
    ans_len = dist[1]
    return ans_len, "".join(color)

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return ""
    m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); t = int(next(it))
        edges.append((u,v,t))
    d, c = solve_case(n, edges)
    out = [str(d), c]
    return "\n".join(out)

def main():
    data = read_input()
    print(solve_all(data))

if __name__ == "__main__":
    # Edge checks
    n = 3
    edges = [(1,2,0),(2,3,0),(1,3,1)]
    d, c = solve_case(n, edges)
    assert d == 2
    n2 = 2
    edges2 = []
    d2, c2 = solve_case(n2, edges2)
    assert d2 == -1
    # Self-loop does not help unless it is on type allowed
    n3 = 1
    edges3 = [(1,1,0)]
    d3, c3 = solve_case(n3, edges3)
    assert d3 == 0  # already at n
    main()
\end{minted}
\VALIDATION{Validated on tiny graphs including self-loop and empty graph; matches expectations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Reverse Forcing BFS with Greedy Coloring}
\WHICHFORMULA{Use the reverse-graph BFS with two-type seen flags; assign colors to avoid enabling an early move whenever possible.}
\ASSUMPTIONS{Works for arbitrary directed graphs with up to $5\cdot 10^5$ nodes and edges; uses $O(n{+}m)$ memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Reverse adjacency build as in Approach B.
\item BFS from $n$; for each processed $v$, mark $b(u,t)$ for every incoming $(u,t)$; when a node $u$ has $b(u,0)=b(u,1)=1$, set $d(u)=d(v)+1$ and enqueue.
\item After BFS, set $c_u$ to a type $t$ for which $b(u,t)=0$ if any; else arbitrary.
\item Report $d(1)$ or $-1$ if $d(1)$ unset, and the coloring string.
\end{algosteps}
\OPTIMALITY{Any coloring enabling an edge to a discovered neighbor allows Egor to shorten the path. The algorithm delays enabling such edges as long as possible and fixes $d(u)$ only when unavoidable. This is tight by construction.}
\COMPLEXITY{Linear in input size.}
\[
\begin{aligned}
T(n,m) &= O(n+m),\quad S(n,m) = O(n+m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def solve_case(n, edges):
    rg = [[] for _ in range(n+1)]
    for u,v,t in edges:
        rg[v].append((u,t))
    dist = [-1]*(n+1)
    seen0 = [False]*(n+1)
    seen1 = [False]*(n+1)
    q = deque([n])
    dist[n] = 0
    while q:
        v = q.popleft()
        for (u,t) in rg[v]:
            if t == 0:
                if not seen0[u]:
                    seen0[u] = True
            else:
                if not seen1[u]:
                    seen1[u] = True
            if dist[u] == -1 and seen0[u] and seen1[u]:
                dist[u] = dist[v] + 1
                q.append(u)
    color_bits = []
    for u in range(1, n+1):
        if not seen0[u]:
            color_bits.append('0')
        elif not seen1[u]:
            color_bits.append('1')
        else:
            color_bits.append('0')
    return dist[1], "".join(color_bits)

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return ""
    m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); t = int(next(it))
        edges.append((u,v,t))
    ans, colors = solve_case(n, edges)
    return f"{ans}\n{colors}"

def main():
    data = read_input()
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Exactly 3 asserts
    # 1) Simple chain with alternate shortcut
    n = 3
    edges = [(1,2,0),(2,3,0),(1,3,1)]
    d, c = solve_case(n, edges)
    assert d == 2
    # 2) No edges
    d2, c2 = solve_case(2, [])
    assert d2 == -1
    # 3) Star into n with both types from 1; can block
    n3 = 4
    edges3 = [(1,2,0),(1,3,1),(2,4,0),(3,4,1)]
    d3, c3 = solve_case(n3, edges3)
    assert d3 == -1 or d3 >= 2
    main()
\end{minted}
\VALIDATION{Three asserts on handcrafted graphs, including a case where the manager can block all paths ($-1$).}
\RESULT{Print $-1$ if $1$ cannot reach $n$ under the chosen schedule; otherwise, print the maximum shortest-path length and one valid schedule achieving it.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny graphs; property test comparing brute force (Approach A) to optimal (Approach C) for $n\le 7$ on random graphs; targeted cases with self-loops and parallel edges.}
\LINE{CROSS-CHECKS}{Compare lengths from brute force vs. optimal on randomly generated small graphs; verify coloring preference rule ($b(u,t)=0$) never worsens the answer.}
\LINE{EDGE-CASE GENERATOR}{Produce graphs with: empty edges; all edges one type; nodes with only in-edges; self-loops; parallel edges; disconnected components.}
\begin{minted}{python}
import sys
from collections import deque
import random

def brute_force_max(n, edges):
    def bfs(adj):
        dist = [-1]*(n+1)
        dq = deque([1])
        dist[1] = 0
        while dq:
            u = dq.popleft()
            if u == n:
                return dist[u]
            for v in adj[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    dq.append(v)
        return -1
    best_len = -1
    best_mask = 0
    for mask in range(1<<n):
        adj = [[] for _ in range(n+1)]
        for (u,v,t) in edges:
            if ((mask>>(u-1)) & 1) == t:
                adj[u].append(v)
        d = bfs(adj)
        if d == -1:
            return -1
        if best_len != -1 and d > best_len:
            best_len = d
            best_mask = mask
        elif best_len == -1:
            # keep looking for -1; else record first finite
            best_len = d
            best_mask = mask
    color = "".join('1' if ((best_mask>>i)&1) else '0' for i in range(n))
    return best_len

def optimal_len(n, edges):
    rg = [[] for _ in range(n+1)]
    for u,v,t in edges:
        rg[v].append((u,t))
    dist = [-1]*(n+1)
    seen0 = [False]*(n+1)
    seen1 = [False]*(n+1)
    dq = deque([n])
    dist[n] = 0
    while dq:
        v = dq.popleft()
        for (u,t) in rg[v]:
            if t == 0:
                if not seen0[u]:
                    seen0[u] = True
            else:
                if not seen1[u]:
                    seen1[u] = True
            if dist[u] == -1 and seen0[u] and seen1[u]:
                dist[u] = dist[v] + 1
                dq.append(u)
    return dist[1]

def property_test():
    random.seed(7)
    for n in range(2, 8):
        for _ in range(50):
            m = random.randint(0, n*(n-1))
            edges = []
            for __ in range(m):
                u = random.randint(1, n)
                v = random.randint(1, n)
                t = random.randint(0, 1)
                edges.append((u,v,t))
            bf = brute_force_max(n, edges) if n <= 7 else None
            opt = optimal_len(n, edges)
            if bf == -1:
                assert opt == -1
            else:
                assert opt >= bf

if __name__ == "__main__":
    property_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def solve_case(n, edges):
    # Build reverse adjacency
    rg = [[] for _ in range(n+1)]
    for u,v,t in edges:
        rg[v].append((u,t))
    dist = [-1]*(n+1)
    seen0 = [False]*(n+1)
    seen1 = [False]*(n+1)
    dq = deque([n])
    dist[n] = 0
    while dq:
        v = dq.popleft()
        for (u,t) in rg[v]:
            if t == 0:
                if not seen0[u]:
                    seen0[u] = True
            else:
                if not seen1[u]:
                    seen1[u] = True
            if dist[u] == -1 and seen0[u] and seen1[u]:
                dist[u] = dist[v] + 1
                dq.append(u)
    color = []
    for u in range(1, n+1):
        if not seen0[u]:
            color.append('0')
        elif not seen1[u]:
            color.append('1')
        else:
            color.append('0')
    return dist[1], "".join(color)

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return ""
    m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); t = int(next(it))
        edges.append((u,v,t))
    d, c = solve_case(n, edges)
    return f"{d}\n{c}"

def main():
    data = read_input()
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Minimal internal sanity checks (do not print)
    # 1) Simple chain with alternate shortcut
    n = 3
    edges = [(1,2,0),(2,3,0),(1,3,1)]
    d, c = solve_case(n, edges)
    assert d == 2
    # 2) No edges
    d2, c2 = solve_case(2, [])
    assert d2 == -1
    # 3) Self-loop on start only, n=1
    d3, c3 = solve_case(1, [(1,1,0)])
    assert d3 == 0
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reverse BFS from $n$; mark for each node which outgoing types lead to discovered nodes; enqueue a node when both types are seen; color to avoid enabling a discovered type if possible.}
\WHY{Classic adversarial shortest path with per-node action restrictions; appears in interviews to test reverse-graph reasoning and greedy choices.}
\CHECKLIST{
- Build reverse adjacency.
- Initialize $d[n]=0$ and queue with $n$.
- While queue: pop $v$; for each incoming $(u,t)$ mark type seen; if both types seen and $d[u]$ unset, set $d[u]=d[v]+1$, enqueue.
- After BFS, assign colors preferring unseen types.
- Print $d[1]$ or $-1$, and the color string.}
\EDGECASES{
- No edges at all.
- Nodes with no outgoing edges.
- Self-loops and parallel edges.
- Start equals target ($n=1$).
- All edges same type.
- Disconnected components.}
\PITFALLS{
- Forgetting to only enqueue $u$ once when both types become seen.
- Assigning colors before finishing BFS.
- Using forward graph instead of reverse for propagation.
- Off-by-one in $1$-indexing.
- Printing colors in $1..n$ order.
- Memory blowup by storing both directions unnecessarily.}
\FAILMODES{Brute force fails for $n>20$. Greedy on forward graph without reverse forcing can pick non-optimal colors. The reverse-forcing method avoids these by only fixing $d(u)$ when unavoidable.}
\ELI{Work backward from the destination: mark which exits from a city would allow a quick step toward the goal. If there is still a safe exit type that does not lead closer, choose it; otherwise, you are forced and your distance is set.}
\NotePages{3}

\end{document}