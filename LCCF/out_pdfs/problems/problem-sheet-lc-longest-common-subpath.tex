% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Longest Common Subpath}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/longest-common-subpath/}}
\LINE{DIFFICULTY / RATING}{Hard}
\STATEMENT{There is a country of $n$ cities numbered from $0$ to $n-1$. In this country, there is a road connecting every pair of cities.

There are $m$ friends numbered from $0$ to $m-1$ who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively.

Given an integer $n$ and a 2D integer array $\text{paths}$ where $\text{paths}[i]$ is an integer array representing the path of the $i$th friend, return the length of the longest common subpath that is shared by every friend's path, or $0$ if there is no common subpath at all.

A subpath of a path is a contiguous sequence of cities within that path.

Example 1:

Input: $n=5$, $\text{paths}=[[0,1,2,3,4],[2,3,4],[4,0,1,2,3]]$.

Output: $2$.

Explanation: The longest common subpath is $[2,3]$.

Example 2:

Input: $n=3$, $\text{paths}=[[0],[1],[2]]$.

Output: $0$.

Explanation: There is no common subpath shared by the three paths.

Example 3:

Input: $n=5$, $\text{paths}=[[0,1,2,3,4],[4,3,2,1,0]]$.

Output: $1$.

Explanation: The possible longest common subpaths are $[0]$, $[1]$, $[2]$, $[3]$, and $[4]$. All have a length of $1$.

Constraints:
\begin{bullets}
\item $1 \le n \le 10^{5}$
\item $m = \text{paths.length}$
\item $2 \le m \le 10^{5}$
\item $\sum \text{paths}[i].\text{length} \le 10^{5}$
\item $0 \le \text{paths}[i][j] < n$
\item The same city is not listed multiple times consecutively in $\text{paths}[i]$.
\end{bullets}}
\BREAKDOWN{Find the maximum length $L$ such that there exists at least one contiguous sequence of cities of length $L$ appearing in all $m$ paths. Use decision + search: for a candidate $L$, test whether a common subpath of length $L$ exists; then binary search on $L$.}
\ELI{Binary search the answer length and use rolling hashes to check if some length-$L$ window appears in every path.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LC): \texttt{def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int}.

Inputs:
\begin{bullets}
\item $n$: number of cities, integer.
\item $\text{paths}$: list of $m$ integer lists, each list is a path; values are in $[0,n-1]$; no adjacent equal cities.
\end{bullets}}
\OUTPUTS{An integer equal to the maximum length of a subpath that appears in every path.}
\SAMPLES{
\begin{bullets}
\item $n=5$, $\text{paths}=[[0,1,2,3,4],[2,3,4],[4,0,1,2,3]] \Rightarrow 2$
\item $n=3$, $\text{paths}=[[0],[1],[2]] \Rightarrow 0$
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given sequences $P_1,\ldots,P_m$ over alphabet $\{0,\ldots,n-1\}$, find
\begin{BreakableEquation*}
L^\star = \max\{L \in \mathbb{Z}_{\ge 0} \mid \exists~S~\text{of length }L\text{ s.t. } S \text{ occurs contiguously in every } P_i\}.
\end{BreakableEquation*}}
\varmapStart
\var{n}{number of cities (alphabet size upper bound)}
\var{m}{number of paths}
\var{P_i}{the $i$th path (sequence of integers)}
\var{L}{candidate subpath length}
\var{S}{a contiguous sequence (pattern) of cities}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i \in \{1,\ldots,m\}:\quad S \prec P_i \quad\text{where } S \prec P \text{ means $S$ is a contiguous subsequence of $P$}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $0$-based; paths may revisit cities but not in consecutive positions; all values are in $[0,n-1]$.}
\INVARIANTS{
\begin{bullets}
\item If a length $L$ subpath exists in all paths, then any $L' \le L$ also exists in all paths (monotonicity for binary search).
\item For fixed $L$, the set of length-$L$ windows in each path can be represented by hashes; intersection across all $m$ determines feasibility.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all subpaths of the shortest path and intersect with the set of subpaths of each other path.}
\ASSUMPTIONS{Suitable only for very small total input size; stores explicit tuples of cities.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pick the shortest path $Q$ among all paths.
\item Generate all contiguous windows of $Q$ as tuples and group them by length $L$.
\item For $L$ from $|Q|$ down to $0$, intersect the set of all length-$L$ windows of $Q$ with the set of length-$L$ windows of every other path. Return the first $L$ with a nonempty intersection.
\end{algosteps}
\COMPLEXITY{Let $S=\sum |P_i|$ and let $s_{\min}$ be the shortest path length. Generating all subpaths of $Q$ is $O(s_{\min}^2)$ in time and space; building window sets for the other paths is $O(S)$ per length, i.e., worst-case $O(S\cdot s_{\min})$, which is too large for constraints but fine for tiny tests.}
\[
\begin{aligned}
T_{\text{baseline}} &\in \Theta\bigl(s_{\min}^2 + \sum_{L=1}^{s_{\min}} \sum_{i=1}^{m} |P_i|\bigr) \\
S_{\text{baseline}} &\in \Theta(s_{\min}^2).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration covers all candidate subpaths; intersection ensures presence in every path. The first $L$ found when scanning downward is maximal.}
\EDGECASES{
\begin{bullets}
\item If any path is empty, answer is $0$.
\item If $m=1$, answer is the length of that path.
\item Repeated cities allowed as long as not consecutively; tuples capture exact contiguity.
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Set

class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        # Choose shortest path to minimize enumeration
        paths_sorted = sorted(paths, key=len)
        shortest = paths_sorted[0]
        if len(shortest) == 0:
            return 0
        if len(paths_sorted) == 1:
            return len(shortest)

        # Precompute all windows of the shortest path grouped by length
        windows_by_len = {}
        smin = len(shortest)
        for L in range(1, smin + 1):
            seen = set()
            for i in range(0, smin - L + 1):
                seen.add(tuple(shortest[i:i+L]))
            windows_by_len[L] = seen

        # For each length from large to small, check intersection across all paths
        for L in range(smin, 0, -1):
            cand = windows_by_len[L]
            ok = True
            for idx in range(1, len(paths_sorted)):
                P = paths_sorted[idx]
                if len(P) < L:
                    ok = False
                    break
                cur = set()
                for i in range(0, len(P) - L + 1):
                    cur.add(tuple(P[i:i+L]))
                cand = cand.intersection(cur)
                if not cand:
                    ok = False
                    break
            if ok and cand:
                return L
        return 0

# Tiny sanity checks for the baseline
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[2,3,4],[4,0,1,2,3]]) == 2
    assert sol.longestCommonSubpath(3, [[0],[1],[2]]) == 0
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[4,3,2,1,0]]) == 1
\end{minted}
\VALIDATION{Checked on the three examples. Also implicitly verifies empty intersection handling when a path is shorter than the candidate length.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search + Single Rolling Hash}
\WHICHFORMULA{Use monotonicity in $L$ with binary search; for a fixed $L$, compute rolling-hash sets of length-$L$ windows per path and intersect them.}
\ASSUMPTIONS{Polynomial rolling hash with one large modulus. Low collision probability on typical data; still nonzero.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort paths by length to prune early when intersecting.
\item Binary search $L$ in $[0,\min |P_i|]$.
\item For a fixed $L>0$, compute the set of hashes of all length-$L$ windows of the first (shortest) path. For each subsequent path, compute its set and intersect.
\item If the intersection is nonempty, $L$ is feasible; otherwise not. Return the maximum feasible $L$.
\end{algosteps}
\COMPLEXITY{Each feasibility check runs in $O(S)$ expected time with hashing; binary search adds a $\log s_{\min}$ factor.}
\[
\begin{aligned}
T_{\text{improved}} &\in \Theta\bigl(S \log s_{\min}\bigr),\quad S=\sum_i |P_i|,\ s_{\min}=\min_i |P_i|, \\
S_{\text{improved}} &\in O\bigl(\max_i |P_i|\bigr).
\end{aligned}
\]
\CORRECTNESS{Rolling hashes preserve contiguity. Monotonicity ensures binary search correctness. With a single modulus there is a minute collision risk; addressed fully in the optimal approach with double hashing.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Set

class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        paths = sorted(paths, key=len)
        smin = len(paths[0])
        if smin == 0:
            return 0

        mod = 1_000_000_007
        base = 911382323  # < mod

        def has_len(L: int) -> bool:
            if L == 0:
                return True
            powL = pow(base, L-1, mod)
            inter: Set[int] = set()

            # Process the shortest path first to seed intersection
            P0 = paths[0]
            h = 0
            for i in range(L):
                h = (h * base + (P0[i] + 1)) % mod
            inter.add(h)
            for i in range(L, len(P0)):
                h = (h * base - (P0[i-L] + 1) * powL + (P0[i] + 1)) % mod
                inter.add(h)
            # Normalize modulo
            inter = {x % mod for x in inter}

            for k in range(1, len(paths)):
                P = paths[k]
                if len(P) < L:
                    return False
                seen: Set[int] = set()
                h = 0
                for i in range(L):
                    h = (h * base + (P[i] + 1)) % mod
                seen.add(h)
                for i in range(L, len(P)):
                    h = (h * base - (P[i-L] + 1) * powL + (P[i] + 1)) % mod
                    seen.add(h % mod)
                inter = inter.intersection(seen)
                if not inter:
                    return False
            return bool(inter)

        lo, hi = 0, smin
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if has_len(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo

# Sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[2,3,4],[4,0,1,2,3]]) == 2
    assert sol.longestCommonSubpath(3, [[0],[1],[2]]) == 0
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[4,3,2,1,0]]) == 1
\end{minted}
\VALIDATION{Validated on the provided examples. For stronger guarantees against collisions, use two independent moduli (next section).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search + Double Rolling Hash (Rabin--Karp) With Intersection}
\WHICHFORMULA{Binary search on $L$; feasibility by intersecting double-hash pairs across all paths, processing in ascending path length.}
\ASSUMPTIONS{Two large prime moduli and a common base yield negligible collision probability. Works within $O(S \log s_{\min})$ time for $\sum |P_i| \le 10^{5}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort paths by length.
\item Binary search $L$ in $[0,s_{\min}]$.
\item For a fixed $L>0$, compute all length-$L$ rolling hashes for each path under both moduli, form pairs, and intersect across all paths.
\item If intersection nonempty, $L$ is feasible; otherwise not. Return the maximum feasible $L$.
\end{algosteps}
\OPTIMALITY{By monotonicity, binary search on $L$ is optimal up to a $\log$ factor. Each feasibility check touches each element a constant number of times; hence $T \in \Theta(S \log s_{\min})$, which matches known optimal solutions for these constraints.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &\in \Theta\bigl(S \log s_{\min}\bigr), \\
S(n) &\in O\bigl(\max_i |P_i|\bigr),
\end{aligned}
\]
with $S=\sum_i |P_i|$ and $s_{\min}=\min_i |P_i|$.
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Set, Tuple

class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        paths = sorted(paths, key=len)
        smin = len(paths[0])
        if smin == 0:
            return 0
        if len(paths) == 1:
            return smin

        mod1 = 1_000_000_007
        mod2 = 1_000_000_009
        base = 911382323  # < both moduli, fixed and deterministic

        def has_len(L: int) -> bool:
            if L == 0:
                return True
            pow1 = pow(base, L-1, mod1)
            pow2 = pow(base, L-1, mod2)

            # Seed with hashes from the shortest path
            P0 = paths[0]
            h1 = 0
            h2 = 0
            inter: Set[Tuple[int, int]] = set()
            for i in range(L):
                v = P0[i] + 1
                h1 = (h1 * base + v) % mod1
                h2 = (h2 * base + v) % mod2
            inter.add((h1, h2))
            for i in range(L, len(P0)):
                v_out = P0[i - L] + 1
                v_in = P0[i] + 1
                h1 = (h1 * base - v_out * pow1 + v_in) % mod1
                h2 = (h2 * base - v_out * pow2 + v_in) % mod2
                inter.add((h1 % mod1, h2 % mod2))

            for k in range(1, len(paths)):
                P = paths[k]
                if len(P) < L:
                    return False
                seen: Set[Tuple[int, int]] = set()
                h1 = 0
                h2 = 0
                for i in range(L):
                    v = P[i] + 1
                    h1 = (h1 * base + v) % mod1
                    h2 = (h2 * base + v) % mod2
                seen.add((h1, h2))
                for i in range(L, len(P)):
                    v_out = P[i - L] + 1
                    v_in = P[i] + 1
                    h1 = (h1 * base - v_out * pow1 + v_in) % mod1
                    h2 = (h2 * base - v_out * pow2 + v_in) % mod2
                    seen.add((h1 % mod1, h2 % mod2))
                inter = inter.intersection(seen)
                if not inter:
                    return False
            return bool(inter)

        lo, hi = 0, smin
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if has_len(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo

# Tests (exactly 3)
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[2,3,4],[4,0,1,2,3]]) == 2
    assert sol.longestCommonSubpath(3, [[0],[1],[2]]) == 0
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[4,3,2,1,0]]) == 1
\end{minted}
\VALIDATION{Three asserts cover the provided examples. Additional randomized tests are provided later to cross-check against the baseline on tiny inputs.}
\RESULT{Returns the maximum length $L$ of a contiguous subpath appearing in every path; ties are irrelevant as only the length is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify on official examples; random small cases cross-checking baseline vs final; adversarial cases like disjoint paths, identical paths, single-city paths, and varying path lengths.}
\LINE{CROSS-CHECKS}{On small sizes, compare the brute-force baseline with the optimal method to detect any hashing anomaly.}
\LINE{EDGE-CASE GENERATOR}{Generate random paths ensuring no consecutive duplicates; include extremes like $L=0$ and $L=s_{\min}$.}
\begin{minted}{python}
import random
from typing import List

def gen_paths(n: int, m: int, max_len: int, seed: int = 0) -> List[List[int]]:
    rng = random.Random(seed)
    paths = []
    for _ in range(m):
        L = rng.randint(0, max_len)
        if L == 0:
            paths.append([])
            continue
        path = [rng.randrange(n)]
        for _ in range(1, L):
            nxt = rng.randrange(n)
            if nxt == path[-1]:
                nxt = (nxt + 1) % n
            path.append(nxt)
        paths.append(path)
    return paths

# Cross-check baseline vs optimal on tiny randoms
def longest_common_subpath_baseline(n: int, paths: List[List[int]]) -> int:
    if not paths:
        return 0
    paths_sorted = sorted(paths, key=len)
    shortest = paths_sorted[0]
    if len(shortest) == 0:
        return 0
    best = 0
    for L in range(len(shortest), 0, -1):
        cand = set(tuple(shortest[i:i+L]) for i in range(0, len(shortest)-L+1))
        ok = True
        for P in paths_sorted[1:]:
            if len(P) < L:
                ok = False
                break
            cur = set(tuple(P[i:i+L]) for i in range(0, len(P)-L+1))
            cand &= cur
            if not cand:
                ok = False
                break
        if ok and cand:
            return L
    return 0

# Final reference (duplicated from Approach C)
class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        paths = sorted(paths, key=len)
        smin = len(paths[0])
        if smin == 0:
            return 0
        if len(paths) == 1:
            return smin
        mod1 = 1_000_000_007
        mod2 = 1_000_000_009
        base = 911382323
        def has_len(L: int) -> bool:
            if L == 0:
                return True
            pow1 = pow(base, L-1, mod1)
            pow2 = pow(base, L-1, mod2)
            P0 = paths[0]
            h1 = h2 = 0
            inter = set()
            for i in range(L):
                v = P0[i] + 1
                h1 = (h1 * base + v) % mod1
                h2 = (h2 * base + v) % mod2
            inter.add((h1, h2))
            for i in range(L, len(P0)):
                v_out = P0[i - L] + 1
                v_in = P0[i] + 1
                h1 = (h1 * base - v_out * pow1 + v_in) % mod1
                h2 = (h2 * base - v_out * pow2 + v_in) % mod2
                inter.add((h1 % mod1, h2 % mod2))
            for P in paths[1:]:
                if len(P) < L:
                    return False
                seen = set()
                h1 = h2 = 0
                for i in range(L):
                    v = P[i] + 1
                    h1 = (h1 * base + v) % mod1
                    h2 = (h2 * base + v) % mod2
                seen.add((h1, h2))
                for i in range(L, len(P)):
                    v_out = P[i - L] + 1
                    v_in = P[i] + 1
                    h1 = (h1 * base - v_out * pow1 + v_in) % mod1
                    h2 = (h2 * base - v_out * pow2 + v_in) % mod2
                    seen.add((h1 % mod1, h2 % mod2))
                inter &= seen
                if not inter:
                    return False
            return True
        lo, hi = 0, smin
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if has_len(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo

if __name__ == "__main__":
    # Official examples
    sol = Solution()
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[2,3,4],[4,0,1,2,3]]) == 2
    assert sol.longestCommonSubpath(3, [[0],[1],[2]]) == 0
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[4,3,2,1,0]]) == 1

    # Random cross-checks on tiny sizes
    for seed in range(10):
        n = 6
        m = 3
        paths = gen_paths(n, m, max_len=8, seed=seed)
        b = longest_common_subpath_baseline(n, paths)
        c = sol.longestCommonSubpath(n, paths)
        assert b == c, (seed, paths, b, c)

    # Edge crafted cases
    assert sol.longestCommonSubpath(1, [[0,0,0], [0], [0,0]]) == 1
    assert sol.longestCommonSubpath(10, [[], [], []]) == 0
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Set, Tuple

class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        paths = sorted(paths, key=len)
        smin = len(paths[0])
        if smin == 0:
            return 0
        if len(paths) == 1:
            return smin

        mod1 = 1_000_000_007
        mod2 = 1_000_000_009
        base = 911382323  # fixed base < mod

        def has_len(L: int) -> bool:
            if L == 0:
                return True
            pow1 = pow(base, L-1, mod1)
            pow2 = pow(base, L-1, mod2)

            # Hash windows of the shortest path
            P0 = paths[0]
            h1 = h2 = 0
            inter: Set[Tuple[int, int]] = set()
            for i in range(L):
                v = P0[i] + 1
                h1 = (h1 * base + v) % mod1
                h2 = (h2 * base + v) % mod2
            inter.add((h1, h2))
            for i in range(L, len(P0)):
                v_out = P0[i - L] + 1
                v_in = P0[i] + 1
                h1 = (h1 * base - v_out * pow1 + v_in) % mod1
                h2 = (h2 * base - v_out * pow2 + v_in) % mod2
                inter.add((h1 % mod1, h2 % mod2))

            # Intersect with others
            for P in paths[1:]:
                if len(P) < L:
                    return False
                seen: Set[Tuple[int, int]] = set()
                h1 = h2 = 0
                for i in range(L):
                    v = P[i] + 1
                    h1 = (h1 * base + v) % mod1
                    h2 = (h2 * base + v) % mod2
                seen.add((h1, h2))
                for i in range(L, len(P)):
                    v_out = P[i - L] + 1
                    v_in = P[i] + 1
                    h1 = (h1 * base - v_out * pow1 + v_in) % mod1
                    h2 = (h2 * base - v_out * pow2 + v_in) % mod2
                    seen.add((h1 % mod1, h2 % mod2))
                inter &= seen
                if not inter:
                    return False
            return True

        lo, hi = 0, smin
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if has_len(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo

# Self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[2,3,4],[4,0,1,2,3]]) == 2
    assert sol.longestCommonSubpath(3, [[0],[1],[2]]) == 0
    assert sol.longestCommonSubpath(5, [[0,1,2,3,4],[4,3,2,1,0]]) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the maximum length of a contiguous city sequence common to all given paths.}
\WHY{Combines binary search, hashing, and set intersections under tight sum-length constraints — a common hard-interview pattern.}
\CHECKLIST{
\begin{bullets}
\item Sort paths by length.
\item Binary search length $L$.
\item For fixed $L$, compute rolling hashes and intersect across paths.
\item Use double hashing to avoid collisions.
\item Early abort if a path is shorter than $L$ or intersection becomes empty.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Empty path present $\Rightarrow$ answer $0$.
\item Single path $\Rightarrow$ answer is its length.
\item All paths identical $\Rightarrow$ answer is their length.
\item Disjoint alphabets across paths $\Rightarrow$ answer $0$.
\item Repeats allowed but no consecutive duplicates; algorithm does not rely on this but inputs satisfy it.
\item Very short $s_{\min}$ bounds the answer immediately.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to offset values (use $+1$) when hashing can increase collisions if zeros abound.
\item Using a single modulus risks rare collisions; mitigate by double hashing.
\item Not taking modulo after subtraction in rolling update can yield negative values.
\item Building sets for long $L$ before checking path length wastes time; check early.
\item Intersecting in arbitrary order instead of from smallest set can slow down; sorting by path length helps.
\item Off-by-one in rolling window range loops.
\end{bullets}
}
\FAILMODES{Brute-force tuple enumeration explodes to $O(s_{\min}^2)$ storage. Single-hash approaches have a residual collision risk; double hashing addresses it.}
\ELI{We try lengths and check if any subpath of that length appears in all paths by hashing all sliding windows and taking intersections. If some length works, try longer; if not, try shorter, until we find the maximum.}
\NotePages{3}

\end{document}