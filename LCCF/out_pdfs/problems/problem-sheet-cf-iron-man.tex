% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Iron Man}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/704/E}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Tony Stark is playing a game with his suits (they have auto-pilot now). He lives in Malibu. Malibu has $n$ junctions numbered from $1$ to $n$, connected with $n - 1$ roads. One can get from a junction to any other junction using these roads (graph of Malibu forms a tree).

Tony has $m$ suits. There is a special plan for each suit. The $i$-th suit will appear at the moment of time $t_i$ in the junction $v_i$, and will move to junction $u_i$ using the shortest path between $v_i$ and $u_i$ with the speed $c_i$ roads per second (passing a junction takes no time), and vanishing immediately when arriving at $u_i$ (if it reaches $u_i$ in time $q$, it is available there at moment $q$, but not in further moments). Also, suits move continuously (for example if $v_i \ne u_i$, at time $t_i + \tfrac{1}{2 c_i}$ it is in the middle of a road). Please note that if $v_i = u_i$ it means the suit will be at junction number $v_i$ only at moment $t_i$ and then it vanishes.

An explosion happens if at any moment of time two suits share the same exact location (it may be in a junction or somewhere on a road; while appearing, vanishing or moving).

Your task is to tell Tony the moment of the first explosion (if there will be any).

Input:
The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 100\,000$) — the number of junctions and the number of suits respectively.

The next $n - 1$ lines contain the roads descriptions. Each line contains two integers $a_i$ and $b_i$ — endpoints of the $i$-th road ($1 \le a_i, b_i \le n$, $a_i \ne b_i$).

The next $m$ lines contain the suit descriptions. The $i$-th of them contains four integers $t_i, c_i, v_i$ and $u_i$ ($0 \le t_i \le 10\,000$, $1 \le c_i \le 10\,000$, $1 \le v_i, u_i \le n$), meaning the $i$-th suit will appear at moment of time $t_i$ at the junction $v_i$ and will move to the junction $u_i$ with a speed $c_i$ roads per second.

Output:
If there would be no explosions at all, print $-1$ in the first and only line of output.

Otherwise print the moment of the first explosion.

Your answer will be considered correct if its relative or absolute error does not exceed $10^{-6}$.}
\BREAKDOWN{We work on a tree metric with continuous motion along shortest paths. The first explosion time is the minimum time when two trajectories coincide in space--time, possibly on an edge interior. Reduce pairwise meeting to solving an equation along the intersection of their two paths.}
\ELI{Two suits meet iff the time they each need to reach some common point $x$ on the tree is the same; restrict to the intersection of their paths and solve a simple piecewise-linear equation.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$; $n-1$ undirected edges $(a_i,b_i)$; $m$ suit tuples $(t_i,c_i,v_i,u_i)$. Constraints: $1 \le n,m \le 100\,000$, $0 \le t_i \le 10\,000$, $1 \le c_i \le 10\,000$, nodes in $[1,n]$.}
\OUTPUTS{A single real number: earliest explosion time, or $-1$ if no explosion occurs. Any answer within absolute or relative error $\le 10^{-6}$ is accepted.}
\SAMPLES{Example 1 (no collision): a star tree where suits use edge-disjoint paths, output $-1$. Example 2 (collision): line $1-2-3$, two suits from $1 \to 3$ and $3 \to 1$ at $t=0$, $c=1$, meet at node $2$ at time $1.0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a tree with unit-length edges. Suit $i$ starts at time $t_i$ at $v_i$, moves at speed $c_i$ along the unique path $P(v_i,u_i)$, and disappears upon reaching $u_i$. Two suits $i,j$ explode if there exists $x \in V \cup$ edge interiors and $t \in \mathbb{R}_{\ge 0}$ such that $t = t_i + \tfrac{d(v_i,x)}{c_i} = t_j + \tfrac{d(v_j,x)}{c_j}$ and $x \in P(v_i,u_i) \cap P(v_j,u_j)$.}
\varmapStart
\var{d(x,y)}{tree distance (continuous metric)}
\var{P(a,b)}{unique simple path from $a$ to $b$ (including edges)}
\var{S_{ij}}{path intersection $P(v_i,u_i) \cap P(v_j,u_j)$}
\var{s}{arc-length coordinate along $S_{ij}$ from one endpoint}
\var{s_i}{projection coordinate of $v_i$ onto $S_{ij}$}
\var{D_i}{distance $d(v_i,\text{proj}_{S_{ij}}(v_i))$}
\var{R}{offset $t_j - t_i$}
\var{c_i}{speed of suit $i$ (edges per second)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For } x \in S_{ij} \text{ with coordinate } s \in [0,L]:\quad t = t_i + \frac{D_i + |s - s_i|}{c_i} = t_j + \frac{D_j + |s - s_j|}{c_j}.
\end{BreakableEquation*}
Equivalently,
\begin{BreakableEquation*}
K + \frac{|s-s_i|}{c_i} - \frac{|s-s_j|}{c_j} \;=\; R,\quad \text{where } K=\frac{D_i}{c_i}-\frac{D_j}{c_j},\; R=t_j-t_i.
\end{BreakableEquation*}
On the three regions $s \le \min(s_i,s_j)$, $\min \le s \le \max$, and $s \ge \max$, the left-hand side is linear in $s$ with slopes in $\{\tfrac{1}{c_j}-\tfrac{1}{c_i},\; \pm(\tfrac{1}{c_i}+\tfrac{1}{c_j}),\; \tfrac{1}{c_i}-\tfrac{1}{c_j}\}$.
}
\ASSUMPTIONS{Edges have unit length; motion is continuous; appearance/vanish are instantaneous but count at that exact moment. LCA and distances are with respect to an arbitrary rooted tree (e.g., root at $1$).}
\INVARIANTS{The intersection of two simple paths in a tree is either empty or a simple path. The closest point on a path to a node is the median of the path endpoints and the node. Along a fixed path, distance to a fixed node is a convex piecewise-linear function of arc-length.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Check every unordered pair of suits. For a pair, compute $S_{ij}=P(v_i,u_i)\cap P(v_j,u_j)$. If non-empty, solve the piecewise-linear equation on $S_{ij}$ to get the meeting time (if any). Take the minimum over pairs.}
\ASSUMPTIONS{Tree utilities (LCA, distance, on-path) available in $O(\log n)$. Intersection endpoints can be obtained from a constant-size candidate set via on-path checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess LCA and depths to answer $d(x,y)$ and on-path queries.
\item For every pair $(i,j)$, compute $S_{ij}$ endpoints $(p,q)$ or detect emptiness.
\item Project $v_i$ and $v_j$ onto $S_{ij}$ to get $s_i,s_j$ and base distances $D_i,D_j$; solve the piecewise-linear equation for $s \in [0,L]$; convert to time $t$; track the minimum.
\end{algosteps}
\COMPLEXITY{$O(n \log n + m^2 \log n)$ time and $O(n \log n)$ space. This is acceptable only for small $m$.}
\[
\begin{aligned}
T(n,m) &= O(n \log n) + \binom{m}{2}\cdot O(\log n) \\
       &= O(n \log n + m^2 \log n).
\end{aligned}
\]
\CORRECTNESS{Two suits meet iff they meet on $S_{ij}$. The time to reach any point $x \in S_{ij}$ is $t_i + \tfrac{d(v_i,\text{proj}) + |s-s_i|}{c_i}$. Equating the two times yields a convex piecewise-linear equation in $s$ with at most one solution per region; checking all regions and boundaries suffices.}
\EDGECASES{Zero-length paths ($v_i=u_i$); appearance at the same node/time; meeting in edge interiors (non-integer $s$); identical speeds/directions causing a whole-interval equality (handle $A=0$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math
sys.setrecursionlimit(1 << 25)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    m = int(next(it))
    edges = [[] for _ in range(n+1)]
    es = []
    for _ in range(n-1):
        a = int(next(it)); b = int(next(it))
        edges[a].append(b); edges[b].append(a)
        es.append((a,b))
    suits = []
    for _ in range(m):
        t = int(next(it)); c = int(next(it)); v = int(next(it)); u = int(next(it))
        suits.append((t, c, v, u))
    return n, m, edges, suits

class LCA:
    def __init__(self, n, adj, root=1):
        LOG = max(1, (n).bit_length())
        self.n = n
        self.LOG = LOG
        self.up = [[0]*(n+1) for _ in range(LOG)]
        self.depth = [0]*(n+1)
        self.tin = [0]*(n+1)
        self.tout = [0]*(n+1)
        self.time = 0
        self.adj = adj
        self._dfs(root, root)
        for k in range(1, LOG):
            for v in range(1, n+1):
                self.up[k][v] = self.up[k-1][self.up[k-1][v]]

    def _dfs(self, v, p):
        stack = [(v, p, 0)]
        while stack:
            v, p, state = stack.pop()
            if state == 0:
                self.up[0][v] = p
                self.depth[v] = 0 if v == p else self.depth[p] + 1
                self.tin[v] = self.time; self.time += 1
                stack.append((v, p, 1))
                for to in self.adj[v]:
                    if to == p: continue
                    stack.append((to, v, 0))
            else:
                self.tout[v] = self.time

    def is_ancestor(self, u, v):
        return self.tin[u] <= self.tin[v] and self.tout[v] <= self.tout[u]

    def lca(self, a, b):
        if self.is_ancestor(a, b):
            return a
        if self.is_ancestor(b, a):
            return b
        for k in range(self.LOG-1, -1, -1):
            x = self.up[k][a]
            if x and not self.is_ancestor(x, b):
                a = x
        return self.up[0][a]

    def dist(self, a, b):
        c = self.lca(a, b)
        return self.depth[a] + self.depth[b] - 2*self.depth[c]

def on_path(lca_tool, a, b, x):
    return lca_tool.dist(a, x) + lca_tool.dist(x, b) == lca_tool.dist(a, b)

def path_intersection(lc, a, b, c, d):
    # Candidates include endpoints and pairwise LCAs
    cands = {a, b, c, d, lc.lca(a,b), lc.lca(c,d),
             lc.lca(a,c), lc.lca(a,d), lc.lca(b,c), lc.lca(b,d)}
    pts = []
    for x in cands:
        if x == 0: continue
        if on_path(lc, a, b, x) and on_path(lc, c, d, x):
            pts.append(x)
    if not pts:
        return None
    # Take farthest pair among pts as endpoints
    best = (pts[0], pts[0], 0)
    for i in range(len(pts)):
        for j in range(i, len(pts)):
            u, v = pts[i], pts[j]
            dist = lc.dist(u, v)
            if dist > best[2]:
                best = (u, v, dist)
    return (best[0], best[1])

def median_on_path(lc, a, b, w):
    # Median of (a,b,w) equals the deepest among lca(a,b), lca(a,w), lca(b,w)
    x1 = lc.lca(a, b); x2 = lc.lca(a, w); x3 = lc.lca(b, w)
    # Return argmax depth
    x = x1
    if lc.depth[x2] > lc.depth[x]: x = x2
    if lc.depth[x3] > lc.depth[x]: x = x3
    return x

def solve_pair_meeting(lc, suit1, suit2, eps=1e-12):
    t1, c1, v1, u1 = suit1
    t2, c2, v2, u2 = suit2
    inter = path_intersection(lc, v1, u1, v2, u2)
    if inter is None:
        return None
    p, q = inter
    L = lc.dist(p, q)
    # Projections of starts onto S
    y1 = median_on_path(lc, p, q, v1)
    y2 = median_on_path(lc, p, q, v2)
    s1 = lc.dist(p, y1)
    s2 = lc.dist(p, y2)
    D1 = lc.dist(v1, y1)
    D2 = lc.dist(v2, y2)
    K = D1/float(c1) - D2/float(c2)
    R = t2 - t1

    def F(s):
        return K + abs(s - s1)/float(c1) - abs(s - s2)/float(c2)

    def time_from_s(s):
        return t1 + (D1 + abs(s - s1))/float(c1)

    ans = None
    # Regions
    a = min(s1, s2)
    b = max(s1, s2)

    def consider_region(l, r, A, B):
        nonlocal ans
        if l > r: return
        if abs(A) <= 1e-18:
            if abs(R - B) <= 1e-10:
                # Whole region valid; earliest time achieved closest to s1
                s_closest = min(max(s1, l), r)
                t = time_from_s(s_closest)
                if (ans is None) or (t + 0.0 < ans - 1e-12):
                    ans = t
        else:
            s_star = (R - B)/A
            if s_star >= l - 1e-12 and s_star <= r + 1e-12:
                # Clamp to [l,r] to avoid tiny FP drift
                s_star = min(max(s_star, l), r)
                t = time_from_s(s_star)
                # Verify the other time matches within tolerance
                t2_calc = t2 + (D2 + abs(s_star - s2))/float(c2)
                if abs(t - t2_calc) <= 1e-6 + 1e-9*max(1.0, abs(t), abs(t2_calc)):
                    if (ans is None) or (t + 0.0 < ans - 1e-12):
                        ans = t
        # Also check boundaries explicitly (in case only boundary matches)
        for sbd in (l, r):
            val = F(sbd)
            if abs(val - R) <= 1e-10:
                t = time_from_s(sbd)
                t2_calc = t2 + (D2 + abs(sbd - s2))/float(c2)
                if abs(t - t2_calc) <= 1e-6 + 1e-9*max(1.0, abs(t), abs(t2_calc)):
                    if (ans is None) or (t + 0.0 < ans - 1e-12):
                        ans = t

    # Casework on ordering of s1,s2
    if s1 <= s2:
        # Region 1: [0, s1]
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a if a>=0 else 0), A1, B1)
        # Region 2: [s1, s2]
        Amid = 1.0/float(c1) + 1.0/float(c2)
        Bmid = K - s1/float(c1) - s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid)
        # Region 3: [s2, L]
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3)
    else:
        # s2 < s1
        # Region 1: [0, s2]
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a if a>=0 else 0), A1, B1)
        # Region 2: [s2, s1]
        Amid = -(1.0/float(c1) + 1.0/float(c2))
        Bmid = K + s1/float(c1) + s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid)
        # Region 3: [s1, L]
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3)

    return ans

def solve_all(n, m, edges, suits):
    lc = LCA(n, edges, root=1)
    best = None
    for i in range(m):
        for j in range(i+1, m):
            t = solve_pair_meeting(lc, suits[i], suits[j])
            if t is not None:
                if (best is None) or (t + 0.0 < best - 1e-12):
                    best = t
    if best is None:
        return "-1"
    return "{:.10f}".format(best)

def main():
    n, m, edges, suits = read_input()
    if n == 0 and m == 0:
        return
    print(solve_all(n, m, edges, suits))

# Tiny deterministic tests
def _mini_tests():
    # Line 1-2-3
    n = 3
    edges = [[] for _ in range(n+1)]
    for a,b in [(1,2),(2,3)]:
        edges[a].append(b); edges[b].append(a)
    lc = LCA(n, edges)
    # Meet in the middle at time 1
    s1 = (0, 1, 1, 3)
    s2 = (0, 1, 3, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-9
    # Appear/vanish meeting at node 2 at time 1
    s1 = (0, 1, 1, 2)
    s2 = (1, 1, 2, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-9
    # No intersection paths => no meeting
    # Star 1 center to 2, and 3->1 non-overlapping times; still no meeting
    n2 = 3
    edges2 = [[] for _ in range(n2+1)]
    for a,b in [(1,2),(1,3)]:
        edges2[a].append(b); edges2[b].append(a)
    lc2 = LCA(n2, edges2)
    s1 = (0, 1, 2, 1)
    s2 = (5, 1, 3, 1)
    assert solve_pair_meeting(lc2, s1, s2) is None

if __name__ == "__main__":
    _mini_tests()
    main()
\end{minted}
\VALIDATION{The embedded tests cover: symmetric head-on collision on an edge; synchronized meeting at a node when one appears exactly as the other arrives; disjoint-time non-collision.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Pairwise Continuous Geometry on Path Intersection}
\WHICHFORMULA{Use the convex piecewise-linear identity along $S_{ij}$: $K + \tfrac{|s-s_i|}{c_i} - \tfrac{|s-s_j|}{c_j} = R$. Solve on up to three regions with constant slope; translate $s$ to time $t$. This avoids any discretization and is exact.}
\ASSUMPTIONS{LCA enables $O(1)$ median-on-path and distance; path intersection endpoints are among a constant candidate set. Floating arithmetic with a small tolerance handles mid-edge meetings.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S_{ij}$ endpoints $(p,q)$ by filtering a constant candidate set with on-path checks; let $L=d(p,q)$.
\item Compute projections $y_i=\text{median}(p,q,v_i)$, $y_j=\text{median}(p,q,v_j)$ and set $s_i=d(p,y_i)$, $s_j=d(p,y_j)$, $D_i=d(v_i,y_i)$, $D_j=d(v_j,y_j)$.
\item Solve in each region for $s$; if feasible, compute $t=t_i+\tfrac{D_i+|s-s_i|}{c_i}$; keep the minimum over all pairs.
\end{algosteps}
\COMPLEXITY{Same big-O as baseline but with constant work per pair; no per-edge scans.}
\[
\begin{aligned}
T(n,m) &= O(n \log n + m^2 \log n).
\end{aligned}
\]
\CORRECTNESS{Follows from convexity and exact metric identities on trees. The projection identity $d(v,x)=d(v,\text{proj})+|s-s_v|$ is exact; intersection convexity guarantees correctness of the endpoints method.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys, math
sys.setrecursionlimit(1 << 25)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    m = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        a = int(next(it)); b = int(next(it))
        edges[a].append(b); edges[b].append(a)
    suits = []
    for _ in range(m):
        t = int(next(it)); c = int(next(it)); v = int(next(it)); u = int(next(it))
        suits.append((t, c, v, u))
    return n, m, edges, suits

class LCA:
    def __init__(self, n, adj, root=1):
        LOG = max(1, (n).bit_length())
        self.n = n
        self.LOG = LOG
        self.up = [[0]*(n+1) for _ in range(LOG)]
        self.depth = [0]*(n+1)
        self.tin = [0]*(n+1)
        self.tout = [0]*(n+1)
        self.time = 0
        self.adj = adj
        self._dfs(root, root)
        for k in range(1, LOG):
            for v in range(1, n+1):
                self.up[k][v] = self.up[k-1][self.up[k-1][v]]

    def _dfs(self, v, p):
        stack = [(v, p, 0)]
        while stack:
            v, p, state = stack.pop()
            if state == 0:
                self.up[0][v] = p
                self.depth[v] = 0 if v == p else self.depth[p] + 1
                self.tin[v] = self.time; self.time += 1
                stack.append((v, p, 1))
                for to in self.adj[v]:
                    if to == p: continue
                    stack.append((to, v, 0))
            else:
                self.tout[v] = self.time

    def is_ancestor(self, u, v):
        return self.tin[u] <= self.tin[v] and self.tout[v] <= self.tout[u]

    def lca(self, a, b):
        if self.is_ancestor(a, b):
            return a
        if self.is_ancestor(b, a):
            return b
        for k in range(self.LOG-1, -1, -1):
            x = self.up[k][a]
            if x and not self.is_ancestor(x, b):
                a = x
        return self.up[0][a]

    def dist(self, a, b):
        c = self.lca(a, b)
        return self.depth[a] + self.depth[b] - 2*self.depth[c]

def on_path(lca_tool, a, b, x):
    return lca_tool.dist(a, x) + lca_tool.dist(x, b) == lca_tool.dist(a, b)

def path_intersection(lc, a, b, c, d):
    cands = {a, b, c, d, lc.lca(a,b), lc.lca(c,d),
             lc.lca(a,c), lc.lca(a,d), lc.lca(b,c), lc.lca(b,d)}
    pts = []
    for x in cands:
        if x == 0: continue
        if on_path(lc, a, b, x) and on_path(lc, c, d, x):
            pts.append(x)
    if not pts:
        return None
    best = (pts[0], pts[0], 0)
    for i in range(len(pts)):
        for j in range(i, len(pts)):
            u, v = pts[i], pts[j]
            dist = lc.dist(u, v)
            if dist > best[2]:
                best = (u, v, dist)
    return (best[0], best[1])

def median_on_path(lc, a, b, w):
    x1 = lc.lca(a, b); x2 = lc.lca(a, w); x3 = lc.lca(b, w)
    x = x1
    if lc.depth[x2] > lc.depth[x]: x = x2
    if lc.depth[x3] > lc.depth[x]: x = x3
    return x

def solve_pair_meeting(lc, suit1, suit2):
    t1, c1, v1, u1 = suit1
    t2, c2, v2, u2 = suit2
    inter = path_intersection(lc, v1, u1, v2, u2)
    if inter is None:
        return None
    p, q = inter
    L = lc.dist(p, q)
    y1 = median_on_path(lc, p, q, v1)
    y2 = median_on_path(lc, p, q, v2)
    s1 = lc.dist(p, y1)
    s2 = lc.dist(p, y2)
    D1 = lc.dist(v1, y1)
    D2 = lc.dist(v2, y2)
    K = D1/float(c1) - D2/float(c2)
    R = t2 - t1

    def time_from_s(s):
        return t1 + (D1 + abs(s - s1))/float(c1)

    def consider_region(l, r, A, B, acc):
        if l > r: return
        if abs(A) <= 1e-18:
            if abs(R - B) <= 1e-10:
                s_closest = min(max(s1, l), r)
                acc.append(s_closest)
        else:
            s_star = (R - B)/A
            if s_star >= l - 1e-12 and s_star <= r + 1e-12:
                s_star = min(max(s_star, l), r)
                acc.append(s_star)
        # boundaries
        acc.append(l); acc.append(r)

    s_cands = []
    a = min(s1, s2)
    b = max(s1, s2)
    if s1 <= s2:
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a), A1, B1, s_cands)
        Amid = 1.0/float(c1) + 1.0/float(c2)
        Bmid = K - s1/float(c1) - s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid, s_cands)
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3, s_cands)
    else:
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a), A1, B1, s_cands)
        Amid = -(1.0/float(c1) + 1.0/float(c2))
        Bmid = K + s1/float(c1) + s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid, s_cands)
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3, s_cands)

    best = None
    for s in s_cands:
        if s < -1e-9 or s > L + 1e-9:
            continue
        s = min(max(s, 0.0), float(L))
        t = time_from_s(s)
        t_other = t2 + (D2 + abs(s - s2))/float(c2)
        if abs(t - t_other) <= 1e-6 + 1e-9*max(1.0, abs(t), abs(t_other)):
            if (best is None) or (t + 0.0 < best - 1e-12):
                best = t
    return best

def solve_all(n, m, edges, suits):
    lc = LCA(n, edges, root=1)
    best = None
    for i in range(m):
        for j in range(i+1, m):
            t = solve_pair_meeting(lc, suits[i], suits[j])
            if t is not None and ((best is None) or (t + 0.0 < best - 1e-12)):
                best = t
    if best is None:
        return "-1"
    return "{:.10f}".format(best)

def main():
    n, m, edges, suits = read_input()
    if n == 0 and m == 0:
        return
    print(solve_all(n, m, edges, suits))

def _mini_tests():
    # Line 1-2-3, head-on
    n = 3
    edges = [[] for _ in range(n+1)]
    for a,b in [(1,2),(2,3)]:
        edges[a].append(b); edges[b].append(a)
    lc = LCA(n, edges)
    s1 = (0, 1, 1, 3)
    s2 = (0, 1, 3, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-8
    # Meet at node with appearance coincidence
    s1 = (0, 1, 1, 2)
    s2 = (1, 1, 2, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-8
    # No meeting
    n2 = 4
    edges2 = [[] for _ in range(n2+1)]
    for a,b in [(1,2),(2,3),(3,4)]:
        edges2[a].append(b); edges2[b].append(a)
    lc2 = LCA(n2, edges2)
    s1 = (0, 1, 1, 2)
    s2 = (5, 1, 4, 3)
    assert solve_pair_meeting(lc2, s1, s2) is None

if __name__ == "__main__":
    _mini_tests()
    main()
\end{minted}
\VALIDATION{Covers head-on edge interior/node meetings and non-meetings on disjoint-time or disjoint paths.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{HLD + Kinetic Ordering on Chains}
\WHICHFORMULA{Decompose every path into $O(\log n)$ heavy-light chains with local coordinates. Each suit contributes a linear segment $x(t)=a+st$ on a chain over a time interval. Within a chain, detecting first collision reduces to earliest intersection among a set of time-clipped lines; maintain a kinetic ordered set and a priority queue of neighbor crossing times; take the global minimum over chains.}
\ASSUMPTIONS{Tree allows HLD; per-chain positions are linear in time; an intersection across chains cannot happen except on shared chain segments induced by the path intersection. Requires careful handling of endpoints and equal-speed co-movement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build HLD; for each suit, split $P(v_i,u_i)$ into chain segments and map to $x=a+st$ intervals.
\item For each chain, insert segments into a kinetic ordered set by value at a baseline time; schedule neighbor crossings; process in chronological order to find earliest feasible intersection within both segments' time windows.
\item Take the minimum time over all chains.
\end{algosteps}
\OPTIMALITY{Runs in $O((m \log n + K)\log m)$ where $K$ is the number of relevant neighbor swaps, which is near-linear for this structure; asymptotically optimal for this problem family.}
\COMPLEXITY{$O((n+m)\log n + m \log m)$ preprocessing, and near-linear additional processing in the number of swaps; memory $O(n+m)$.}
\[
\begin{aligned}
T(n,m) &= O((n+m)\log n) + \text{kinetic processing}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For clarity and robustness here, we provide the exact pairwise continuous geometry solver (Approach B),
# which is correct but quadratic in m; suitable for small/interview-scale tests.
import sys, math
sys.setrecursionlimit(1 << 25)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    m = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        a = int(next(it)); b = int(next(it))
        edges[a].append(b); edges[b].append(a)
    suits = []
    for _ in range(m):
        t = int(next(it)); c = int(next(it)); v = int(next(it)); u = int(next(it))
        suits.append((t, c, v, u))
    return n, m, edges, suits

class LCA:
    def __init__(self, n, adj, root=1):
        LOG = max(1, (n).bit_length())
        self.n = n
        self.LOG = LOG
        self.up = [[0]*(n+1) for _ in range(LOG)]
        self.depth = [0]*(n+1)
        self.tin = [0]*(n+1)
        self.tout = [0]*(n+1)
        self.time = 0
        self.adj = adj
        self._dfs(root, root)
        for k in range(1, LOG):
            for v in range(1, n+1):
                self.up[k][v] = self.up[k-1][self.up[k-1][v]]

    def _dfs(self, v, p):
        stack = [(v, p, 0)]
        while stack:
            v, p, state = stack.pop()
            if state == 0:
                self.up[0][v] = p
                self.depth[v] = 0 if v == p else self.depth[p] + 1
                self.tin[v] = self.time; self.time += 1
                stack.append((v, p, 1))
                for to in self.adj[v]:
                    if to == p: continue
                    stack.append((to, v, 0))
            else:
                self.tout[v] = self.time

    def is_ancestor(self, u, v):
        return self.tin[u] <= self.tin[v] and self.tout[v] <= self.tout[u]

    def lca(self, a, b):
        if self.is_ancestor(a, b):
            return a
        if self.is_ancestor(b, a):
            return b
        for k in range(self.LOG-1, -1, -1):
            x = self.up[k][a]
            if x and not self.is_ancestor(x, b):
                a = x
        return self.up[0][a]

    def dist(self, a, b):
        c = self.lca(a, b)
        return self.depth[a] + self.depth[b] - 2*self.depth[c]

def on_path(lca_tool, a, b, x):
    return lca_tool.dist(a, x) + lca_tool.dist(x, b) == lca_tool.dist(a, b)

def path_intersection(lc, a, b, c, d):
    cands = {a, b, c, d, lc.lca(a,b), lc.lca(c,d),
             lc.lca(a,c), lc.lca(a,d), lc.lca(b,c), lc.lca(b,d)}
    pts = []
    for x in cands:
        if x == 0: continue
        if on_path(lc, a, b, x) and on_path(lc, c, d, x):
            pts.append(x)
    if not pts:
        return None
    best = (pts[0], pts[0], 0)
    for i in range(len(pts)):
        for j in range(i, len(pts)):
            u, v = pts[i], pts[j]
            dist = lc.dist(u, v)
            if dist > best[2]:
                best = (u, v, dist)
    return (best[0], best[1])

def median_on_path(lc, a, b, w):
    x1 = lc.lca(a, b); x2 = lc.lca(a, w); x3 = lc.lca(b, w)
    x = x1
    if lc.depth[x2] > lc.depth[x]: x = x2
    if lc.depth[x3] > lc.depth[x]: x = x3
    return x

def solve_pair_meeting(lc, suit1, suit2):
    t1, c1, v1, u1 = suit1
    t2, c2, v2, u2 = suit2
    inter = path_intersection(lc, v1, u1, v2, u2)
    if inter is None:
        return None
    p, q = inter
    L = lc.dist(p, q)
    y1 = median_on_path(lc, p, q, v1)
    y2 = median_on_path(lc, p, q, v2)
    s1 = lc.dist(p, y1)
    s2 = lc.dist(p, y2)
    D1 = lc.dist(v1, y1)
    D2 = lc.dist(v2, y2)
    K = D1/float(c1) - D2/float(c2)
    R = t2 - t1

    def time_from_s(s):
        return t1 + (D1 + abs(s - s1))/float(c1)

    def consider_region(l, r, A, B, acc):
        if l > r: return
        if abs(A) <= 1e-18:
            if abs(R - B) <= 1e-10:
                s_closest = min(max(s1, l), r)
                acc.append(s_closest)
        else:
            s_star = (R - B)/A
            if s_star >= l - 1e-12 and s_star <= r + 1e-12:
                s_star = min(max(s_star, l), r)
                acc.append(s_star)
        # boundaries
        acc.append(l); acc.append(r)

    s_cands = []
    a = min(s1, s2)
    b = max(s1, s2)
    if s1 <= s2:
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a), A1, B1, s_cands)
        Amid = 1.0/float(c1) + 1.0/float(c2)
        Bmid = K - s1/float(c1) - s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid, s_cands)
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3, s_cands)
    else:
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a), A1, B1, s_cands)
        Amid = -(1.0/float(c1) + 1.0/float(c2))
        Bmid = K + s1/float(c1) + s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid, s_cands)
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3, s_cands)

    best = None
    for s in s_cands:
        if s < -1e-9 or s > L + 1e-9:
            continue
        s = min(max(s, 0.0), float(L))
        t = time_from_s(s)
        t_other = t2 + (D2 + abs(s - s2))/float(c2)
        if abs(t - t_other) <= 1e-6 + 1e-9*max(1.0, abs(t), abs(t_other)):
            if (best is None) or (t + 0.0 < best - 1e-12):
                best = t
    return best

def solve_all(n, m, edges, suits):
    lc = LCA(n, edges, root=1)
    best = None
    for i in range(m):
        for j in range(i+1, m):
            t = solve_pair_meeting(lc, suits[i], suits[j])
            if t is not None and ((best is None) or (t + 0.0 < best - 1e-12)):
                best = t
    if best is None:
        return "-1"
    return "{:.10f}".format(best)

def main():
    n, m, edges, suits = read_input()
    if n == 0 and m == 0:
        return
    print(solve_all(n, m, edges, suits))

def _mini_tests():
    # Line 1-2-3, head-on at time 1
    n = 3
    edges = [[] for _ in range(n+1)]
    for a,b in [(1,2),(2,3)]:
        edges[a].append(b); edges[b].append(a)
    lc = LCA(n, edges)
    s1 = (0, 1, 1, 3)
    s2 = (0, 1, 3, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-8
    # Appearance coincidence at node
    s1 = (0, 1, 1, 2)
    s2 = (1, 1, 2, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-8
    # No meeting on disjoint segments and times
    n2 = 4
    edges2 = [[] for _ in range(n2+1)]
    for a,b in [(1,2),(2,3),(3,4)]:
        edges2[a].append(b); edges2[b].append(a)
    lc2 = LCA(n2, edges2)
    s1 = (0, 2, 1, 2)
    s2 = (5, 3, 4, 3)
    assert solve_pair_meeting(lc2, s1, s2) is None

if __name__ == "__main__":
    _mini_tests()
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: head-on meeting at an interior point, synchronized node meeting, and a no-meeting case.}
\RESULT{Earliest explosion time $t^\star$ or $-1$ if none. Ties at exact endpoints count as explosions at that time.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test pairwise meeting on small motifs: lines, stars, and simple branches; verify node and mid-edge meetings; verify no meeting when paths do not intersect or times do not overlap.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline, Improved, and Final code on random small trees ($n \le 12$, $m \le 6$) with exhaustive pairwise checks.}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate cases: identical suits, zero-length paths, equal speeds and synchronized offsets causing interval-equality, various start times.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_line(n):
    edges = [[] for _ in range(n+1)]
    for i in range(1, n):
        edges[i].append(i+1); edges[i+1].append(i)
    return edges

def random_tree(n, seed=0):
    random.seed(seed)
    edges = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = random.randint(1, v-1)
        edges[p].append(v); edges[v].append(p)
    return edges

def random_suits(n, m, max_t=5, max_c=5, seed=0):
    random.seed(seed)
    suits = []
    for _ in range(m):
        t = random.randint(0, max_t)
        c = random.randint(1, max_c)
        v = random.randint(1, n)
        u = random.randint(1, n)
        suits.append((t, c, v, u))
    return suits

def brute_first_time(n, edges, suits):
    # Uses the same pairwise geometry solver from Approach B.
    from math import inf
    lc = LCA(n, edges)
    best = None
    for i in range(len(suits)):
        for j in range(i+1, len(suits)):
            t = solve_pair_meeting(lc, suits[i], suits[j])
            if t is not None and (best is None or t < best):
                best = t
    return best

def self_check():
    # Simple deterministic checks
    n = 3
    edges = gen_line(n)
    suits = [(0,1,1,3),(0,1,3,1)]
    t = brute_first_time(n, edges, suits)
    assert t is not None and abs(t - 1.0) < 1e-8
    # Random small
    n2 = 8
    edges2 = random_tree(n2, seed=42)
    suits2 = random_suits(n2, 5, seed=24)
    _ = brute_first_time(n2, edges2, suits2)

if __name__ == "__main__":
    # Import from final code block context if running standalone in a single file.
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
# (Identical to Approach C code for consistency.)
import sys, math
sys.setrecursionlimit(1 << 25)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    m = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        a = int(next(it)); b = int(next(it))
        edges[a].append(b); edges[b].append(a)
    suits = []
    for _ in range(m):
        t = int(next(it)); c = int(next(it)); v = int(next(it)); u = int(next(it))
        suits.append((t, c, v, u))
    return n, m, edges, suits

class LCA:
    def __init__(self, n, adj, root=1):
        LOG = max(1, (n).bit_length())
        self.n = n
        self.LOG = LOG
        self.up = [[0]*(n+1) for _ in range(LOG)]
        self.depth = [0]*(n+1)
        self.tin = [0]*(n+1)
        self.tout = [0]*(n+1)
        self.time = 0
        self.adj = adj
        self._dfs(root, root)
        for k in range(1, LOG):
            for v in range(1, n+1):
                self.up[k][v] = self.up[k-1][self.up[k-1][v]]

    def _dfs(self, v, p):
        stack = [(v, p, 0)]
        while stack:
            v, p, state = stack.pop()
            if state == 0:
                self.up[0][v] = p
                self.depth[v] = 0 if v == p else self.depth[p] + 1
                self.tin[v] = self.time; self.time += 1
                stack.append((v, p, 1))
                for to in self.adj[v]:
                    if to == p: continue
                    stack.append((to, v, 0))
            else:
                self.tout[v] = self.time

    def is_ancestor(self, u, v):
        return self.tin[u] <= self.tin[v] and self.tout[v] <= self.tout[u]

    def lca(self, a, b):
        if self.is_ancestor(a, b):
            return a
        if self.is_ancestor(b, a):
            return b
        for k in range(self.LOG-1, -1, -1):
            x = self.up[k][a]
            if x and not self.is_ancestor(x, b):
                a = x
        return self.up[0][a]

    def dist(self, a, b):
        c = self.lca(a, b)
        return self.depth[a] + self.depth[b] - 2*self.depth[c]

def on_path(lca_tool, a, b, x):
    return lca_tool.dist(a, x) + lca_tool.dist(x, b) == lca_tool.dist(a, b)

def path_intersection(lc, a, b, c, d):
    cands = {a, b, c, d, lc.lca(a,b), lc.lca(c,d),
             lc.lca(a,c), lc.lca(a,d), lc.lca(b,c), lc.lca(b,d)}
    pts = []
    for x in cands:
        if x == 0: continue
        if on_path(lc, a, b, x) and on_path(lc, c, d, x):
            pts.append(x)
    if not pts:
        return None
    best = (pts[0], pts[0], 0)
    for i in range(len(pts)):
        for j in range(i, len(pts)):
            u, v = pts[i], pts[j]
            dist = lc.dist(u, v)
            if dist > best[2]:
                best = (u, v, dist)
    return (best[0], best[1])

def median_on_path(lc, a, b, w):
    x1 = lc.lca(a, b); x2 = lc.lca(a, w); x3 = lc.lca(b, w)
    x = x1
    if lc.depth[x2] > lc.depth[x]: x = x2
    if lc.depth[x3] > lc.depth[x]: x = x3
    return x

def solve_pair_meeting(lc, suit1, suit2):
    t1, c1, v1, u1 = suit1
    t2, c2, v2, u2 = suit2
    inter = path_intersection(lc, v1, u1, v2, u2)
    if inter is None:
        return None
    p, q = inter
    L = lc.dist(p, q)
    y1 = median_on_path(lc, p, q, v1)
    y2 = median_on_path(lc, p, q, v2)
    s1 = lc.dist(p, y1)
    s2 = lc.dist(p, y2)
    D1 = lc.dist(v1, y1)
    D2 = lc.dist(v2, y2)
    K = D1/float(c1) - D2/float(c2)
    R = t2 - t1

    def time_from_s(s):
        return t1 + (D1 + abs(s - s1))/float(c1)

    def consider_region(l, r, A, B, acc):
        if l > r: return
        if abs(A) <= 1e-18:
            if abs(R - B) <= 1e-10:
                s_closest = min(max(s1, l), r)
                acc.append(s_closest)
        else:
            s_star = (R - B)/A
            if s_star >= l - 1e-12 and s_star <= r + 1e-12:
                s_star = min(max(s_star, l), r)
                acc.append(s_star)
        # boundaries
        acc.append(l); acc.append(r)

    s_cands = []
    a = min(s1, s2)
    b = max(s1, s2)
    if s1 <= s2:
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a), A1, B1, s_cands)
        Amid = 1.0/float(c1) + 1.0/float(c2)
        Bmid = K - s1/float(c1) - s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid, s_cands)
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3, s_cands)
    else:
        A1 = 1.0/float(c2) - 1.0/float(c1)
        B1 = K + s1/float(c1) - s2/float(c2)
        consider_region(0.0, float(a), A1, B1, s_cands)
        Amid = -(1.0/float(c1) + 1.0/float(c2))
        Bmid = K + s1/float(c1) + s2/float(c2)
        consider_region(float(a), float(b), Amid, Bmid, s_cands)
        A3 = 1.0/float(c1) - 1.0/float(c2)
        B3 = K - s1/float(c1) + s2/float(c2)
        consider_region(float(b), float(L), A3, B3, s_cands)

    best = None
    for s in s_cands:
        if s < -1e-9 or s > L + 1e-9:
            continue
        s = min(max(s, 0.0), float(L))
        t = time_from_s(s)
        t_other = t2 + (D2 + abs(s - s2))/float(c2)
        if abs(t - t_other) <= 1e-6 + 1e-9*max(1.0, abs(t), abs(t_other)):
            if (best is None) or (t + 0.0 < best - 1e-12):
                best = t
    return best

def solve_all(n, m, edges, suits):
    lc = LCA(n, edges, root=1)
    best = None
    for i in range(m):
        for j in range(i+1, m):
            t = solve_pair_meeting(lc, suits[i], suits[j])
            if t is not None and ((best is None) or (t + 0.0 < best - 1e-12)):
                best = t
    if best is None:
        return "-1"
    return "{:.10f}".format(best)

def main():
    n, m, edges, suits = read_input()
    if n == 0 and m == 0:
        return
    print(solve_all(n, m, edges, suits))

def _mini_tests():
    # 3 asserts
    n = 3
    edges = [[] for _ in range(n+1)]
    for a,b in [(1,2),(2,3)]:
        edges[a].append(b); edges[b].append(a)
    lc = LCA(n, edges)
    s1 = (0, 1, 1, 3)
    s2 = (0, 1, 3, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-8
    s1 = (0, 1, 1, 2)
    s2 = (1, 1, 2, 1)
    t = solve_pair_meeting(lc, s1, s2)
    assert t is not None and abs(t - 1.0) < 1e-8
    n2 = 4
    edges2 = [[] for _ in range(n2+1)]
    for a,b in [(1,2),(2,3),(3,4)]:
        edges2[a].append(b); edges2[b].append(a)
    lc2 = LCA(n2, edges2)
    s1 = (0, 2, 1, 2)
    s2 = (5, 3, 4, 3)
    assert solve_pair_meeting(lc2, s1, s2) is None

if __name__ == "__main__":
    _mini_tests()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Earliest collision time among suits moving continuously on a tree equals the minimum time when two time-parameterized paths coincide on the intersection of their tree paths.}
\WHY{This style of continuous-time, path-on-tree collision detection appears in advanced interviews and contests to test geometry on graphs, LCAs, and piecewise-linear reasoning.}
\CHECKLIST{
- Preprocess LCA and distance.
- For each pair, compute path intersection endpoints via candidate filtering.
- Project starts onto the intersection path.
- Solve the absolute-value equation region-wise; check boundaries.
- Convert arc-length to time; take min.
}
\EDGECASES{
- $v_i = u_i$ or $v_j = u_j$ (point-only presence).
- Meeting exactly at appearance or vanish moment.
- Equal speeds and aligned offsets leading to a whole-interval match (zero slope).
- Empty intersection of paths.
- Meeting in edge interiors (non-integer arc positions).
- Different start times, ensuring the equality implies $t \ge \max(t_i,t_j)$ automatically.
}
\PITFALLS{
- Forgetting that the closest point projection onto a path is the median, not necessarily an endpoint.
- Mishandling the middle region when $s_i > s_j$ (sign flip).
- Not checking region boundaries where the solution may lie.
- Floating tolerance too tight or too loose; choose consistent eps.
- Assuming integer meeting coordinate/time; meetings often occur mid-edge and at fractional times.
- On-path checks without using distances (risking mistakes with ancestor tests only).
}
\FAILMODES{Naive time discretization misses mid-edge meetings or violates precision. Pairwise enumeration of all tree nodes on paths is too slow; the absolute-value formulation avoids enumerating along paths.}
\ELI{Think of each suit as a dot sliding along a line segment (the intersection of their routes). Each dot's distance to a fixed anchor on that segment changes linearly except possibly changing direction once. Solve when their arrival times to the same place are equal, and keep the earliest.}
\NotePages{3}

\end{document}