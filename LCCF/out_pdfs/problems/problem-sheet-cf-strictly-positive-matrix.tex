% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Strictly Positive Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/402/E}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{You have matrix $a$ of size $n \times n$. Let's number the rows of the matrix from 1 to $n$ from top to bottom, let's number the columns from 1 to $n$ from left to right. Let's use $a_{ij}$ to represent the element on the intersection of the $i$-th row and the $j$-th column.

Matrix $a$ meets the following two conditions:
\begin{bullets}
\item for any numbers $i, j$ ($1 \le i, j \le n$) the following inequality holds: $a_{ij} \ge 0$;
\item $\sum_{i=1}^{n}a_{ii}>0$.
\end{bullets}

Matrix $b$ is strictly positive, if for any numbers $i, j$ ($1 \le i, j \le n$) the inequality $b_{ij} > 0$ holds. Your task is to determine if there is such integer $k \ge 1$, that matrix $a^k$ is strictly positive.

Input:
The first line contains integer $n$ ($2 \le n \le 2000$) — the number of rows and columns in matrix $a$.

The next $n$ lines contain the description of the rows of matrix $a$. The $i$-th line contains $n$ non-negative integers $a_{i1}, a_{i2}, \ldots, a_{in}$ ($0 \le a_{ij} \le 50$). It is guaranteed that $\sum_{i=1}^{n}a_{ii}>0$.

Output:
If there is a positive integer $k \ge 1$, such that matrix $a^k$ is strictly positive, print ``YES''. Otherwise, print ``NO''.}
\BREAKDOWN{Model $a$ as a directed graph on $n$ nodes with an arc $i \to j$ iff $a_{ij} > 0$. Then $(a^k)_{ij} > 0$ iff there exists a length-$k$ directed walk from $i$ to $j$. Because at least one diagonal entry is positive, there is a self-loop somewhere, which aperiodizes any strongly connected graph. Thus, the task reduces to checking if this graph is strongly connected.}
\ELI{Turn the matrix into a graph by keeping only positive entries; answer YES iff every node can reach every other (thanks to at least one self-loop).}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$ with $2 \le n \le 2000$; then an $n \times n$ matrix $a$ of integers with $0 \le a_{ij} \le 50$.}
\OUTPUTS{Print YES if there exists $k \ge 1$ such that $a^k$ is strictly positive (all entries $>0$); otherwise print NO.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{verbatim}
2
1 1
1 0
\end{verbatim}
\item Output:
\begin{verbatim}
YES
\end{verbatim}
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\begin{verbatim}
3
1 0 0
0 0 1
0 0 0
\end{verbatim}
\item Output:
\begin{verbatim}
NO
\end{verbatim}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be the directed graph on $V=\{1,\ldots,n\}$ with $(i,j)\in E$ iff $a_{ij}>0$. For $k\ge 0$, $(a^k)_{ij}>0$ iff there exists a length-$k$ directed walk from $i$ to $j$ in $G$.}
\varmapStart
\var{n}{matrix size and number of vertices}
\var{a_{ij}}{weight from $i$ to $j$; edge present if and only if $a_{ij}>0$}
\var{G}{directed graph derived from $a$ by keeping positive entries}
\var{k}{walk length / matrix power}
\varmapEnd
\GOVERN{
\[
(a^k)_{ij}=\sum_{v_1,\ldots,v_{k-1}} a_{i v_1} a_{v_1 v_2} \cdots a_{v_{k-1} j}
\quad\Longrightarrow\quad
(a^k)_{ij} > 0 \iff \text{there exists a length-$k$ walk } i \to j \text{ in } G.
\]
}
\ASSUMPTIONS{All $a_{ij} \ge 0$. The condition $\sum_i a_{ii}>0$ guarantees the existence of at least one self-loop in $G$.}
\INVARIANTS{
\begin{bullets}
\item If $G$ is not strongly connected, then there exist $u,v$ such that no walk from $u$ to $v$ exists for any $k$, hence $(a^k)_{uv}=0$ for all $k$.
\item If $G$ is strongly connected and contains a self-loop, then the period (gcd of all cycle lengths) is 1, and there exists $K$ s.t. for all $k \ge K$, a length-$k$ walk exists between any ordered pair.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute reachability between all pairs by transitive closure (Floyd--Warshall over boolean adjacency). Then check if every pair is mutually reachable (strong connectivity).}
\ASSUMPTIONS{Treat any positive $a_{ij}$ as a directed edge $i \to j$. The guarantee of at least one $a_{ii}>0$ means that strong connectivity is sufficient.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build boolean matrix $R$ where $R[i][j]=\text{True}$ iff $a_{ij}>0$.
\item Run Floyd--Warshall: for $k,i,j$, set $R[i][j] \leftarrow R[i][j]\lor (R[i][k]\land R[k][j])$.
\item If every $R[i][j]$ and every $R[j][i]$ hold, print YES; else NO.
\end{algosteps}
\COMPLEXITY{Cubic time and quadratic space.}
\[
\begin{aligned}
T(n) &= \Theta(n^3),\quad S(n)=\Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Transitive closure exactly captures existence of a directed path between any two vertices. With at least one self-loop present, strong connectivity implies the existence of some power $k$ with $a^k$ strictly positive.}
\EDGECASES{Zero rows or columns (except diagonal) are allowed; if any vertex cannot reach another, answer is NO.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            a[i][j] = int(next(it))
    return n, a

def solve_case_floyd(n, a):
    # Build boolean adjacency from positive entries
    R = [[False]*n for _ in range(n)]
    for i in range(n):
        row = a[i]
        Ri = R[i]
        for j, val in enumerate(row):
            if val > 0:
                Ri[j] = True
    # Floyd-Warshall transitive closure
    for k in range(n):
        Rk = R[k]
        for i in range(n):
            if R[i][k]:
                Ri = R[i]
                # OR with row k
                for j in range(n):
                    if Rk[j]:
                        Ri[j] = True
    # Check strong connectivity
    for i in range(n):
        for j in range(n):
            if not R[i][j]:
                return "NO"
    # self-loop condition is guaranteed by problem statement
    return "YES"

def solve_all_floyd():
    ia = read_input()
    if ia is None:
        return
    n, a = ia
    print(solve_case_floyd(n, a))

def _tests_baseline():
    # Simple YES: strongly connected 2x2 with a self-loop
    n = 2
    a = [[1,1],[1,0]]
    assert solve_case_floyd(n, a) == "YES"
    # Simple NO: not strongly connected
    n = 2
    a = [[1,1],[0,1]]
    assert solve_case_floyd(n, a) == "NO"
    # 3-cycle plus self-loop ensures YES
    n = 3
    a = [[1,1,0],[0,0,1],[1,0,0]]
    assert solve_case_floyd(n, a) == "YES"

if __name__ == "__main__":
    # Run baseline solver if desired:
    # solve_all_floyd()
    _tests_baseline()
\end{minted}
\VALIDATION{The asserts cover: strongly connected with loop (YES), missing edge causing non-SCC (NO), and a 3-cycle with a self-loop (YES).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bitset Transitive Closure}
\WHICHFORMULA{Use integer bitsets to represent reachability rows and propagate via bit operations to reduce constant factors vs. nested loops.}
\ASSUMPTIONS{Adjacency is dense in worst case. Python integer bit operations process many bits per CPU word.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build bitset rows $R[i]$ with bit $j$ set iff $a_{ij}>0$.
\item For $k$ from $0$ to $n-1$, for each $i$ with bit $k$ set in $R[i]$, update $R[i] \leftarrow R[i] \lor R[k]$.
\item After closure, check that every $R[i]$ has all $n$ low bits set.
\end{algosteps}
\COMPLEXITY{Still $\Theta(n^3/\text{word\_size})$ in worst case, but much faster in practice for $n \le 2000$.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\frac{n^3}{w}\right),\quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{Bitset closure is equivalent to Floyd--Warshall over the boolean semiring.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    rows = [0]*n
    for i in range(n):
        mask = 0
        for j in range(n):
            x = int(next(it))
            if x > 0:
                mask |= (1 << j)
        rows[i] = mask
    return n, rows

def solve_case_bitset_tc(n, rows):
    R = rows[:]  # copy
    for k in range(n):
        col_k_mask = 1 << k
        Rk = R[k]
        for i in range(n):
            if R[i] & col_k_mask:
                R[i] |= Rk
    full = (1 << n) - 1
    for i in range(n):
        if R[i] != full:
            return "NO"
    return "YES"

def solve_all_bitset_tc():
    ia = read_input()
    if ia is None:
        return
    n, rows = ia
    print(solve_case_bitset_tc(n, rows))

def _tests_improved():
    n = 2
    rows = [(1<<0)|(1<<1), (1<<0)]  # [[1,1],[1,0]]
    assert solve_case_bitset_tc(n, rows) == "YES"
    n = 2
    rows = [(1<<0)|(1<<1), (1<<1)]  # [[1,1],[0,1]]
    assert solve_case_bitset_tc(n, rows) == "NO"
    n = 3
    # [[1,1,0],[0,0,1],[1,0,0]]
    rows = [(1<<0)|(1<<1), (1<<2), (1<<0)]
    assert solve_case_bitset_tc(n, rows) == "YES"

if __name__ == "__main__":
    # solve_all_bitset_tc()
    _tests_improved()
\end{minted}
\VALIDATION{Tests mirror the baseline and confirm identical results while using bitsets.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Strong Connectivity via Two Bitset BFS}
\WHICHFORMULA{With at least one self-loop, the matrix is primitive iff the positive-entry digraph is strongly connected. It suffices to check reachability from an arbitrary node in both the original and reversed graph.}
\ASSUMPTIONS{The graph has $n \le 2000$; store adjacency and its transpose as bitsets to get near $O(n^2/w)$ time and $O(n)$ space.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build bitset adjacency arrays $adj[i]$ and $radj[i]$ (transpose).
\item Compute the set $R$ of nodes reachable from 0 by repeated frontier expansion using bitsets.
\item Compute the set $L$ of nodes that can reach 0 by expanding from 0 in $radj$.
\item If both $R$ and $L$ contain all $n$ nodes, print YES; else NO.
\end{algosteps}
\OPTIMALITY{Two bitset BFS/DFS runs suffice to decide strong connectivity; no need for full transitive closure or $n$ BFS passes.}
\COMPLEXITY{Each expansion scans at most $n$ rows, each a machine-word bitset OR; number of iterations is $O(n)$ in worst case but typically much less.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\frac{n^2}{w}\right),\quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    adj = [0]*n
    radj = [0]*n
    for i in range(n):
        mask = 0
        for j in range(n):
            x = int(next(it))
            if x > 0:
                mask |= (1 << j)
        adj[i] = mask
        # build reverse bits
        m = mask
        while m:
            lsb = m & -m
            j = (lsb.bit_length() - 1)
            radj[j] |= (1 << i)
            m ^= lsb
    return n, adj, radj

def _bitset_reach_from0(n, rows):
    # BFS/DFS-like expansion using bitsets starting from node 0
    full0 = 1 << 0
    reach = full0
    changed = True
    while changed:
        changed = False
        # expand: for each bit u in reach, OR rows[u]
        m = reach
        acc = reach
        while m:
            lsb = m & -m
            u = (lsb.bit_length() - 1)
            acc |= rows[u]
            m ^= lsb
        if acc != reach:
            reach = acc
            changed = True
    return reach

def solve_case(n, adj, radj):
    # Early necessary condition: every node must have at least one in and one out in SCCs,
    # but we directly check strong connectivity via two reachability checks.
    reach_from0 = _bitset_reach_from0(n, adj)
    if reach_from0 != (1 << n) - 1:
        return "NO"
    reach_to0 = _bitset_reach_from0(n, radj)
    if reach_to0 != (1 << n) - 1:
        return "NO"
    # Self-loop existence is guaranteed by problem: sum of diagonal > 0
    return "YES"

def solve_all():
    ia = read_input()
    if ia is None:
        return
    n, adj, radj = ia
    print(solve_case(n, adj, radj))

def _tests_final():
    # YES: strongly connected; self-loop on node 0
    n = 2
    adj = [(1<<0)|(1<<1), (1<<0)]
    radj = [ (1<<0)|(1<<1), (1<<0) ]  # built accordingly
    assert solve_case(n, adj, radj) == "YES"
    # NO: not strongly connected
    n = 2
    adj = [(1<<0)|(1<<1), (1<<1)]
    radj = [ (1<<0), (1<<0)|(1<<1) ]
    assert solve_case(n, adj, radj) == "NO"
    # YES: 3-cycle and a self-loop on node 0
    n = 3
    adj = [(1<<0)|(1<<1), (1<<2), (1<<0)]
    radj = [ (1<<0)|(1<<2), (1<<0), (1<<1) ]
    assert solve_case(n, adj, radj) == "YES"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests_final()
    else:
        solve_all()
\end{minted}
\VALIDATION{Three asserts: YES for a 2-node SCC with loop, NO for a non-SCC, YES for a 3-node SCC with a loop.}
\RESULT{Print YES iff the digraph of positive entries is strongly connected (the given diagonal positivity guarantees aperiodicity), else NO.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted matrices: SCC vs. non-SCC; dense vs. sparse; presence of self-loop guaranteed by problem. Property check: if any vertex cannot reach another, the answer must be NO.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (Floyd) and Approach C (bitset two-BFS) on small random matrices ($n \le 10$) by treating positive entries as edges.}
\LINE{EDGE-CASE GENERATOR}{Generate matrices with: a single self-loop and otherwise empty; line graphs; cycles; fully connected graphs.}
\begin{minted}{python}
import random

def gen_matrix(n, p_edge=0.3, ensure_self=True):
    a = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if random.random() < p_edge:
                a[i][j] = random.randint(1, 3)
    if ensure_self:
        i = random.randrange(n)
        a[i][i] = max(1, a[i][i])
    return a

def to_bitrows(a):
    n = len(a)
    adj = [0]*n
    radj = [0]*n
    for i in range(n):
        m = 0
        for j in range(n):
            if a[i][j] > 0:
                m |= (1 << j)
        adj[i] = m
        mm = m
        while mm:
            lsb = mm & -mm
            j = (lsb.bit_length()-1)
            radj[j] |= (1 << i)
            mm ^= lsb
    return adj, radj

def baseline_answer(a):
    n = len(a)
    R = [[False]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            R[i][j] = a[i][j] > 0
    for k in range(n):
        for i in range(n):
            if R[i][k]:
                R[i] = [ri or rk for ri, rk in zip(R[i], R[k])]
    ok = all(all(row) for row in R)
    return "YES" if ok else "NO"

def final_answer(a):
    n = len(a)
    adj, radj = to_bitrows(a)
    # reuse solver from Approach C
    def reach0(rows):
        full0 = 1
        reach = full0
        changed = True
        while changed:
            changed = False
            m = reach
            acc = reach
            while m:
                lsb = m & -m
                u = (lsb.bit_length()-1)
                acc |= rows[u]
                m ^= lsb
            if acc != reach:
                reach = acc
                changed = True
        return reach
    if reach0(adj) != (1<<n)-1:
        return "NO"
    if reach0(radj) != (1<<n)-1:
        return "NO"
    return "YES"

def run_cross_checks(trials=100, n=8):
    for _ in range(trials):
        a = gen_matrix(n, p_edge=0.4, ensure_self=True)
        assert baseline_answer(a) == final_answer(a)

if __name__ == "__main__":
    run_cross_checks(20, n=6)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    adj = [0]*n
    radj = [0]*n
    for i in range(n):
        mask = 0
        for j in range(n):
            x = int(next(it))
            if x > 0:
                mask |= (1 << j)
        adj[i] = mask
        m = mask
        while m:
            lsb = m & -m
            j = (lsb.bit_length() - 1)
            radj[j] |= (1 << i)
            m ^= lsb
    return n, adj, radj

def _bitset_reach_from0(n, rows):
    reach = 1  # start from node 0
    changed = True
    while changed:
        changed = False
        m = reach
        acc = reach
        while m:
            lsb = m & -m
            u = (lsb.bit_length() - 1)
            acc |= rows[u]
            m ^= lsb
        if acc != reach:
            reach = acc
            changed = True
    return reach

def solve_case(n, adj, radj):
    if _bitset_reach_from0(n, adj) != (1 << n) - 1:
        return "NO"
    if _bitset_reach_from0(n, radj) != (1 << n) - 1:
        return "NO"
    return "YES"

def solve_all():
    ia = read_input()
    if ia is None:
        return
    n, adj, radj = ia
    print(solve_case(n, adj, radj))

def _unit_tests():
    # YES: strongly connected with a self-loop
    n = 2
    adj = [(1<<0)|(1<<1), (1<<0)]
    radj = [ (1<<0)|(1<<1), (1<<0) ]
    assert solve_case(n, adj, radj) == "YES"
    # NO: not strongly connected
    n = 2
    adj = [(1<<0)|(1<<1), (1<<1)]
    radj = [ (1<<0), (1<<0)|(1<<1) ]
    assert solve_case(n, adj, radj) == "NO"
    # YES: 3-cycle plus loop
    n = 3
    adj = [(1<<0)|(1<<1), (1<<2), (1<<0)]
    radj = [ (1<<0)|(1<<2), (1<<0), (1<<1) ]
    assert solve_case(n, adj, radj) == "YES"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _unit_tests()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{The matrix has a strictly positive power iff the digraph induced by positive entries is strongly connected (a self-loop is guaranteed, so aperiodicity holds).}
\WHY{This reduces a potentially heavy algebraic question to a graph connectivity check, a common reduction in algorithmic interviews.}
\CHECKLIST{
\begin{bullets}
\item Build digraph with edges where $a_{ij}>0$.
\item Check reachability from a fixed node to all nodes.
\item Check reachability to that node from all nodes (using transpose).
\item If both pass, print YES; else NO.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Entire row of zeros except diagonal elsewhere: may break SCC.
\item Star-like patterns: center cannot be reached back.
\item Multiple components with internal loops: still NO.
\item Dense graph missing one back edge: can still be NO.
\item Self-loop on an isolated node: NO.
\item Fully positive matrix: trivially YES.
\item $n=2$ minimal cases.
\item Diagonal-only matrix with a single positive $a_{ii}$: NO if $n>1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Storing all $n^2$ edges explicitly as Python lists may TLE/MLE; prefer bitsets.
\item Forgetting to use the transpose for the reverse reachability check.
\item Misinterpreting weights: only positivity matters, not magnitudes.
\item Assuming periodicity matters despite the guaranteed self-loop.
\item Off-by-one when mapping bits to indices.
\item Mixing 1-based and 0-based indices while parsing.
\end{bullets}
}
\FAILMODES{Approaches that attempt to compute $a^k$ numerically will overflow and are unnecessary; boolean reachability suffices. Doing $n$ BFS runs is slower than needed; two runs suffice.}
\ELI{Think of the matrix as an arrow map between rooms. If you can go from any room to any other and there is at least one one-step loop somewhere, then by looping as needed you can make a trip of any length. Otherwise, some pair is forever disconnected for every trip length.}
\NotePages{3}

\end{document}