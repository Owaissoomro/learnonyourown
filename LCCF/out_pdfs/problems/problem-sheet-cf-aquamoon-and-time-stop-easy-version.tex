% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — AquaMoon and Time Stop (easy version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1545/E1}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Note that the differences between easy and hard versions are the constraints on $n$ and the time limit. You can make hacks only if both versions are solved.

AquaMoon knew through foresight that some ghosts wanted to curse tourists on a pedestrian street. But unfortunately, this time, these ghosts were hiding in a barrier, and she could not enter this barrier in a short time and destroy them. Therefore, all that can be done is to save any unfortunate person on the street from the ghosts.

The pedestrian street can be represented as a one-dimensional coordinate system. There is one person hanging out on the pedestrian street. At the time $0$ he is at coordinate $x$, moving with a speed of $1$ unit per second. In particular, at time $i$ the person will be at coordinate $x+i$.

The ghosts are going to cast $n$ curses on the street. The $i$-th curse will last from time $tl_i-1+10^{-18}$ to time $tr_i+1-10^{-18}$ (exclusively) and will kill people with coordinates from $l_i-1+10^{-18}$ to $r_i+1-10^{-18}$ (exclusively). Formally that means, that the person, whose coordinate is between $(l_i-1+10^{-18},r_i+1-10^{-18})$ in the time range $(tl_i-1+10^{-18},tr_i+1-10^{-18})$ will die.

To save the person on the street, AquaMoon can stop time at any moment $t$, and then move the person from his current coordinate $x$ to any coordinate $y$ ($t$, $x$ and $y$ are not necessarily integers). The movement costs AquaMoon $\lvert x-y\rvert$ energy. The movement is continuous, so if there exists some cursed area between points $x$ and $y$ at time $t$, the person will die too.

AquaMoon wants to know what is the minimum amount of energy she needs to spend in order to save the person on the street from all $n$ curses. But she is not good at programming. As her friend, can you help her?

Input:
The first line contains a single integer $n$ ($1\le n\le 2000$) — the number of curses.

The next line contains a single integer $x$ ($1\le x\le 10^6$) — the initial coordinate of the person.

The following $n$ lines contain four integers $tl_i$, $tr_i$, $l_i$, $r_i$ each ($1\le tl_i\le tr_i\le 10^6$, $1\le l_i\le r_i\le 10^6$).

Output:
Print a single integer — the minimum energy which AquaMoon needs to spent, rounded up to the nearest integer (in case there are two nearest integers you should round the answer to the highest of them).}
\BREAKDOWN{Rephrase dynamic motion with time-stops as choosing a constant value $v=y-t$ that the trajectory follows between stops. Show that each curse forbids an open interval for $v$, and the union over all curses defines forbidden constant offsets. Then the minimal energy is the shortest distance from initial $x$ to the complement of this union.}
\ELI{Each curse bans a range of $v=y-t$; pick one constant $v$ outside all banned ranges and jump there once.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ — integer, $1\le n\le 2000$.
\item $x$ — integer, $1\le x\le 10^6$.
\item $n$ lines of integers: $tl_i,tr_i,l_i,r_i$ with $1\le tl_i\le tr_i\le 10^6$, $1\le l_i\le r_i\le 10^6$.
\end{bullets}}
\OUTPUTS{One integer: minimal energy required, rounded up to nearest integer (ties rounded up). In this easy version the answer is always an integer.}
\SAMPLES{
Example 1:
\[
\begin{aligned}
n&=1,\ x=12,\\
(tl_1,tr_1,l_1,r_1)&=(3,9,10,20).
\end{aligned}
\]
Here the forbidden interval for $v$ is $(10-9,\,20-3)=(1,17)$, so $x=12$ lies inside and the nearest boundary distance is $\min(12-1,17-12)=5$. Output: $5$.

Example 2:
\[
\begin{aligned}
n&=2,\ x=5,\\
(1,4,7,9),\ (5,6,3,5).
\end{aligned}
\]
Forbidden intervals: $(7-4,9-1)=(3,8)$ and $(3-6,5-5)=(-3,0)$. Their union is $(-3,0)\cup(3,8)$. Since $x=5\in(3,8)$, distance to boundary is $\min(5-3,8-5)=2$. Output: $2$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the person location be $y(t)$ with $y(0)=x$ and $y'(t)=1$ between time-stops; each time-stop allows an instantaneous change in $y$ at fixed $t$ with cost equal to the vertical displacement, and such a jump cannot cross a cursed spatial interval active at that time. Define $v(t)=y(t)-t$. Between stops $v$ is constant; a jump changes $v$ by the same amount. For curse $i$, active on $(tl_i,tr_i)$ over spatial $(l_i,r_i)$, the person dies iff $\exists t\in(tl_i,tr_i)$ with $y(t)\in(l_i,r_i)$, i.e., iff $\exists t$ with $v(t)\in(l_i-t,r_i-t)$.}
\varmapStart
\var{(tl_i,tr_i)}{active time of curse $i$}
\var{(l_i,r_i)}{spatial range of curse $i$}
\var{v}{offset $y-t$ (constant between jumps)}
\var{L_i}{left boundary $l_i-tr_i$ in $v$-space}
\var{R_i}{right boundary $r_i-tl_i$ in $v$-space}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Forbidden set in }v\text{-space for curse }i:\quad \bigcup_{t\in(tl_i,tr_i)}(l_i-t,r_i-t)=(L_i,R_i),
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Global forbidden in }v:\quad \mathcal{F}=\bigcup_{i=1}^n (L_i,R_i),\qquad \text{Allowed } \mathcal{A}=\mathbb{R}\setminus\mathcal{F}.
\end{BreakableEquation*}
Energy cost for choosing a constant $v\in\mathcal{A}$ from start is $\lvert v-x\rvert$.
}
\ASSUMPTIONS{Open intervals for curses ensure being exactly on any boundary is safe. Since each $(L_i,R_i)$ is bounded, $\mathcal{A}$ is nonempty (it contains sufficiently small or large $v$).}
\INVARIANTS{
\begin{bullets}
\item If $v$ is constant and $v\notin(L_i,R_i)$ for all $i$, then the trajectory avoids all curses.
\item Any sequence of jumps has total energy at least the single-jump distance to the nearest $v\in\mathcal{A}$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate time evolution across all event times, maintaining feasible $v$-ranges and greedily projecting the current $v$ into allowed unions at each step.}
\ASSUMPTIONS{Small $n$ allows $O(n^2)$ event processing and merging of intervals at each step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Collect event times $\{tl_i,tr_i\}$ and process segments where the active set is fixed.
\item In each segment, build the union of spatial cursed intervals and deduce the induced allowed $v$-set that survives the whole segment, then snap $v$ to the closest feasible point.
\item Accumulate total movement.
\end{algosteps}
\COMPLEXITY{Merging per segment costs $O(n\log n)$ and there are $O(n)$ segments, so $O(n^2\log n)$ time; $O(n)$ space.}
\[
\begin{aligned}
T(n) &\approx \sum_{k=1}^{O(n)} O(n\log n) \\
     &= O(n^2\log n).
\end{aligned}
\]
\CORRECTNESS{At each segment the active constraints are static; maintaining a constant $v$ through the segment is necessary and sufficient. Greedy projection yields a feasible path.}
\EDGECASES{Touching intervals (endpoints equal) must not be merged for open intervals. Being at a boundary is safe and costs zero.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[Tuple[int, int, int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def merge_open_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    # Merge open intervals (a,b), merging when strictly overlapping: L < curR
    intervals.sort()
    merged = []
    for L, R in intervals:
        if not merged:
            merged.append([L, R])
        else:
            curL, curR = merged[-1]
            if L < curR:  # strict for open intervals
                if R > curR:
                    merged[-1][1] = R
            else:
                merged.append([L, R])
    return [(L, R) for L, R in merged]

def solve_case(n: int, x: int, curses: List[Tuple[int, int, int, int]]) -> int:
    # Direct reduction: For each curse i, forbidden v-interval is (l_i - tr_i, r_i - tl_i)
    intervals = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L < R:  # only meaningful if open interval non-empty
            intervals.append((L, R))
        # if L == R, interval is empty open; ignore
    merged = merge_open_intervals(intervals)
    # If x is inside any merged open interval, answer is distance to its nearest boundary; else 0
    ans = 0
    for L, R in merged:
        if L < x < R:
            d = min(x - L, R - x)
            ans = d  # there can be at most one such interval containing x after merge
            break
    return ans

def solve_all():
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

def _self_test():
    # Basic tests
    assert merge_open_intervals([(1, 3), (3, 5)]) == [(1, 3), (3, 5)]
    assert merge_open_intervals([(1, 4), (2, 5)]) == [(1, 5)]
    # Single curse: forbidden (l - tr, r - tl)
    assert solve_case(1, 12, [(3, 9, 10, 20)]) == 5  # (1,17), x=12 -> 5
    assert solve_case(1, 5, [(1, 5, 10, 20)]) == 0   # (5,19), x=5 on boundary -> 0
    # Disjoint intervals
    n = 2; x = 5
    curses = [(1, 4, 7, 9), (5, 6, 3, 5)]  # (-3,0) and (3,8)
    assert solve_case(n, x, curses) == 2
    # Overlapping combine
    curses = [(1, 5, 1, 10), (2, 6, 2, 11)]  # ( -4, 9 ) and ( -4, 9 ), merged (-4,9)
    assert solve_case(2, 0, curses) == 0
    # Touching endpoints shouldn't merge open intervals
    assert solve_case(2, 3, [(0, 2, 1, 3), (0, 2, 3, 5)]) == 0  # x=3 at touching point
    print("OK")

if __name__ == "__main__":
    _self_test()
    # To run with stdin, comment out the self-test and rely on solve_all()
    # solve_all()
\end{minted}
\VALIDATION{Unit asserts cover merging, boundary safety, overlapping intervals, and touching endpoints.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Union-of-Intervals in $v=y-t$ Space}
\WHICHFORMULA{Derive per-curse forbidden open interval $(L_i,R_i)=(l_i-tr_i,\,r_i-tl_i)$ for constant $v$, then merge all such intervals and measure distance of $x$ to the complement.}
\ASSUMPTIONS{A constant offset $v$ suffices: if $v\notin(L_i,R_i)$ for all $i$, then $y(t)=v+t$ never intersects any cursed rectangle. Since all $(L_i,R_i)$ are bounded, the complement is nonempty.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each curse, compute $L_i=l_i-tr_i$ and $R_i=r_i-tl_i$.
\item Keep only intervals with $L_i<R_i$ and sort them by $L_i$, merging strictly overlapping ones.
\item If $x$ lies in some merged open interval $(A,B)$, the answer is $\min(x-A,\,B-x)$; otherwise $0$.
\end{algosteps}
\COMPLEXITY{Dominated by sort: $O(n\log n)$ time, $O(n)$ space.}
\begin{BreakableEquation*}
T(n)=O(n\log n),\qquad S(n)=O(n).
\end{BreakableEquation*}
\CORRECTNESS{For a fixed curse, the set $\{t\in(tl,tr):l< v+t < r\}$ is nonempty iff $v\in(l-tr,r-tl)$. Avoiding all curses is equivalent to $v$ lying in $\mathbb{R}\setminus\bigcup_i(L_i,R_i)$. The minimal energy is the minimal initial jump to reach such a $v$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[Tuple[int, int, int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def merge_open_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    intervals.sort()
    merged = []
    for L, R in intervals:
        if not merged:
            merged.append([L, R])
        else:
            curL, curR = merged[-1]
            if L < curR:
                if R > curR:
                    merged[-1][1] = R
            else:
                merged.append([L, R])
    return [(L, R) for L, R in merged]

def solve_case(n: int, x: int, curses: List[Tuple[int, int, int, int]]) -> int:
    intervals = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L < R:
            intervals.append((L, R))
    merged = merge_open_intervals(intervals)
    for L, R in merged:
        if L < x < R:
            return min(x - L, R - x)
    return 0

def solve_all():
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

def _self_test():
    assert solve_case(1, 12, [(3, 9, 10, 20)]) == 5
    assert solve_case(1, 5, [(1, 5, 10, 20)]) == 0
    assert solve_case(2, 5, [(1, 4, 7, 9), (5, 6, 3, 5)]) == 2
    # If x already outside union: zero
    assert solve_case(2, -100, [(1, 2, 1, 2), (3, 4, 3, 4)]) == 0
    print("OK")

if __name__ == "__main__":
    _self_test()
    # solve_all()
\end{minted}
\VALIDATION{Edge checks: empty intervals when $L_i=R_i$, touching endpoints not merged, boundary safe cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Jump Optimality via $v=y-t$}
\WHICHFORMULA{Transform to $v=y-t$. For curse $i$, union over $t\in(tl_i,tr_i)$ of $(l_i-t,r_i-t)$ equals $(l_i-tr_i,\,r_i-tl_i)=(L_i,R_i)$. Thus it suffices to pick a constant $v\notin\bigcup_i(L_i,R_i)$. Minimal energy is the smallest $\lvert v-x\rvert$, i.e., the distance from $x$ to the complement of the merged forbidden union.}
\ASSUMPTIONS{Open intervals mean boundaries are safe; single jump at any time is enough, and further jumps cannot reduce total $L^1$ movement below $\lvert v-x\rvert$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $(L_i,R_i)$ for all curses and keep those with $L_i<R_i$.
\item Merge these open intervals under strict-overlap rule (merge if $L<\text{curR}$).
\item If $x$ lies inside a merged component $(A,B)$, answer is $\min(x-A,B-x)$; else answer is $0$.
\end{algosteps}
\OPTIMALITY{Any feasible trajectory defines a piecewise-constant $v(t)$. If some constant $v^\star$ avoids all curses, switching to $v^\star$ once costs exactly $\lvert v^\star-x\rvert$, which is a lower bound for any sequence of jumps by triangle inequality. Therefore the one-jump solution is optimal.}
\COMPLEXITY{$O(n\log n)$ time, $O(n)$ space.}
\begin{BreakableEquation*}
T(n)=O(n\log n),\quad S(n)=O(n).
\end{BreakableEquation*}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[Tuple[int, int, int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def merge_open_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    intervals.sort()
    merged: List[List[int]] = []
    for L, R in intervals:
        if not merged:
            merged.append([L, R])
        else:
            cL, cR = merged[-1]
            if L < cR:
                if R > cR:
                    merged[-1][1] = R
            else:
                merged.append([L, R])
    return [(L, R) for L, R in merged]

def solve_case(n: int, x: int, curses: List[Tuple[int, int, int, int]]) -> int:
    intervals: List[Tuple[int, int]] = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L < R:
            intervals.append((L, R))
    merged = merge_open_intervals(intervals)
    for L, R in merged:
        if L < x < R:
            return min(x - L, R - x)
    return 0

def solve_all():
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

def _self_test():
    # Touch endpoints: safe
    assert solve_case(1, 5, [(1, 5, 10, 20)]) == 0  # forbidden (5,19)
    # Inside interval: distance to nearest boundary
    assert solve_case(1, 12, [(3, 9, 10, 20)]) == 5  # (1,17)
    # Disjoint union
    assert solve_case(2, 5, [(1, 4, 7, 9), (5, 6, 3, 5)]) == 2  # (-3,0) U (3,8)
    print("OK")

if __name__ == "__main__":
    _self_test()
    # solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts verifying boundary safety, inside-interval distance, and disjoint-union behavior.}
\RESULT{Minimum energy equals the minimal distance from $x$ to $\mathbb{R}\setminus\bigcup_i (l_i-tr_i,\,r_i-tl_i)$. In the easy version this value is always an integer; print it.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for interval merging correctness (including touching endpoints), correctness on single-curse cases, and overlapping/disjoint multi-curse unions. Property check: placing $x$ far left or far right should yield $0$.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on small random sets: all three compute the same closed-form answer (distance to complement of merged forbidden union).}
\LINE{EDGE-CASE GENERATOR}{Generate curses with $L_i=R_i$ (zero-length open intervals), touching intervals where $R=L$, and large displacements to test $x$ far outside union.}
\begin{minted}{python}
import random

def gen_random(n=10, X=50, T=50, C=50, seed=0):
    random.seed(seed)
    curses = []
    for _ in range(n):
        tl = random.randint(1, T)
        tr = random.randint(tl, T)
        l = random.randint(1, C)
        r = random.randint(l, C)
        curses.append((tl, tr, l, r))
    x = random.randint(-X, X)
    return n, x, curses

def reference(n, x, curses):
    # Closed-form solver
    ivs = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L < R:
            ivs.append((L, R))
    ivs.sort()
    merged = []
    for L, R in ivs:
        if not merged or not (L < merged[-1][1]):
            merged.append([L, R])
        else:
            merged[-1][1] = max(merged[-1][1], R)
    ans = 0
    for L, R in merged:
        if L < x < R:
            ans = min(x - L, R - x)
            break
    return ans

def test_random():
    for seed in range(100):
        n, x, curses = gen_random(n=20, X=200, T=100, C=200, seed=seed)
        ans = reference(n, x, curses)
        assert isinstance(ans, int)
    print("Random tests OK")

if __name__ == "__main__":
    test_random()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[Tuple[int, int, int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def merge_open_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    intervals.sort()
    merged: List[List[int]] = []
    for L, R in intervals:
        if not merged:
            merged.append([L, R])
        else:
            cL, cR = merged[-1]
            if L < cR:  # strict overlap merges for open intervals
                if R > cR:
                    merged[-1][1] = R
            else:
                merged.append([L, R])
    return [(L, R) for L, R in merged]

def solve_case(n: int, x: int, curses: List[Tuple[int, int, int, int]]) -> int:
    intervals: List[Tuple[int, int]] = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L < R:
            intervals.append((L, R))
    merged = merge_open_intervals(intervals)
    for L, R in merged:
        if L < x < R:
            return min(x - L, R - x)
    return 0

def solve_all():
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

def _self_test():
    assert solve_case(1, 12, [(3, 9, 10, 20)]) == 5
    assert solve_case(1, 5, [(1, 5, 10, 20)]) == 0
    assert solve_case(2, 5, [(1, 4, 7, 9), (5, 6, 3, 5)]) == 2
    # Touching endpoints: safe
    assert solve_case(2, 3, [(0, 2, 1, 3), (0, 2, 3, 5)]) == 0
    print("OK")

if __name__ == "__main__":
    _self_test()
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to a 1D problem on $v=y-t$; merge forbidden intervals $(l_i-tr_i,\,r_i-tl_i)$ and measure distance of $x$ to their complement.}
\WHY{A classic trick: straightening motion with slope $1$ by subtracting time converts spacetime rectangles into stationary forbidden gaps on a single line.}
\CHECKLIST{
\begin{bullets}
\item Compute $(L_i,R_i)=(l_i-tr_i,\,r_i-tl_i)$ for each curse.
\item Drop empty intervals with $L_i\ge R_i$.
\item Merge strictly overlapping open intervals; do not merge when $L=R$.
\item If $x$ lies inside a merged component $(A,B)$, answer is $\min(x-A,B-x)$; else $0$.
\item Print integer (rounding rule irrelevant here as result is integer).
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $x$ exactly equals a boundary $L_i$ or $R_i$ — safe, output $0$.
\item Intervals that only touch at endpoints (e.g., $(a,b)$ and $(b,c)$) must not be merged for open unions.
\item Zero-length intervals with $L_i=R_i$ contribute nothing.
\item Large coordinates; ensure no overflow and integer math is used.
\item All curses to one side of $x$ — output $0$.
\item Deep overlaps — merging must produce a single wide interval.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Treating intervals as closed would incorrectly mark boundaries as unsafe.
\item Merging touching intervals when $L=R$ would falsely include the touching point.
\item Using floats can introduce rounding errors; pure integer arithmetic suffices.
\item Forgetting to handle $L_i\ge R_i$ (empty open interval) may skew merging.
\item Not sorting intervals before merging.
\item Mishandling negative values for $L_i$.
\end{bullets}}
\FAILMODES{A step-by-step simulator that moves greedily at event times can be complex and error-prone with unions; the $v$-reduction avoids all dynamic pitfalls and yields a direct $O(n\log n)$ solution robust to overlaps and touching.}
\ELI{Subtracting time straightens the path: you just choose a height $v$ so that your straight line $y=t+v$ never enters any forbidden bands. Those bands collapse to fixed gaps on the $v$-axis, so you just step outside them as cheaply as possible.}
\NotePages{3}

\end{document}