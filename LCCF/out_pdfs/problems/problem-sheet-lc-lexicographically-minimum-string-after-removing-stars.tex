% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Minimum String After Removing Stars}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographically-minimum-string-after-removing-stars/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a string \texttt{s}. It may contain any number of \texttt{*} characters. Your task is to remove all \texttt{*} characters.

While there is a \texttt{*}, do the following operation:
\begin{itemize}
\item Delete the leftmost \texttt{*} and the \textbf{smallest} non-\texttt{*} character to its \emph{left}. If there are several smallest characters, you can delete any of them.
\end{itemize}

Return the lexicographically smallest resulting string after removing all \texttt{*} characters.

\textbf{Example 1:}

\textbf{Input:} \texttt{s = "aaba*"} \\
\textbf{Output:} \texttt{"aab"} \\
\textbf{Explanation:}
We should delete one of the \texttt{'a'} characters with \texttt{*}. If we choose \texttt{s[3]}, \texttt{s} becomes the lexicographically smallest.

\textbf{Example 2:}

\textbf{Input:} \texttt{s = "abc"} \\
\textbf{Output:} \texttt{"abc"} \\
\textbf{Explanation:}
There is no \texttt{*} in the string.

\textbf{Constraints:}
\begin{itemize}
\item $1 \le s.\text{length} \le 10^5$
\item \texttt{s} consists only of lowercase English letters and \texttt{*}.
\item The input is generated such that it is possible to delete all \texttt{*} characters.
\end{itemize}}
\BREAKDOWN{Simulate the required deletions while always pairing the leftmost \texttt{*} with the smallest available letter to its left. To minimize the final string lexicographically, among equal smallest letters we can delete the most recently added occurrence, which preserves earlier small letters. Efficiently support: append letters, find the current smallest available letter, and delete one occurrence.}
\ELI{Walk left to right, and every time you see a star, cross out one smallest letter seen so far; keep all uncrossed letters in their original order.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single string \texttt{s} of length $n$ with $1 \le n \le 10^5$, consisting of lowercase English letters and \texttt{*}. The input is guaranteed to be feasible: the number of letters on the left is always sufficient when a \texttt{*} is encountered.}
\OUTPUTS{Return a string consisting only of lowercase English letters: the lexicographically smallest possible result after removing all \texttt{*} symbols according to the rule.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{"aaba*"} $\to$ Output: \texttt{"aab"}.
\item Input: \texttt{"abc"} $\to$ Output: \texttt{"abc"}.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s = s_1 s_2 \ldots s_n$ over alphabet $\Sigma = \{a,\ldots,z\} \cup \{\ast\}$. Define an operation on any string with at least one $\ast$: find the leftmost index $j$ with $s_j = \ast$, and delete that symbol together with one index $i<j$ such that $s_i \in \{a,\ldots,z\}$ is minimum under the lexicographic order on letters. If multiple $i$ attain this minimum, any one may be chosen. Iterate until no $\ast$ remains. Among all valid sequences of choices, output the lexicographically smallest terminal string.}
\varmapStart
\var{s}{input string}
\var{n}{length of $s$}
\var{R}{list of currently retained letters in original order}
\var{B_c}{stack (LIFO) of indices in $R$ holding letter $c$}
\var{\text{minc}}{current smallest $c$ with $B_c$ nonempty}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Initialization: } R \leftarrow [\,],\quad B_c \leftarrow [\,]\ \forall c\in\{0,\ldots,25\}.\\
&\text{For } t=1\ldots n:\\
&\quad \text{If } s_t=\text{letter }c:\ R.\text{append}(c),\ B_c.\text{push}(|R|-1),\ \text{minc}\leftarrow \min(\text{minc},c).\\
&\quad \text{If } s_t=\ast:\ \text{let }c^\star=\min\{c: B_c\neq\emptyset\};\ j\leftarrow B_{c^\star}.\text{pop()};\ R[j]\leftarrow \bot.\\
&\text{Answer: }\ \text{concatenate }R\text{ entries } \neq \bot \text{ as letters in order.}
\end{aligned}
\]
}
\ASSUMPTIONS{Zero-based letter encoding $a\mapsto 0,\ldots,z\mapsto 25$. The feasibility condition ensures that at each $\ast$ at least one $B_c$ is nonempty. Ties among equal letters can be broken by deleting the most recent (rightmost) occurrence without harming optimality.}
\INVARIANTS{
\begin{itemize}
\item At any step, $R$ preserves the original relative order of all letters that have not been deleted.
\item The multiset of non-\texttt{*} symbols to the left of the current position equals the multiset represented by $\bigcup_c B_c$.
\item Deleting from $B_{c^\star}$ always removes a smallest available letter.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate the definition: repeatedly find the leftmost \texttt{*}, scan its left segment to find the smallest letter, delete that letter (break ties consistently, e.g., delete the rightmost among minimum letters), then delete the \texttt{*}.}
\ASSUMPTIONS{Operate on a mutable list of characters. Each iteration strictly reduces the number of \texttt{*}, so the process terminates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Convert \texttt{s} to a list \texttt{arr}.
\item While \texttt{arr} contains a \texttt{*}: find index \texttt{j} of the leftmost \texttt{*}.
\item In \texttt{arr[:j]}, find the minimum character \texttt{m}, then find its rightmost index \texttt{i}. Delete \texttt{arr[j]} first, then \texttt{arr[i]}.
\item Return the string from the remaining letters.
\end{algosteps}
\COMPLEXITY{Let $n=|s|$ and $k$ be the number of \texttt{*}. Each iteration scans up to $O(n)$, for $k$ iterations, yielding $O(nk)$ worst case, i.e., $O(n^2)$. Space $O(n)$.}
\[
\begin{aligned}
T(n) &\le \sum_{t=1}^{k} O(n) = O(nk) \\
     &\subseteq O(n^2).
\end{aligned}
\]
\CORRECTNESS{Each loop step exactly mimics the specified operation. Choosing the rightmost among equal minimum letters preserves earlier small letters and cannot worsen the lexicographic order. The loop ends with no \texttt{*} and all required deletions done.}
\EDGECASES{No \texttt{*} present; all letters the same; alternating letters and \texttt{*}; the last character is \texttt{*}; entire result becomes empty.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def clearStars(self, s: str) -> str:
        # Brute-force simulation: O(n^2)
        arr = list(s)
        while True:
            try:
                j = arr.index('*')  # leftmost star
            except ValueError:
                break  # no stars left
            # Among arr[:j], find the smallest letter and delete its rightmost occurrence
            # Feasibility guarantees j > 0 and there exists a letter to delete.
            left = arr[:j]
            # left has only letters because this is the leftmost '*'
            m = min(left)  # smallest letter
            # Find rightmost index of m in left
            i = j - 1 - left[::-1].index(m)
            # Delete star first (higher index), then the letter
            del arr[j]
            del arr[i]
        # Return the remaining letters
        return "".join(ch for ch in arr if ch != '*')


# Basic asserts for the baseline
def _bf_expect(s: str) -> str:
    return Solution().clearStars(s)

assert _bf_expect("aaba*") == "aab"
assert _bf_expect("abc") == "abc"
assert _bf_expect("a*b*c*") == ""
\end{minted}
\VALIDATION{The included asserts check sample cases and a case that fully cancels all letters.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Buckets by Letter + Lazy Deletion}
\WHICHFORMULA{Scan left to right, append letters to a result buffer, and maintain 26 stacks (one per letter) with indices of their positions in the buffer. On a \texttt{*}, remove one smallest letter by popping from the smallest nonempty stack; mark that buffer entry as deleted.}
\ASSUMPTIONS{Alphabet size is constant (26), so scanning for the smallest nonempty bucket per \texttt{*} is $O(26)=O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty list \texttt{res} and 26 stacks \texttt{buckets[0..25]}.
\item For each character \texttt{ch} in \texttt{s}:
  \begin{itemize}
  \item If \texttt{ch} is a letter: append to \texttt{res}; push its index to \texttt{buckets[ord(ch)-97]}.
  \item If \texttt{ch == '*'}: find the smallest $c$ with \texttt{buckets[c]} nonempty; pop an index \texttt{i} and set \texttt{res[i] = None}.
  \end{itemize}
\item Return the concatenation of non-\texttt{None} entries in \texttt{res}.
\end{algosteps}
\COMPLEXITY{Each character is appended once and possibly deleted once. Each \texttt{*} scans at most 26 buckets. Overall $T(n)=O(n)$ with a small constant; space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n + 26\cdot \#\ast) = O(n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{At any time, the multiset of available letters to the left equals the union of buckets. Selecting the smallest nonempty bucket deletes a smallest letter. Deleting the most recent occurrence of that letter (stack pop) preserves earlier small letters, which is optimal for lexicographic minimality.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def clearStars(self, s: str) -> str:
        # O(n) with 26 buckets, lazy delete in result buffer
        res: list = []  # list of letters or None
        buckets = [[] for _ in range(26)]  # stacks of indices into res

        for ch in s:
            if ch != '*':
                res.append(ch)
                buckets[ord(ch) - 97].append(len(res) - 1)
            else:
                # delete one smallest available letter
                for ci in range(26):
                    if buckets[ci]:
                        idx = buckets[ci].pop()
                        res[idx] = None
                        break

        return "".join(ch for ch in res if ch is not None)


# Cross-check improved vs baseline on small randoms
def _bf(s: str) -> str:
    # local brute force for cross-check
    arr = list(s)
    while True:
        try:
            j = arr.index('*')
        except ValueError:
            break
        left = arr[:j]
        m = min(left)
        i = j - 1 - left[::-1].index(m)
        del arr[j]
        del arr[i]
    return "".join(ch for ch in arr if ch != '*')

sol = Solution()
assert sol.clearStars("aaba*") == "aab"
assert sol.clearStars("abc") == "abc"
assert sol.clearStars("a*b*c*") == ""
# a few random-ish crafted checks
cases = [
    "b*a*c*",
    "zz*yx*aba**",
    "aaaa****",
    "bac*ab**c*",
]
for t in cases:
    assert sol.clearStars(t) == _bf(t)
\end{minted}
\VALIDATION{Cross-checked on several crafted cases against the brute-force simulation to ensure equivalence.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{26 Buckets + Rolling Minimum Pointer}
\WHICHFORMULA{Same bucketed simulation as Approach B, but maintain a rolling pointer \texttt{minc} to the smallest nonempty letter bucket so that each \texttt{*} deletion is $O(1)$ amortized without scanning all 26 buckets.}
\ASSUMPTIONS{Alphabet is fixed and small; updating \texttt{minc} on letter arrivals and after pops is constant time amortized.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{res}, \texttt{buckets[26]}, and \texttt{minc = 26}.
\item For each character \texttt{ch}:
  \begin{itemize}
  \item If letter with code \texttt{c}: append to \texttt{res}; push index to \texttt{buckets[c]}; set \texttt{minc = min(minc, c)}.
  \item If \texttt{*}: advance \texttt{minc} upward until a nonempty bucket; pop one index from \texttt{buckets[minc]} and set \texttt{res[idx] = None}. If that bucket becomes empty, advance \texttt{minc} again as needed.
  \end{itemize}
\item Return the concatenation of non-\texttt{None} entries.
\end{algosteps}
\OPTIMALITY{This method is optimal up to constant factors: it performs a single pass with $O(1)$ amortized work per character and linear space, which matches information-theoretic lower bounds for streaming simulation of the required operation.}
\COMPLEXITY{Each character causes $O(1)$ amortized pointer adjustments; total $T(n)=O(n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def clearStars(self, s: str) -> str:
        res: list = []
        buckets = [[] for _ in range(26)]
        minc = 26  # smallest c with nonempty bucket; 26 means none

        def advance():
            nonlocal minc
            while minc < 26 and not buckets[minc]:
                minc += 1

        for ch in s:
            if ch != '*':
                c = ord(ch) - 97
                res.append(ch)
                buckets[c].append(len(res) - 1)
                if c < minc:
                    minc = c
            else:
                # ensure minc points to a nonempty bucket
                advance()
                # feasibility guarantees availability
                idx = buckets[minc].pop()
                res[idx] = None
                # if current bucket empty, advance further
                if not buckets[minc]:
                    advance()

        return "".join(ch for ch in res if ch is not None)


# Exactly 3 asserts (samples and a nontrivial case)
sol = Solution()
assert sol.clearStars("aaba*") == "aab"
assert sol.clearStars("abc") == "abc"
assert sol.clearStars("zz*yx*aba**") == "xzzb"
\end{minted}
\VALIDATION{Checked against samples and a mixed case with interleaved stars and letters.}
\RESULT{Returns the lexicographically smallest possible string after removing all \texttt{*} by always pairing each leftmost \texttt{*} with a smallest letter to its left, breaking ties by deleting the most recent occurrence of that smallest letter.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate basic samples; adversarial patterns like all stars concentrated at the end, alternating letters and stars, repeated letters; random small cases cross-checked against a brute-force simulator.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A vs B vs C on dozens of tiny random strings to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with extreme repetitions of the same letter, or strictly decreasing letters to maximize tie scenarios, and insert stars at random or clustered positions.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def brute_force(s: str) -> str:
    arr = list(s)
    while True:
        try:
            j = arr.index('*')
        except ValueError:
            break
        left = arr[:j]
        m = min(left)
        i = j - 1 - left[::-1].index(m)
        del arr[j]
        del arr[i]
    return "".join(ch for ch in arr if ch != '*')

class Ref:
    def clearStars(self, s: str) -> str:
        # Final reference (Approach C)
        res = []
        buckets = [[] for _ in range(26)]
        minc = 26
        def advance():
            nonlocal minc
            while minc < 26 and not buckets[minc]:
                minc += 1
        for ch in s:
            if ch != '*':
                c = ord(ch) - 97
                res.append(ch)
                buckets[c].append(len(res) - 1)
                if c < minc:
                    minc = c
            else:
                advance()
                idx = buckets[minc].pop()
                res[idx] = None
                if not buckets[minc]:
                    advance()
        return "".join(ch for ch in res if ch is not None)

# Cross-check harness
def run_cross_checks():
    sol = Ref()
    random.seed(0)
    letters = "abc"
    for n in range(1, 12):
        for _ in range(200):
            s = []
            stars = 0
            letters_count = 0
            for __ in range(n):
                if random.random() < 0.2:
                    s.append('*'); stars += 1
                else:
                    ch = random.choice(letters)
                    s.append(ch); letters_count += 1
            # ensure feasibility by appending enough letters if needed
            while stars > letters_count:
                s.append(random.choice(letters))
                letters_count += 1
            t = "".join(s)
            assert sol.clearStars(t) == brute_force(t)
    print("Cross-checks passed.")

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def clearStars(self, s: str) -> str:
        # Optimal one-pass solution with 26 buckets and rolling minimum pointer
        res = []
        buckets = [[] for _ in range(26)]
        minc = 26

        def advance():
            nonlocal minc
            while minc < 26 and not buckets[minc]:
                minc += 1

        for ch in s:
            if ch != '*':
                c = ord(ch) - 97
                res.append(ch)
                buckets[c].append(len(res) - 1)
                if c < minc:
                    minc = c
            else:
                advance()
                idx = buckets[minc].pop()
                res[idx] = None
                if not buckets[minc]:
                    advance()

        return "".join(ch for ch in res if ch is not None)


# Minimal sanity tests for submission
if __name__ == "__main__":
    sol = Solution()
    assert sol.clearStars("aaba*") == "aab"
    assert sol.clearStars("abc") == "abc"
    assert sol.clearStars("a*b*c*") == ""
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain a buffer of letters and delete the smallest available letter when a star appears; use 26 stacks to find and remove quickly.}
\WHY{This pattern tests online greedy reasoning with tie-breaking for lexicographic minimality and efficient data structures for constant alphabet.}
\CHECKLIST{
\begin{itemize}
\item Scan left to right; append letters to buffer, track their indices by letter.
\item On \texttt{*}, remove from the smallest nonempty bucket.
\item Mark deleted entries and skip them in the final join.
\item Prefer deleting the most recent occurrence among equal letters.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item No \texttt{*} at all.
\item All characters are \texttt{*} interleaved with just enough letters.
\item Repeated same letter many times.
\item Stars clustered at the end.
\item Alternating letter and \texttt{*}.
\item Result becomes empty string.
\item Minimal alphabet letter present alongside larger letters.
\item Long runs up to $10^5$ characters.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Accidentally deleting the leftmost occurrence among equal smallest letters can still be correct, but deleting the most recent is safer for lexicographic minimality and simpler with stacks.
\item Forgetting to ensure the star is leftmost in a brute-force simulation.
\item Not handling feasibility might cause underflow when a \texttt{*} appears.
\item Building the output without filtering deleted placeholders.
\item Using $O(n^2)$ operations on large inputs leading to TLE.
\item Off-by-one errors when deleting from arrays.
\end{itemize}
}
\FAILMODES{A naive approach that rescans entire prefixes on every \texttt{*} will time out on $n\approx 10^5$. Using a heap of letters with indices can complicate deletions; 26 stacks keep operations $O(1)$ and stable.}
\ELI{Keep a running pile of letters. Each time you see a star, cross out one smallest letter from your pile, preferably the newest such letter. At the end, read out the leftover letters in order.}
\NotePages{3}

\end{document}