% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Time to Remove All Cars Containing Illegal Goods}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed binary string $s$ which represents a sequence of train cars. $s[i] = \texttt{'0'}$ denotes that the $i$th car does not contain illegal goods and $s[i] = \texttt{'1'}$ denotes that the $i$th car does contain illegal goods.

As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:
\begin{enumerate}
\item Remove a train car from the left end (i.e., remove $s[0]$) which takes $1$ unit of time.
\item Remove a train car from the right end (i.e., remove $s[\lvert s\rvert - 1]$) which takes $1$ unit of time.
\item Remove a train car from anywhere in the sequence which takes $2$ units of time.
\end{enumerate}
Return the minimum time to remove all the cars containing illegal goods.

Note that an empty sequence of cars is considered to have no cars containing illegal goods.

Examples:
\begin{itemize}
\item Input: $s=\texttt{"1100101"}$. Output: $5$.
\item Input: $s=\texttt{"0010"}$. Output: $2$.
\end{itemize}

Constraints:
\begin{itemize}
\item $1 \le \lvert s\rvert \le 2 \times 10^{5}$.
\item $s[i]\in\{\texttt{'0'},\texttt{'1'}\}$.
\end{itemize}}
\BREAKDOWN{We must minimize time by mixing cheap end removals ($1$ each) with in-place removals ($2$ each). The key is to decide how many cars to peel from the left and right versus paying $2$ for remaining illegal cars in the middle, or equivalently compute minimal cost for every prefix/suffix and combine.}
\ELI{Either peel off a bunch from the ends cheaply, or zap remaining illegal cars in the middle for cost $2$ each; pick the split that costs the least.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single binary string $s$ with $1 \le \lvert s\rvert \le 2 \times 10^{5}$, characters in $\{ \texttt{'0'}, \texttt{'1'} \}$.}
\OUTPUTS{An integer: the minimum total time to remove all cars containing illegal goods.}
\SAMPLES{
\begin{bullets}
\item $s=\texttt{"1100101"} \Rightarrow 5$.
\item $s=\texttt{"0010"} \Rightarrow 2$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s\in\{0,1\}^{n}$, indexed $0,\ldots,n-1$. Each operation has cost: remove-left $=1$, remove-right $=1$, remove-anywhere $=2$. We want $\min$ total cost to remove every position $i$ with $s[i]=1$.}
\varmapStart
\var{n}{length of $s$}
\var{s[i]}{bit at position $i$}
\var{L[i]}{minimum time to clear all ones in prefix $[0..i]$}
\var{R[i]}{minimum time to clear all ones in suffix $[i..n-1]$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
L[i] &= \min\big(L[i-1] + 2\cdot[s[i]=1],\ i+1\big),\quad L[-1]=0,\\
R[i] &= \min\big(R[i+1] + 2\cdot[s[i]=1],\ n-i\big),\quad R[n]=0,\\
\text{Answer} &= \min\Big(R[0],\ \min_{0 \le j < n}\big(L[j] + R[j+1]\big)\Big).
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based. Removing from ends preserves order of the remainder. You may interleave operations arbitrarily.}
\INVARIANTS{
\begin{bullets}
\item $0 \le L[i] \le i+1$ and $0 \le R[i] \le n-i$ always hold by definition.
\item $L[i]$ never increases by more than $2$ when moving from $i-1$ to $i$, reflecting at most one new illegal car needing cost $2$ if not peeled by the left end.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all ways to remove $k$ cars from the left and $m$ cars from the right, and remove the remaining illegal cars in the middle individually at cost $2$ each.}
\ASSUMPTIONS{We can compute the number of ones in any interval using a prefix sum of ones.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute prefix sums of ones: $P[0]=0$, $P[i+1]=P[i]+[s[i]=1]$.
\item For every $i\in\{-1,0,\ldots,n-1\}$ as the last index removed from the left and every $j\in\{i+1,\ldots,n\}$ as the first index kept from the right cut, compute:
\begin{BreakableEquation*}
\text{cost}=(i+1)+(n-j)+2\cdot\big(P[j]-P[i+1]\big).
\end{BreakableEquation*}
\item Take the minimum cost over all pairs $(i,j)$.
\end{algosteps}
\COMPLEXITY{Two nested loops over $i$ and $j$. Space for prefix sums.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Every valid sequence of operations is equivalent to choosing some number of left and right removals, plus removing remaining illegal cars in the middle individually. The enumeration covers all such splits; the minimum is optimal.}
\EDGECASES{All zeros $\Rightarrow 0$; all ones $\Rightarrow n$ by peeling from one end; single one in the middle $\Rightarrow 2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LC TEMPLATE (must include class Solution with exact signature + asserts)
from typing import *

class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        P = [0] * (n + 1)
        for i, ch in enumerate(s):
            P[i + 1] = P[i] + (1 if ch == '1' else 0)
        INF = 10**18
        ans = INF
        # i is last removed from left, -1 means remove none on left
        for i in range(-1, n):
            # j is first index kept before removing suffix, n means remove none on right
            for j in range(i + 1, n + 1):
                ones_mid = P[j] - P[i + 1]
                cost = (i + 1) + (n - j) + 2 * ones_mid
                if cost < ans:
                    ans = cost
        return ans

# Basic asserts
assert Solution().minimumTime("1100101") == 5
assert Solution().minimumTime("0010") == 2
assert Solution().minimumTime("0") == 0
assert Solution().minimumTime("1") == 1
\end{minted}
\VALIDATION{Checked samples and small boundaries. Baseline is correct but too slow for large $n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix/Suffix Dynamic Programming}
\WHICHFORMULA{For each prefix, either remove the entire prefix from the left or pay $2$ for each new illegal car; symmetrically for suffixes. Combine at a cut.}
\ASSUMPTIONS{We can compute arrays $L[i]$ and $R[i]$ in $O(1)$ amortized per index via the recurrences.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L[i]$ for $i=0\ldots n-1$:
\begin{BreakableEquation*}
L[i]=\min\big(L[i-1]+2\cdot[s[i]=1],\ i+1\big),\quad L[-1]=0.
\end{BreakableEquation*}
\item Compute $R[i]$ for $i=n-1\ldots 0$:
\begin{BreakableEquation*}
R[i]=\min\big(R[i+1]+2\cdot[s[i]=1],\ n-i\big),\quad R[n]=0.
\end{BreakableEquation*}
\item Answer is $\min\big(R[0],\ \min_{0\le j<n} L[j]+R[j+1]\big)$.
\end{algosteps}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Each $L[i]$ is the optimal cost to clean the prefix, proven by induction using the two choices at position $i$. The same holds for $R[i]$ on suffixes. Any optimal sequence has a last left-end removal and a first right-end removal defining a cut; combining optimal prefix/suffix costs around this cut yields the global optimum.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import *

class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        if n == 0:
            return 0
        # L[i]: min time to clear all '1' in s[:i+1]
        L = [0] * n
        for i, ch in enumerate(s):
            prev = L[i - 1] if i > 0 else 0
            if ch == '1':
                L[i] = min(prev + 2, i + 1)
            else:
                L[i] = min(prev, i + 1)
        # R[i]: min time to clear all '1' in s[i:]
        R = [0] * (n + 1)
        R[n] = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '1':
                R[i] = min(R[i + 1] + 2, n - i)
            else:
                R[i] = min(R[i + 1], n - i)
        ans = R[0]  # remove suffix only
        for j in range(n):
            ans = min(ans, L[j] + R[j + 1])
        return ans

# Checks on edge inputs
sol = Solution()
assert sol.minimumTime("0") == 0
assert sol.minimumTime("1") == 1
assert sol.minimumTime("1100101") == 5
assert sol.minimumTime("0010") == 2
\end{minted}
\VALIDATION{Validated on samples, single-char cases, and mixed patterns.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Pass DP with Rolling Prefix and Suffix Array}
\WHICHFORMULA{Compute the optimal suffix cost array once, then scan left-to-right maintaining the optimal prefix cost in $O(1)$, combining at every split.}
\ASSUMPTIONS{Same recurrence as Approach B; we reuse it but store only the suffix array and a rolling prefix variable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $R[i]$ for all suffixes using $R[i]=\min(R[i+1]+2\cdot[s[i]=1],\ n-i)$.
\item Initialize $left=0$ and $ans=R[0]$.
\item For $i=0\ldots n-1$, update $left=\min(left+2,\ i+1)$ if $s[i]=1$, else $left=\min(left,\ i+1)$, and set $ans=\min(ans,\ left+R[i+1])$.
\end{algosteps}
\OPTIMALITY{This directly evaluates $\min_{-1\le j < n} L[j]+R[j+1]$ with $L[-1]=0$, taking the minimum over all cuts. No heuristic; it is exactly the DP optimum.}
\COMPLEXITY{Linear time, linear extra space for the suffixes.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(n)\ \text{(can be reduced to one array plus $O(1)$ state)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import *

class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        # Suffix DP: R[i] is min time to clear s[i:]
        R = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            if s[i] == '1':
                R[i] = min(R[i + 1] + 2, n - i)
            else:
                R[i] = min(R[i + 1], n - i)
        # Rolling prefix DP combined with R
        left = 0
        ans = R[0]
        for i, ch in enumerate(s):
            if ch == '1':
                left = min(left + 2, i + 1)
            else:
                left = min(left, i + 1)
            ans = min(ans, left + R[i + 1])
        return ans

# Exactly 3 asserts (mini-tests)
sol = Solution()
assert sol.minimumTime("1100101") == 5
assert sol.minimumTime("0010") == 2
assert sol.minimumTime("00000") == 0
\end{minted}
\VALIDATION{Cross-checked against Approach B on random small cases (see Section 7 generators).}
\RESULT{Returns the minimal total time. Ties are irrelevant since the output is a scalar minimum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for edge cases (all zeros, all ones, single one at edges or center), random small strings by exhaustive brute force (Approach A) vs. optimal (Approach C).}
\LINE{CROSS-CHECKS}{For $n \le 14$, enumerate all split pairs $(i,j)$ (Approach A) and ensure equality with Approach C. For larger $n$, spot-check patterns: alternating bits, long runs, and clustered ones.}
\LINE{EDGE-CASE GENERATOR}{Create adversarial strings: all ones, a single one, ones at both ends, and long zero runs between ones to force different trade-offs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import *
import random

def brute_force(s: str) -> int:
    n = len(s)
    P = [0] * (n + 1)
    for i, ch in enumerate(s):
        P[i + 1] = P[i] + (1 if ch == '1' else 0)
    ans = 10**18
    for i in range(-1, n):
        for j in range(i + 1, n + 1):
            ones_mid = P[j] - P[i + 1]
            cost = (i + 1) + (n - j) + 2 * ones_mid
            if cost < ans:
                ans = cost
    return ans

class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        R = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            if s[i] == '1':
                R[i] = min(R[i + 1] + 2, n - i)
            else:
                R[i] = min(R[i + 1], n - i)
        left = 0
        ans = R[0]
        for i, ch in enumerate(s):
            if ch == '1':
                left = min(left + 2, i + 1)
            else:
                left = min(left, i + 1)
            ans = min(ans, left + R[i + 1])
        return ans

def gen_cases() -> List[str]:
    cases = []
    cases += ["0", "1", "00", "11", "01", "10"]
    cases += ["00000", "11111", "10000", "00001", "10101", "11011", "1100101", "0010"]
    # Deterministic pseudo-random
    rnd = random.Random(0)
    for n in range(1, 15):
        s = "".join(rnd.choice("01") for _ in range(n))
        cases.append(s)
    return cases

def run_tests():
    sol = Solution()
    for s in gen_cases():
        bf = brute_force(s)
        opt = sol.minimumTime(s)
        assert bf == opt, (s, bf, opt)
    print("All tests passed on", len(gen_cases()), "cases.")

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import *

class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        # Suffix DP: R[i] is min time to clear all '1' in s[i:]
        R = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            if s[i] == '1':
                R[i] = min(R[i + 1] + 2, n - i)
            else:
                R[i] = min(R[i + 1], n - i)
        # Rolling prefix DP and combine at each split
        left = 0
        ans = R[0]
        for i, ch in enumerate(s):
            if ch == '1':
                left = min(left + 2, i + 1)
            else:
                left = min(left, i + 1)
            ans = min(ans, left + R[i + 1])
        return ans

# Sanity checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumTime("1100101") == 5
    assert sol.minimumTime("0010") == 2
    assert sol.minimumTime("00000") == 0
    assert sol.minimumTime("111") == 3
    assert sol.minimumTime("1010001") == 5
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize a mix of $1$-cost end removals and $2$-cost internal removals to clear all ones.}
\WHY{Common DP pattern: combine optimal prefix and suffix decisions at a cut; appears in string/greedy/DP interviews.}
\CHECKLIST{
\begin{bullets}
\item Build correct prefix DP: $L[i]=\min(L[i-1]+2\cdot[s[i]=1],\ i+1)$.
\item Build correct suffix DP: $R[i]=\min(R[i+1]+2\cdot[s[i]=1],\ n-i)$.
\item Combine: $\min(R[0],\ \min_j L[j]+R[j+1])$.
\item Handle trivial cases: all zeros $\to 0$, all ones $\to n$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $s$ has no ones $\Rightarrow 0$.
\item $s$ is all ones $\Rightarrow n$.
\item Single one at either end vs. middle.
\item Long run of zeros between ones.
\item Very long strings: ensure linear algorithm.
\item Alternating pattern $\texttt{"1010\ldots"}$.
\item Leading/trailing zeros should not force extra cost.
\item One very early and one very late one (test both ends).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the option to remove an entire prefix/suffix for cost $i+1$ or $n-i$ in DP.
\item Off-by-one when combining at $j$ vs. $j+1$.
\item Treating zeros as needing removal cost in DP.
\item Overflow not an issue in Python, but use large initial sentinels carefully.
\item Misinterpreting the ``anywhere'' operation as removing multiple cars at once (it removes one car for cost $2$).
\item Not considering the case of removing only from one side (no split).
\end{bullets}
}
\FAILMODES{Quadratic brute force times out for $n\approx 2\times 10^{5}$. Greedy that only peels from one side fails on patterns where mixing is cheaper. The presented DP survives all such cases by exact minimization.}
\ELI{Either peel cars from the ends at cost $1$ each or pay $2$ to pluck a bad car from the middle. By precomputing the best cost for every prefix and suffix, we can try every split in linear time and pick the cheapest combination.}
\NotePages{3}

\end{document}