% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Shortest Bridge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/shortest-bridge/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an $n \times n$ binary matrix \texttt{grid} where \texttt{1} represents land and \texttt{0} represents water. An \emph{island} is a 4-directionally connected group of \texttt{1}'s not connected to any other \texttt{1}'s. There are exactly two islands in \texttt{grid}. You may change \texttt{0}'s to \texttt{1}'s to connect the two islands to form one island. Return the smallest number of \texttt{0}'s you must flip to connect the two islands.\\
Examples:\\
Input: \texttt{grid = [[0,1],[1,0]]} \quad Output: \texttt{1}\\
Input: \texttt{grid = [[0,1,0],[0,0,0],[0,0,1]]} \quad Output: \texttt{2}\\
Input: \texttt{grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]} \quad Output: \texttt{1}\\
Constraints: $n == \texttt{grid.length} == \texttt{grid[i].length}$, $2 \le n \le 100$, $\texttt{grid[i][j]} \in \{0,1\}$, exactly two islands exist.}
\BREAKDOWN{Identify both islands. Compute the minimum number of water cells to flip so that a 4-directional path connects them. Use either a direct geometric formula or a breadth-first search (BFS) expansion.}
\ELI{Paint one island, then grow across water layer by layer until you touch the other island; the number of layers is the answer.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LeetCode): \texttt{def shortestBridge(self, grid: List[List[int]]) -> int}. Here, \texttt{grid} is an $n \times n$ list of lists of integers with entries in $\{0,1\}$ and $2 \le n \le 100$.}
\OUTPUTS{Return an integer: the minimum number of \texttt{0}'s that must be flipped to \texttt{1} to connect the two islands by 4-directional adjacency.}
\SAMPLES{Example A: \texttt{[[0,1],[1,0]]} $\to$ \texttt{1}. Example B: \texttt{[[0,0,0],[0,1,0],[0,0,1]]} $\to$ \texttt{2}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the grid index set be $V = \{0,\ldots,n-1\} \times \{0,\ldots,n-1\}$. Let $A,B \subset V$ be the cell sets of the two islands. A move is a 4-neighbor step. Flipping a water cell makes it land. We seek the minimum number of flips to create a path of land cells whose endpoints lie in $A$ and $B$.}
\varmapStart
\var{n}{grid dimension}
\var{A,B}{cell sets of the two islands}
\var{d_{1}}{L1 (Manhattan) distance on the grid}
\var{k^\ast}{minimum number of water cells to flip}
\varmapEnd
\GOVERN{
\[
  k^\ast \;=\; \min_{(a \in A,\; b \in B)} \bigl(\, d_{1}(a,b) - 1 \,\bigr)
  \quad=\quad \min_{(a=(r_a,c_a)\in A,\; b=(r_b,c_b)\in B)} \Bigl(\, |r_a-r_b| + |c_a-c_b| - 1 \,\Bigr).
\]
}
\ASSUMPTIONS{Exactly two islands exist; connectivity is 4-directional; flips may be applied to any water cells.}
\INVARIANTS{Flipping only water cells; islands remain 4-connected; BFS layers correspond to shortest flip counts since each layer crosses exactly one ring of water cells.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the closed-form $k^\ast = \min_{a\in A,b\in B} d_{1}(a,b)-1$. After extracting both islands, compute all pairwise Manhattan distances.}
\ASSUMPTIONS{The minimum number of flips equals the minimum L1 distance between any two island cells minus 1, because a monotone shortest path across water can be flipped cell by cell.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Find and record all cells of the first island $A$ via DFS or BFS.
\item Find and record all cells of the second island $B$ by scanning remaining land.
\item Compute $\min_{a\in A,b\in B}\bigl(|r_a-r_b|+|c_a-c_b|\bigr)-1$ and return it.
\end{algosteps}
\COMPLEXITY{Let $|A|+|B|\le n^2$. Extracting islands is $O(n^2)$. Pairwise scan is $O(|A||B|)$, which is $O(n^4)$ in the worst case. Space $O(n^2)$ for visited sets.}
\[
\begin{aligned}
T(n) &= O(n^2) + O(|A||B|) \\
     &\le O(n^2) + O(n^4) = O(n^4), \quad S(n)=O(n^2).
\end{aligned}
\]
\CORRECTNESS{The Manhattan distance between two cells equals the length of a shortest 4-neighbor path. Flipping each water cell along such a path yields a connection. Subtracting 1 accounts for the final step touching the other island's land. Taking the minimum over all pairs yields the optimal flips.}
\EDGECASES{Islands touching diagonally; one island of size 1; islands already adjacent (answer 0).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Deque, Tuple
from collections import deque

class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)
        # Find first island A
        seen = [[False]*n for _ in range(n)]
        A: List[Tuple[int,int]] = []
        B: List[Tuple[int,int]] = []

        def neighbors(r: int, c: int):
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if 0 <= nr < n and 0 <= nc < n:
                    yield nr, nc

        def bfs_collect(sr: int, sc: int, mark_seen: bool) -> List[Tuple[int,int]]:
            q: Deque[Tuple[int,int]] = deque()
            q.append((sr, sc))
            seen[sr][sc] = True
            comp = [(sr, sc)]
            while q:
                r, c = q.popleft()
                for nr, nc in neighbors(r, c):
                    if not seen[nr][nc] and grid[nr][nc] == 1:
                        seen[nr][nc] = True
                        q.append((nr, nc))
                        comp.append((nr, nc))
            return comp

        found = False
        for i in range(n):
            if found:
                break
            for j in range(n):
                if grid[i][j] == 1:
                    A = bfs_collect(i, j, True)
                    found = True
                    break

        # Second island B
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1 and not seen[i][j]:
                    B = bfs_collect(i, j, True)
                    # There are exactly two islands, so we can stop.
                    break
            if B:
                break

        # Brute force pairwise Manhattan distance minus 1
        best = 10**9
        for r1, c1 in A:
            for r2, c2 in B:
                d = abs(r1 - r2) + abs(c1 - c2) - 1
                if d < best:
                    best = d
        return best

# Asserts (sanity)
S = Solution()
assert S.shortestBridge([[0,1],[1,0]]) == 1
assert S.shortestBridge([[0,1,0],[0,0,0],[0,0,1]]) == 2
assert S.shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1
\end{minted}
\VALIDATION{Checks: islands adjacent horizontally or vertically yield 0; diagonally adjacent like \texttt{[[1,0],[0,1]]} yield 1; symmetric cases give same result.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Paint-and-Expand BFS}
\WHICHFORMULA{Mark the first island and then BFS outward over water, growing one layer per flip. The first time we touch land of the second island, the current BFS depth equals the minimum flips.}
\ASSUMPTIONS{4-neighbor steps; BFS layers correspond to increasing flip counts; starting from all cells of the first island ensures multi-source optimal expansion.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS to collect and mark the first island; enqueue all its cells with distance 0.
\item BFS: pop cells layer by layer; expand into unvisited water; when encountering a land cell not in the first island, return the current distance.
\item Each expansion across water increases the flip count by 1.
\end{algosteps}
\COMPLEXITY{Island marking is $O(n^2)$. BFS visits each cell at most once, $O(n^2)$. This beats the $O(n^4)$ brute-force pairwise scan.}
\[
\begin{aligned}
T(n) &= O(n^2), \quad S(n)=O(n^2).
\end{aligned}
\]
\CORRECTNESS{Multi-source BFS from the entire first island ensures that the first time we touch the other island is via the minimum number of water layers, by standard BFS shortest-path optimality in unweighted graphs.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque

class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)

        def neighbors(r: int, c: int):
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if 0 <= nr < n and 0 <= nc < n:
                    yield nr, nc

        # 1) Find and mark first island; queue all its cells
        seen = [[False]*n for _ in range(n)]
        q = deque()
        first_island = set()

        def dfs(r: int, c: int):
            stack = [(r, c)]
            seen[r][c] = True
            first_island.add((r, c))
            while stack:
                x, y = stack.pop()
                for nx, ny in neighbors(x, y):
                    if not seen[nx][ny] and grid[nx][ny] == 1:
                        seen[nx][ny] = True
                        first_island.add((nx, ny))
                        stack.append((nx, ny))

        found = False
        for i in range(n):
            if found:
                break
            for j in range(n):
                if grid[i][j] == 1:
                    dfs(i, j)
                    found = True
                    break

        # Initialize BFS queue with first island cells, distance 0
        for cell in first_island:
            q.append((cell[0], cell[1], 0))
        visited = set(first_island)

        # 2) BFS expansion
        while q:
            r, c, d = q.popleft()
            for nr, nc in neighbors(r, c):
                if (nr, nc) in visited:
                    continue
                if grid[nr][nc] == 1 and (nr, nc) not in first_island:
                    return d
                if grid[nr][nc] == 0:
                    visited.add((nr, nc))
                    q.append((nr, nc, d+1))

        return -1  # Should not happen per problem guarantees

# Asserts (sanity)
S = Solution()
assert S.shortestBridge([[0,1],[1,0]]) == 1
assert S.shortestBridge([[0,1,0],[0,0,0],[0,0,1]]) == 2
assert S.shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1
\end{minted}
\VALIDATION{Check trivial adjacent case returns 0; symmetric and rotated inputs produce same answer; large solid borders like example 3 return 1.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Bidirectional BFS from Both Islands}
\WHICHFORMULA{Run BFS from both islands simultaneously through water cells. Always expand the smaller frontier and stop when searches meet. This minimizes work and retains optimality.}
\ASSUMPTIONS{Both searches advance one layer per flip cost; meeting point between wavefronts yields the minimal sum of flips from both sides, which equals the minimum flips.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract both islands $A$ and $B$ as sets.
\item Initialize frontiers $F_A \leftarrow A$, $F_B \leftarrow B$, visited sets $V_A \leftarrow A$, $V_B \leftarrow B$, and steps $s \leftarrow 0$.
\item Loop: expand the smaller frontier into unvisited water. If any neighbor is in the opposite visited set, return $s$.
\end{algosteps}
\OPTIMALITY{Bidirectional BFS halves the search radius in an unweighted grid. Each layer corresponds to flipping exactly one ring of water cells, so the first meeting yields the minimum flips.}
\COMPLEXITY{$O(n^2)$ time and $O(n^2)$ space. In practice, fewer node visits than one-sided BFS.}
\[
\begin{aligned}
T(n) &= O(n^2), \quad S(n)=O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Deque
from collections import deque

class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)

        def neighbors(r: int, c: int):
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if 0 <= nr < n and 0 <= nc < n:
                    yield nr, nc

        # Find both islands via two passes
        seen = [[False]*n for _ in range(n)]

        def collect(sr: int, sc: int) -> set:
            q: Deque[Tuple[int,int]] = deque()
            q.append((sr, sc))
            seen[sr][sc] = True
            comp = {(sr, sc)}
            while q:
                r, c = q.popleft()
                for nr, nc in neighbors(r, c):
                    if not seen[nr][nc] and grid[nr][nc] == 1:
                        seen[nr][nc] = True
                        comp.add((nr, nc))
                        q.append((nr, nc))
            return comp

        A, B = set(), set()
        found_first = False
        for i in range(n):
            if found_first:
                break
            for j in range(n):
                if grid[i][j] == 1:
                    A = collect(i, j)
                    found_first = True
                    break

        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1 and not seen[i][j]:
                    B = collect(i, j)
                    break
            if B:
                break

        # Bidirectional BFS across water cells only
        VA, VB = set(A), set(B)
        FA, FB = set(A), set(B)
        steps = 0

        while True:
            # Always expand the smaller frontier
            if len(FA) > len(FB):
                FA, FB = FB, FA
                VA, VB = VB, VA
            newF = set()
            for r, c in FA:
                for nr, nc in neighbors(r, c):
                    if (nr, nc) in VB:
                        return steps
                    if grid[nr][nc] == 0 and (nr, nc) not in VA:
                        VA.add((nr, nc))
                        newF.add((nr, nc))
            FA = newF
            steps += 1

# Asserts (exactly 3)
S = Solution()
assert S.shortestBridge([[0,1],[1,0]]) == 1
assert S.shortestBridge([[0,1,0],[0,0,0],[0,0,1]]) == 2
assert S.shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1
\end{minted}
\VALIDATION{Three asserts from the problem statement pass. Additional corner checks: already-adjacent islands yield 0; diagonal-touching islands yield 1.}
\RESULT{Return the minimal number of water cells to flip so that a 4-connected land path exists between the two islands; ties do not arise since the result is a nonnegative integer.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests from examples; adjacency edge case; diagonal edge case; hollow and border-heavy cases; random small grids with exactly two islands where a verifier compares Approaches A and B.}
\LINE{CROSS-CHECKS}{On small $n \le 8$, compare the brute-force formula (Approach A) against BFS solutions (B or C). They must agree.}
\LINE{EDGE-CASE GENERATOR}{Crafted grids: two singletons at distance $d$; diagonal neighbors; one island enclosing the other separated by a ring of water; long thin islands.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
from collections import deque

def two_points(n: int, a: Tuple[int,int], b: Tuple[int,int]) -> List[List[int]]:
    g = [[0]*n for _ in range(n)]
    g[a[0]][a[1]] = 1
    g[b[0]][b[1]] = 1
    return g

def ring_with_hole(n: int) -> List[List[int]]:
    g = [[1]*n for _ in range(n)]
    for i in range(1, n-1):
        for j in range(1, n-1):
            g[i][j] = 0
    g[n//2][n//2] = 1  # second island in the hole
    return g

# Cross-check A vs B on small cases
from typing import Deque, Set

class A_Brute:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)
        seen = [[False]*n for _ in range(n)]
        A, B = [], []
        def nb(r,c):
            for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if 0 <= nr < n and 0 <= nc < n:
                    yield nr, nc
        def collect(sr, sc):
            q: Deque[Tuple[int,int]] = deque([(sr, sc)])
            seen[sr][sc] = True
            comp = [(sr, sc)]
            while q:
                r, c = q.popleft()
                for nr, nc in nb(r, c):
                    if not seen[nr][nc] and grid[nr][nc] == 1:
                        seen[nr][nc] = True
                        comp.append((nr, nc))
                        q.append((nr, nc))
            return comp
        gotA = False
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1 and not gotA:
                    A = collect(i, j)
                    gotA = True
                elif grid[i][j] == 1 and not seen[i][j]:
                    B = collect(i, j)
        best = 10**9
        for r1, c1 in A:
            for r2, c2 in B:
                best = min(best, abs(r1-r2)+abs(c1-c2)-1)
        return best

class B_BFS:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)
        def nb(r,c):
            for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if 0 <= nr < n and 0 <= nc < n:
                    yield nr, nc
        seen = [[False]*n for _ in range(n)]
        first = set()
        def dfs(i,j):
            st = [(i,j)]
            seen[i][j] = True
            first.add((i,j))
            while st:
                r,c = st.pop()
                for nr,nc in nb(r,c):
                    if not seen[nr][nc] and grid[nr][nc] == 1:
                        seen[nr][nc] = True
                        first.add((nr,nc))
                        st.append((nr,nc))
        found = False
        for i in range(n):
            if found: break
            for j in range(n):
                if grid[i][j] == 1:
                    dfs(i,j); found=True; break
        q = deque([(r,c,0) for r,c in first])
        vis = set(first)
        while q:
            r,c,d = q.popleft()
            for nr,nc in nb(r,c):
                if (nr,nc) in vis: continue
                if grid[nr][nc] == 1 and (nr,nc) not in first:
                    return d
                if grid[nr][nc] == 0:
                    vis.add((nr,nc))
                    q.append((nr,nc,d+1))
        return -1

# Simple cross-checks
A = A_Brute()
B = B_BFS()
cases = [
    [[0,1],[1,0]],
    [[0,1,0],[0,0,0],[0,0,1]],
    [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]],
    two_points(3, (0,0), (2,2)),
    two_points(4, (0,3), (3,0)),
    ring_with_hole(5),
]
for g in cases:
    assert A.shortestBridge(g) == B.shortestBridge(g)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple, Deque
from collections import deque

class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)

        def neighbors(r: int, c: int):
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if 0 <= nr < n and 0 <= nc < n:
                    yield nr, nc

        # Mark first island
        seen = [[False]*n for _ in range(n)]
        first = set()

        def dfs(sr: int, sc: int):
            st = [(sr, sc)]
            seen[sr][sc] = True
            first.add((sr, sc))
            while st:
                r, c = st.pop()
                for nr, nc in neighbors(r, c):
                    if not seen[nr][nc] and grid[nr][nc] == 1:
                        seen[nr][nc] = True
                        first.add((nr, nc))
                        st.append((nr, nc))

        found = False
        for i in range(n):
            if found:
                break
            for j in range(n):
                if grid[i][j] == 1:
                    dfs(i, j)
                    found = True
                    break

        # BFS outward until touching the second island
        q: Deque[Tuple[int,int,int]] = deque()
        visited = set(first)
        for r, c in first:
            q.append((r, c, 0))

        while q:
            r, c, d = q.popleft()
            for nr, nc in neighbors(r, c):
                if (nr, nc) in visited:
                    continue
                if grid[nr][nc] == 1 and (nr, nc) not in first:
                    return d
                if grid[nr][nc] == 0:
                    visited.add((nr, nc))
                    q.append((nr, nc, d+1))

        return -1

# Final quick checks
S = Solution()
assert S.shortestBridge([[0,1],[1,0]]) == 1
assert S.shortestBridge([[0,1,0],[0,0,0],[0,0,1]]) == 2
assert S.shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shortest flips to connect two islands in a binary grid.}
\WHY{Classic BFS/Paint problem; tests graph search fluency and handling of multiple sources.}
\CHECKLIST{Identify an island; mark it; initialize BFS frontier; expand over water; stop on touching the other island; return BFS depth.}
\EDGECASES{Islands already adjacent (answer 0). Diagonal-only contact (needs 1 flip). One-cell islands. Non-convex islands with narrow channels. Large border rings. Multiple equally short paths.}
\PITFALLS{Forgetting to multi-source from all first-island cells. Accidentally counting steps when moving within land. Not marking visited water, causing revisits. Modifying input in ways that break logic. Off-by-one when returning distance.}
\FAILMODES{Brute-force pair scan is $O(n^4)$ and times out for worst shapes; single-source BFS from only one border cell can miss shorter paths; DFS alone cannot count flips. The multi-source BFS or bidirectional BFS avoids these issues.}
\ELI{Color one island, then let its color seep through water one layer at a time until it touches the other island. The number of layers you spilled is exactly how many water tiles you must flip.}
\NotePages{3}

\end{document}