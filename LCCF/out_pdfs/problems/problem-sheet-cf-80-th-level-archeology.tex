% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — 80-th Level Archeology}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/731/D}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{Archeologists have found a secret pass in the dungeon of one of the pyramids of Cycleland. To enter the treasury they have to open an unusual lock on the door. The lock consists of $n$ words, each consisting of some hieroglyphs. The wall near the lock has a round switch. Each rotation of this switch changes the hieroglyphs according to some rules. The instruction nearby says that the door will open only if words written on the lock would be sorted in lexicographical order (the definition of lexicographical comparison is given in notes section).

The rule that changes hieroglyphs is the following. One clockwise rotation of the round switch replaces each hieroglyph with the next hieroglyph in alphabet, i.e. hieroglyph $x$ ($1 \le x \le c - 1$) is replaced with hieroglyph $(x + 1)$, and hieroglyph $c$ is replaced with hieroglyph $1$.

Help archeologist determine, how many clockwise rotations they should perform in order to open the door, or determine that this is impossible, i.e. no cyclic shift of the alphabet will make the sequence of words sorted lexicographically.

Input:\\
The first line of the input contains two integers $n$ and $c$ ($2 \le n \le 500{,}000$, $1 \le c \le 10^6$) — the number of words, written on the lock, and the number of different hieroglyphs.

Each of the following $n$ lines contains the description of one word. The $i$-th of these lines starts with integer $l_i$ ($1 \le l_i \le 500{,}000$), that denotes the length of the $i$-th word, followed by $l_i$ integers $w_{i,1}, w_{i,2}, \ldots, w_{i,l_i}$ ($1 \le w_{i,j} \le c$) — the indices of hieroglyphs that make up the $i$-th word. Hieroglyph with index $1$ is the smallest in the alphabet and with index $c$ — the biggest.

It is guaranteed that the total length of all words does not exceed $10^6$.

Output:\\
If it is possible to open the door by rotating the round switch, print integer $x$ ($0 \le x \le c - 1$) that defines the required number of clockwise rotations. If there are several valid $x$, print any of them.

If it is impossible to open the door by this method, print $-1$.

Note:\\
Word $a_1, a_2, \ldots, a_m$ of length $m$ is lexicographically not greater than word $b_1, b_2, \ldots, b_k$ of length $k$, if one of two conditions holds:
\begin{bullets}
\item at first position $i$, such that $a_i \ne b_i$, the character $a_i$ goes earlier in the alphabet than character $b_i$, i.e. $a$ has smaller character in the first position where they differ;
\item if there is no such position $i$ and $m \le k$, i.e. the first word is a prefix of the second or two words are equal.
\end{bullets}
The sequence of words is said to be sorted in lexicographical order if each word (except the last one) is lexicographically not greater than the next word.

In the first sample, after the round switch is rotated $1$ position clockwise the words look as follows:

In the second sample, words are already sorted in lexicographical order.

In the last sample, one can check that no shift of the alphabet will work.}
\BREAKDOWN{We must pick a cyclic rotation $x$ of the alphabet such that, after adding $x$ modulo $c$ to every symbol of every word, the word list becomes non-decreasing lexicographically. Each adjacent pair yields a constraint on $x$. We must aggregate all constraints efficiently.}
\ELI{Compare each neighboring pair at their first differing symbol and translate ``must be less'' into an interval constraint on the rotation $x$, then find any $x$ that satisfies all constraints.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Standard input:
\begin{bullets}
\item Integers $n$, $c$ with $2 \le n \le 500{,}000$, $1 \le c \le 10^6$.
\item For each $i=1\ldots n$: an integer $l_i$ ($1 \le l_i \le 500{,}000$), then $l_i$ integers $w_{i,1},\ldots,w_{i,l_i}$ with $1 \le w_{i,j} \le c$.
\item Total number of symbols $\sum l_i \le 10^6$.
\end{bullets}}
\OUTPUTS{A single integer $x$ with $0 \le x \le c-1$ such that rotating the alphabet by $x$ clockwise makes the sequence non-decreasing lexicographically, or $-1$ if impossible. Any valid $x$ is acceptable.}
\SAMPLES{Examples (illustrative, minimal):
\begin{bullets}
\item Input:
\[
\begin{aligned}
3~\,5\\
2~\,1~\,2\\
2~\,1~\,3\\
1~\,5
\end{aligned}
\]
Output: 0
\item Input:
\[
\begin{aligned}
2~\,4\\
2~\,3~\,1\\
2~\,2~\,4
\end{aligned}
\]
Output: 1
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $c$ be alphabet size with symbols $\{1,2,\ldots,c\}$. A rotation by $x \in \{0,\ldots,c-1\}$ maps each symbol $s$ to $\operatorname{rot}_x(s) = ((s-1+x) \bmod c) + 1$. The standard lex order on $\{1,\ldots,c\}$ is fixed. Given words $W_1,\ldots,W_n$, find $x$ such that $\operatorname{rot}_x(W_1) \le_{\text{lex}} \cdots \le_{\text{lex}} \operatorname{rot}_x(W_n)$.}
\varmapStart
\var{c}{alphabet size}
\var{n}{number of words}
\var{W_i}{sequence of symbols in $\{1,\ldots,c\}$}
\var{x}{rotation amount, $0 \le x \le c-1$}
\var{a,b}{first differing symbols of a neighboring pair (0-based $a,b \in \{0,\ldots,c-1\}$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For each adjacent pair }(W_i,W_{i+1}),~\text{let }p=\min\{t:W_i[t]\ne W_{i+1}[t]\}.
\end{BreakableEquation*}
If no such $p$ and $|W_i|>|W_{i+1}|$, infeasible. Otherwise for differing $a=W_i[p]-1$, $b=W_{i+1}[p]-1$ we require:
\begin{BreakableEquation*}
((a+x)\bmod c) < ((b+x)\bmod c).
\end{BreakableEquation*}
This inequality over $\{0,\ldots,c-1\}$ translates to interval constraints on $x$:
\]
\[
\begin{cases}
a<b:~x \notin [c-b,~c-a),\\
a>b:~x \in [c-a,~c-b).
\end{cases}
\]
}
\ASSUMPTIONS{Symbols are integers; lexicographical order uses the usual numeric order $1<2<\cdots<c$. Rotation is applied to every symbol in all words uniformly.}
\INVARIANTS{
\begin{bullets}
\item The first-difference position between two words is unchanged by any uniform rotation.
\item For a fixed pair $(a,b)$ with $a\ne b$, the set of valid $x$ is a single contiguous half-open interval if $a>b$, or its complement single interval if $a<b$.
\item Intersection of all ``must be in'' intervals remains a contiguous interval $[L,R)$; feasibility reduces to finding any $x \in [L,R)$ not covered by forbidden intervals.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try every rotation $x \in [0,c-1]$ and check if the rotated words are non-decreasing.}
\ASSUMPTIONS{Suitable only for tiny $c$ or as a validator.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $x$ from $0$ to $c-1$, define $\operatorname{rot}_x(s)=((s-1+x)\bmod c)+1$.
\item Check all adjacent pairs using lexicographical comparison after mapping via $\operatorname{rot}_x$.
\item Return the first $x$ that passes; otherwise return $-1$.
\end{algosteps}
\COMPLEXITY{Brute force enumerates all rotations and compares words character-by-character.
\[
\begin{aligned}
T(n) &= O\big(c \cdot (\textstyle\sum_i l_i)\big), \\
S(n) &= O(1) \text{ extra (in-place comparisons)}.
\end{aligned}
\]}
\CORRECTNESS{Directly tests the definition for each $x$, so if any valid $x$ exists, it will be found.}
\EDGECASES{Handle equal words, proper-prefix cases, and $c=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, []
    c = int(next(it))
    words: List[List[int]] = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for __ in range(li)]
        words.append(w)
    return n, c, words

def rotate_symbol(val: int, x: int, c: int) -> int:
    return ((val - 1 + x) % c) + 1

def leq_lex(a: List[int], b: List[int], x: int, c: int) -> bool:
    la, lb = len(a), len(b)
    m = min(la, lb)
    for i in range(m):
        ra = rotate_symbol(a[i], x, c)
        rb = rotate_symbol(b[i], x, c)
        if ra != rb:
            return ra < rb
    return la <= lb

def brute_find_rotation(words: List[List[int]], c: int) -> int:
    n = len(words)
    # Quick infeasibility: if any is a strict longer prefix of the next (no rotation can help)
    for i in range(n - 1):
        a, b = words[i], words[i + 1]
        m = min(len(a), len(b))
        if a[:m] == b[:m] and len(a) > len(b):
            return -1
    for x in range(c):
        ok = True
        for i in range(n - 1):
            if not leq_lex(words[i], words[i + 1], x, c):
                ok = False
                break
        if ok:
            return x
    return -1

def solve_all():
    n, c, words = read_input()
    if n == 0:
        return
    ans = brute_find_rotation(words, c)
    print(ans)

def main():
    solve_all()

if __name__ == "__main__":
    # Basic asserts (tiny cases)
    assert rotate_symbol(1, 0, 5) == 1
    assert rotate_symbol(5, 1, 5) == 1
    # Already sorted, x = 0 works
    assert brute_find_rotation([[1,2],[1,3],[5]], 5) == 0
    # Needs rotation by 1
    assert brute_find_rotation([[3,1],[2,4]], 4) == 1
    main()
\end{minted}
\VALIDATION{Checked a no-rotation case, a simple rotation-by-1 case, and wrap-around behavior of a single symbol.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Interval Constraints via First-Difference Analysis}
\WHICHFORMULA{Translate each adjacent pair into an interval constraint on $x$: for first differing symbols $a,b$ (0-based), require $x \in [c-a, c-b)$ if $a>b$, and forbid $x \in [c-b, c-a)$ if $a<b$. Intersect all required-intervals and subtract all forbidden-intervals.}
\ASSUMPTIONS{The first-difference index is invariant to uniform rotation; range arithmetic over $[0,c)$ uses half-open intervals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize required intersection $[L,R)=[0,c)$ and an array \texttt{ban} of length $c+1$ to mark forbidden coverage via difference-array.
\item For each adjacent pair, compute the first-difference position:
\begin{bullets}
\item If no difference and the first word is longer, return infeasible ($-1$).
\item If first differing 0-based symbols are $a$ and $b$:
\begin{bullets}
\item If $a>b$: update $L=\max(L,c-a)$, $R=\min(R,c-b)$.
\item If $a<b$: add forbidden interval $[c-b,c-a)$ into \texttt{ban} via \texttt{ban[L]+=1}, \texttt{ban[R]-=1}.
\end{bullets}
\end{bullets}
\item If $L \ge R$, infeasible.
\item Prefix-sum \texttt{ban}. Scan $x \in [L,R)$ and return the first with \texttt{ban[x]}$=0$. If none, infeasible.
\end{algosteps}
\COMPLEXITY{Linear in input size and alphabet size:
\begin{BreakableEquation*}
T(n)=O\!\big(\textstyle\sum l_i + c + n\big),\quad S(n)=O(c).
\end{BreakableEquation*}
This is a large improvement over brute force when $c$ is large.}
\CORRECTNESS{For each pair the derived interval characterization is exact; intersecting all required intervals enforces all $a>b$ constraints, and removing forbidden covered points enforces all $a<b$ constraints. A point $x$ survives iff it satisfies every pairwise constraint.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, os
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, []
    c = int(next(it))
    words: List[List[int]] = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for __ in range(li)]
        words.append(w)
    return n, c, words

def find_first_diff(a: List[int], b: List[int]) -> int:
    m = min(len(a), len(b))
    for i in range(m):
        if a[i] != b[i]:
            return i
    return -1  # identical up to min length

def improved_find_rotation(words: List[List[int]], c: int) -> int:
    n = len(words)
    L, R = 0, c  # required intersection [L, R)
    ban = [0] * (c + 1)  # difference array for forbidden intervals
    for i in range(n - 1):
        a, b = words[i], words[i + 1]
        p = find_first_diff(a, b)
        if p == -1:
            if len(a) > len(b):  # strict prefix violation, impossible
                return -1
            else:
                continue
        A0 = a[p] - 1
        B0 = b[p] - 1
        if A0 > B0:
            l = c - A0
            r = c - B0
            if l > L:
                L = l
            if r < R:
                R = r
        else:  # A0 < B0
            l = c - B0
            r = c - A0
            # mark forbidden [l, r)
            ban[l] += 1
            ban[r] -= 1
    if L >= R:
        return -1
    # Build coverage and search x in [L, R)
    cur = 0
    for x in range(c):
        cur += ban[x]
        ban[x] = cur  # reuse as coverage
    for x in range(L, R):
        if ban[x] == 0:
            return x
    return -1

def solve_all():
    n, c, words = read_input()
    if n == 0:
        return
    ans = improved_find_rotation(words, c)
    print(ans)

def main():
    # Optional: run tests only if demanded
    if os.environ.get("RUN_TESTS") == "1":
        # Trivial: already sorted
        assert improved_find_rotation([[1,2],[1,3],[5]], 5) == 0
        # Needs rotation by 1
        assert improved_find_rotation([[3,1],[2,4]], 4) == 1
        # Impossible due to prefix
        assert improved_find_rotation([[1,2,3],[1,2]], 10) == -1
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers already-sorted, a small rotation-needed case, and an impossible prefix case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single-Pass Constraint Aggregation with Interval Intersection}
\WHICHFORMULA{Compute $[L,R)=\bigcap_{(a>b)}[c-a, c-b)$ and a forbidden coverage array for all $(a<b)$ intervals $[c-b,c-a)$. Pick any $x \in [L,R)$ with zero forbidden coverage.}
\ASSUMPTIONS{Half-open intervals on the discrete domain $\{0,1,\ldots,c-1\}$, total input size up to $10^6$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $L=0$, $R=c$, \texttt{ban} as a difference array of zeros of length $c+1$.
\item For each adjacent pair, compute first difference and update as per case $a>b$ or $a<b$.
\item If $L \ge R$, return $-1$.
\item Prefix-sum \texttt{ban} to get coverage counts; scan $x \in [L,R)$ to find any with \texttt{ban[x]}$=0$.
\end{algosteps}
\OPTIMALITY{Each pair contributes $O(1)$ work; building forbidden coverage and scanning is $O(c)$. Any solution must at least examine input and, in worst-case, touch $O(c)$ states, so the bound is tight up to constants.}
\COMPLEXITY{
\begin{BreakableEquation*}
T(n)=O\!\big(\textstyle\sum l_i + c\big),\quad S(n)=O(c).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, []
    c = int(next(it))
    words: List[List[int]] = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for __ in range(li)]
        words.append(w)
    return n, c, words

def find_first_diff(a: List[int], b: List[int]) -> int:
    m = min(len(a), len(b))
    for i in range(m):
        if a[i] != b[i]:
            return i
    return -1

def find_rotation(words: List[List[int]], c: int) -> int:
    n = len(words)
    L, R = 0, c  # required intersection [L, R)
    ban = [0] * (c + 1)  # forbidden coverage difference array
    for i in range(n - 1):
        a, b = words[i], words[i + 1]
        p = find_first_diff(a, b)
        if p == -1:
            if len(a) > len(b):
                return -1
            else:
                continue
        A0 = a[p] - 1
        B0 = b[p] - 1
        if A0 > B0:
            l = c - A0
            r = c - B0
            if l > L:
                L = l
            if r < R:
                R = r
        else:
            l = c - B0
            r = c - A0
            ban[l] += 1
            ban[r] -= 1
    if L >= R:
        return -1
    cur = 0
    for x in range(c):
        cur += ban[x]
        ban[x] = cur
    for x in range(L, R):
        if ban[x] == 0:
            return x
    return -1

def solve_all():
    n, c, words = read_input()
    if n == 0:
        return
    ans = find_rotation(words, c)
    print(ans)

def main():
    # Exactly 3 asserts (unit mini-tests)
    assert find_rotation([[1,2],[1,3],[5]], 5) == 0
    assert find_rotation([[3,1],[2,4]], 4) == 1
    assert find_rotation([[2,2],[2]], 3) == -1
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover a trivial valid case, a small non-trivial rotation, and an impossible strict-prefix case.}
\RESULT{Outputs any $x \in \{0,\ldots,c-1\}$ that satisfies all constraints; if none exists, outputs $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on helper function with crafted pairs: equal words, prefix violations, $a<b$-only constraints (some rotations forbidden), $a>b$-only constraints (narrow window), and mixed constraints. Property test: if we brute-force check the returned $x$, it must satisfy all pairs.}
\LINE{CROSS-CHECKS}{On small $c$ and short words, compare brute-force (Approach A) and optimal (Approach C) to ensure identical feasibility and agree on validity of the produced rotation.}
\LINE{EDGE-CASE GENERATOR}{Generate random $c \le 20$, $n \le 8$, random words of limited length; verify the chosen rotation by simulating lex order after rotation.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def brute_check(words: List[List[int]], c: int, x: int) -> bool:
    def rot(v): return ((v - 1 + x) % c) + 1
    def leq(a,b):
        m = min(len(a), len(b))
        for i in range(m):
            ra, rb = rot(a[i]), rot(b[i])
            if ra != rb:
                return ra < rb
        return len(a) <= len(b)
    return all(leq(words[i], words[i+1]) for i in range(len(words)-1))

def gen_case(seed: int=0) -> Tuple[int,int,List[List[int]]]:
    random.seed(seed)
    c = random.randint(1, 20)
    n = random.randint(2, 8)
    words: List[List[int]] = []
    for _ in range(n):
        L = random.randint(1, 10)
        w = [random.randint(1, c) for __ in range(L)]
        words.append(w)
    return n, c, words

# Reference Code (reusing optimal finder)
def find_rotation(words: List[List[int]], c: int) -> int:
    n = len(words)
    L, R = 0, c
    ban = [0] * (c + 1)
    def first_diff(a,b):
        m = min(len(a), len(b))
        for i in range(m):
            if a[i] != b[i]:
                return i
        return -1
    for i in range(n - 1):
        a, b = words[i], words[i + 1]
        p = first_diff(a, b)
        if p == -1:
            if len(a) > len(b):
                return -1
            else:
                continue
        A0 = a[p] - 1
        B0 = b[p] - 1
        if A0 > B0:
            l = c - A0
            r = c - B0
            L = max(L, l)
            R = min(R, r)
        else:
            l = c - B0
            r = c - A0
            ban[l] += 1
            ban[r] -= 1
    if L >= R:
        return -1
    cur = 0
    for x in range(c):
        cur += ban[x]
        ban[x] = cur
    for x in range(L, R):
        if ban[x] == 0:
            return x
    return -1

# Cross-check random cases
def self_test():
    for seed in range(50):
        n, c, words = gen_case(seed)
        x = find_rotation(words, c)
        if x != -1:
            assert 0 <= x < c and brute_check(words, c, x)
        else:
            # If brute force finds a rotation, our solver should not miss it
            bf = -1
            for t in range(c):
                if brute_check(words, c, t):
                    bf = t
                    break
            assert bf == -1

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, []
    c = int(next(it))
    words: List[List[int]] = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for __ in range(li)]
        words.append(w)
    return n, c, words

def find_first_diff(a: List[int], b: List[int]) -> int:
    m = min(len(a), len(b))
    for i in range(m):
        if a[i] != b[i]:
            return i
    return -1

def find_rotation(words: List[List[int]], c: int) -> int:
    n = len(words)
    L, R = 0, c
    ban = [0] * (c + 1)
    for i in range(n - 1):
        a, b = words[i], words[i + 1]
        p = find_first_diff(a, b)
        if p == -1:
            if len(a) > len(b):
                return -1
            else:
                continue
        A0 = a[p] - 1
        B0 = b[p] - 1
        if A0 > B0:
            l = c - A0
            r = c - B0
            if l > L:
                L = l
            if r < R:
                R = r
        else:
            l = c - B0
            r = c - A0
            ban[l] += 1
            ban[r] -= 1
    if L >= R:
        return -1
    cur = 0
    for x in range(c):
        cur += ban[x]
        ban[x] = cur
    for x in range(L, R):
        if ban[x] == 0:
            return x
    return -1

def solve_all():
    n, c, words = read_input()
    if n == 0:
        return
    ans = find_rotation(words, c)
    print(ans)

def main():
    # quick sanity asserts
    assert find_rotation([[1,2],[1,3],[5]], 5) == 0
    assert find_rotation([[3,1],[2,4]], 4) == 1
    assert find_rotation([[1,2,3],[1,2]], 10) == -1
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce lex-order-after-rotation to interval constraints on the rotation $x$ via first-difference analysis, then pick any feasible $x$.}
\WHY{Captures a common trick: when operations preserve the first-difference index, inequalities often become range constraints. Recognizing and exploiting this yields linear-time solutions.}
\CHECKLIST{
\begin{bullets}
\item Scan adjacent pairs; find first difference or detect prefix.
\item If strict-prefix violation, answer $-1$ immediately.
\item For differing symbols $a,b$ (0-based), compute:
\begin{bullets}
\item If $a>b$: $[c-a,c-b)$ intersect into $[L,R)$.
\item If $a<b$: forbid $[c-b,c-a)$.
\end{bullets}
\item If $L \ge R$, infeasible.
\item Build forbidden coverage; choose any $x \in [L,R)$ with zero coverage.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $c=1$ (only rotation $x=0$ possible).
\item Equal words adjacent.
\item First is a strict longer prefix of second (impossible).
\item Multiple required intervals that pinch to empty.
\item All constraints $a<b$ forbid the entire $[L,R)$.
\item Very large $c$ near $10^6$ (ensure memory fits).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in converting to 0-based and back.
\item Mishandling half-open intervals $[L,R)$ endpoints.
\item Forgetting to apply difference-array prefix sum before scanning.
\item Not checking the prefix-violation case when no first difference exists.
\item Using $>$ instead of $\ge$ in emptiness check $L \ge R$.
\item Building forbidden intervals that wrap — here they never wrap; ensure $l<r$ holds.
\end{bullets}}
\FAILMODES{Brute force times out for large $c$. Incorrect interval logic can incorrectly allow wrapped segments when $a<b$; our derivation shows $[c-b,c-a)$ is a single contiguous forbidden interval, never wrapping.}
\ELI{Look at where two neighboring words first differ. If the first has a bigger symbol there, we must rotate enough so that the bigger one wraps but the smaller does not — that gives a window. If the first has a smaller symbol, avoid those rotations where the order flips — that gives a banned window. Intersect all must-have windows and avoid all banned ones; pick any surviving rotation.}
\NotePages{3}

\end{document}