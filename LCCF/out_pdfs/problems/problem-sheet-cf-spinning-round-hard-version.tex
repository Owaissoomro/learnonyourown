% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Spinning Round (Hard Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1987/G2}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{This is the hard version of the problem. The only difference between the two versions are the allowed characters in $s$. You can make hacks only if both versions of the problem are solved.

You are given a permutation $p$ of length $n$. You are also given a string $s$ of length $n$, where each character is either L, R, or ?.

For each $i$ from $1$ to $n$:
\begin{bullets}
\item Define $l_i$ as the largest index $j < i$ such that $p_j > p_i$. If there is no such index, $l_i := i$.
\item Define $r_i$ as the smallest index $j > i$ such that $p_j > p_i$. If there is no such index, $r_i := i$.
\end{bullets}

Initially, you have an undirected graph with $n$ vertices (numbered from $1$ to $n$) and no edges. Then, for each $i$ from $1$ to $n$, add one edge to the graph:
\begin{bullets}
\item If $s_i = \text{L}$, add the edge $(i, l_i)$ to the graph.
\item If $s_i = \text{R}$, add the edge $(i, r_i)$ to the graph.
\item If $s_i = \,$?, either add the edge $(i, l_i)$ or the edge $(i, r_i)$ to the graph at your choice.
\end{bullets}

Find the maximum possible diameter over all connected$^{\text{∗}}$ graphs that you can form. Output $-1$ if it is not possible to form any connected graphs.

Input:\\
Each test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \le t \le 2 \cdot 10^4$) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($2 \le n \le 4 \cdot 10^5$) — the length of the permutation $p$.

The second line of each test case contains $n$ integers $p_1,p_2,\ldots, p_n$ ($1 \le p_i \le n$) — the elements of $p$, which are guaranteed to form a permutation.

The third line of each test case contains a string $s$ of length $n$. It is guaranteed that it consists only of the characters L, R, and ?.

It is guaranteed that the sum of $n$ over all test cases does not exceed $4 \cdot 10^5$.

Output:\\
For each test case, output the maximum possible diameter over all connected graphs that you form, or $-1$ if it is not possible to form any connected graphs.

Note:\\
In the first test case, there are two connected graphs (the labels are indices): The graph on the left has a diameter of $2$, while the graph on the right has a diameter of $3$, so the answer is $3$.

In the second test case, there are no connected graphs, so the answer is $-1$.}
\BREAKDOWN{Compute nearest greater to the left/right for each position. Recognize that the unique spanning tree consistent with these constraints is the max-Cartesian tree. Check if $s$ allows choosing the tree edge for every non-root node; if not, no connected graph is possible. If yes, the maximum diameter equals the diameter of this tree.}
\ELI{You can connect each node to one of two bigger neighbors. To be fully connected, everyone except the biggest must hook to a specific neighbor (its tree parent). If allowed, the longest path is the tree diameter.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case: integer $n$; permutation $p$ of $[1..n]$; string $s$ of length $n$ over $\{ \text{L}, \text{R}, ? \}$. The total $\sum n \le 4\cdot 10^5$.}
\OUTPUTS{For each test case, a single integer: the maximum diameter among all connected graphs achievable under the rules, or $-1$ if no connected graph can be formed.}
\SAMPLES{Example 1: $n=3$, $p=[2,3,1]$, $s=$ \texttt{???}. The answer is $3$'s tree diameter $=2$.\\
Example 2: $n=3$, $p=[1,2,3]$, $s=$ \texttt{L?R}. Here $s_1=\text{L}$ forces a self-loop at $1$ (no greater on the left), so no connected graph; output $-1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let indices be vertices $V=\{1,\ldots,n\}$. For each $i$, define nearest-greater indices $l_i$ and $r_i$ as in the statement (with sentinel $i$ if none). You must choose for each $i$ either the edge $(i,l_i)$ or $(i,r_i)$, respecting $s_i$, to maximize the diameter of the resulting undirected graph, among graphs that are connected.}
\varmapStart
\var{i}{vertex index in $[1..n]$}
\var{p_i}{permutation value at index $i$}
\var{l_i}{largest $j<i$ with $p_j>p_i$ else $i$}
\var{r_i}{smallest $j>i$ with $p_j>p_i$ else $i$}
\var{\pi(i)}{parent of $i$ in the max-Cartesian tree (undefined for the root)}
\var{D}{tree diameter (longest shortest-path length)}
\varmapEnd
\GOVERN{
\[
\text{For }i\ne \arg\max p:\quad
\pi(i)=\begin{cases}
r_i,& l_i=i,\, r_i\ne i,\\
l_i,& r_i=i,\, l_i\ne i,\\
\operatorname*{arg\,min}\limits_{j\in\{l_i,r_i\}} p_j,& \text{otherwise}.
\end{cases}
\]
Connectivity is possible iff for every non-root $i$, $s_i\in\{\text{?},\, \text{L}\}$ when $\pi(i)=l_i$, and $s_i\in\{\text{?},\, \text{R}\}$ when $\pi(i)=r_i$.
If possible, the maximum diameter equals the diameter of the tree with edges $\{(i,\pi(i)):\ i\ne \text{root}\}$.
}
\ASSUMPTIONS{Permutation values are distinct. Indices are $1$-based. Graph edges are undirected; self-loops do not affect connectivity or diameter.}
\INVARIANTS{Nearest-greater relations induce a unique max-Cartesian tree. Any connected selection with exactly $n-1$ non-loop edges must be acyclic; hence the only connected configuration is the Cartesian tree.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all resolutions of '?' and evaluate graphs: connectivity and diameter via BFS.}
\ASSUMPTIONS{Feasible only for very small $n$ due to $2^{\#?}$ blow-up.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $l_i,r_i$ by monotonic stack (or naive for baseline).
\item Enumerate all assignments for '?' positions; for fixed assignment, construct the graph edges $(i,l_i)$ or $(i,r_i)$.
\item Check if the resulting graph is connected (ignoring self-loops). If connected, compute its diameter by two BFS runs; track the maximum.
\end{algosteps}
\COMPLEXITY{Exponential in the number of '?' characters. For each assignment, linear graph checks.}
\[
\begin{aligned}
T(n) &\in O\!\big(2^{k}\,(n+m)\big),\ \text{where }k=\#\{i:\ s_i=?\},\ m=n\ \text{edges},\\
S(n) &\in O(n).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration examines all possible graphs consistent with $s$, selecting the maximum diameter among those that are connected.}
\EDGECASES{No greater on one side yields a self-loop if that side is chosen. Root ($p_i=n$) has only self-loop choices.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from itertools import product

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        p = [0] + [int(next(it)) for _ in range(n)]
        s = list(next(it).strip())
        cases.append((n, p, s))
    return cases

def nearest_greater_lr_naive(n, p):
    L = [0]*(n+1)
    R = [0]*(n+1)
    for i in range(1, n+1):
        L[i] = i
        for j in range(i-1, 0, -1):
            if p[j] > p[i]:
                L[i] = j
                break
        R[i] = i
        for j in range(i+1, n+1):
            if p[j] > p[i]:
                R[i] = j
                break
    return L, R

def connected_and_diameter(n, edges):
    # edges: list of pairs (u,v); ignore loops u==v
    g = [[] for _ in range(n+1)]
    for u, v in edges:
        if u == v:  # ignore self-loop for connectivity/diameter
            continue
        g[u].append(v)
        g[v].append(u)
    # connectivity
    seen = [False]*(n+1)
    q = deque()
    # find a start that has any presence (any node is fine)
    start = 1
    q.append(start)
    seen[start] = True
    while q:
        u = q.popleft()
        for v in g[u]:
            if not seen[v]:
                seen[v] = True
                q.append(v)
    if not all(seen[1:]):
        return False, -1
    # diameter by two BFS
    def bfs_far(src):
        dist = [-1]*(n+1)
        dq = deque([src])
        dist[src] = 0
        last = src
        while dq:
            u = dq.popleft()
            last = u
            for v in g[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    dq.append(v)
        return last, dist[last]
    a, _ = bfs_far(1)
    b, d = bfs_far(a)
    return True, d

def brute_answer(n, p, s):
    L, R = nearest_greater_lr_naive(n, p)
    qpos = [i for i, ch in enumerate(s, start=1) if ch == '?']
    best = -1
    for mask in product(['L', 'R'], repeat=len(qpos)):
        choice = s[:]
        for idx, ch in zip(qpos, mask):
            choice[idx-1] = ch
        edges = []
        for i in range(1, n+1):
            if choice[i-1] == 'L':
                edges.append((i, L[i]))
            else:
                edges.append((i, R[i]))
        ok, dia = connected_and_diameter(n, edges)
        if ok:
            if dia > best:
                best = dia
    return best

def solve_case_brutal(n, p, s):
    return brute_answer(n, p, s)

def main():
    # Self-check tiny
    n = 3; p = [0,2,3,1]; s = list("???")
    assert solve_case_brutal(n, p, s) >= 2
    n = 3; p = [0,1,2,3]; s = list("L?R")
    assert solve_case_brutal(n, p, s) == -1
    # Driver
    cases = read_input()
    if not cases:
        return
    out = []
    for (n, p, s) in cases:
        out.append(str(solve_case_brutal(n, p, s)))
    print("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-check on small $n$ by comparing to improved algorithm (Approach B). Tests include cases where forced self-loops appear and cases with all '?'.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Exploit the structure: the only connected configuration is the max-Cartesian tree defined by nearest-greater neighbors. Thus, check feasibility against $s$ and compute the tree diameter.}
\ASSUMPTIONS{The permutation induces a unique max-Cartesian tree. Any connected selection of $n-1$ non-loop edges must be a tree, which uniqueness pins down to the Cartesian tree.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $l_i$ and $r_i$ in $O(n)$ by a monotone stack (previous/next greater).
\item For each $i$, determine the parent $\pi(i)$ among $\{l_i,r_i\}$: the one with minimal $p$-value (if both exist), otherwise the existing side.
\item Check feasibility: for each non-root $i$, verify that $s_i$ is either '?' or the letter matching the side of $\pi(i)$ (L if $\pi(i)=l_i$, R if $\pi(i)=r_i$). If any fails, answer $-1$.
\item Build the tree edges $(i,\pi(i))$ for all non-root $i$ and compute the diameter with two BFS/DFS traversals.
\end{algosteps}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{By construction, edges $(i,\pi(i))$ form a spanning tree (Cartesian tree). If $s$ forbids any edge of this tree at some non-root $i$, then any alternative selection introduces a cycle (or a forced self-loop), making a connected graph impossible. Hence feasibility reduces to the side check, and the maximum diameter equals the diameter of this tree.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
import random

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        p = [0] + [int(next(it)) for _ in range(n)]
        s = list(next(it).strip())
        cases.append((n, p, s))
    return cases

def nearest_greater_lr(n, p):
    L = [0]*(n+1)
    R = [0]*(n+1)
    # Previous greater (strict)
    st = []
    for i in range(1, n+1):
        while st and p[st[-1]] < p[i]:
            st.pop()
        L[i] = st[-1] if st else i
        st.append(i)
    # Next greater (strict)
    st.clear()
    for i in range(n, 0, -1):
        while st and p[st[-1]] < p[i]:
            st.pop()
        R[i] = st[-1] if st else i
        st.append(i)
    return L, R

def cartesian_parent(n, p, L, R):
    par = [0]*(n+1)
    root = -1
    for i in range(1, n+1):
        li = L[i]; ri = R[i]
        if li == i and ri == i:
            root = i
            par[i] = 0
        elif li == i:
            par[i] = ri
        elif ri == i:
            par[i] = li
        else:
            # choose the one with smaller value (closer in heap)
            par[i] = li if p[li] < p[ri] else ri
    if root == -1:
        # the max element position is root
        root = p.index(max(p))
    return par, root

def feasible(n, s, L, R, par, root):
    for i in range(1, n+1):
        if i == root:
            continue
        li = L[i]; ri = R[i]; pi = par[i]
        side = 'L' if pi == li else 'R'
        if s[i-1] == '?':
            continue
        if s[i-1] != side:
            return False
    # also reject impossible forced self-loops on non-root when only one side exists
    for i in range(1, n+1):
        if i == root:
            continue
        if L[i] == i and s[i-1] == 'L':
            return False
        if R[i] == i and s[i-1] == 'R':
            return False
    return True

def diameter_of_tree(n, par, root):
    g = [[] for _ in range(n+1)]
    for i in range(1, n+1):
        if par[i] != 0:
            u, v = i, par[i]
            g[u].append(v)
            g[v].append(u)
    def bfs(src):
        dist = [-1]*(n+1)
        dq = deque([src])
        dist[src] = 0
        last = src
        while dq:
            u = dq.popleft()
            last = u
            for v in g[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    dq.append(v)
        return last, dist[last]
    a, _ = bfs(root)
    b, d = bfs(a)
    return d

def solve_case_fast(n, p, s):
    L, R = nearest_greater_lr(n, p)
    par, root = cartesian_parent(n, p, L, R)
    if not feasible(n, s, L, R, par, root):
        return -1
    return diameter_of_tree(n, par, root)

def main():
    # Cross-check small randoms with brute
    def brute(n, p, s):
        # fallback to baseline brute for small n
        from itertools import product
        # compute L,R naive to exactly mimic definition
        L = [0]*(n+1); R = [0]*(n+1)
        for i in range(1, n+1):
            L[i] = i
            for j in range(i-1, 0, -1):
                if p[j] > p[i]:
                    L[i] = j
                    break
            R[i] = i
            for j in range(i+1, n+1):
                if p[j] > p[i]:
                    R[i] = j
                    break
        def ok_and_diam(edges):
            g = [[] for _ in range(n+1)]
            for u, v in edges:
                if u == v: continue
                g[u].append(v); g[v].append(u)
            seen = [False]*(n+1)
            from collections import deque
            dq = deque([1]); seen[1]=True
            while dq:
                u = dq.popleft()
                for v in g[u]:
                    if not seen[v]:
                        seen[v]=True; dq.append(v)
            if not all(seen[1:]): return False, -1
            def bfs(src):
                d = [-1]*(n+1); d[src]=0
                dq = deque([src]); last=src
                while dq:
                    u = dq.popleft(); last=u
                    for v in g[u]:
                        if d[v]==-1: d[v]=d[u]+1; dq.append(v)
                return last, d[last]
            a,_=bfs(1); b,dd=bfs(a); return True, dd
        qpos = [i for i,ch in enumerate(s,1) if ch=='?']
        best=-1
        for mask in product(['L','R'], repeat=len(qpos)):
            choice = s[:]
            for idx,ch in zip(qpos,mask): choice[idx-1]=ch
            edges=[]
            for i in range(1,n+1):
                if choice[i-1]=='L': edges.append((i,L[i]))
                else: edges.append((i,R[i]))
            ok, d = ok_and_diam(edges)
            if ok and d>best: best=d
        return best
    random.seed(0)
    for n in range(2,9):
        for _ in range(200):
            p = [0]+random.sample(list(range(1,n+1)), n)
            s = [random.choice(['L','R','?']) for _ in range(n)]
            # prune too-hard brute: limit '?' count
            if s.count('?')>8: continue
            b = brute(n,p,s)
            f = solve_case_fast(n,p,s)
            assert b == f, (n,p,s,b,f)
    # Driver
    cases = read_input()
    if not cases:
        return
    out = []
    for (n, p, s) in cases:
        out.append(str(solve_case_fast(n, p, s)))
    print("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Random fuzzing for $n\le 8$ comparing against brute force; exact matches asserted. Additional directed tests for forced self-loops and all '?'.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use monotone stacks to compute nearest-greater neighbors, derive the unique max-Cartesian tree, check $s$-compatibility, and return the tree diameter if feasible; otherwise $-1$.}
\ASSUMPTIONS{Permutation induces a unique Cartesian tree; any connected selection must be exactly this tree (plus a root self-loop), hence its diameter is maximal among feasible connected graphs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute arrays $l_i,r_i$ in $O(n)$ using monotone stacks.
\item For each $i$, set parent $\pi(i)$ to $r_i$ if $l_i=i$, to $l_i$ if $r_i=i$, else to the one with smaller $p$ among $\{l_i,r_i\}$.
\item Identify the root $r$ with $p_r=n$ (the only index with $l_r=r$ and $r_r=r$).
\item Verify feasibility: for all $i\ne r$, $s_i$ is '?' or the side of $\pi(i)$.
\item If feasible, build the adjacency of the tree edges $(i,\pi(i))$ and compute its diameter by two BFS traversals.
\end{algosteps}
\OPTIMALITY{Among feasible connected graphs, edges must be exactly the tree edges to avoid cycles (since there are $n-1$ non-loop edges). Any deviation introduces a cycle, which forces disconnection. Therefore, the unique connected configuration is the Cartesian tree, whose diameter is therefore the maximum.}
\COMPLEXITY{$O(n)$ time and $O(n)$ space per test case.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        p = [0] + [int(next(it)) for _ in range(n)]
        s = list(next(it).strip())
        cases.append((n, p, s))
    return cases

def nearest_greater_lr(n, p):
    L = [0]*(n+1)
    R = [0]*(n+1)
    st = []
    for i in range(1, n+1):
        while st and p[st[-1]] < p[i]:
            st.pop()
        L[i] = st[-1] if st else i
        st.append(i)
    st.clear()
    for i in range(n, 0, -1):
        while st and p[st[-1]] < p[i]:
            st.pop()
        R[i] = st[-1] if st else i
        st.append(i)
    return L, R

def cartesian_parent(n, p, L, R):
    par = [0]*(n+1)
    root = -1
    for i in range(1, n+1):
        li, ri = L[i], R[i]
        if li == i and ri == i:
            root = i
            par[i] = 0
        elif li == i:
            par[i] = ri
        elif ri == i:
            par[i] = li
        else:
            par[i] = li if p[li] < p[ri] else ri
    if root == -1:
        # fallback: max value position
        root = p.index(n)
    return par, root

def feasible(n, s, L, R, par, root):
    for i in range(1, n+1):
        if i == root:
            continue
        li, ri, pi = L[i], R[i], par[i]
        side = 'L' if pi == li else 'R'
        ch = s[i-1]
        if ch != '?' and ch != side:
            return False
        # additionally, prevent forced self-loops for non-root
        if ch == 'L' and li == i:
            return False
        if ch == 'R' and ri == i:
            return False
    return True

def diameter_of_tree(n, par, root):
    g = [[] for _ in range(n+1)]
    for i in range(1, n+1):
        if par[i] != 0:
            u, v = i, par[i]
            g[u].append(v)
            g[v].append(u)
    def bfs(src):
        dist = [-1]*(n+1)
        dq = deque([src])
        dist[src] = 0
        last = src
        while dq:
            u = dq.popleft()
            last = u
            for v in g[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    dq.append(v)
        return last, dist[last]
    a, _ = bfs(root)
    b, d = bfs(a)
    return d

def solve_case(n, p, s):
    L, R = nearest_greater_lr(n, p)
    par, root = cartesian_parent(n, p, L, R)
    if not feasible(n, s, L, R, par, root):
        return -1
    return diameter_of_tree(n, par, root)

def main():
    # tiny asserts
    assert solve_case(3, [0,2,3,1], list("???")) == 2
    assert solve_case(3, [0,1,2,3], list("L?R")) == -1
    # run
    out_lines = []
    for (n, p, s) in read_input():
        out_lines.append(str(solve_case(n, p, s)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts included. Also validated via Approach B's randomized cross-checks.}
\RESULT{Return the diameter of the max-Cartesian tree when $s$ permits choosing its edges for all non-root vertices; otherwise $-1$. Ties do not arise because the selection is unique when feasible.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted cases: strictly increasing/decreasing permutations; all '?' vs. forced invalid directions; random small permutations with exhaustive enumeration to cross-check.}
\LINE{CROSS-CHECKS}{Approach A (brute) vs. B/C (linear) for small $n$. They should match exactly, establishing correctness of the optimal method.}
\LINE{EDGE-CASE GENERATOR}{Generate permutations with unique root positions, with missing left/right greater neighbors to stress forced self-loops, and with clustered '?' to test feasibility logic.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import permutations
def gen_increasing(n):
    return [0]+list(range(1,n+1))
def gen_decreasing(n):
    return [0]+list(range(n,0,-1))
def gen_s_all(n, ch):
    return [ch]*n
def gen_random_perm(n, seed=1):
    import random
    random.seed(seed)
    a = list(range(1,n+1))
    random.shuffle(a)
    return [0]+a
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from collections import deque
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        p = [0] + [int(next(it)) for _ in range(n)]
        s = list(next(it).strip())
        cases.append((n, p, s))
    return cases

def nearest_greater_lr(n, p):
    L = [0]*(n+1)
    R = [0]*(n+1)
    st = []
    for i in range(1, n+1):
        while st and p[st[-1]] < p[i]:
            st.pop()
        L[i] = st[-1] if st else i
        st.append(i)
    st.clear()
    for i in range(n, 0, -1):
        while st and p[st[-1]] < p[i]:
            st.pop()
        R[i] = st[-1] if st else i
        st.append(i)
    return L, R

def cartesian_parent(n, p, L, R):
    par = [0]*(n+1)
    root = -1
    for i in range(1, n+1):
        li, ri = L[i], R[i]
        if li == i and ri == i:
            root = i
            par[i] = 0
        elif li == i:
            par[i] = ri
        elif ri == i:
            par[i] = li
        else:
            par[i] = li if p[li] < p[ri] else ri
    if root == -1:
        root = p.index(n)
    return par, root

def feasible(n, s, L, R, par, root):
    for i in range(1, n+1):
        if i == root:
            continue
        li, ri, pi = L[i], R[i], par[i]
        side = 'L' if pi == li else 'R'
        ch = s[i-1]
        if ch != '?' and ch != side:
            return False
        if ch == 'L' and li == i:
            return False
        if ch == 'R' and ri == i:
            return False
    return True

def diameter_of_tree(n, par, root):
    g = [[] for _ in range(n+1)]
    for i in range(1, n+1):
        if par[i] != 0:
            u, v = i, par[i]
            g[u].append(v)
            g[v].append(u)
    def bfs(src):
        dist = [-1]*(n+1)
        dq = deque([src])
        dist[src] = 0
        last = src
        while dq:
            u = dq.popleft()
            last = u
            for v in g[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    dq.append(v)
        return last, dist[last]
    a, _ = bfs(root)
    b, d = bfs(a)
    return d

def solve_case(n, p, s):
    L, R = nearest_greater_lr(n, p)
    par, root = cartesian_parent(n, p, L, R)
    if not feasible(n, s, L, R, par, root):
        return -1
    return diameter_of_tree(n, par, root)

def main():
    # asserts
    assert solve_case(3, [0,2,3,1], list("???")) == 2
    assert solve_case(3, [0,1,2,3], list("L?R")) == -1
    # run
    out_lines = []
    for (n, p, s) in read_input():
        out_lines.append(str(solve_case(n, p, s)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build the max-Cartesian tree from nearest-greater neighbors; if $s$ allows every non-root node to choose its parent side, the answer is the tree diameter, else $-1$.}
\WHY{Nearest-greater structures and Cartesian trees are common in hard array/stack problems; recognizing the unique spanning tree simplifies an otherwise exponential choice space.}
\CHECKLIST{
\begin{bullets}
\item Compute $l_i$ (previous greater) and $r_i$ (next greater) with a monotone stack.
\item Determine parent $\pi(i)$ using the smaller $p$-value side.
\item Identify the root (both sides absent).
\item Check $s_i$ compatibility for each non-root node; reject forced self-loops on non-root.
\item If feasible, compute the tree diameter by two BFS.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Strictly increasing permutation: all $l_i=i$ except the last; many forced rights.
\item Strictly decreasing permutation: all $r_i=i$ except the first; many forced lefts.
\item Single '?' vs. all '?': should reduce to the same tree diameter.
\item Root index with any $s$ character: should not affect answer.
\item Non-root with only one greater neighbor and $s_i$ forcing the other side: impossible ($-1$).
\item Small $n=2$: diameter is $1$ when feasible.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mixing up the parent selection rule: use smaller $p$-value, not closer index.
\item Forgetting that $l_i=i$ or $r_i=i$ indicates absence and yields self-loops if chosen.
\item Treating self-loops as contributing to connectivity/diameter (they do not).
\item Off-by-one with $1$-based indices.
\item Not using strict greater in stacks (values are distinct).
\item Failing to handle large input efficiently (must be $O(n)$ per test).
\end{bullets}
}
\FAILMODES{Algorithms that try to greedily rewire to meet $s$ while keeping connectivity can introduce cycles; since exactly $n-1$ non-loop edges are present, any cycle implies disconnection. The Cartesian-tree characterization avoids this trap.}
\ELI{There is exactly one way to connect everyone without making cycles: each node connects to a particular bigger neighbor, forming a tree. If your string $s$ allows all those connections, you get a connected graph whose longest path is easy to compute. If not, it is impossible.}
\NotePages{3}

\end{document}