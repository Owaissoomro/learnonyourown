% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Shortest Common Supersequence}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/shortest-common-supersequence/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given two strings \texttt{str1} and \texttt{str2}, return the shortest string that has both \texttt{str1} and \texttt{str2} as subsequences. If there are multiple valid strings, return any of them.

A string \texttt{s} is a subsequence of string \texttt{t} if deleting some number of characters from \texttt{t} (possibly $0$) results in the string \texttt{s}.

Example 1:

Input: \texttt{str1 = "abac"}, \texttt{str2 = "cab"}

Output: \texttt{"cabac"}

Explanation:
\texttt{str1 = "abac"} is a subsequence of \texttt{"cabac"} because we can delete the first \texttt{"c"}.
\texttt{str2 = "cab"} is a subsequence of \texttt{"cabac"} because we can delete the last \texttt{"ac"}.
The answer provided is the shortest such string that satisfies these properties.

Example 2:

Input: \texttt{str1 = "aaaaaaaa"}, \texttt{str2 = "aaaaaaaa"}

Output: \texttt{"aaaaaaaa"}

Constraints:
\begin{bullets}
\item $1 \le \texttt{str1}.\texttt{length},~\texttt{str2}.\texttt{length} \le 1000$.
\item \texttt{str1} and \texttt{str2} consist of lowercase English letters.
\end{bullets}}
\BREAKDOWN{We need a supersequence that embeds both inputs as subsequences while being as short as possible. This is tightly connected to the longest common subsequence (LCS): the SCS length equals $|s_1|+|s_2|-\text{LCS}(s_1,s_2)$. We must also reconstruct one valid shortest supersequence.}
\ELI{Align the two strings; whenever they match, take the shared character once, otherwise take the next character from the side that keeps the remaining result shortest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two strings \texttt{str1}, \texttt{str2} with $1 \le |\texttt{str1}|,|\texttt{str2}| \le 1000$, characters in \texttt{a..z}.}
\OUTPUTS{Return a string that is a shortest common supersequence (SCS) of \texttt{str1} and \texttt{str2}. Any one shortest answer is acceptable.}
\SAMPLES{
Example A:
\begin{bullets}
\item Input: \texttt{str1="abac"}, \texttt{str2="cab"}
\item One valid output: \texttt{"cabac"}
\end{bullets}
Example B:
\begin{bullets}
\item Input: \texttt{str1="aaaaaaaa"}, \texttt{str2="aaaaaaaa"}
\item Output: \texttt{"aaaaaaaa"}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given strings $s_1, s_2$, find a string $w$ of minimum length such that $s_1 \preceq w$ and $s_2 \preceq w$, where $\preceq$ denotes the subsequence relation.}
\varmapStart
\var{s_1,s_2}{input strings over alphabet $\Sigma=\{a,\ldots,z\}$}
\var{n,m}{lengths $|s_1|=n$, $|s_2|=m$}
\var{L}{LCS length of $(s_1,s_2)$}
\var{\text{SCS}}{a shortest common supersequence}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\min_{w \in \Sigma^\ast}\quad & |w| \\
\text{s.t.}\quad & s_1 \preceq w,\quad s_2 \preceq w \\
\text{Fact:}\quad & |\text{SCS}| = n + m - L,\quad L = \text{LCS}(s_1,s_2).
\end{aligned}
\]
}
\ASSUMPTIONS{Standard indexing from $0$. Any shortest solution is acceptable; uniqueness is not required.}
\INVARIANTS{
\begin{bullets}
\item Along optimal reconstruction, when $s_1[i]=s_2[j]$, taking that character once preserves optimality.
\item If $s_1[i]\ne s_2[j]$, choosing the branch with smaller remaining SCS length preserves minimality.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct recursive definition of SCS: for positions $(i,j)$, try appending $s_1[i]$ or $s_2[j]$ and take the shorter result; base cases when one string is exhausted.}
\ASSUMPTIONS{No memoization; exponential time. Suitable only for tiny inputs; used for sanity checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $i=n$, return $s_2[j:]$; if $j=m$, return $s_1[i:]$.
\item If $s_1[i]=s_2[j]$, return $s_1[i]$ plus recurse on $(i+1,j+1)$.
\item Else compute $a=s_1[i]+\text{SCS}(i+1,j)$ and $b=s_2[j]+\text{SCS}(i,j+1)$; return the shorter (break ties deterministically).
\end{algosteps}
\COMPLEXITY{Exponential in worst case without memoization; space proportional to recursion depth $O(n+m)$.}
\[
\begin{aligned}
T(n,m) &= T(n-1,m) + T(n,m-1) + O(1) \\
       &= \Theta\!\big(2^{n+m}\big)\ \text{in the worst case.}
\end{aligned}
\]
\CORRECTNESS{By structural recursion on $(i,j)$ matching the optimal substructure of SCS.}
\EDGECASES{All characters equal; no characters equal; one string empty (handled by base cases).}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode: 1092. Shortest Common Supersequence
# Baseline exponential recursion (no memoization) -- for tiny tests only.
from typing import *

class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n, m = len(str1), len(str2)

        def scs(i: int, j: int) -> str:
            if i == n:
                return str2[j:]
            if j == m:
                return str1[i:]
            if str1[i] == str2[j]:
                return str1[i] + scs(i + 1, j + 1)
            # Explore both options and pick the shorter; tie-break by taking from str1
            a = str1[i] + scs(i + 1, j)
            b = str2[j] + scs(i, j + 1)
            if len(a) <= len(b):
                return a
            else:
                return b

        return scs(0, 0)

# Tiny sanity tests (keep inputs very small to avoid explosion)
def _is_subseq(x: str, y: str) -> bool:
    it = iter(y)
    return all(ch in it and ch == next(filter(lambda c: True, it), None) for ch in x)  # won't work reliably

# Replace the above with a simple deterministic check:
def _is_subseq(x: str, y: str) -> bool:
    j = 0
    for c in y:
        if j < len(x) and x[j] == c:
            j += 1
    return j == len(x)

S = Solution()
ans = S.shortestCommonSupersequence("a", "b")
assert _is_subseq("a", ans) and _is_subseq("b", ans) and len(ans) == 2

ans = S.shortestCommonSupersequence("ab", "ac")
assert _is_subseq("ab", ans) and _is_subseq("ac", ans) and len(ans) in (3, 3)

ans = S.shortestCommonSupersequence("ab", "ba")
assert _is_subseq("ab", ans) and _is_subseq("ba", ans) and len(ans) == 3
\end{minted}
\VALIDATION{Used three tiny asserts to confirm subsequence embedding and plausible lengths.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DP on Suffix SCS Length with Reconstruction}
\WHICHFORMULA{Bottom-up DP table for SCS lengths: $dp[i][j]=$ SCS length of $s_1[i:]$ and $s_2[j:]$, then backtrack to build one shortest supersequence.}
\ASSUMPTIONS{Standard $O(nm)$ time and $O(nm)$ space; deterministic tie-breaking.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[n][j]=m-j$ and $dp[i][m]=n-i$.
\item Fill $dp$ backwards: if $s_1[i]=s_2[j]$, set $dp[i][j]=1+dp[i+1][j+1]$; else $1+\min(dp[i+1][j], dp[i][j+1])$.
\item Reconstruct from $(0,0)$: when equal, take the char once; else follow the smaller of the two successors, appending the corresponding character.
\end{algosteps}
\COMPLEXITY{Time $O(nm)$, space $O(nm)$; strictly better than exponential brute force.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm),\quad S(n,m)=\Theta(nm).
\end{aligned}
\]
\CORRECTNESS{By dynamic programming with optimal substructure; reconstruction follows choices that achieve the $dp$ optimum.}
\textbf{Code (Improved)}
\begin{minted}{python}
# LeetCode: 1092. Shortest Common Supersequence
# DP for SCS length + reconstruction.
from typing import *

class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n, m = len(str1), len(str2)
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(n + 1):
            dp[i][m] = n - i
        for j in range(m + 1):
            dp[n][j] = m - j
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                if str1[i] == str2[j]:
                    dp[i][j] = 1 + dp[i + 1][j + 1]
                else:
                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1])

        i = j = 0
        out = []
        while i < n and j < m:
            if str1[i] == str2[j]:
                out.append(str1[i])
                i += 1
                j += 1
            else:
                # choose the path that yields shorter remaining SCS
                if dp[i + 1][j] <= dp[i][j + 1]:
                    out.append(str1[i])
                    i += 1
                else:
                    out.append(str2[j])
                    j += 1
        if i < n:
            out.append(str1[i:])
        if j < m:
            out.append(str2[j:])
        return "".join(out)

def _is_subseq(x: str, y: str) -> bool:
    j = 0
    for c in y:
        if j < len(x) and x[j] == c:
            j += 1
    return j == len(x)

S = Solution()
ans = S.shortestCommonSupersequence("abac", "cab")
assert _is_subseq("abac", ans) and _is_subseq("cab", ans) and len(ans) == 5

ans = S.shortestCommonSupersequence("aaaaaaaa", "aaaaaaaa")
assert ans == "aaaaaaaa"

ans = S.shortestCommonSupersequence("ab", "ba")
assert _is_subseq("ab", ans) and _is_subseq("ba", ans) and len(ans) == 3
\end{minted}
\VALIDATION{Checked examples and a crossing case \texttt{"ab"} vs \texttt{"ba"}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{LCS Then Merge}
\WHICHFORMULA{Compute an LCS of the two strings, then merge by walking both strings and the LCS: emit non-LCS characters in order, and emit each LCS character once when reached by both sides.}
\ASSUMPTIONS{Always yields an SCS of length $n+m-L$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build LCS DP table and reconstruct one LCS string $c$.
\item Walk pointers $i,j$ on $s_1,s_2$ and $k$ on $c$:
\begin{bullets}
\item While $i<n$ and $s_1[i]\ne c[k]$, emit $s_1[i]$, advance $i$.
\item While $j<m$ and $s_2[j]\ne c[k]$, emit $s_2[j]$, advance $j$.
\item Emit $c[k]$, advance all $i,j,k$ by one.
\end{bullets}
\item After LCS consumed, append remaining suffixes of $s_1$ and $s_2$.
\end{algosteps}
\OPTIMALITY{By classic identity $|\text{SCS}|=n+m-|\text{LCS}|$ and construction that keeps only one copy of each matched LCS character.}
\COMPLEXITY{Time $O(nm)$ to compute LCS and $O(n+m)$ to merge; space $O(nm)$ for LCS table (can be reduced with Hirschberg if needed).}
\[
\begin{aligned}
T(n,m) &= \Theta(nm),\quad S(n,m)=\Theta(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# LeetCode: 1092. Shortest Common Supersequence
# LCS then merge into SCS (final reference approach).
from typing import *

class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n, m = len(str1), len(str2)
        # LCS DP
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                if str1[i] == str2[j]:
                    dp[i][j] = 1 + dp[i + 1][j + 1]
                else:
                    dp[i][j] = dp[i + 1][j] if dp[i + 1][j] >= dp[i][j + 1] else dp[i][j + 1]
        # Reconstruct one LCS
        i = j = 0
        lcs_chars: List[str] = []
        while i < n and j < m:
            if str1[i] == str2[j]:
                lcs_chars.append(str1[i])
                i += 1
                j += 1
            elif dp[i + 1][j] >= dp[i][j + 1]:
                i += 1
            else:
                j += 1
        # Merge into SCS using LCS
        i = j = k = 0
        out: List[str] = []
        while k < len(lcs_chars):
            c = lcs_chars[k]
            while i < n and str1[i] != c:
                out.append(str1[i]); i += 1
            while j < m and str2[j] != c:
                out.append(str2[j]); j += 1
            out.append(c); i += 1; j += 1; k += 1
        if i < n: out.append(str1[i:])
        if j < m: out.append(str2[j:])
        return "".join(out)

def _is_subseq(x: str, y: str) -> bool:
    j = 0
    for c in y:
        if j < len(x) and x[j] == c:
            j += 1
    return j == len(x)

S = Solution()
# 1) Given example
ans = S.shortestCommonSupersequence("abac", "cab")
assert _is_subseq("abac", ans) and _is_subseq("cab", ans) and len(ans) == 5
# 2) Identical strings
assert S.shortestCommonSupersequence("aaaaaaaa", "aaaaaaaa") == "aaaaaaaa"
# 3) Disjoint characters
ans = S.shortestCommonSupersequence("abc", "def")
assert _is_subseq("abc", ans) and _is_subseq("def", ans) and len(ans) == 6
\end{minted}
\VALIDATION{Three asserts: examples, identical strings, and disjoint alphabets ensuring length $n+m$.}
\RESULT{Returns any shortest common supersequence. Ties are resolved deterministically by the chosen DP backtracking rules.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate subsequence embedding of both inputs; verify minimal length for small strings by brute force; cross-check equivalence of DP variants on random tiny cases.}
\LINE{CROSS-CHECKS}{Compare Approach B (SCS-DP) and Approach C (LCS-merge) results on random small inputs: lengths must match $n+m-\text{LCS}$.}
\LINE{EDGE-CASE GENERATOR}{Covers identical strings, disjoint strings, one contained in the other, alternating overlaps.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import *
import random

def brute_scs(a: str, b: str) -> str:
    # Exponential brute force with memoization to keep it manageable for small sizes
    from functools import lru_cache
    @lru_cache(maxsize=None)
    def scs(i: int, j: int) -> str:
        if i == len(a): return b[j:]
        if j == len(b): return a[i:]
        if a[i] == b[j]: return a[i] + scs(i+1, j+1)
        x = a[i] + scs(i+1, j)
        y = b[j] + scs(i, j+1)
        return x if len(x) <= len(y) else y
    return scs(0, 0)

def is_subseq(x: str, y: str) -> bool:
    j = 0
    for c in y:
        if j < len(x) and x[j] == c: j += 1
    return j == len(x)

def test_random(seed: int = 7, trials: int = 50) -> None:
    random.seed(seed)
    from string import ascii_lowercase
    alph = "abc"
    from typing import List
    # Use Approach C's Solution as the reference implementation
    class Solution:
        def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
            n, m = len(str1), len(str2)
            dp = [[0]*(m+1) for _ in range(n+1)]
            for i in range(n-1, -1, -1):
                for j in range(m-1, -1, -1):
                    if str1[i] == str2[j]:
                        dp[i][j] = 1 + dp[i+1][j+1]
                    else:
                        dp[i][j] = dp[i+1][j] if dp[i+1][j] >= dp[i][j+1] else dp[i][j+1]
            # reconstruct LCS
            i = j = 0
            lcs: List[str] = []
            while i < n and j < m:
                if str1[i] == str2[j]:
                    lcs.append(str1[i]); i += 1; j += 1
                elif dp[i+1][j] >= dp[i][j+1]:
                    i += 1
                else:
                    j += 1
            # merge into SCS
            out: List[str] = []
            i = j = k = 0
            while k < len(lcs):
                c = lcs[k]
                while i < n and str1[i] != c: out.append(str1[i]); i += 1
                while j < m and str2[j] != c: out.append(str2[j]); j += 1
                out.append(c); i += 1; j += 1; k += 1
            out.append(str1[i:]); out.append(str2[j:])
            return "".join(out)

    sol = Solution()
    for _ in range(trials):
        n = random.randint(0, 5)
        m = random.randint(0, 5)
        a = "".join(random.choice(alph) for _ in range(n))
        b = "".join(random.choice(alph) for _ in range(m))
        ans = sol.shortestCommonSupersequence(a, b)
        brute = brute_scs(a, b)
        assert is_subseq(a, ans) and is_subseq(b, ans)
        assert len(ans) == len(brute)

test_random()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation for LC 1092 — Shortest Common Supersequence
from typing import *
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n, m = len(str1), len(str2)
        # Compute LCS length table
        dp = [[0]*(m+1) for _ in range(n+1)]
        for i in range(n-1, -1, -1):
            for j in range(m-1, -1, -1):
                if str1[i] == str2[j]:
                    dp[i][j] = 1 + dp[i+1][j+1]
                else:
                    dp[i][j] = dp[i+1][j] if dp[i+1][j] >= dp[i][j+1] else dp[i][j+1]
        # Reconstruct one SCS directly while walking by LCS decisions
        i = j = 0
        out: List[str] = []
        while i < n and j < m:
            if str1[i] == str2[j]:
                out.append(str1[i])
                i += 1; j += 1
            else:
                # Prefer moving towards a cell with same LCS length as dp[i][j]
                if dp[i+1][j] >= dp[i][j+1]:
                    out.append(str1[i]); i += 1
                else:
                    out.append(str2[j]); j += 1
        if i < n: out.append(str1[i:])
        if j < m: out.append(str2[j:])
        return "".join(out)

# Basic asserts
def _is_subseq(x: str, y: str) -> bool:
    j = 0
    for c in y:
        if j < len(x) and x[j] == c:
            j += 1
    return j == len(x)

S = Solution()
a, b = "abac", "cab"
res = S.shortestCommonSupersequence(a, b)
assert _is_subseq(a, res) and _is_subseq(b, res) and len(res) == 5
assert S.shortestCommonSupersequence("aaaaaaaa", "aaaaaaaa") == "aaaaaaaa"
assert len(S.shortestCommonSupersequence("abc", "def")) == 6
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute a shortest common supersequence by leveraging LCS structure and deterministic reconstruction.}
\WHY{Classic DP/lattice-alignment pattern; shows up in string DP interviews and bioinformatics alignments.}
\CHECKLIST{
\begin{bullets}
\item Recall $|\text{SCS}|=n+m-\text{LCS}$.
\item Choose DP state and fill order correctly.
\item Backtrack deterministically; append leftover suffixes.
\item Validate subsequence property for both inputs.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Identical strings $\Rightarrow$ return either string.
\item One string contained in the other.
\item Completely disjoint alphabets.
\item Repeated runs of the same character.
\item Alternating overlaps like \texttt{"abab"} vs \texttt{"baba"}.
\item Very unbalanced lengths.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to append remaining tail after backtracking stops.
\item Using ambiguous tie-breaking that produces non-minimal results if not aligned with $dp$.
\item Off-by-one in DP table borders ($i=n$ or $j=m$).
\item Reconstructing LCS incorrectly, then merging wrong.
\item Concatenating characters inefficiently in a loop without a list buffer.
\item Assuming uniqueness of the answer.
\end{bullets}
}
\FAILMODES{Brute-force enumeration blows up exponentially. Greedy mismatched-character picks without DP guidance can produce non-minimal supersequences.}
\ELI{Find common parts to avoid duplication. Use DP to know whether to take a character from the first string, the second, or a shared one. Append any leftovers at the end.}
\NotePages{3}

\end{document}