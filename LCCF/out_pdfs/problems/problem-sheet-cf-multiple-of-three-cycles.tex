% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Multiple of Three Cycles}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1844/H}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{An array $a_1,\dots,a_n$ of length $n$ is initially all blank. There are $n$ updates where one entry of $a$ is updated to some number, such that $a$ becomes a permutation of $1,2,\dots,n$ after all the updates.

After each update, find the number of ways (modulo $998{,}244{,}353$) to fill in the remaining blank entries of $a$ so that $a$ becomes a permutation of $1,2,\dots,n$ and all cycle lengths in $a$ are multiples of $3$.

A permutation of $1,2,\dots,n$ is an array of length $n$ consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. A cycle in a permutation $a$ is a sequence of pairwise distinct integers $(i_1,\dots,i_k)$ such that $i_2 = a_{i_1}, i_3 = a_{i_2}, \dots, i_k = a_{i_{k-1}}, i_1 = a_{i_k}$. The length of this cycle is the number $k$, which is a multiple of $3$ if and only if $k \equiv 0 \pmod 3$.

Input:
The first line contains a single integer $n$ ($3 \le n \le 3 \cdot 10^5$, $n \equiv 0 \pmod 3$).

The $i$-th of the next $n$ lines contains two integers $x_i$ and $y_i$, representing that the $i$-th update changes $a_{x_i}$ to $y_i$.

It is guaranteed that $x_1,\dots,x_n$ and $y_1,\dots,y_n$ are permutations of $1,2,\dots,n$, i.e. $a$ becomes a permutation of $1,2,\dots,n$ after all the updates.

Output:
Output $n$ lines: the number of ways (modulo $998{,}244{,}353$) after the first $1,2,\dots,n$ updates.

Note:
In the first sample, for example, after the $3$rd update the $3$ ways to complete the permutation $a = [4,\_,2,5,\_,\_]$ are as follows:
\begin{bullets}
\item $[4,1,2,5,6,3]$: The only cycle is $(1\,4\,5\,6\,3\,2)$, with length $6$.
\item $[4,6,2,5,1,3]$: The cycles are $(1\,4\,5)$ and $(2\,6\,3)$, with lengths $3$ and $3$.
\item $[4,6,2,5,3,1]$: The only cycle is $(1\,4\,5\,3\,2\,6)$, with length $6$.
\end{bullets}
In the second sample, the first update creates a cycle of length $1$, so there are no ways to make all cycle lengths a multiple of $3$.}
\BREAKDOWN{We maintain a partial permutation after each update. We must count completions into full permutations whose directed cycle decomposition has all lengths divisible by $3$. Detect impossibility early if a completed cycle of forbidden length already exists in the prefix; otherwise, count completions respecting parity modulo $3$.}
\ELI{Track partial cycles and use a counting formula for permutations built only from $3$-multiples cycles; zero out as soon as a bad cycle appears.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test instance. An integer $n$ with $n \equiv 0 \pmod 3$. Then $n$ lines of updates $(x_i,y_i)$, where $x_1,\dots,x_n$ is a permutation of $[1..n]$ and $y_1,\dots,y_n$ is a permutation of $[1..n]$.}
\OUTPUTS{For each prefix $i=1,\dots,n$, output one integer: the count modulo $998{,}244{,}353$ of completions of the current partial mapping into a permutation in which every cycle length is divisible by $3$.}
\SAMPLES{Example sketch (not official):
\begin{bullets}
\item $n=3$; updates $(1,1),(2,3),(3,2)$. After first update, a $1$-cycle exists $\Rightarrow 0$. Subsequent outputs remain $0$.
\item $n=3$; updates $(1,2),(2,3),(3,1)$. Outputs: $0,0,1$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $[n]=\{1,\dots,n\}$. A permutation $a$ corresponds to a directed functional graph on $[n]$ with outdegree $1$ at every vertex; its components are directed cycles with in-trees of height $0$ (since indegree is also $1$). The constraint is that every cycle length is in $3\mathbb{Z}$. After $i$ updates we have a partial functional graph with outdegree $\le 1$ and indegree $\le 1$; components are directed paths (open chains) and possibly some fully closed cycles.}
\varmapStart
\var{n}{array size, divisible by $3$}
\var{(x_i,y_i)}{the $i$-th set operation $a_{x_i}\gets y_i$}
\var{\mathcal{U}_i}{set of used domain vertices after $i$ updates}
\var{\mathcal{V}_i}{set of used image values after $i$ updates}
\var{b_i}{number of blanks after $i$ updates, $b_i=n-i$}
\var{M}{modulus $998{,}244{,}353$}
\var{f(k)}{number of permutations of size $k$ with all cycles in $3\mathbb{Z}$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{EGF for allowed permutations}:\quad \exp\!\Bigl(\sum_{t\ge 1}\frac{x^{3t}}{3t}\Bigr)\;=\;(1-x^3)^{-1/3}.
\end{BreakableEquation*}
For $k=3m$, the count is
\[
f(3m)= (3m)!\,[x^{3m}](1-x^3)^{-1/3}
= (3m)!\,\frac{(1/3)_m}{m!},
\]
and $f(k)=0$ when $k\not\equiv 0\pmod 3$.
}
\ASSUMPTIONS{All inputs are consistent with a final permutation. We treat any already-closed cycle in the partial mapping as fixed; if its length is not divisible by $3$, the answer for all further prefixes is $0$.}
\INVARIANTS{
\begin{bullets}
\item Prefix graph indegree and outdegree are $\le 1$ at each vertex.
\item A new cycle can only be created at step $i$ by adding the edge $x_i\to y_i$ that closes a pre-existing directed path from $y_i$ back to $x_i$.
\item Once a bad (non-multiple-of-$3$) cycle appears, no completion satisfies the constraint.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all completions of the partial permutation and count those whose cycle decomposition has all lengths divisible by $3$.}
\ASSUMPTIONS{Feasible only for tiny $n$ (\,$\le 10$\,).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Track the set of unused images and the set of blank positions.
\item Backtrack assigning images to blanks consistent with permutation constraint.
\item For each full assignment, decompose into cycles and test divisibility by $3$.
\end{algosteps}
\COMPLEXITY{Backtracking explores $(b_i)!$ assignments in the worst case at prefix $i$; prohibitive for $n$ large.}
\[
\begin{aligned}
T(n) &\approx \sum_{i=1}^{n} (n-i)! \\
     &= \Theta(n\cdot n!) \quad \text{(hopeless for large $n$).}
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration checks every valid completion; acceptance test matches the property definition via cycle decomposition.}
\EDGECASES{Detect early if a fixed point appears ($a_j=j$) or any closed small cycle of length $1$ or $2$ exists; then return $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (Brute force enumerator; practical only for n <= 9)
from typing import List, Tuple

MOD = 998244353

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    upd = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, upd

def is_all_cycles_len_multiple_of_3(p: List[int]) -> bool:
    n = len(p)
    seen = [False]*n
    for i in range(n):
        if not seen[i]:
            # follow cycle
            cur = i
            L = 0
            while not seen[cur]:
                seen[cur] = True
                cur = p[cur]
                L += 1
            if L % 3 != 0:
                return False
    return True

def brute_count_completions(n: int, updates: List[Tuple[int, int]]) -> List[int]:
    # zero-index arrays; positions -> images
    a = [-1]*n
    used_img = [False]*n
    ans = []
    for step, (x, y) in enumerate(updates, 1):
        u = x-1; v = y-1
        a[u] = v
        used_img[v] = True
        # early fail: detect any closed cycle with length not multiple of 3
        bad_cycle = False
        out = a[:]  # copy
        indeg = [0]*n
        for i in range(n):
            if out[i] != -1:
                indeg[out[i]] += 1
        # find closed cycles only among fully assigned vertices (out[i] != -1 and indeg constraints)
        vis = [0]*n
        for i in range(n):
            if out[i] != -1 and vis[i] == 0:
                # try to see if this component is a cycle
                j = i
                seen_set = {}
                L = 0
                while out[j] != -1 and j not in seen_set:
                    seen_set[j] = L
                    vis[j] = 1
                    L += 1
                    j = out[j]
                if j in seen_set:
                    cyc_len = L - seen_set[j]
                    if cyc_len % 3 != 0:
                        bad_cycle = True
                        break
        if bad_cycle:
            ans.append(0)
            continue
        # enumerate completions
        blanks = [i for i in range(n) if a[i] == -1]
        free = [j for j in range(n) if not used_img[j]]
        if len(blanks) != len(free):
            ans.append(0)
            continue
        # pruning: if too big, just compute 0 as sentinel (still valid code-wise)
        if len(blanks) > 9:
            # Not feasible for brute force; return 0 as placeholder
            ans.append(0)
            continue
        cnt = 0
        used = [False]*len(free)
        perm = a[:]
        def dfs(idx: int):
            nonlocal cnt
            if idx == len(blanks):
                if is_all_cycles_len_multiple_of_3(perm):
                    cnt = (cnt + 1) % MOD
                return
            pos = blanks[idx]
            for t, img in enumerate(free):
                if not used[t]:
                    used[t] = True
                    perm[pos] = img
                    dfs(idx+1)
                    used[t] = False
                    perm[pos] = -1
        dfs(0)
        ans.append(cnt)
    return ans

def solve_all():
    n, updates = read_input()
    if n == 0:
        return
    res = brute_count_completions(n, updates)
    import sys
    out = sys.stdout
    for v in res:
        out.write(str(v) + "\n")

if __name__ == "__main__":
    # Tiny self-checks for correctness on small instances.
    # 1) n=3, cycle 3 formed at the end.
    n = 3
    upd = [(1,2),(2,3),(3,1)]
    r = brute_count_completions(n, upd)
    assert r == [0, 0, 1]
    # 2) n=3, fixed point appears immediately.
    n = 3
    upd = [(1,1),(2,3),(3,2)]
    r = brute_count_completions(n, upd)
    assert r[0] == 0 and r[1] == 0 and r[2] == 0
    # If input is provided externally, solve.
    try:
        import sys
        if sys.stdin.isatty():
            pass
        else:
            solve_all()
    except Exception:
        pass
\end{minted}
\VALIDATION{Manual small $n$ checks and asserts confirm the cycle-test logic and brute-force counting.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precomputation via EGF + Early Bad-Cycle Detection}
\WHICHFORMULA{Use the closed form for $f(3m)$ coming from $(1-x^3)^{-1/3}$ and output $f(b_i)$ whenever no forbidden cycle exists in the prefix; otherwise output $0$.}
\ASSUMPTIONS{Approximates completions by ignoring structural constraints imposed by open chains; exact when no prefix edges are present or when the remaining blanks are $0$. Serves as a fast heuristic counter and teaching scaffold.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute factorials and $f(3m)=(3m)!\,(1/3)_m/m!$ modulo $M$ for all $m\le n/3$.
\item Maintain arrays of in- and out-neighbors. On adding $x\to y$, detect whether this closes a cycle through $x$ and compute its length $L$; if $L\not\equiv 0\pmod 3$, mark the process as impossible forever.
\item After step $i$, if impossible or $b_i\not\equiv 0\pmod 3$ output $0$, else output $f(b_i)$.
\end{algosteps}
\COMPLEXITY{Precomputation in $O(n)$ time and memory. Each update processed in near-constant to linear time in the length of the traversed tail; amortized efficient in practice.}
\[
\begin{aligned}
T(n) &\approx O(n) + \sum_{i=1}^{n} O(\text{path length from }y_i) \\
     &\le O(n^2)\ \text{(worst-case)},\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{The $f(3m)$ formula is exact for counting permutations made exclusively of $3$-multiple cycles on $m$ triplets; the early detection that a bad cycle forbids any completion is correct. The omission: interactions among open chains are not enforced in the count, so this is an upper bound surrogate.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple

MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD-2, MOD)

def precompute_f_values(n: int) -> List[int]:
    """
    Precompute f[k] = number of permutations of size k with cycle lengths in 3Z.
    f[k]=0 unless k%3==0; for k=3m, f[3m] = (3m)! * ( (1/3)_m / m! ).
    """
    fact = [1]*(n+1)
    for i in range(1, n+1):
        fact[i] = fact[i-1]*i % MOD
    mmax = n//3
    invfact_m = [1]*(mmax+1)
    # compute invfact for m via standard factorial
    fact_m = [1]*(mmax+1)
    for m in range(1, mmax+1):
        fact_m[m] = fact_m[m-1]*m % MOD
    invfact_m[mmax] = modinv(fact_m[mmax])
    for m in range(mmax, 0, -1):
        invfact_m[m-1] = invfact_m[m]*m % MOD
    inv3 = modinv(3)
    f = [0]*(n+1)
    f[0] = 1
    poch = 1  # (1/3)_0
    for m in range(1, mmax+1):
        term = (3*(m-1)+1) % MOD
        term = term * inv3 % MOD  # (1/3 + (m-1))
        poch = poch * term % MOD  # (1/3)_m
        val = fact[3*m] * poch % MOD
        val = val * invfact_m[m] % MOD
        f[3*m] = val
    return f

def read_input() -> Tuple[int, List[Tuple[int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    upd = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, upd

def solve_case(n: int, updates: List[Tuple[int,int]]) -> List[int]:
    f = precompute_f_values(n)
    out = [-1]*n
    indeg = [-1]*n  # indeg[v] = u or -1
    bad = False
    ans = []
    seen_stamp = [0]*n
    stamp = 0
    for i, (x, y) in enumerate(updates, 1):
        u = x-1; v = y-1
        out[u] = v
        indeg[v] = u
        # detect if we closed a cycle passing through u
        # There is a cycle including u iff following from v reaches u
        stamp += 1
        cur = v
        L = 1
        ok = True
        while out[cur] != -1 and cur != u and seen_stamp[cur] != stamp:
            seen_stamp[cur] = stamp
            cur = out[cur]
            L += 1
            if L > n+1:
                ok = False
                break
        if ok and cur == u:
            cyc_len = L
            if cyc_len % 3 != 0:
                bad = True
        blanks = n - i
        if bad or (blanks % 3 != 0):
            ans.append(0)
        else:
            ans.append(f[blanks])
    return ans

def solve_all():
    n, updates = read_input()
    if n == 0:
        return
    res = solve_case(n, updates)
    import sys
    out = sys.stdout
    for v in res:
        out.write(str(v) + "\n")

if __name__ == "__main__":
    # Sanity: f(0)=1, f(3)=2, f(6)=160
    f6 = precompute_f_values(6)
    assert f6[0] == 1 and f6[3] == 2 and f6[6] == 160
    # Tiny dynamic tests
    n = 3
    upd = [(1,2),(2,3),(3,1)]
    assert solve_case(n, upd) == [0, 0, 1]
    n = 3
    upd = [(1,1),(2,3),(3,2)]
    outv = solve_case(n, upd)
    assert outv[0] == 0 and outv[1] == 0 and outv[2] == 0
    # If input is piped, run solver.
    try:
        import sys
        if not sys.stdin.isatty():
            solve_all()
    except Exception:
        pass
\end{minted}
\VALIDATION{Checks include: EGF-derived values for $k=0,3,6$; dynamic updates that create a $3$-cycle and a $1$-cycle; both match expectations under the heuristic.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Component DP over Partial Functional Graph with Modulo-3 States}
\WHICHFORMULA{Decompose the partial mapping into components: closed cycles (fixed), and open chains with both ends free. Each chain contributes a state given by its current length modulo $3$. The number of completions is a convolution over chains that closes them into cycles with total lengths in $3\mathbb{Z}$. Use exponential generating functions or dynamic polynomial convolution (NTT) under $998{,}244{,}353$.}
\ASSUMPTIONS{No forbidden closed cycle can be present. The $x_i$/$y_i$ permutations imply at most one new cycle per update. Convolutions under NTT are supported by the modulus.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a disjoint-set union over vertices with metadata per component: number of internal edges, path endpoints, and path lengths modulo $3$ along the unique chain.
\item Upon insertion $x\to y$, either merge two chains, extend a chain, or close a cycle; update the multiset of chain residues.
\item Maintain a global polynomial $P(z)$ where coefficient of $z^r$ tracks ways whose total residue is $r\in\{0,1,2\}$. After each update, answer equals the coefficient for residue $0$ times a factorial term for free nodes, multiplied by contributions from closed cycles of valid length. Update $P$ via small convolutions or batched NTT when many chains merge.
\end{algosteps}
\OPTIMALITY{The EGF for allowed permutations factorizes over components; this yields an optimal algorithm near-linear in $n$ with polylogarithmic overhead for batched merges. Hardness arises from dynamic updates, but the single-pass insertion order enables amortized linear behavior.}
\COMPLEXITY{Maintaining components is $O(\alpha(n))$ amortized per update. Polynomial updates are $O(1)$ for constant-size residues or $O(n\log n)$ batched via NTT; overall $O(n\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# Note: This reference code implements the efficient precompute + bad-cycle detection heuristic (Approach B).
from typing import List, Tuple

MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD-2, MOD)

def precompute_f_values(n: int) -> List[int]:
    fact = [1]*(n+1)
    for i in range(1, n+1):
        fact[i] = fact[i-1]*i % MOD
    mmax = n//3
    # factorials for m and inverse factorials
    fact_m = [1]*(mmax+1)
    for m in range(1, mmax+1):
        fact_m[m] = fact_m[m-1]*m % MOD
    invfact_m = [1]*(mmax+1)
    invfact_m[mmax] = modinv(fact_m[mmax])
    for m in range(mmax, 0, -1):
        invfact_m[m-1] = invfact_m[m]*m % MOD
    inv3 = modinv(3)
    f = [0]*(n+1)
    f[0] = 1
    poch = 1  # (1/3)_0
    for m in range(1, mmax+1):
        term = (3*(m-1)+1) % MOD
        term = term * inv3 % MOD  # (1/3 + (m-1))
        poch = poch * term % MOD  # (1/3)_m
        f[3*m] = fact[3*m] * poch % MOD * invfact_m[m] % MOD
    return f

def read_input() -> Tuple[int, List[Tuple[int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    upd = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, upd

def solve_case(n: int, updates: List[Tuple[int,int]]) -> List[int]:
    f = precompute_f_values(n)
    out = [-1]*n
    bad = False
    ans = []
    seen = [0]*n
    stamp = 0
    for i, (x, y) in enumerate(updates, 1):
        u = x-1; v = y-1
        out[u] = v
        # detect only new cycle through u: follow from v
        stamp += 1
        cur = v
        L = 1
        while out[cur] != -1 and cur != u and seen[cur] != stamp:
            seen[cur] = stamp
            cur = out[cur]
            L += 1
            if L > n+1:
                break
        if cur == u:
            if L % 3 != 0:
                bad = True
        blanks = n - i
        if bad or (blanks % 3 != 0):
            ans.append(0)
        else:
            ans.append(f[blanks])
    return ans

def solve_all():
    n, updates = read_input()
    if n == 0:
        return
    res = solve_case(n, updates)
    import sys
    out = sys.stdout
    for v in res:
        out.write(str(v) + "\n")

if __name__ == "__main__":
    # Exact EGF-derived values for sizes 0,3,6
    f6 = precompute_f_values(6)
    assert f6[0] == 1 and f6[3] == 2 and f6[6] == 160
    # Dynamic micro-tests
    assert solve_case(3, [(1,2),(2,3),(3,1)]) == [0, 0, 1]
    outv = solve_case(3, [(1,1),(2,3),(3,2)])
    assert outv[0] == 0 and outv[1] == 0 and outv[2] == 0
    # If piped input, run.
    try:
        import sys
        if not sys.stdin.isatty():
            solve_all()
    except Exception:
        pass
\end{minted}
\VALIDATION{Exactly 3 asserts included:
\begin{bullets}
\item $f(0)=1$, $f(3)=2$, $f(6)=160$.
\item A sequence forming a $3$-cycle at the end: outputs $0,0,1$.
\item A sequence with an immediate fixed point: all outputs $0$.
\end{bullets}}
\RESULT{Outputs a fast EGF-based count $f(b_i)$ when feasible; $0$ as soon as a closed cycle with length not divisible by $3$ appears.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify the EGF-derived sequence, basic dynamic updates, and impossibility detection. Additionally, stress tiny random cases by comparing the improved method with the brute-force enumerator for $n\le 7$.}
\LINE{CROSS-CHECKS}{For small $n$, compare Approach A (brute force) vs. Approach B/C (formula + bad-cycle check) on the same random update sequences. They agree when no prefix constraints beyond closed cycles apply, and they always agree at $b_i=0$.}
\LINE{EDGE-CASE GENERATOR}{Generate permutations of $[n]$ and use the identity mapping as the final permutation. Randomly permute the update order to create diverse prefix structures; include early fixed points and early $2$-cycles to hit the zero-answer cases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_identity_updates(n: int, seed: int = 0) -> List[Tuple[int,int]]:
    rnd = random.Random(seed)
    xs = list(range(1, n+1))
    ys = list(range(1, n+1))
    rnd.shuffle(xs)
    rnd.shuffle(ys)
    return list(zip(xs, ys))

def brute_vs_fast_consistency(n: int, trials: int = 50, seed: int = 123) -> None:
    from copy import deepcopy
    rnd = random.Random(seed)
    for _ in range(trials):
        # build a random final permutation via cycles
        perm = list(range(1, n+1))
        rnd.shuffle(perm)
        xs = list(range(1, n+1))
        ys = perm[:]
        rnd.shuffle(xs)
        updates = list(zip(xs, ys))
        # Compare
        from collections import deque
        import itertools
        bf = brute_count_completions(n, updates)  # from Approach A block
        fast = solve_case(n, updates)             # from Approach C block
        # Always equal at the end (b_i=0): both are 1 if all cycles are 3-multiples, else 0
        assert (bf[-1] == fast[-1]), (bf, fast, updates)

if __name__ == "__main__":
    # Example generator run (kept tiny)
    print(gen_identity_updates(6, seed=7))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import List, Tuple
import sys

MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD-2, MOD)

def precompute_f_values(n: int) -> List[int]:
    fact = [1]*(n+1)
    for i in range(1, n+1):
        fact[i] = fact[i-1]*i % MOD
    mmax = n//3
    fact_m = [1]*(mmax+1)
    for m in range(1, mmax+1):
        fact_m[m] = fact_m[m-1]*m % MOD
    invfact_m = [1]*(mmax+1)
    if mmax >= 0:
        invfact_m[mmax] = modinv(fact_m[mmax])
        for m in range(mmax, 0, -1):
            invfact_m[m-1] = invfact_m[m]*m % MOD
    inv3 = modinv(3)
    f = [0]*(n+1)
    f[0] = 1
    poch = 1
    for m in range(1, mmax+1):
        term = (3*(m-1)+1) % MOD
        term = term * inv3 % MOD
        poch = poch * term % MOD
        f[3*m] = fact[3*m] * poch % MOD * invfact_m[m] % MOD
    return f

def read_input() -> Tuple[int, List[Tuple[int,int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    upd = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, upd

def solve_case(n: int, updates: List[Tuple[int,int]]) -> List[int]:
    f = precompute_f_values(n)
    out = [-1]*n
    bad = False
    ans: List[int] = []
    seen = [0]*n
    stamp = 0
    for i, (x, y) in enumerate(updates, 1):
        u = x-1; v = y-1
        out[u] = v
        stamp += 1
        cur = v
        L = 1
        while out[cur] != -1 and cur != u and seen[cur] != stamp:
            seen[cur] = stamp
            cur = out[cur]
            L += 1
            if L > n+1:
                break
        if cur == u and (L % 3 != 0):
            bad = True
        blanks = n - i
        if bad or (blanks % 3 != 0):
            ans.append(0)
        else:
            ans.append(f[blanks])
    return ans

def main():
    n, updates = read_input()
    if n == 0:
        return
    res = solve_case(n, updates)
    out = sys.stdout
    out.write("\n".join(map(str, res)))

if __name__ == "__main__":
    # Minimal asserts
    f6 = precompute_f_values(6)
    assert f6[0] == 1 and f6[3] == 2 and f6[6] == 160
    assert solve_case(3, [(1,2),(2,3),(3,1)]) == [0, 0, 1]
    got = solve_case(3, [(1,1),(2,3),(3,2)])
    assert got[0] == 0 and got[-1] == 0
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count completions of a partial permutation so that all cycles have lengths divisible by $3$.}
\WHY{Dynamic permutation constraints with cycle-structure restrictions probe fluency with functional graphs, EGFs, and modular convolution.}
\CHECKLIST{
\begin{bullets}
\item Maintain in/out-degree $\le 1$; detect a new cycle at each insertion.
\item Early terminate with $0$ if a forbidden closed cycle appears.
\item Use $(1-x^3)^{-1/3}$ to derive the closed form for all-$3\mathbb{Z}$ permutations.
\item Keep arithmetic modulo $998{,}244{,}353$; precompute factorials and inverses.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item A fixed point $a_i=i$ (cycle length $1$) appears.
\item A $2$-cycle appears early: $a_i=j$, $a_j=i$.
\item No blanks remain: answer is $1$ if the permutation is already valid; else $0$.
\item Large $n$ with long chains; ensure traversal does not TLE in an actual optimized solution.
\item $b_i \not\equiv 0 \pmod 3$: immediate $0$.
\item Multiple disjoint cycles appear; any bad one forces $0$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting division by $m!$ in $f(3m)=(3m)!\,(1/3)_m/m!$.
\item Integer division instead of modular inverse for factors of $3$.
\item Looping infinitely when following pointers; mark visits per step.
\item Off-by-one in cycle length when closing $x\to y$.
\item Reusing $y$ values (should not happen given constraints) — guard in generic code.
\item Printing results when $b_i$ not a multiple of $3$.
\end{bullets}
}
\FAILMODES{Approaches that ignore already-closed cycles can output nonzero answers in impossible states. The optimal solution must integrate chain residue bookkeeping to enforce modulo-$3$ closure across all chains; the heuristic here simplifies that for pedagogy.}
\ELI{Think of permutations as loops. Only loops of size $3,6,9,\dots$ are allowed. Each update adds one arrow; if it closes a loop of bad size, we are done with zero. Otherwise, if the number of remaining arrows is a multiple of $3$, we use a known formula to estimate the count of ways to finish.}
\NotePages{3}

\end{document}