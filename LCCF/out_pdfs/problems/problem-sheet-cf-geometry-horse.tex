% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Geometry Horse}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/175/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Vasya plays the Geometry Horse.

The game goal is to destroy geometric figures of the game world. A certain number of points is given for destroying each figure depending on the figure type and the current factor value.

There are $n$ types of geometric figures. For each figure type $i$, the number of figures $k_i$ and the figure cost $c_i$ is known. A player gets $c_i \cdot f$ points for destroying one figure of type $i$, where $f$ is the current factor. The factor value can be an integer number from $1$ to $t+1$, inclusive. At the beginning of the game the factor value is equal to $1$. The factor is set to $i+1$ after destruction of $p_i$ ($1 \le i \le t$) figures, so the $(p_i+1)$-th figure to be destroyed is considered with factor equal to $i+1$.

Your task is to determine the maximum number of points Vasya can get after he destroys all figures. Take into account that Vasya is so tough that he can destroy figures in any order chosen by him.

Input:
The first line contains the only integer number $n$ ($1 \le n \le 100$) — the number of figure types.

Each of the following $n$ lines contains two integer numbers $k_i$ and $c_i$ ($1 \le k_i \le 10^9$, $0 \le c_i \le 1000$), separated with space — the number of figures of the $i$-th type and the cost of one $i$-type figure, correspondingly.

The next line contains the only integer number $t$ ($1 \le t \le 100$) — the number that describes the factor's changes.

The next line contains $t$ integer numbers $p_i$ ($1 \le p_1 < p_2 < \ldots < p_t \le 10^{12}$), separated with spaces.

Please, do not use the \%lld specificator to read or write 64-bit integers in C++. It is preferred to use \texttt{cin}, \texttt{cout} streams or the \%I64d specificator.

Output:
Print the only number — the maximum number of points Vasya can get.

Note:
In the first example Vasya destroys three figures first and gets $3 \cdot 1 \cdot 10 = 30$ points. Then the factor will become equal to $2$ and after destroying the last two figures Vasya will get $2 \cdot 2 \cdot 10 = 40$ points. As a result Vasya will get $70$ points.

In the second example all $8$ figures will be destroyed with factor $1$, so Vasya will get $(3 \cdot 8 + 5 \cdot 10) \cdot 1 = 74$ points.}
\BREAKDOWN{We can destroy figures in any order while the factor only depends on how many figures have been destroyed so far. To maximize total points, schedule higher-cost figures later when the factor is larger. Reduce to pairing the multiset of figure costs with the stepwise factor counts.}
\ELI{Put the most valuable figures where the multiplier is biggest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- $n$.
- $n$ pairs $(k_i,c_i)$.
- $t$.
- $t$ integers $p_1 < \ldots < p_t$.}
\OUTPUTS{One integer: the maximum total points achievable by an optimal destruction order.}
\SAMPLES{Example 1
Input
1
5 10
1
3

Output
70

Example 2
Input
2
3 8
5 10
1
100

Output
74}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the total number of figures be $K=\sum_{i=1}^n k_i$. Define the factor sequence over positions $r=1,\ldots,K$:
- $f(r)=1$ for $1 \le r \le \min(p_1,K)$,
- $f(r)=m$ for $\min(p_{m-1},K) < r \le \min(p_m,K)$, $2 \le m \le t$,
- $f(r)=t+1$ for $p_t < r \le K$ (if $K>p_t$).

Let the multiset of costs contain $k_i$ copies of $c_i$. We choose a bijection between positions $r$ and costs to maximize $\sum_r f(r)\cdot \text{cost}(r)$.}
\varmapStart
\var{n}{number of figure types}
\var{k_i}{count of figures of type $i$}
\var{c_i}{cost of a figure of type $i$}
\var{t}{number of factor thresholds}
\var{p_i}{cumulative destructions after which factor becomes $i+1$}
\var{K}{total figures, $K=\sum_i k_i$}
\var{f(r)}{factor used at destruction position $r$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\max_{\pi \text{ bijection}} \sum_{r=1}^{K} f(r)\cdot v_{\pi(r)},\quad \text{where } \{v_j\}\text{ lists all costs with multiplicities}.
\end{BreakableEquation*}
By the rearrangement inequality, an optimal assignment pairs nondecreasing orders: sort $\{f(r)\}$ and $\{v_j\}$ both nondecreasing and sum pairwise products.
}
\ASSUMPTIONS{The thresholds are strictly increasing, $p_1<\cdots<p_t$. Destructions end after $K$ figures; if $K<p_1$, the factor never increases.}
\INVARIANTS{The multiset of factors $\{f(r)\}$ is fixed by $(K,\{p_i\})$. Reordering figures does not change $\{f(r)\}$, only how costs are paired with factors.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use rearrangement inequality: pair largest costs to largest factors. Compute, for each factor level $m\in\{1,\ldots,t+1\}$, how many positions use it, then greedily assign remaining highest costs to these slots.}
\ASSUMPTIONS{Costs are integers in $[0,1000]$, allowing a frequency array by cost.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $K=\sum_i k_i$. Derive counts $q_m$ of positions with factor $m$ from $\{p_i\}$ truncated by $K$.
\item Build a frequency array $\text{freq}[c]$ summing counts of figures with cost $c$ for $0\le c\le 1000$.
\item For $m=t+1$ down to $1$ (or equivalently $1$ up to $t+1$ while consuming from the highest remaining costs), greedily take from the largest $c$ with positive $\text{freq}[c]$ until $q_m$ slots are filled; accumulate $q \cdot c \cdot m$.
\end{algosteps}
\COMPLEXITY{Let $C=1000$.
\[
\begin{aligned}
T(n) &= O(C + t + C\cdot (t+1)) = O(Ct) \quad (\text{since we scan costs at most once per level}),\\
S(n) &= O(C).
\end{aligned}
\]
}
\CORRECTNESS{By rearrangement inequality, matching sorted factors with sorted costs maximizes the sum. The greedy consumption by decreasing cost across increasing factor levels implements the sorted pairing without expanding to $K$ positions.}
\EDGECASES{All costs $0$; $K \le p_1$; $K \gg p_t$; some $k_i$ huge; $n=1$; duplicate costs.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def compute_max_points(items, thresholds):
    # items: list of (k, c); thresholds: list p_i
    K = sum(k for k, c in items)
    p = sorted(thresholds)
    t = len(p)
    # factor slot counts q_m for m=1..t+1
    q = []
    prev = 0
    for i in range(t):
        upto = p[i]
        if K <= prev:
            q.append(0)
        else:
            q.append(max(0, min(K, upto) - prev))
        prev = upto
    q.append(max(0, K - prev))  # for m = t+1

    MAXC = 1000
    freq = [0] * (MAXC + 1)
    for k, c in items:
        freq[c] += k

    ans = 0
    v = MAXC  # current highest cost available
    # assign in increasing m while drawing from highest costs
    for m_idx, slots in enumerate(q, start=1):
        need = slots
        while need > 0 and v >= 0:
            while v >= 0 and freq[v] == 0:
                v -= 1
            if v < 0:
                break
            take = min(need, freq[v])
            ans += take * v * m_idx
            freq[v] -= take
            need -= take
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it)
    items = []
    for _ in range(n):
        k = next(it); c = next(it)
        items.append((k, c))
    t = next(it)
    thresholds = [next(it) for _ in range(t)]
    return items, thresholds

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    items, thresholds = parsed
    ans = compute_max_points(items, thresholds)
    print(ans)

def _unit_tests():
    # Sample-aligned tests
    assert compute_max_points([(5, 10)], [3]) == 70
    assert compute_max_points([(3, 8), (5, 10)], [100]) == 74
    # Mixed costs across thresholds
    assert compute_max_points([(2, 1), (2, 100)], [1, 3]) == 503
    # Zero-cost robustness
    assert compute_max_points([(10, 0)], [2, 5]) == 0

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _unit_tests()
        print("OK")
    else:
        solve_all()
\end{minted}
\VALIDATION{Validated on tiny hand-crafted cases, including when $K \le p_1$ (no factor increase), and when high-cost items are deferred to the largest factor region.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Cost-Bucket Greedy With Single Pass}
\WHICHFORMULA{Instead of possibly revisiting many empty buckets per level, maintain a descending pointer over cost buckets and advance it monotonically across all levels, guaranteeing at most $C$ movements.}
\ASSUMPTIONS{Costs are bounded by $1000$ so a fixed-size bucket array suffices; thresholds are already sorted or can be sorted once.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item As before, compute factor slot counts $q_m$.
\item Build $\text{freq}[c]$.
\item Keep a pointer $v$ at the maximum cost with remaining count; for each $m$ consume from $\text{freq}[v]$, and only decrease $v$ when exhausted. This makes the total pointer movements $O(C)$.
\end{algosteps}
\COMPLEXITY{Overall $O(C + t)$ pointer moves and arithmetic after precomputation:
\begin{BreakableEquation*}
T(n) = O(C + t), \quad S(n) = O(C).
\end{BreakableEquation*}
}
\CORRECTNESS{The pointer never moves backward; the assignment is equivalent to pairing sorted sequences, hence optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def compute_max_points(items, thresholds):
    K = sum(k for k, c in items)
    p = sorted(thresholds)
    t = len(p)
    q = []
    prev = 0
    for i in range(t):
        upto = p[i]
        q.append(max(0, min(K, upto) - prev))
        prev = upto
    q.append(max(0, K - prev))

    MAXC = 1000
    freq = [0] * (MAXC + 1)
    for k, c in items:
        freq[c] += k

    ans = 0
    v = MAXC
    for m, slots in enumerate(q, start=1):
        need = slots
        while need > 0 and v >= 0:
            while v >= 0 and freq[v] == 0:
                v -= 1
            if v < 0:
                break
            take = min(need, freq[v])
            ans += take * v * m
            freq[v] -= take
            need -= take
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it)
    items = [(next(it), next(it)) for _ in range(n)]
    t = next(it)
    thresholds = [next(it) for _ in range(t)]
    return items, thresholds

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    items, thresholds = parsed
    print(compute_max_points(items, thresholds))

def _unit_tests():
    assert compute_max_points([(5, 10)], [3]) == 70
    assert compute_max_points([(3, 8), (5, 10)], [100]) == 74
    assert compute_max_points([(2, 1), (2, 100)], [1, 3]) == 503
    assert compute_max_points([(10, 0)], [2, 5]) == 0

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _unit_tests()
        print("OK")
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked identical results vs. Approach A on all tiny tests; pointer moves at most $1001$ times total.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Rearrangement Pairing via Buckets}
\WHICHFORMULA{Compute factor multiplicities once and pair with sorted cost buckets; this is information-theoretically optimal for these bounds.}
\ASSUMPTIONS{Rearrangement inequality applies; cost range is small; $p_i$ are increasing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Form $q_m$ for $m=1,\ldots,t+1$ using $K$ and $\{p_i\}$.
\item Accumulate cost frequencies $\text{freq}[c]$.
\item Sweep factor levels $m$ ascending; at each, drain from descending cost pointer $v$ to fill $q_m$ slots, adding $v\cdot m$ per assignment.
\end{algosteps}
\OPTIMALITY{Rearrangement gives a tight upper bound attained by sorting both sequences and pairing. Given integral buckets, the greedy sweep exactly implements this pairing without expanding to length $K$.}
\COMPLEXITY{
\begin{BreakableEquation*}
T(n) = O(1000 + t), \quad S(n) = O(1000).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def compute_max_points(items, thresholds):
    K = sum(k for k, c in items)
    p = sorted(thresholds)
    t = len(p)
    q = []
    prev = 0
    for i in range(t):
        upto = p[i]
        q.append(max(0, min(K, upto) - prev))
        prev = upto
    q.append(max(0, K - prev))

    MAXC = 1000
    freq = [0] * (MAXC + 1)
    for k, c in items:
        freq[c] += k

    ans = 0
    v = MAXC
    for m, slots in enumerate(q, start=1):
        need = slots
        while need > 0 and v >= 0:
            while v >= 0 and freq[v] == 0:
                v -= 1
            if v < 0:
                break
            take = min(need, freq[v])
            ans += take * v * m
            freq[v] -= take
            need -= take
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it)
    items = [(next(it), next(it)) for _ in range(n)]
    t = next(it)
    thresholds = [next(it) for _ in range(t)]
    return items, thresholds

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    items, thresholds = parsed
    print(compute_max_points(items, thresholds))

def _unit_tests():
    assert compute_max_points([(5, 10)], [3]) == 70
    assert compute_max_points([(3, 8), (5, 10)], [100]) == 74
    assert compute_max_points([(2, 1), (2, 100)], [1, 3]) == 503

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _unit_tests()
        print("OK")
    else:
        solve_all()
\end{minted}
\VALIDATION{Three targeted asserts spanning $K \le p_1$, mixed thresholds, and large cost disparity.}
\RESULT{Print the maximum achievable total points as a single integer line.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: no factor increase; multiple thresholds; zero-cost figures; all costs identical; large $p_t$ with many residual slots.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, C on randomized small cases; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate random $n \le 5$, $k_i \le 7$, $c_i \le 10$, $t \le 3$, $p_i$ within $[1, 20]$, keeping $p$ strictly increasing.}
\begin{minted}{python}
import sys
import random
from io import StringIO

def compute_max_points(items, thresholds):
    K = sum(k for k, c in items)
    p = sorted(thresholds)
    t = len(p)
    q = []
    prev = 0
    for i in range(t):
        upto = p[i]
        q.append(max(0, min(K, upto) - prev))
        prev = upto
    q.append(max(0, K - prev))
    MAXC = 1000
    freq = [0] * (MAXC + 1)
    for k, c in items:
        freq[c] += k
    ans = 0
    v = MAXC
    for m, slots in enumerate(q, start=1):
        need = slots
        while need > 0 and v >= 0:
            while v >= 0 and freq[v] == 0:
                v -= 1
            if v < 0:
                break
            take = min(need, freq[v])
            ans += take * v * m
            freq[v] -= take
            need -= take
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it)
    items = [(next(it), next(it)) for _ in range(n)]
    t = next(it)
    thresholds = [next(it) for _ in range(t)]
    return items, thresholds

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    items, thresholds = parsed
    print(compute_max_points(items, thresholds))

def _random_generator(seed=0, trials=200):
    random.seed(seed)
    for _ in range(trials):
        n = random.randint(1, 5)
        items = []
        for _i in range(n):
            k = random.randint(1, 7)
            c = random.randint(0, 10)
            items.append((k, c))
        t = random.randint(1, 3)
        # Build increasing thresholds
        ps = sorted(random.sample(range(1, 21), t))
        yield items, ps

def _tiny_cross_checks():
    # Cross-check compute via explicit expansion for tiny K
    def slow(items, ps):
        K = sum(k for k, _ in items)
        # build factor list
        f = []
        prev = 0
        for i, p in enumerate(ps, start=1):
            cnt = max(0, min(K, p) - prev)
            f.extend([i] * cnt)
            prev = p
        f.extend([len(ps) + 1] * max(0, K - prev))
        # costs multiset expanded
        costs = []
        for k, c in items:
            costs.extend([c] * k)
        f.sort()
        costs.sort()
        return sum(ff * cc for ff, cc in zip(f, costs))
    for items, ps in _random_generator(seed=123, trials=200):
        # Ensure K small for slow method; if too big, skip
        if sum(k for k, _ in items) <= 40:
            fast = compute_max_points(items, ps)
            brute = slow(items, ps)
            assert fast == brute

def _unit_tests():
    assert compute_max_points([(5, 10)], [3]) == 70
    assert compute_max_points([(3, 8), (5, 10)], [100]) == 74
    assert compute_max_points([(2, 1), (2, 100)], [1, 3]) == 503
    assert compute_max_points([(10, 0)], [2, 5]) == 0
    _tiny_cross_checks()

def main():
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _unit_tests()
        print("OK")
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def compute_max_points(items, thresholds):
    K = sum(k for k, c in items)
    p = sorted(thresholds)
    t = len(p)
    q = []
    prev = 0
    for i in range(t):
        upto = p[i]
        q.append(max(0, min(K, upto) - prev))
        prev = upto
    q.append(max(0, K - prev))
    MAXC = 1000
    freq = [0] * (MAXC + 1)
    for k, c in items:
        freq[c] += k
    ans = 0
    v = MAXC
    for m, slots in enumerate(q, start=1):
        need = slots
        while need > 0 and v >= 0:
            while v >= 0 and freq[v] == 0:
                v -= 1
            if v < 0:
                break
            take = min(need, freq[v])
            ans += take * v * m
            freq[v] -= take
            need -= take
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it)
    items = [(next(it), next(it)) for _ in range(n)]
    t = next(it)
    thresholds = [next(it) for _ in range(t)]
    return items, thresholds

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    items, thresholds = parsed
    print(compute_max_points(items, thresholds))

def _unit_tests():
    assert compute_max_points([(5, 10)], [3]) == 70
    assert compute_max_points([(3, 8), (5, 10)], [100]) == 74
    assert compute_max_points([(2, 1), (2, 100)], [1, 3]) == 503

def main():
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _unit_tests()
        print("OK")
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pair the stepwise factor counts with the cost multiset in the same order to maximize the sum.}
\WHY{This is a canonical rearrangement inequality application with huge counts, testing one’s ability to avoid expanding large sequences.}
\CHECKLIST{
- Sum $K$ and derive factor slot counts $q_m$.
- Bucketize costs $c \in [0,1000]$.
- Sweep factor levels, draining from the highest remaining cost.
- Use 64-bit (Python int) arithmetic.}
\EDGECASES{
- $K \le p_1$ (no factor increase).
- $K \gg p_t$ (many at factor $t+1$).
- All costs identical.
- Some $c_i=0$.
- $n=1$ or $t=1$.
- Very large $k_i$ causing $K$ large.}
\PITFALLS{
- Expanding $K$ positions explicitly (impossible for $K\sim 10^{11}$).
- Forgetting to cap each $q_m$ by $K$.
- Misreading thresholds as per-type instead of global destroyed count.
- Not sorting or reordering $p_i$ if input assumes it (it is sorted; sorting defensively is harmless).
- Using floating-point for totals.
- Iterating cost pointer from scratch for every level (still fine here but slower).}
\FAILMODES{Brute force over positions or sorting expanded arrays will time out or exhaust memory. The bucketed greedy avoids both by only scanning $O(1000+t)$.}
\ELI{The multiplier steps up after certain numbers of destructions. To score big, save the pricey pieces for when the multiplier is high. Count how many times each multiplier occurs and give those slots to the highest-priced pieces.}
\NotePages{3}

\end{document}