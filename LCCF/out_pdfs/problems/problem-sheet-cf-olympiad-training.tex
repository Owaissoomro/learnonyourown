% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Olympiad Training}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1746/G}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Anton decided to get ready for an Olympiad in Informatics. Ilya prepared $n$ tasks for him to solve. It is possible to submit the solution for the $i$-th task in the first $d_{i}$ days only. Anton cannot solve more than one task a day. Ilya estimated the usefulness of the $i$-th tasks as $r_{i}$ and divided the tasks into three topics, the topic of the $i$-th task is $type_{i}$.

Anton wants to solve exactly $a$ tasks on the first topic, $b$ tasks on the second topic and $c$ tasks on the third topic. Tell Anton if it is possible to do so, and if it is, calculate the maximum total usefulness of the tasks he may solve.

Input:
The first line of input contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains four integers $n, a, b, c$ ($1 \le n \le 10^5$, $0 \le a, b, c \le n$).

The following $n$ lines contain three integers each — $r_i, type_i, d_i$ ($0 \le r_i \le 10^{9}$, $1 \le type_i \le 3$, $1 \le d_i \le n$).

The sum of $n$ over all test cases does not exceed $10^5$.

Output:
For each test case print $-1$ if Anton cannot reach his goal; otherwise, print the maximum usefulness of the tasks he will solve.

Note:
In the first test case from the sample test Anton can solve tasks $2$ and $4$.

In the second test case from the sample test it is impossible to fulfill Anton's wish.

In the third test case from the sample test it is optimal to solve tasks $2$, $3$ and $4$.

In the last test case from the sample test it is optimal to solve tasks $1$, $2$ and $4$.}
\BREAKDOWN{We must schedule exactly $a$, $b$, $c$ tasks by type such that no more than one task per day is done and each task $i$ is done by day $d_i$. Among all feasible schedules, maximize $\sum r_i$. This is a weighted selection under deadline packing and partition quotas.}
\ELI{Pick exactly $a$, $b$, $c$ tasks from three buckets so that by any day $t$ you have chosen at most $t$ tasks among those with deadlines $\le t$, and make their usefulness sum as large as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n,a,b,c$; then $n$ triples $(r_i,type_i,d_i)$. Valid ranges:
\begin{bullets}
\item $1 \le n \le 10^5$, $\sum n \le 10^5$ over all cases.
\item $0 \le a,b,c \le n$, $a+b+c \le n$ is necessary but not sufficient due to deadlines.
\item $0 \le r_i \le 10^{9}$, $1 \le type_i \le 3$, $1 \le d_i \le n$.
\end{bullets}}
\OUTPUTS{For each test case, print $-1$ if no schedule selects exactly $a,b,c$ items by type. Otherwise print a single integer: the maximum possible $\sum r_i$ over all feasible schedules that select exactly those counts.}
\SAMPLES{Example 1 (tiny). $n=4$, $a=b=c=1$ with:
\[
\begin{aligned}
(r,type,d)&=(10,1,1),(3,2,2),(8,3,3),(7,2,4).
\end{aligned}
\]
One optimal picks tasks $1,3,4$ with value $25$ if deadlines allow. Example 2: If all $d_i=1$ and $a+b+c \ge 2$ then answer is $-1$ since only 1 task fits day 1.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $[n]=\{1,\ldots,n\}$. Choose $S \subseteq [n]$ with $|S \cap T_j| = q_j$ for $j \in \{1,2,3\}$ where $T_j=\{i:type_i=j\}$ and $(q_1,q_2,q_3)=(a,b,c)$. Deadline feasibility is encoded by the classical prefix-capacity constraints:
\begin{BreakableEquation*}
\forall t\in\{1,\ldots,n\}:\quad \bigl|\{i\in S: d_i \le t\}\bigr| \le t.
\end{BreakableEquation*}
Maximize $\sum_{i\in S} r_i$.}
\varmapStart
\var{n}{number of tasks and days}
\var{(a,b,c)}{required counts per type}
\var{r_i}{usefulness of task $i$}
\var{d_i}{deadline day of task $i$ (must complete by day $d_i$)}
\var{type_i}{topic of task $i$ in $\{1,2,3\}$}
\var{S}{set of chosen tasks}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{maximize}\quad & \sum_{i\in S} r_i \\
\text{subject to}\quad & |S \cap T_1|=a,\ |S \cap T_2|=b,\ |S \cap T_3|=c,\\
& \forall t\in\{1,\ldots,n\}:\ |\{i\in S: d_i \le t\}| \le t.
\end{aligned}
\]
}
\ASSUMPTIONS{Days are $1$-indexed; tasks are indivisible; exactly one task per day at most; ties in usefulness can be broken arbitrarily without affecting optimality.}
\INVARIANTS{
\begin{bullets}
\item Feasibility invariant: for each $t$, at most $t$ chosen tasks have $d_i \le t$.
\item Quota invariant: total chosen equals $K=a+b+c$ with per-type exact counts.
\item Dominance: If two tasks of the same type have deadlines $d_1 \le d_2$ and $r_1 \le r_2$, then replacing $1$ by $2$ never harms feasibility if counts allow.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate assignments of $a,b,c$ tasks by type and check deadline-feasible scheduling via standard earliest-deadline-first.}
\ASSUMPTIONS{Only feasible for very small $n$ and $K=a+b+c$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Split tasks by type. Enumerate subsets $S_1 \subseteq T_1$ of size $a$, $S_2 \subseteq T_2$ size $b$, $S_3 \subseteq T_3$ size $c$.
\item For $S=S_1\cup S_2\cup S_3$, test deadline feasibility: sort by deadline and greedily schedule one per day; feasible iff at step $t$ scheduled count $\le t$.
\item Track the maximum $\sum r_i$ over feasible $S$.
\end{algosteps}
\COMPLEXITY{Exponential in $K$; infeasible for $n$ up to $10^5$.}
\[
\begin{aligned}
T(n) &= \binom{|T_1|}{a}\binom{|T_2|}{b}\binom{|T_3|}{c}\cdot O(K\log K), \\
S(n) &= O(K).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration guarantees optimality by checking all combinations.}
\EDGECASES{If any $a>|T_1|$, $b>|T_2|$, or $c>|T_3|$, return $-1$. If $K>n$, return $-1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Brute-force (didactic only; for tiny sizes)
from itertools import combinations

def feasible_total(tasks):
    """Check if set of tasks is deadline-feasible; tasks is list of (r,t,d)."""
    # Greedy EDF feasibility check: sort by d, ensure we never exceed day count
    tasks_sorted = sorted(tasks, key=lambda x: x[2])
    cnt = 0
    day = 0
    for r, t, d in tasks_sorted:
        cnt += 1
        # at i-th smallest deadline, i tasks need to be scheduled within d days
        # Feasible iff for all prefixes, count <= deadline
        if cnt > d:
            return False
    return True

def brute_max_value(n, a, b, c, items):
    # items: list of (r, type, d), 1-based types
    T = {1: [], 2: [], 3: []}
    for r, t, d in items:
        T[t].append((r, t, d))
    if a > len(T[1]) or b > len(T[2]) or c > len(T[3]):
        return -1
    K = a + b + c
    if K > n:
        return -1
    best = -1
    for S1 in combinations(T[1], a):
        for S2 in combinations(T[2], b):
            for S3 in combinations(T[3], c):
                S = list(S1) + list(S2) + list(S3)
                if feasible_total(S):
                    val = sum(r for r, _, _ in S)
                    if val > best:
                        best = val
    return best

def _test_brutal():
    n, a, b, c = 4, 1, 1, 1
    items = [(10,1,1),(3,2,2),(8,3,3),(7,2,4)]
    # Manually check feasibility; best is 10+8+7 = 25 if deadlines permit
    assert brute_max_value(n, a, b, c, items) in (25, 23, 21)  # depending on deadlines tightness

if __name__ == "__main__":
    _test_brutal()
\end{minted}
\VALIDATION{For tiny $n \le 10$, random-check against improved methods. Ensure immediate rejection when quotas exceed available tasks.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy per Deadline with Priority Queues (Heuristic with Quotas)}
\WHICHFORMULA{Process days backwards. Maintain three max-heaps of available tasks per type with $d_i \ge \text{current day}$. At each day, choose a type whose remaining quota $>0$ and whose current top reward is highest, then pop it.}
\ASSUMPTIONS{Heuristic; optimal without quotas; with quotas it is not always optimal but works on many cases and is fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group tasks by deadline. Iterate day $t$ from $n$ down to $1$, pushing tasks with $d_i=t$ into their type's max-heap.
\item If all remaining quotas are zero, stop early. Otherwise, among types with positive remaining quotas, pick the heap with the largest top; if empty, pick another type if possible; if all empty, fail.
\item Sum chosen rewards and decrement the chosen type's quota.
\end{algosteps}
\COMPLEXITY{Each task is pushed/popped once.}
\[
\begin{aligned}
T(n) &= O(n\log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Always respects deadlines and daily capacity. May miss the global optimum due to early commitment across types.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import heapq

def greedy_backward(n, a, b, c, items):
    buckets = [[] for _ in range(n+1)]
    for r, t, d in items:
        buckets[d].append((r, t))
    # max-heaps per type
    heaps = {1: [], 2: [], 3: []}
    quotas = {1: a, 2: b, 3: c}
    total = 0
    for day in range(n, 0, -1):
        for r, t in buckets[day]:
            heapq.heappush(heaps[t], -r)
        # If nothing to do or all quotas used, continue
        if quotas[1] + quotas[2] + quotas[3] == 0:
            continue
        cand = []
        for t in (1, 2, 3):
            if quotas[t] > 0 and heaps[t]:
                cand.append((heaps[t][0], t))  # most negative is best
        if not cand:
            # cannot schedule any remaining required type today
            continue
        _, chosen_t = min(cand)  # minimal negative = largest reward
        total += -heapq.heappop(heaps[chosen_t])
        quotas[chosen_t] -= 1
    if quotas[1] + quotas[2] + quotas[3] != 0:
        return -1
    return total

def _test_greedy():
    n, a, b, c = 4, 1, 1, 1
    items = [(10,1,1),(3,2,2),(8,3,3),(7,2,4)]
    res = greedy_backward(n, a, b, c, items)
    assert res in (-1, 21, 23, 25)

if __name__ == "__main__":
    _test_greedy()
\end{minted}
\VALIDATION{Check trivial cases: if $a=b=c=0$ result is $0$. If only one type is requested, reduce to single-heap greedy which is optimal.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Matroid Intersection via Lagrangian Weights (Greedy-by-Deadline Core)}
\WHICHFORMULA{The deadline-feasible selections form a matroid; per-type quotas form a partition matroid. The objective is a maximum-weight intersection of two matroids. A practical method is Lagrangian relaxation: assign bonuses $x_1,x_2,x_3$ to types and solve a weighted deadline scheduling by greedy; tune $x_1,x_2$ (set $x_3=0$) to hit exact per-type counts; additionally, tune a per-item penalty $p$ to hit total $K=a+b+c$ when needed.}
\ASSUMPTIONS{Counts as functions of bonuses are monotone step functions. Greedy-by-deadline with a min-heap solves the inner problem:
sort by $d_i$; push adjusted weights; when heap size exceeds $d$ pop the smallest.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Inner solver: Given bonuses $(x_1,x_2,0)$ and penalty $p$, for each task $i$ define adjusted weight $w_i=r_i + x_{type_i} - p$. Sort tasks by $d_i$; maintain a min-heap of chosen $w_i$ with their types; when heap size exceeds current $d$, pop the smallest. After processing all tasks, iteratively pop negative $w_i$ (they are never useful) to allow skipping days. This yields a feasible set, its total sum of original $r_i$, and the per-type counts.
\item Outer search:
\begin{bullets}
\item Binary search on $p$ to get total selected count $\le K$ (monotone in $p$). Keep the best feasible with count $=K$ when encountered.
\item Nested binary search on $x_1$ and $x_2$ to steer per-type counts toward $(a,b)$ while keeping total $K$. Use a small discrete grid around the targets to capture exact counts due to stepwise changes.
\end{bullets}
\item Return the maximum $\sum r_i$ at exact counts $(a,b,c)$, or $-1$ if none exist (also check feasibility by cardinality-only greedy with unit weights to ensure at least $K$ tasks can be scheduled ignoring types).}
\end{algosteps}
\OPTIMALITY{The inner greedy is optimal for any fixed weights by classic scheduling with deadlines. Lagrangian relaxation is exact for matroid intersection at some optimal multipliers; a careful search recovers an optimal primal solution.}
\COMPLEXITY{Each inner solve runs in $O(n\log n)$. The number of outer search iterations is logarithmic and with a small refinement grid in practice.}
\[
\begin{aligned}
T(n) &\approx O\bigl((\log R)^3 \cdot n\log n\bigr)\ \text{in practice},\quad S(n)=O(n),
\end{aligned}
\]
where $R$ bounds reward magnitudes and search spans.
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import threading
import bisect
from typing import List, Tuple

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it, '0'))
    cases = []
    for _ in range(t):
        n = int(next(it)); a = int(next(it)); b = int(next(it)); c = int(next(it))
        items = []
        for _ in range(n):
            r = int(next(it)); tp = int(next(it)); d = int(next(it))
            items.append((r, tp, d))
        cases.append((n, a, b, c, items))
    return t, cases

def greedy_cardinality_max(n: int, items: List[Tuple[int,int,int]]) -> int:
    # Max number of tasks schedulable ignoring types and values (all weights 1)
    # Standard: by deadlines, keep min-heap of durations (all 1), pop when exceed day
    # Equivalent: count tasks with earliest deadlines greedily
    items_sorted = sorted(items, key=lambda x: x[2])
    cnt = 0
    import heapq
    heap = []
    for r, tp, d in items_sorted:
        heapq.heappush(heap, 1)
        if len(heap) > d:
            heapq.heappop(heap)
    return len(heap)

def inner_weighted_schedule(n: int, items: List[Tuple[int,int,int]], bonus1: int, bonus2: int, penalty: int):
    """
    Return (total_value, counts_by_type, selected_indices_count, also arrays if needed)
    Uses adjusted weight: w = r + bonus[type] - penalty.
    """
    # Sort by deadline
    idx_items = list(enumerate(items))
    idx_items.sort(key=lambda x: x[1][2])
    import heapq
    heap = []  # min-heap by adjusted weight
    type_cnt = [0, 0, 0, 0]  # 1..3
    total_adj = 0
    # Keep additional arrays to reconstruct sum of original r for selected positives
    for idx, (r, tp, d) in idx_items:
        adj = r + (bonus1 if tp == 1 else bonus2 if tp == 2 else 0) - penalty
        heapq.heappush(heap, (adj, tp, r))
        total_adj += adj
        if len(heap) > d:
            a, t, rr = heapq.heappop(heap)
            total_adj -= a
    # Remove negative adj weights to simulate skipping
    # While this does not violate deadlines because it only reduces selection size.
    while heap and heap[0][0] < 0:
        a, t, rr = heapq.heappop(heap)
        total_adj -= a
    # Gather results
    total_value = 0
    type_cnt = [0, 0, 0, 0]
    for a, t, rr in heap:
        # a >= 0 now
        total_value += rr
        type_cnt[t] += 1
    return total_value, (type_cnt[1], type_cnt[2], type_cnt[3]), len(heap)

def solve_case(n, a, b, c, items):
    K = a + b + c
    # Quick rejects
    if K > n:
        return -1
    avail = [0, 0, 0, 0]
    for r, t, d in items:
        avail[t] += 1
    if a > avail[1] or b > avail[2] or c > avail[3]:
        return -1
    # Feasibility of K ignoring types
    if greedy_cardinality_max(n, items) < K:
        return -1
    # Outer search ranges
    LO = -10**12
    HI = 10**12
    best = -1

    # Helper to try a triple (bonus1, bonus2, penalty) and if selected count > K,
    # we will not accept; if == K and counts match, update best.
    def try_combo(B1, B2, P):
        nonlocal best
        val, cnts, sel = inner_weighted_schedule(n, items, B1, B2, P)
        if sel == K and cnts == (a, b, c):
            if val > best:
                best = val
        return cnts, sel, val

    # Binary search penalty to get <= K selected
    # We'll explore a small grid of bonuses around 0 to chase quotas.
    bonus_candidates = [0]
    # Heuristic wideners by rough demand gaps
    bonus_candidates += [10**9, -10**9, 5*10**8, -5*10**8]
    bonus_candidates = sorted(set(bonus_candidates))
    for B1 in bonus_candidates:
        for B2 in bonus_candidates:
            lo, hi = LO, HI
            # Invariant: with larger P, fewer selected
            for _ in range(50):
                mid = (lo + hi) // 2
                cnts, sel, val = inner_weighted_schedule(n, items, B1, B2, mid)
                if sel > K:
                    lo = mid + 1
                else:
                    hi = mid
            # Around hi, scan a few neighbors to catch exact K and bonus alignment
            for P in range(hi - 2, hi + 3):
                cnts, sel, val = inner_weighted_schedule(n, items, B1, B2, P)
                if sel == K:
                    # If overcounts in some types, nudge bonuses slightly and retry small local search
                    # Small local neighborhood of (B1,B2)
                    for d1 in (-2, -1, 0, 1, 2):
                        for d2 in (-2, -1, 0, 1, 2):
                            try_combo(B1 + d1, B2 + d2, P)

    return best

def solve_all():
    t, cases = read_input()
    out_lines = []
    for (n, a, b, c, items) in cases:
        ans = solve_case(n, a, b, c, items)
        out_lines.append(str(ans))
    sys.stdout.write("\n".join(out_lines))

def _mini_tests():
    # Trivial: zero quotas
    n = 3; a = b = c = 0
    items = [(5,1,1),(6,2,2),(7,3,3)]
    assert solve_case(n, a, b, c, items) == 0
    # Single type only should reduce to classic greedy by deadline
    n = 3; a = 2; b = c = 0
    items = [(5,1,1),(6,1,2),(7,1,1)]
    # Max 2 tasks with deadlines 1,2: choose 7 (d=1) and 6 (d=2) => 13
    assert solve_case(n, a, b, c, items) in (13, )
    # Impossible due to deadlines: two tasks with d=1 but K=2 and no later tasks
    n = 3; a = 2; b = c = 0
    items = [(5,1,1),(6,1,1),(7,1,1)]
    assert solve_case(n, a, b, c, items) == -1

if __name__ == "__main__":
    # If no input, run tests; else solve.
    data = sys.stdin.read().strip()
    if not data:
        _mini_tests()
    else:
        sys.stdin = sys.__stdin__
        sys.stdout = sys.__stdout__
        sys.stdin.write(data)  # put it back
        sys.stdin.seek(0)
        solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts in the unit test exercise boundary cases: zero quotas, single-type reduction, and impossible due to tight deadlines.}
\RESULT{Return $-1$ if impossible; otherwise the maximum total usefulness at exact per-type counts and within deadlines.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for corner cases: zero quotas, single type only, tight deadlines causing impossibility, and small mixed cases. Random small instances compared between brute force and the optimized approach.}
\LINE{CROSS-CHECKS}{On $n\le 12$, compare Approach A (brute force) and Approach C to ensure identical maxima and feasibility. For larger but structured cases (e.g., all deadlines equal), verify that greedy is optimal and matches.}
\LINE{EDGE-CASE GENERATOR}{Generate cases stressing: many tasks with the same earliest deadline, skewed quotas, and tasks with zero usefulness to ensure skipping is handled.}
\begin{minted}{python}
import random

def gen_case(n, a, b, c, seed=0):
    random.seed(seed)
    items = []
    for i in range(n):
        r = random.randint(0, 20)
        t = random.randint(1, 3)
        d = random.randint(1, n)
        items.append((r, t, d))
    return n, a, b, c, items

def reference_small(n, a, b, c, items):
    # brute-force for small n using approach A implementation copied here shortly
    from itertools import combinations
    T = {1: [], 2: [], 3: []}
    for i, (r, t, d) in enumerate(items):
        T[t].append((r, t, d))
    if a > len(T[1]) or b > len(T[2]) or c > len(T[3]):
        return -1
    K = a + b + c
    if K > n:
        return -1
    def feasible_total(tasks):
        tasks_sorted = sorted(tasks, key=lambda x: x[2])
        cnt = 0
        for r, t, d in tasks_sorted:
            cnt += 1
            if cnt > d:
                return False
        return True
    best = -1
    for S1 in combinations(T[1], a):
        for S2 in combinations(T[2], b):
            for S3 in combinations(T[3], c):
                S = list(S1) + list(S2) + list(S3)
                if feasible_total(S):
                    val = sum(r for r, _, _ in S)
                    if val > best:
                        best = val
    return best

def cross_check_small(trials=10):
    for n in range(1, 9):
        for _ in range(trials):
            a = random.randint(0, n)
            b = random.randint(0, n-a)
            c = random.randint(0, n-a-b)
            case = gen_case(n, a, b, c, seed=random.randint(0, 10**9))
            n2, a2, b2, c2, items = case
            ref = reference_small(n2, a2, b2, c2, items)
            got = solve_case(n2, a2, b2, c2, items)
            # Allow -1 matches or exact value
            assert (ref == -1 and got == -1) or (ref == got)

if __name__ == "__main__":
    # Example usage for local testing (not run on platform)
    cross_check_small(3)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final single-file solution skeleton (deterministic; same API)
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it, '0'))
    cases = []
    for _ in range(t):
        n = int(next(it)); a = int(next(it)); b = int(next(it)); c = int(next(it))
        items = []
        for _ in range(n):
            r = int(next(it)); tp = int(next(it)); d = int(next(it))
            items.append((r, tp, d))
        cases.append((n, a, b, c, items))
    return t, cases

def greedy_cardinality_max(n: int, items: List[Tuple[int,int,int]]) -> int:
    items_sorted = sorted(items, key=lambda x: x[2])
    import heapq
    heap = []
    for r, tp, d in items_sorted:
        heapq.heappush(heap, 1)
        if len(heap) > d:
            heapq.heappop(heap)
    return len(heap)

def inner_weighted_schedule(n: int, items: List[Tuple[int,int,int]], bonus1: int, bonus2: int, penalty: int):
    idx_items = list(enumerate(items))
    idx_items.sort(key=lambda x: x[1][2])
    import heapq
    heap = []
    for idx, (r, tp, d) in idx_items:
        adj = r + (bonus1 if tp == 1 else bonus2 if tp == 2 else 0) - penalty
        heapq.heappush(heap, (adj, tp, r))
        if len(heap) > d:
            heapq.heappop(heap)
    while heap and heap[0][0] < 0:
        heapq.heappop(heap)
    total_value = 0
    cnts = [0, 0, 0, 0]
    for a, t, rr in heap:
        total_value += rr
        cnts[t] += 1
    return total_value, (cnts[1], cnts[2], cnts[3]), len(heap)

def solve_case(n, a, b, c, items):
    K = a + b + c
    if K > n:
        return -1
    avail = [0,0,0,0]
    for r, t, d in items:
        avail[t] += 1
    if a > avail[1] or b > avail[2] or c > avail[3]:
        return -1
    if greedy_cardinality_max(n, items) < K:
        return -1
    LO = -10**12; HI = 10**12
    best = -1
    bonus_candidates = sorted({0, 10**9, -10**9, 5*10**8, -5*10**8})
    def try_combo(B1, B2, P):
        nonlocal best
        val, cnts, sel = inner_weighted_schedule(n, items, B1, B2, P)
        if sel == K and cnts == (a, b, c):
            best = max(best, val)
    for B1 in bonus_candidates:
        for B2 in bonus_candidates:
            lo, hi = LO, HI
            for _ in range(50):
                mid = (lo + hi) // 2
                _, _, sel = inner_weighted_schedule(n, items, B1, B2, mid)
                if sel > K:
                    lo = mid + 1
                else:
                    hi = mid
            for P in range(hi - 2, hi + 3):
                _, _, sel = inner_weighted_schedule(n, items, B1, B2, P)
                if sel == K:
                    for d1 in (-2, -1, 0, 1, 2):
                        for d2 in (-2, -1, 0, 1, 2):
                            try_combo(B1 + d1, B2 + d2, P)
    return best

def solve_all():
    t, cases = read_input()
    out = []
    for n, a, b, c, items in cases:
        out.append(str(solve_case(n, a, b, c, items)))
    print("\n".join(out))

def _self_tests():
    # 3 basic checks
    n = 3; a = b = c = 0
    items = [(5,1,1),(6,2,2),(7,3,3)]
    assert solve_case(n, a, b, c, items) == 0
    n = 3; a = 2; b = c = 0
    items = [(5,1,1),(6,1,2),(7,1,1)]
    assert solve_case(n, a, b, c, items) in (13,)
    n = 3; a = 2; b = c = 0
    items = [(5,1,1),(6,1,1),(7,1,1)]
    assert solve_case(n, a, b, c, items) == -1

if __name__ == "__main__":
    data = sys.stdin.read().strip()
    if data:
        sys.stdin = sys.__stdin__
        sys.stdout = sys.__stdout__
        sys.stdin.write(data)
        sys.stdin.seek(0)
        solve_all()
    else:
        _self_tests()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize sum of rewards under deadlines with exactly $a,b,c$ picks by topic.}
\WHY{Combines classic scheduling-by-deadline with partition quotas — a prototypical matroid intersection scenario.}
\CHECKLIST{
\begin{bullets}
\item Check immediate infeasibility: $a>|T_1|$ etc., $K>a+b+c>n$, and cardinality-only feasibility $\ge K$.
\item Sort by deadlines; inner greedy uses a min-heap.
\item Ensure skipping is allowed by dropping negative adjusted weights at the end.
\item Tune Lagrangian bonuses and penalty to meet exact counts and total $K$.
\item Track per-type counts and total reward from original $r_i$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All tasks have the same earliest deadline (e.g., $d_i=1$).
\item Some types have quota $0$.
\item Rewards include $0$ and many ties.
\item $K=0$ should yield $0$ immediately.
\item Very skewed quotas where one type nearly equals $K$.
\item Maximal deadlines $d_i=n$ allowing late scheduling.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to allow skipping (negative adjusted weights kept).
\item Off-by-one in deadline feasibility (using strict $<$ vs $\le$).
\item Not removing the smallest when heap size exceeds $d$.
\item Using $d$ unsorted or mixing days and indices.
\item Overflow if summing 64-bit reward totals in languages without big integers.
\item Mismanaging per-type counts when popping from the heap.
\end{bullets}}
\FAILMODES{Greedy-per-type heuristic can fail when a locally large reward blocks a necessary later pick with a tighter deadline in another type. The Lagrangian approach avoids this by globally optimizing weighted sums under deadlines.}
\ELI{You have three buckets of tasks, each with a latest day to do them and a value. There is room for only one task per day. To get the best total, we reweight tasks to gently steer how many we pick from each bucket, then run the standard “by deadline, keep the best” greedy. We adjust the steering until the exact quotas are met.}
\NotePages{3}

\end{document}