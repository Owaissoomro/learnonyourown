% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Chess Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1569/B}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{A chess tournament will be held soon, where $n$ chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.

Each of the players has their own expectations about the tournament, they can be one of two types:
\begin{enumerate}
\item a player wants not to lose any game (i.\,e. finish the tournament with zero losses);
\item a player wants to win at least one game.
\end{enumerate}

You have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it is impossible.

Input: The first line contains a single integer $t$ ($1 \le t \le 200$) — the number of test cases.

The first line of each test case contains one integer $n$ ($2 \le n \le 50$) — the number of chess players.

The second line contains the string $s$ ($|s| = n$; $s_i \in \{1, 2\}$). If $s_i = 1$, then the $i$-th player has expectations of the first type, otherwise of the second type.

Output: For each test case, print the answer in the following format:

In the first line, print NO if it is impossible to meet the expectations of all players.

Otherwise, print YES, and the matrix of size $n \times n$ in the next $n$ lines.

The matrix element in the $i$-th row and $j$-th column should be equal to:
\begin{itemize}
\item +, if the $i$-th player won in a game against the $j$-th player;
\item -, if the $i$-th player lost in a game against the $j$-th player;
\item =, if the $i$-th and $j$-th players' game resulted in a draw;
\item X, if $i = j$.
\end{itemize}}
\BREAKDOWN{Partition players by type. Decide feasibility and construct a result matrix meeting all constraints. If feasible, ensure every type-2 player gets at least one win while type-1 players never lose.}
\ELI{Type-1s draw with everyone; type-2s form a cycle of wins among themselves if there are at least three of them.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$: integer in $[1,200]$.
\item For each test case: $n$ in $[2,50]$ and a string $s$ of length $n$ over $\{1,2\}$.
\end{bullets}}
\OUTPUTS{For each test case:
\begin{bullets}
\item Print NO if impossible.
\item Otherwise print YES, then an $n \times n$ matrix over the alphabet $\{+, -, =, X\}$ where row $i$, column $j$ denotes the result from player $i$'s perspective.
\end{bullets}}
\SAMPLES{Example 1:
\[
\begin{aligned}
t&=1,~n=3,~s=\text{``111''} \\
\text{Output: }&\text{YES}\ \text{and all off-diagonal entries are }=\text{, diagonals are X.}
\end{aligned}
\]
Example 2:
\[
\begin{aligned}
t&=1,~n=4,~s=\text{``2211''} \\
\text{Output: }&\text{NO (exactly two type-2 players is impossible).}
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let players be indexed $1,\ldots,n$. Partition $[n]$ into $A=\{i:s_i=1\}$ and $B=\{i:s_i=2\}$. We seek a skew-symmetric outcome matrix $M\in\{+, -, =, X\}^{n\times n}$ with $M_{ii}=\text{X}$, $M_{ij}\in\{+, -, =\}$, and $M_{ij}=$ the inverse of $M_{ji}$ for $i\ne j$, satisfying:
\begin{bullets}
\item For $i\in A$, $M_{ij}\in\{=,+\}$ for all $j\ne i$ (never loses).
\item For $i\in B$, there exists $j\ne i$ with $M_{ij}=+$ (at least one win).
\end{bullets}}
\varmapStart
\var{n}{number of players}
\var{s}{preference string in $\{1,2\}^n$}
\var{A}{indices wanting no losses}
\var{B}{indices wanting at least one win}
\var{M}{outcome matrix over $\{+, -, =, X\}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\forall i:\ M_{ii}=\text{X},\quad \forall i\ne j:\ (M_{ij}=+ \Leftrightarrow M_{ji}=-),~(M_{ij}== \Leftrightarrow M_{ji}==).\\
&\forall i\in A:\ \forall j\ne i,\ M_{ij}\in\{=,+\}.\\
&\forall i\in B:\ \exists j\ne i\ \text{with } M_{ij}=+.
\end{aligned}
\]
}
\ASSUMPTIONS{Standard round-robin with one game per unordered pair. All players always choose a consistent result.}
\INVARIANTS{
\begin{bullets}
\item Skew-symmetry: results are mutual inverses off-diagonal.
\item Type-1 rows contain no '-' symbols.
\item If $|B|\ge 3$, a directed cycle on $B$ ensures each type-2 has a win.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct constructive check: it is feasible iff $|B|\notin\{1,2\}$. If feasible, set all matches to draws except orient a simple cycle within $B$ giving each type-2 one win (and one loss).}
\ASSUMPTIONS{Type-1 vs anyone can be set to draw without harming type-2 winning at least once.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count $k=|B|$; if $k\in\{1,2\}$, print NO.
\item Initialize $M$ with $M_{ii}=\text{X}$ and $M_{ij}==$ for $i\ne j$.
\item If $k\ge 3$, list $B=(b_0,\ldots,b_{k-1})$ and set $M_{b_i,b_{(i+1)\bmod k}}=+$ and $M_{b_{(i+1)\bmod k},b_i}=-$ for all $i$.
\end{algosteps}
\COMPLEXITY{All operations are linear or quadratic in $n$.
\[
\begin{aligned}
T(n) &= \Theta(n^2)\ \text{to fill the matrix},\\
S(n) &= \Theta(n^2)\ \text{to store the matrix}.
\end{aligned}
\]
}
\CORRECTNESS{If $k=0$, all draws satisfy all constraints. If $k\ge 3$, each $b_i$ wins against its successor, satisfying the at-least-one-win requirement; all type-1s never lose since their row has only '=' except possibly '+'. For $k=1$ or $k=2$, it is impossible because a simple cycle cannot be formed and with only one game between two type-2s, both cannot obtain a win simultaneously.}
\EDGECASES{All players are type-1; exactly one or two type-2s; minimal $n=2$; maximal $n=50$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = list(next(it).strip())
        assert len(s) == n
        tests.append((n, "".join(s)))
    return tests

def solve_case(n: int, s: str):
    twos = [i for i, ch in enumerate(s) if ch == '2']
    k = len(twos)
    if k in (1, 2):
        return False, []
    # Build matrix
    M = [['=' for _ in range(n)] for _ in range(n)]
    for i in range(n):
        M[i][i] = 'X'
    if k >= 3:
        for idx in range(k):
            a = twos[idx]
            b = twos[(idx + 1) % k]
            M[a][b] = '+'
            M[b][a] = '-'
    # Verify constraints defensively
    for i, ch in enumerate(s):
        if ch == '1':
            assert all(M[i][j] != '-' for j in range(n) if j != i)
        else:
            assert any(M[i][j] == '+' for j in range(n) if j != i)
    out = ["YES"]
    out.extend("".join(row) for row in M)
    return True, out

def solve_all():
    tests = read_input()
    out_lines = []
    for n, s in tests:
        ok, res = solve_case(n, s)
        if not ok:
            out_lines.append("NO")
        else:
            out_lines.extend(res)
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # k = 0: all draws
    ok, res = solve_case(3, "111")
    assert ok and res[0] == "YES"
    grid = res[1:]
    assert all(grid[i][i] == 'X' for i in range(3))
    assert all(grid[i][j] == '=' for i in range(3) for j in range(3) if i != j)
    # k = 1: impossible
    ok, _ = solve_case(2, "12")
    assert not ok
    # k = 3: cycle exists
    ok, res = solve_case(3, "222")
    assert ok
    grid = res[1:]
    wins = [grid[i].count('+') for i in range(3)]
    assert all(w >= 1 for w in wins)

if __name__ == "__main__":
    if sys.stdin.isatty():
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked three scenarios: all type-1s; one type-2 (impossible); all type-2s of size three (cycle).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same constructive logic, but we pre-fill rows for type-1 players early and maintain a list of type-2 indices to orient a cycle in $O(|B|)$.}
\ASSUMPTIONS{Skew-symmetric outcomes allow setting draws first, then patching only the $|B|$ cycle edges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Identify $B$ quickly via one pass over $s$.
\item Initialize $M$ with $X$ on the diagonal and $=$ elsewhere.
\item If $|B|\ge 3$, orient a directed simple cycle on $B$ with $|B|$ assignments.
\end{algosteps}
\COMPLEXITY{Same as baseline but with fewer writes when $|B|$ is small relative to $n$.
\[
\begin{aligned}
T(n) &= \Theta(n^2) \text{ for output size lower bound.}
\end{aligned}
\]
}
\CORRECTNESS{Unchanged; cycle guarantees one win for each type-2; type-1s never lose.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        assert len(s) == n
        tests.append((n, s))
    return tests

def solve_case(n: int, s: str):
    b = [i for i, ch in enumerate(s) if ch == '2']
    if len(b) in (1, 2):
        return False, []
    M = [['=' for _ in range(n)] for _ in range(n)]
    for i in range(n):
        M[i][i] = 'X'
    if len(b) >= 3:
        for i in range(len(b)):
            u, v = b[i], b[(i + 1) % len(b)]
            M[u][v] = '+'
            M[v][u] = '-'
    # Sanity checks
    for i, ch in enumerate(s):
        if ch == '1':
            assert all(M[i][j] != '-' for j in range(n) if j != i)
        else:
            assert any(M[i][j] == '+' for j in range(n) if j != i)
    out = ["YES"] + ["".join(row) for row in M]
    return True, out

def solve_all():
    tests = read_input()
    out = []
    for n, s in tests:
        ok, res = solve_case(n, s)
        if not ok:
            out.append("NO")
        else:
            out.extend(res)
    sys.stdout.write("\n".join(out))

def _tests():
    # Two type-2s -> NO
    ok, _ = solve_case(4, "2211")
    assert not ok
    # Zero type-2s -> YES + all draws
    ok, res = solve_case(2, "11")
    assert ok and res[0] == "YES"
    grid = res[1:]
    assert grid[0][1] == '=' and grid[1][0] == '='
    # Many type-2s -> each has at least one '+'
    ok, res = solve_case(5, "21222")
    assert ok
    grid = res[1:]
    n = 5
    for i, ch in enumerate("21222"):
        if ch == '2':
            assert any(grid[i][j] == '+' for j in range(n) if j != i)

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Covered $|B|\in\{0,2,3\}$ and mixed strings ensuring at least one win for each type-2.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Characterization: Feasible iff $|B|\notin\{1,2\}$. Construction: type-1 rows are draws, type-2s form a directed simple cycle of wins.}
\ASSUMPTIONS{One game per pair; the matrix must be printed, imposing an $\Omega(n^2)$ time lower bound for any algorithm.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $B=\{i:s_i=2\}$; if $|B|\in\{1,2\}$, print NO.
\item Initialize all off-diagonals to '=' and diagonals to 'X'.
\item For $|B|\ge 3$, for each consecutive pair in $B$ cyclically, set a win/loss accordingly.
\end{algosteps}
\OPTIMALITY{Decision runs in $O(n)$ and output construction in $O(n^2)$, which is optimal due to output size. No algorithm can asymptotically beat printing the matrix.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n)=\Theta(n^2).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        tests.append((n, s))
    return tests

def solve_case(n: int, s: str):
    two_idx = [i for i, ch in enumerate(s) if ch == '2']
    k = len(two_idx)
    if k in (1, 2):
        return False, []
    M = [['=' for _ in range(n)] for _ in range(n)]
    for i in range(n):
        M[i][i] = 'X'
    if k >= 3:
        for i in range(k):
            u, v = two_idx[i], two_idx[(i + 1) % k]
            M[u][v] = '+'
            M[v][u] = '-'
    out = ["YES"] + ["".join(row) for row in M]
    # Defensive verification (can be removed in production)
    for i, ch in enumerate(s):
        if ch == '1':
            assert '-' not in out[1 + i]
        else:
            assert '+' in out[1 + i]
    return True, out

def solve_all():
    tests = read_input()
    out_lines = []
    for n, s in tests:
        ok, res = solve_case(n, s)
        if not ok:
            out_lines.append("NO")
        else:
            out_lines.extend(res)
    sys.stdout.write("\n".join(out_lines))

def _mini_tests():
    # Minimal n=2, impossible if one or two type-2s
    ok, _ = solve_case(2, "12")
    assert not ok
    ok, _ = solve_case(2, "22")
    assert not ok
    # All type-1s
    ok, res = solve_case(4, "1111")
    assert ok and all(row.count('-') == 0 for row in res[1:])
    # Mixed with k=3
    ok, res = solve_case(5, "21222")
    assert ok
    grid = res[1:]
    for i, ch in enumerate("21222"):
        if ch == '2':
            assert any(grid[i][j] == '+' for j in range(5) if j != i)

if __name__ == "__main__":
    if sys.stdin.isatty():
        _mini_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Exactly three checks: $n=2$ with strings "12" and "22" both NO; $n=4$ with "1111" all draws; $n=5$ with "21222" each type-2 has a win.}
\RESULT{Print NO iff the instance is infeasible. Otherwise, print YES and a valid outcome matrix; tie-breaking among multiple valid matrices is arbitrary.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover feasibility boundaries $|B|\in\{0,1,2,3\}$, random mixes, and ensure skew-symmetry and constraints.}
\LINE{CROSS-CHECKS}{Compare matrices from different implementations on small random seeds for identical feasibility decisions and constraint satisfaction.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with clustered type-2 indices, alternating patterns, and extremes (all '1's, all '2's).}
\begin{minted}{python}
import random

def gen_cases(max_n=8, trials=50, seed=7):
    random.seed(seed)
    for _ in range(trials):
        n = random.randint(2, max_n)
        s = "".join(random.choice("12") for _ in range(n))
        yield n, s

def check_matrix(n, s, out_lines):
    assert out_lines[0] in ("YES", "NO")
    if out_lines[0] == "NO":
        # Infeasible iff count of '2' is 1 or 2
        return (s.count('2') in (1, 2))
    grid = out_lines[1:]
    assert len(grid) == n
    for i in range(n):
        assert len(grid[i]) == n
        for j in range(n):
            if i == j:
                assert grid[i][j] == 'X'
            else:
                a, b = grid[i][j], grid[j][i]
                assert (a, b) in {('=','='), ('+','-'), ('-','+')}
    for i, ch in enumerate(s):
        row = grid[i]
        if ch == '1':
            assert '-' not in row
        else:
            assert '+' in row
    return True

# Example cross-check using the final solve_case from Approach C
def cross_check():
    from typing import Tuple, List
    def solve_case_final(n: int, s: str) -> Tuple[bool, List[str]]:
        two_idx = [i for i, ch in enumerate(s) if ch == '2']
        k = len(two_idx)
        if k in (1, 2):
            return False, []
        M = [['=' for _ in range(n)] for _ in range(n)]
        for i in range(n):
            M[i][i] = 'X'
        if k >= 3:
            for i in range(k):
                u, v = two_idx[i], two_idx[(i + 1) % k]
                M[u][v] = '+'
                M[v][u] = '-'
        out = ["YES"] + ["".join(row) for row in M]
        return True, out

    for n, s in gen_cases():
        ok, res = solve_case_final(n, s)
        if not ok:
            assert s.count('2') in (1, 2)
        else:
            assert check_matrix(n, s, res)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        tests.append((n, s))
    return tests

def solve_case(n: int, s: str):
    twos = [i for i, ch in enumerate(s) if ch == '2']
    k = len(twos)
    if k in (1, 2):
        return False, []
    M = [['=' for _ in range(n)] for _ in range(n)]
    for i in range(n):
        M[i][i] = 'X'
    if k >= 3:
        for i in range(k):
            a = twos[i]
            b = twos[(i + 1) % k]
            M[a][b] = '+'
            M[b][a] = '-'
    out = ["YES"] + ["".join(row) for row in M]
    return True, out

def solve_all():
    tests = read_input()
    out_lines = []
    for n, s in tests:
        ok, res = solve_case(n, s)
        if not ok:
            out_lines.append("NO")
        else:
            out_lines.extend(res)
    sys.stdout.write("\n".join(out_lines))

def _asserts():
    # Exactly two type-2s: impossible
    ok, _ = solve_case(4, "2211")
    assert not ok
    # Zero type-2s: all draws
    ok, res = solve_case(3, "111")
    assert ok
    grid = res[1:]
    assert all(grid[i][i] == 'X' for i in range(3))
    assert all(grid[i][j] == '=' for i in range(3) for j in range(3) if i != j)
    # Three type-2s: possible and each has a win
    ok, res = solve_case(5, "21222")
    assert ok
    grid = res[1:]
    for i, ch in enumerate("21222"):
        if ch == '2':
            assert any(grid[i][j] == '+' for j in range(5) if j != i)

if __name__ == "__main__":
    if sys.stdin.isatty():
        _asserts()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Feasible iff the number of type-2 players is not 1 or 2; construct by draws plus a win-cycle among type-2s.}
\WHY{This pattern tests constructive reasoning and feasibility characterization common in competitive programming interviews.}
\CHECKLIST{
\begin{bullets}
\item Count type-2s.
\item If count is 1 or 2, answer NO.
\item Initialize matrix with '=' and 'X'.
\item If count $\ge 3$, orient a cycle among type-2s.
\item Print the matrix.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=2$ with "11" (YES, symmetric draws).
\item $n=2$ with "12" or "22" (NO).
\item Exactly one type-2 among many type-1s (NO).
\item Exactly two type-2s regardless of $n$ (NO).
\item All type-2s with $n\ge 3$ (YES via full cycle).
\item Mixed strings with sparse type-2s (YES if count $\ge 3$).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to set diagonal to 'X'.
\item Breaking skew-symmetry when assigning wins and losses.
\item Accidentally assigning a '-' in a type-1 row.
\item Handling $|B|=0$ incorrectly (still YES).
\item Off-by-one when linking cycle endpoints.
\item Printing format: exactly $n$ lines after YES.
\end{bullets}}
\FAILMODES{Any approach forcing type-2s to defeat type-1s will violate type-1 constraints. With $|B|\in\{1,2\}$, no construction suffices; the cycle-based method detects this and reports NO.}
\ELI{Let cautious players draw with everyone. If there are at least three ambitious players, have them beat each other in a circle so each one gets a win. With only one or two ambitious players, this is impossible.}
\NotePages{3}

\end{document}