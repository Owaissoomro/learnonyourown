% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Modify the Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/modify-the-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given a 0-indexed $m \times n$ integer matrix \texttt{matrix}, create a new 0-indexed matrix called \texttt{answer}. Make \texttt{answer} equal to \texttt{matrix}, then replace each element with the value $-1$ with the maximum element in its respective column. Return \textit{the matrix} \texttt{answer}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{matrix = [[1,2,-1],[4,-1,6],[7,8,9]]}

\quad \textbf{Output:} \texttt{[[1,2,9],[4,8,6],[7,8,9]]}

\quad \textbf{Explanation:} The diagram above shows the elements that are changed (in blue).
\begin{bullets}
\item We replace the value in the cell \texttt{[1][1]} with the maximum value in the column 1, that is 8.
\item We replace the value in the cell \texttt{[0][2]} with the maximum value in the column 2, that is 9.
\end{bullets}

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{matrix = [[3,-1],[5,2]]}

\quad \textbf{Output:} \texttt{[[3,2],[5,2]]}

\quad \textbf{Explanation:} The diagram above shows the elements that are changed (in blue).

\textbf{Constraints:}
\begin{bullets}
\item $m = \texttt{matrix.length}$
\item $n = \texttt{matrix[i].length}$
\item $2 \le m, n \le 50$
\item $-1 \le \texttt{matrix[i][j]} \le 100$
\item The input is generated such that each column contains at least one non-negative integer.
\end{bullets}}
\BREAKDOWN{Compute the maximum of each column once and then replace every occurrence of $-1$ in that column with this maximum. Preserve all other entries.}
\ELI{For each column, find its biggest number and use it to fill the $-1$ holes in that column.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists \texttt{matrix} with shape $m \times n$, where $2 \le m,n \le 50$ and entries are integers in $[-1,100]$. At least one non-negative integer exists in every column.}
\OUTPUTS{A new matrix \texttt{answer} of the same shape where every $-1$ in column $j$ is replaced with the column maximum of column $j$.}
\SAMPLES{
\textbf{Sample A}

Input: \texttt{[[1,2,-1],[4,-1,6],[7,8,9]]}

Output: \texttt{[[1,2,9],[4,8,6],[7,8,9]]}

\textbf{Sample B}

Input: \texttt{[[3,-1],[5,2]]}

Output: \texttt{[[3,2],[5,2]]}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M \in \mathbb{Z}^{m \times n}$ be the input matrix and $A \in \mathbb{Z}^{m \times n}$ the output. For each column $j$, define $c_j = \max_{0 \le i < m} M_{i,j}$. Then for each entry:
\[
A_{i,j} =
\begin{cases}
M_{i,j}, & \text{if } M_{i,j} \ne -1,\\
c_j, & \text{if } M_{i,j} = -1.
\end{cases}
\] }
\varmapStart
\var{m,n}{matrix dimensions}
\var{M_{i,j}}{input value at row $i$, column $j$}
\var{A_{i,j}}{output value at row $i$, column $j$}
\var{c_j}{maximum value in column $j$ of $M$}
\varmapEnd
\GOVERN{
\[
c_j = \max_{0 \le i < m} M_{i,j},\quad
A_{i,j} = \begin{cases}
M_{i,j} & \text{if } M_{i,j} \ne -1,\\
c_j & \text{if } M_{i,j} = -1.
\end{cases}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Indexing is 0-based: $i \in \{0,\ldots,m-1\}$, $j \in \{0,\ldots,n-1\}$.
\item Every column has at least one non-negative element, so $c_j$ is well-defined and non-negative.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item Entries not equal to $-1$ are preserved: if $M_{i,j} \ne -1$, then $A_{i,j} = M_{i,j}$.
\item All $-1$ entries become the same value within a column, namely $c_j$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each cell equal to $-1$, scan its entire column to compute the maximum $c_j$ on the fly, then replace.}
\ASSUMPTIONS{Direct scanning with no preprocessing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Copy \texttt{matrix} into \texttt{answer}.
\item For each cell $(i,j)$, if \texttt{answer[i][j] == -1}, compute the maximum of column $j$ by scanning all $m$ rows, then set \texttt{answer[i][j]} to that maximum.
\item Return \texttt{answer}.
\end{algosteps}
\COMPLEXITY{In the worst case with many $-1$ entries, each such cell triggers an $O(m)$ column scan. With up to $mn$ such cells, $T(n)$ is $O(m^2 n)$, space $S(n)$ is $O(mn)$ for the copy.}
\[
\begin{aligned}
T(m,n) &\le mn \cdot O(m) = O(m^2 n), \\
S(m,n) &= O(mn).
\end{aligned}
\]
\CORRECTNESS{Each $-1$ is replaced by the true column maximum at the time of computation, which equals the original column maximum since non-$-1$ values are never altered. Non-$-1$ entries remain unchanged.}
\EDGECASES{
\begin{bullets}
\item Columns with exactly one non-negative element.
\item Rows or columns containing no $-1$ values.
\item All entries non-negative (output equals input).
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0]) if m > 0 else 0
        # Copy the matrix
        ans = [row[:] for row in matrix]
        # For each -1, recompute the column maximum on the fly
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    colmax = matrix[0][j]
                    for r in range(1, m):
                        if matrix[r][j] > colmax:
                            colmax = matrix[r][j]
                    ans[i][j] = colmax
        return ans

# Basic tests for the baseline approach
s = Solution()
assert s.modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]]
assert s.modifiedMatrix([[3,-1],[5,2]]) == [[3,2],[5,2]]
# Edge: no -1 present
assert s.modifiedMatrix([[0,1],[2,3]]) == [[0,1],[2,3]]
\end{minted}
\VALIDATION{Checked sample cases and a no-replacement case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Precompute all column maxima once, then do a single pass to fill $-1$ entries.}
\ASSUMPTIONS{Use an auxiliary array \texttt{colmax} of length $n$ storing $c_j$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute \texttt{colmax[j]} as the maximum of column $j$ across all rows.
\item Copy \texttt{matrix} into \texttt{answer}.
\item For each cell $(i,j)$, if \texttt{answer[i][j] == -1}, set \texttt{answer[i][j] = colmax[j]}.
\end{algosteps}
\COMPLEXITY{Computing column maxima takes $O(mn)$; the fill pass is $O(mn)$. Total $T(m,n)=O(mn)$, $S(m,n)=O(m+n)$ (copy plus column maxima).}
\[
\begin{aligned}
T(m,n) &= O(mn) + O(mn) = O(mn),\\
S(m,n) &= O(mn) \text{ (for the copy) } + O(n).
\end{aligned}
\]
\CORRECTNESS{By definition of \texttt{colmax[j]} as the maximum of column $j$, replacing each $-1$ in column $j$ with \texttt{colmax[j]} yields the specified output. Non-$-1$ entries are preserved by copying.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0]) if m > 0 else 0
        # Precompute column maxima
        colmax = [float("-inf")] * n
        for j in range(n):
            mx = matrix[0][j]
            for i in range(1, m):
                if matrix[i][j] > mx:
                    mx = matrix[i][j]
            colmax[j] = mx
        # Build the answer with replacements for -1
        ans = [row[:] for row in matrix]
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    ans[i][j] = colmax[j]
        return ans

# Tests
s = Solution()
assert s.modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]]
assert s.modifiedMatrix([[3,-1],[5,2]]) == [[3,2],[5,2]]
# Column with a single non-negative value
assert s.modifiedMatrix([[-1,5],[-1,0],[7,-1]]) == [[7,5],[7,0],[7,5]]
\end{minted}
\VALIDATION{Covers samples and a case where each column has exactly one non-negative value to ensure correct propagation.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same as Approach B: a single pass to compute column maxima, followed by a single fill pass. This is optimal up to constant factors because every entry must be inspected at least once.}
\ASSUMPTIONS{Finite $m,n$ with at least one non-negative per column, ensuring maxima are well-defined.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \texttt{colmax[j]} for all columns $j$ in $O(mn)$ time.
\item Copy the matrix to \texttt{answer}.
\item Replace $-1$ entries using \texttt{colmax[j]} and return \texttt{answer}.
\end{algosteps}
\OPTIMALITY{Any algorithm must read all $mn$ inputs to know which cells are $-1$ and to determine each column's maximum. Hence $\Omega(mn)$ is a lower bound. The method achieves $O(mn)$ and is therefore asymptotically optimal.}
\COMPLEXITY{
\[
\begin{aligned}
T(m,n) &= O(mn), \\
S(m,n) &= O(mn) \text{ for the output plus } O(n) \text{ for column maxima.}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0]) if m > 0 else 0
        # Compute column maxima
        colmax = [float("-inf")] * n
        for j in range(n):
            mx = matrix[0][j]
            for i in range(1, m):
                if matrix[i][j] > mx:
                    mx = matrix[i][j]
            colmax[j] = mx
        # Produce the answer
        ans = [row[:] for row in matrix]
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    ans[i][j] = colmax[j]
        return ans

# Exactly 3 asserts (samples + a custom check)
s = Solution()
assert s.modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]]
assert s.modifiedMatrix([[3,-1],[5,2]]) == [[3,2],[5,2]]
assert s.modifiedMatrix([[-1,-1,4],[0,-1,1]]) == [[0,0,4],[0,0,1]]
\end{minted}
\VALIDATION{Three asserts confirm the two samples and a mixed case with multiple $-1$ per column.}
\RESULT{Return the updated matrix \texttt{answer}; ties are irrelevant since we always use the column maximum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{
\begin{bullets}
\item Samples from the prompt.
\item No-replacement case: all entries non-negative.
\item Heavy-replacement case: many $-1$ per column.
\item Columns with exactly one non-negative value.
\end{bullets}
}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (baseline) and Approach B/C (optimal) on small random-like matrices to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Produce small deterministic matrices covering: no $-1$, many $-1$, single non-negative per column, varying $m,n$.}
\begin{minted}{python}
from typing import List

def gen_matrices():
    cases = []
    # No -1
    cases.append([[0,1],[2,3]])
    # All -1 except one per column
    cases.append([[-1,5],[-1,0],[7,-1]])
    # Mixed
    cases.append([[1,-1,-1],[4,2,-1],[-1,3,0]])
    # Single row or column are disallowed by constraints, but test near-boundary sizes
    cases.append([[ -1,  2, -1,  0],
                  [  5, -1, -1, -1],
                  [ -1,  1,  9, -1]])
    return cases

class Baseline:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix); n = len(matrix[0]) if m > 0 else 0
        ans = [row[:] for row in matrix]
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    colmax = matrix[0][j]
                    for r in range(1, m):
                        if matrix[r][j] > colmax:
                            colmax = matrix[r][j]
                    ans[i][j] = colmax
        return ans

class Optimal:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix); n = len(matrix[0]) if m > 0 else 0
        colmax = [float("-inf")] * n
        for j in range(n):
            mx = matrix[0][j]
            for i in range(1, m):
                if matrix[i][j] > mx:
                    mx = matrix[i][j]
            colmax[j] = mx
        ans = [row[:] for row in matrix]
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    ans[i][j] = colmax[j]
        return ans

# Cross-check
b = Baseline()
o = Optimal()
for mat in gen_matrices():
    assert b.modifiedMatrix(mat) == o.modifiedMatrix(mat)

# Reference implementation for submission
class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0]) if m > 0 else 0
        colmax = [float("-inf")] * n
        for j in range(n):
            mx = matrix[0][j]
            for i in range(1, m):
                if matrix[i][j] > mx:
                    mx = matrix[i][j]
            colmax[j] = mx
        ans = [row[:] for row in matrix]
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    ans[i][j] = colmax[j]
        return ans

# Final quick checks
s = Solution()
assert s.modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]]
assert s.modifiedMatrix([[3,-1],[5,2]]) == [[3,2],[5,2]]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0]) if m > 0 else 0
        # Precompute column maxima in one pass per column
        colmax = [float("-inf")] * n
        for j in range(n):
            mx = matrix[0][j]
            for i in range(1, m):
                if matrix[i][j] > mx:
                    mx = matrix[i][j]
            colmax[j] = mx
        # Build the answer by replacing -1 with the column maximum
        ans = [row[:] for row in matrix]
        for i in range(m):
            for j in range(n):
                if ans[i][j] == -1:
                    ans[i][j] = colmax[j]
        return ans

# Sanity tests
if __name__ == "__main__":
    s = Solution()
    assert s.modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]]
    assert s.modifiedMatrix([[3,-1],[5,2]]) == [[3,2],[5,2]]
    assert s.modifiedMatrix([[-1,5],[-1,0],[7,-1]]) == [[7,5],[7,0],[7,5]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Replace each $-1$ with its column maximum; keep other entries unchanged.}
\WHY{This pattern of precomputing per-column aggregates and then applying them is common in array and matrix problems.}
\CHECKLIST{
\begin{bullets}
\item Compute column maxima correctly for all columns.
\item Copy the matrix before modifying, or write into a new matrix.
\item Replace only entries equal to $-1$.
\item Return the new matrix.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No $-1$ in the matrix (output equals input).
\item Columns with exactly one non-negative element.
\item Multiple $-1$ in the same column.
\item Repeated maximum values in a column.
\item Negative numbers only allowed are $-1$; ensure not to treat other negatives that are disallowed by constraints.
\item Minimal sizes: $m=2$ or $n=2$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mutating the input in place when not intended; safer to build a copy.
\item Recomputing maxima repeatedly (leads to unnecessary $O(m^2 n)$).
\item Off-by-one in column or row loops.
\item Assuming columns might be empty; constraints prevent this.
\item Using uninitialized maxima; initialize with the first element of the column.
\item Forgetting that $-1$ can appear alongside non-negative numbers in the same column.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Baseline method may time out for very large $m,n$ in other contexts; here constraints are small, but the optimal $O(mn)$ method is robust.
\end{bullets}
}
\ELI{Find the biggest number in each column, then fill every $-1$ in that column with that number. Everything else stays the same.}
\NotePages{3}

\end{document}