% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Yet Another Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1783/C}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{You are participating in Yet Another Tournament. There are $n + 1$ participants: you and $n$ other opponents, numbered from $1$ to $n$.

Each two participants will play against each other exactly once. If the opponent $i$ plays against the opponent $j$, he wins if and only if $i > j$.

When the opponent $i$ plays against you, everything becomes a little bit complicated. In order to get a win against opponent $i$, you need to prepare for the match for at least $a_i$ minutes — otherwise, you lose to that opponent.

You have $m$ minutes in total to prepare for matches, but you can prepare for only one match at one moment. In other words, if you want to win against opponents $p_1, p_2, \dots, p_k$, you need to spend $a_{p_1} + a_{p_2} + \dots + a_{p_k}$ minutes for preparation — and if this number is greater than $m$, you cannot achieve a win against all of these opponents at the same time.

The final place of each contestant is equal to the number of contestants with strictly more wins $+$ $1$. For example, if $3$ contestants have $5$ wins each, $1$ contestant has $3$ wins and $2$ contestants have $1$ win each, then the first $3$ participants will get the $1$-st place, the fourth one gets the $4$-th place and two last ones get the $5$-th place.

Calculate the minimum possible place (lower is better) you can achieve if you cannot prepare for the matches more than $m$ minutes in total.

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains two integers $n$ and $m$ ($1 \le n \le 5 \cdot 10^5$; $0 \le m \le \sum\limits_{i=1}^{n}{a_i}$) — the number of your opponents and the total time you have for preparation.

The second line of each test case contains $n$ integers $a_1, a_2, \dots, a_n$ ($0 \le a_i \le 1000$), where $a_i$ is the time you need to prepare in order to win against the $i$-th opponent.

It is guaranteed that the total sum of $n$ over all test cases does not exceed $5 \cdot 10^5$.

Output:
For each test case, print the minimum possible place you can take if you can prepare for the matches no more than $m$ minutes in total.

Note:
In the first test case, you can prepare to all opponents, so you will win $4$ games and get the $1$-st place, since all your opponents win no more than $3$ games.

In the second test case, you can prepare against the second opponent and win. As a result, you will have $1$ win, opponent $1$ — $1$ win, opponent $2$ — $1$ win, opponent $3$ — $3$ wins. So, opponent $3$ will take the $1$-st place, and all other participants, including you, get the $2$-nd place.

In the third test case, you have no time to prepare at all, so you will lose all games. Since each opponent has at least $1$ win, you will take the last place (place $6$).

In the fourth test case, you have no time to prepare, but you can still win against the first opponent. As a result, opponent $1$ has no wins, you have $1$ win and all others have at least $2$ wins. So your place is $4$.}
\BREAKDOWN{Choose a subset of opponents to beat within time $m$ to minimize the number of contestants with strictly more wins than you. Opponents' mutual results are fixed by their indices; only your matches are controllable.}
\ELI{Beat as many cheap opponents as possible, and if you can also beat opponent $k{+}1$ (where $k$ is your number of wins), you improve your place by $1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$: integer, number of test cases ($1 \le t \le 10^4$).
\item For each test:
\begin{bullets}
\item $n$: integer, number of opponents ($1 \le n \le 5 \cdot 10^5$).
\item $m$: integer, total preparation minutes ($0 \le m \le \sum a_i$).
\item $a_1,\ldots,a_n$: integers ($0 \le a_i \le 1000$).
\end{bullets}
\end{bullets}
Total $\sum n \le 5 \cdot 10^5$.}
\OUTPUTS{For each test case, a single integer: the minimum possible place (rank) you can achieve.}
\SAMPLES{
Example mini-cases:
\begin{bullets}
\item $n=4$, $m=4$, $a=[1,1,1,1]$ $\Rightarrow$ output $1$.
\item $n=3$, $m=2$, $a=[2,5,1]$ $\Rightarrow$ output $3$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Opponents are indexed $1,\ldots,n$. Opponent $i$ beats opponent $j$ iff $i>j$. Let $S\subseteq \{1,\ldots,n\}$ be the set of opponents you beat (by preparing), with $\sum_{i\in S} a_i \le m$. Your wins are $|S|=k$. Opponent $i$'s wins equal $(i-1) + \mathbf{1}[i\notin S]$. Your place is the number of contestants with strictly more wins than you plus $1$.}
\varmapStart
\var{n}{number of opponents}
\var{m}{total preparation minutes}
\var{a_i}{minutes needed to beat opponent $i$}
\var{S}{set of opponents you beat; $k=|S|$}
\var{k}{your number of wins}
\var{r}{index $k+1$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{place}(S) \;=\; \#\{\, i: (i-1)+\mathbf{1}[i\notin S] > k \,\} + 1 \;=\; (n-k) - \mathbf{1}[\,k{+}1 \in S\,] + 1.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $1$-based; all matches among opponents are deterministic by index ordering; you may choose any subset $S$ obeying the time budget.}
\INVARIANTS{
\begin{bullets}
\item Opponent $i \le k$ never has strictly more wins than you, regardless of $S$.
\item Opponent $i \ge k+2$ always has strictly more wins than you, even if $i \in S$.
\item Only opponent $k{+}1$ can be ``pulled down'' to not exceed you by including $k{+}1$ in $S$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{From the model, only $k$ and whether $k{+}1\in S$ matter for the place. For each $k$, check feasibility of picking any $k$ opponents within $m$, and separately feasibility of picking $k$ opponents including $k{+}1$.}
\ASSUMPTIONS{We can compute minimal costs by sorting $a_i$ once and using prefix sums; then try all $k$ from $0$ to $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build pairs $(a_i,i)$ and sort by $a_i$; compute prefix sums $\mathrm{pref}[t]$ of the $t$ cheapest costs.
\item For each $k$ from $0$ to $n$, feasibility of any $k$ wins is $\mathrm{pref}[k]\le m$.
\item For the same $k$, feasibility of including $k{+}1$ is:
\begin{bullets}
\item If the position of $k{+}1$ in the sorted list is $\le k$, then feasible with cost $\mathrm{pref}[k]$.
\item Else feasible iff $a_{k+1}+\mathrm{pref}[k-1]\le m$.
\end{bullets}
\item Track the best place $(n-k)+1-\mathbf{1}[\text{include }k{+}1]$ over feasible $k$.
\end{algosteps}
\COMPLEXITY{Sorting $O(n\log n)$; scanning $k$ is $O(n)$; per test $O(n\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n) = O(n\log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{The minimal cost to beat any $k$ opponents is the sum of the $k$ smallest $a_i$. The minimal cost to beat any $k$ opponents including $k{+}1$ is $a_{k+1}$ plus the sum of the $(k-1)$ smallest $a_i$ among the remaining opponents; this is realized by prefix sums after sorting. The place formula then follows directly from the invariants.}
\EDGECASES{Handle $k=0$ (cannot include $1$), $k=n$ (already first place), and equal costs (ties are harmless; existence is enough).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from bisect import bisect_right

def min_place_brutelike(a, m):
    n = len(a)
    pairs = sorted([(a[i], i + 1) for i in range(n)])
    pref = [0] * (n + 1)
    for i in range(1, n + 1):
        pref[i] = pref[i - 1] + pairs[i - 1][0]
    pos_of = [0] * (n + 1)  # 1-based id -> position in pairs (1..n)
    for p, (_, idx) in enumerate(pairs, start=1):
        pos_of[idx] = p

    best = n + 1  # worst place
    for k in range(0, n + 1):
        if pref[k] > m:
            continue  # cannot get k wins at all
        place = (n - k) + 1
        if k < n:
            r = k + 1
            can_bonus = False
            if pos_of[r] <= k:
                can_bonus = True
            elif k > 0:
                can_bonus = (pref[k - 1] + a[r - 1] <= m)
            # else k == 0: cannot include r
            if can_bonus:
                place -= 1
        best = min(best, place)
    return best

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, m, arr))
    return tests

def solve_case(n, m, arr):
    return min_place_brutelike(arr, m)

def solve_all(tests):
    out = []
    for n, m, arr in tests:
        out.append(str(solve_case(n, m, arr)))
    return "\n".join(out)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Quick asserts (do not print on success)
    assert min_place_brutelike([1,1,1,1], 4) == 1
    assert min_place_brutelike([2,5,1], 2) == 3
    assert min_place_brutelike([0,0,0], 0) == 1
    assert min_place_brutelike([1,3,4], 5) == 1
    # Ready for I/O
    main()
\end{minted}
\VALIDATION{Checked basic scenarios: all zero costs, no time, and a case where including $k{+}1$ reduces the place by $1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Maximal $k$ Only + One Bonus Check}
\WHICHFORMULA{It is never better to pick fewer wins just to include the bonus: for $k' < k$, $(n-k')+1-1 \ge (n-k)+1$. Hence, compute $k$ as the maximum number of wins achievable and then check the single bonus condition for $k{+}1$.}
\ASSUMPTIONS{Use prefix sums of sorted costs to get $k=\max\{t:\mathrm{pref}[t]\le m\}$ via binary search, then test whether including $k{+}1$ is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $(a_i,i)$ by $a_i$; compute prefix sums $\mathrm{pref}$.
\item Let $k=\mathrm{bisect\_right}(\mathrm{pref}, m)-1$.
\item Base answer: $(n-k)+1$.
\item If $k<n$ and either the sorted position of $k{+}1$ is $\le k$ or $\mathrm{pref}[k-1]+a_{k+1}\le m$ (when $k>0$), subtract $1$ from the answer.
\end{algosteps}
\COMPLEXITY{Same $O(n\log n)$ time, $O(n)$ space, but a single pass after binary search.}
\[
\begin{aligned}
T(n) &= O(n\log n), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{By the invariants, the only effect of $S$ beyond $k$ is potentially neutralizing opponent $k{+}1$. The minimal-cost inclusion test is exact by construction.}
\textbf{Code (Improved)}
\begin{minted}{python}
from bisect import bisect_right

def min_place_fast(a, m):
    n = len(a)
    pairs = sorted((a[i], i + 1) for i in range(n))
    pref = [0] * (n + 1)
    for i in range(1, n + 1):
        pref[i] = pref[i - 1] + pairs[i - 1][0]
    pos_of = [0] * (n + 1)
    for p, (_, idx) in enumerate(pairs, start=1):
        pos_of[idx] = p

    k = bisect_right(pref, m) - 1
    ans = (n - k) + 1
    if k < n:
        r = k + 1
        bonus = False
        if pos_of[r] <= k:
            bonus = True
        elif k > 0 and (pref[k - 1] + a[r - 1] <= m):
            bonus = True
        if bonus:
            ans -= 1
    return ans

def read_input():
    import sys
    it = iter(sys.stdin.read().strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, m, arr))
    return tests

def solve_case(n, m, arr):
    return min_place_fast(arr, m)

def solve_all(tests):
    return "\n".join(str(solve_case(n, m, arr)) for n, m, arr in tests)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Edge checks
    assert min_place_fast([1,1,1,1], 4) == 1
    assert min_place_fast([2,5,1], 2) == 3
    assert min_place_fast([0,0,0], 0) == 1
    assert min_place_fast([1,3,4], 5) == 1
    main()
\end{minted}
\VALIDATION{Covers zero-time, all-zero-costs, and a case where the ``bonus'' applies only via replacement ($k{-}1$ cheapest plus $k{+}1$).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prefix-Sum + One-Time Bonus Decision}
\WHICHFORMULA{Final method: maximize $k$ with prefix sums and apply the one-off inclusion check for opponent $k{+}1$.}
\ASSUMPTIONS{Applicable for all valid inputs; sorting by $a_i$ is sufficient since only costs matter for feasibility.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $(a_i,i)$ by $a_i$ and build $\mathrm{pref}$ and the map $\mathrm{pos\_of}[i]$.
\item Compute $k=\max\{t: \mathrm{pref}[t]\le m\}$ via binary search.
\item Set $\text{ans}=(n-k)+1$; if $k<n$ and either $\mathrm{pos\_of}[k{+}1]\le k$ or ($k>0$ and $\mathrm{pref}[k-1]+a_{k+1}\le m$), decrement $\text{ans}$.
\item Output $\text{ans}$.
\end{algosteps}
\OPTIMALITY{Any solution must sort or otherwise find the $k$ smallest costs; the decision about $k{+}1$ is necessary and sufficient by the problem's structure, giving a tight $O(n\log n)$ bound.}
\COMPLEXITY{$O(n\log n)$ time dominated by sorting; $O(n)$ memory.}
\[
\begin{aligned}
T(n) &= O(n\log n), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from bisect import bisect_right

def read_input():
    import sys
    it = iter(sys.stdin.read().strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, m, arr))
    return tests

def solve_case(n, m, a):
    pairs = sorted((a[i], i + 1) for i in range(n))
    pref = [0] * (n + 1)
    for i in range(1, n + 1):
        pref[i] = pref[i - 1] + pairs[i - 1][0]
    pos_of = [0] * (n + 1)
    for p, (_, idx) in enumerate(pairs, start=1):
        pos_of[idx] = p

    k = bisect_right(pref, m) - 1
    ans = (n - k) + 1
    if k < n:
        r = k + 1
        bonus = False
        if pos_of[r] <= k:
            bonus = True
        elif k > 0 and (pref[k - 1] + a[r - 1] <= m):
            bonus = True
        if bonus:
            ans -= 1
    return ans

def solve_all():
    tests = read_input()
    res = []
    for n, m, arr in tests:
        res.append(str(solve_case(n, m, arr)))
    return "\n".join(res)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(4, 4, [1,1,1,1]) == 1
    assert solve_case(3, 2, [2,5,1]) == 3
    assert solve_case(3, 5, [1,3,4]) == 1
    main()
\end{minted}
\VALIDATION{Three asserts exercise full coverage: full-coverage case, no-bonus case, and bonus-by-inclusion with $k<n$.}
\RESULT{For each test case, print the minimum achievable place (rank) given the budget $m$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the core solver on crafted cases: all-zero costs, zero budget, tight budget where only the bonus makes a difference, and full budget.}
\LINE{CROSS-CHECKS}{Compare results between Approaches A, B, and C on small random arrays to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with many zeros, many equal values, strictly increasing, and strictly decreasing values to stress sorting and prefix sums.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_zero(n):
    return [0]*n

def gen_increasing(n, base=1, step=1):
    return [base + i*step for i in range(n)]

def gen_equal(n, val):
    return [val]*n

def brute_compare():
    import random
    random.seed(0)
    for n in range(1, 30):
        for _ in range(200):
            a = [random.randint(0, 6) for _ in range(n)]
            m = random.randint(0, sum(a))
            v1 = min_place_brutelike(a, m)
            v2 = min_place_fast(a, m)
            assert v1 == v2, (n, m, a, v1, v2)

if __name__ == "__main__":
    # Quick self-checks for generators and cross-compare
    assert gen_all_zero(5) == [0,0,0,0,0]
    assert gen_increasing(4, base=2, step=3) == [2,5,8,11]
    assert gen_equal(3, 7) == [7,7,7]
    # Cross-check on small instances
    from bisect import bisect_right
    brute_compare()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from bisect import bisect_right

def read_input():
    import sys
    it = iter(sys.stdin.read().strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, m, arr))
    return tests

def solve_case(n, m, a):
    pairs = sorted((a[i], i + 1) for i in range(n))
    pref = [0] * (n + 1)
    for i in range(1, n + 1):
        pref[i] = pref[i - 1] + pairs[i - 1][0]
    pos_of = [0] * (n + 1)
    for p, (_, idx) in enumerate(pairs, start=1):
        pos_of[idx] = p
    k = bisect_right(pref, m) - 1
    ans = (n - k) + 1
    if k < n:
        r = k + 1
        bonus = False
        if pos_of[r] <= k:
            bonus = True
        elif k > 0 and (pref[k - 1] + a[r - 1] <= m):
            bonus = True
        if bonus:
            ans -= 1
    return ans

def solve_all(tests):
    return "\n".join(str(solve_case(n, m, arr)) for n, m, arr in tests)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Asserts
    assert solve_case(4, 4, [1,1,1,1]) == 1
    assert solve_case(3, 2, [2,5,1]) == 3
    assert solve_case(3, 0, [0,5,0]) == 2  # beat #1 and #3 for free -> k=2 -> rank 2
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the count of cheapest wins $k$, then check if you can also include opponent $k{+}1$ to gain one more position.}
\WHY{Common CF pattern: fixed tournament among others, your actions only affect edges incident to you; solve via sorting costs and a one-off adjustment.}
\CHECKLIST{
\begin{bullets}
\item Sort $(a_i,i)$; build prefix sums.
\item Compute $k=\max\{t:\mathrm{pref}[t]\le m\}$.
\item Base answer $(n-k)+1$.
\item If $k<n$ and (pos$(k{+}1)\le k$ or $\mathrm{pref}[k-1]+a_{k+1}\le m$ when $k>0$), decrement by $1$.
\item Output.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=0$: cannot include $1$; no bonus.
\item $k=n$: already first place; ignore bonus.
\item Many zeros: $k$ may jump to $n$ even for $m=0$.
\item Equal costs: existence is enough; any prefix set works.
\item Large $n$ across tests: ensure $O(n\log n)$ total and no per-test reallocation hot spots.
\item $m$ just below/above thresholds: verify binary search on prefix sums.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in defining $k$ vs.\ index $k{+}1$.
\item Accessing $\mathrm{pref}[k-1]$ when $k=0$ (guard it).
\item Confusing sorted position with original index; map them explicitly.
\item Forgetting that including indices $\ge k{+}2$ cannot reduce their wins below yours.
\item Using floating-point or 64-bit overflow (Python is safe; in C\texttt{++} use 64-bit).
\item Mishandling input when $t$ is large; prefer fast I/O and iterative parsing.
\end{bullets}
}
\FAILMODES{Greedy that tries to always include the next cheapest without considering the special role of opponent $k{+}1$ can miss the extra $-1$ improvement; our method explicitly checks and applies it.}
\ELI{Beat as many cheap players as you can. Then, try to also beat the specific player numbered $k{+}1$; if you can, you jump one more place because you prevent exactly that player from having more wins than you.}
\NotePages{3}

\end{document}