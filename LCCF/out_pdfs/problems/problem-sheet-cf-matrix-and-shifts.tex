% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Matrix and Shifts}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1660/E}}
\LINE{DIFFICULTY / RATING}{CF: 1660/E, Rating: 1600}
\STATEMENT{You are given a binary matrix $A$ of size $n \times n$. Rows are numbered from top to bottom from $1$ to $n$, columns are numbered from left to right from $1$ to $n$. The element located at the intersection of row $i$ and column $j$ is called $A_{ij}$. Consider a set of $4$ operations:
\begin{enumerate}
\item Cyclically shift all rows up. The row with index $i$ will be written in place of the row $i-1$ ($2 \le i \le n$), the row with index $1$ will be written in place of the row $n$.
\item Cyclically shift all rows down. The row with index $i$ will be written in place of the row $i+1$ ($1 \le i \le n - 1$), the row with index $n$ will be written in place of the row $1$.
\item Cyclically shift all columns to the left. The column with index $j$ will be written in place of the column $j-1$ ($2 \le j \le n$), the column with index $1$ will be written in place of the column $n$.
\item Cyclically shift all columns to the right. The column with index $j$ will be written in place of the column $j+1$ ($1 \le j \le n - 1$), the column with index $n$ will be written in place of the column $1$.
\end{enumerate}
The $3 \times 3$ matrix is shown on the left before the $3$-rd operation is applied to it, on the right — after.

You can perform an arbitrary (possibly zero) number of operations on the matrix; the operations can be performed in any order.

After that, you can perform an arbitrary (possibly zero) number of new xor-operations:
\begin{itemize}
\item Select any element $A_{ij}$ and assign it with new value $A_{ij} \oplus 1$. In other words, the value of $(A_{ij} + 1) \bmod 2$ will have to be written into element $A_{ij}$.
\end{itemize}
Each application of this xor-operation costs one burl. Note that the $4$ shift operations — are free. These $4$ operations can only be performed before xor-operations are performed.

Output the minimum number of burles you would have to pay to make the $A$ matrix unitary. A unitary matrix is a matrix with ones on the main diagonal and the rest of its elements are zeros (that is, $A_{ij} = 1$ if $i = j$ and $A_{ij} = 0$ otherwise).

Input: The first line of the input contains an integer $t$ ($1 \le t \le 10^4$) — the number of test cases in the test.

The descriptions of the test cases follow. Before each test case, an empty line is written in the input.

The first line of each test case contains a single number $n$ ($1 \le n \le 2000$).

This is followed by $n$ lines, each containing exactly $n$ characters and consisting only of zeros and ones. These lines describe the values in the elements of the matrix.

It is guaranteed that the sum of $n^2$ values over all test cases does not exceed $4 \cdot 10^6$.

Output: For each test case, output the minimum number of burles you would have to pay to make the $A$ matrix unitary. In other words, print the minimum number of xor-operations it will take after applying cyclic shifts to the matrix for the $A$ matrix to become unitary.

Note: In the first test case, you can do the following: first, shift all the rows down cyclically, then the main diagonal of the matrix will contain only ``1''. Then it will be necessary to apply xor-operation to the only ``1'' that is not on the main diagonal.

In the second test case, you can make a unitary matrix by applying the operation $2$ — cyclic shift of rows upward twice to the matrix.}
\BREAKDOWN{We may shift rows and columns cyclically for free before flipping bits. Those shifts effectively choose which wrap-around diagonal of the original matrix becomes the main diagonal. We must then flip bits to obtain the identity. Minimize flips by choosing the diagonal with the most ones.}
\ELI{Pick the wrap-around diagonal that already has the most ones, make it the main diagonal by shifts, then flip the few remaining wrong bits.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case: integer $n$ ($1 \le n \le 2000$), followed by $n$ binary strings of length $n$. The total $\sum n^2 \le 4 \cdot 10^6$.}
\OUTPUTS{For each test case, print a single integer: the minimum number of xor-operations needed after optimal cyclic shifts to make the matrix equal to the $n \times n$ identity matrix.}
\SAMPLES{Example:
\begin{verbatim}
Input
2
2
11
11
2
01
10

Output
2
0
\end{verbatim}
Explanation: In the first case, two off-diagonal ones must be flipped to zero. In the second, a cyclic shift aligns ones to the main diagonal with no flips needed.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let indices be zero-based: $i,j \in \{0,\ldots,n-1\}$. Define wrap-diagonals by residue $k \in \{0,\ldots,n-1\}$ where a cell $(i,j)$ belongs to diagonal $k$ if $(j-i) \bmod n = k$. Let $c_k$ be the number of ones on diagonal $k$, and let $S$ be the total number of ones in the matrix.}
\varmapStart
\var{n}{matrix size}
\var{A}{binary matrix}
\var{S}{total ones in $A$}
\var{c_k}{ones on wrap-diagonal $k$}
\var{k^\*}{chosen wrap-diagonal to align to the main diagonal}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{After aligning diagonal } k \text{ to the main diagonal, flips needed} = (n - c_k) + (S - c_k) = n + S - 2c_k.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Cyclic shifts up/down and left/right compose to an independent vertical and horizontal shift; their net effect is selecting a residue class $k = (c-r) \bmod n$ to align as the main diagonal. The xor-operations occur only after shifts are done.}
\INVARIANTS{
\begin{bullets}
\item The multiset of wrap-diagonals is invariant under uniform cyclic row and column shifts; only which residue aligns to the main diagonal changes.
\item $S$ is invariant under shifts; only flips can change $S$.
\item For any fixed $k$, exactly $n$ positions lie on wrap-diagonal $k$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all $k \in \{0,\ldots,n-1\}$ and for each, rescan the entire matrix to count $c_k$, then compute $n + S - 2c_k$. Take the minimum.}
\ASSUMPTIONS{We do not cache counts; each candidate diagonal is recomputed independently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$ and the $n$ binary strings; compute $S$ by summing all ones.
\item For each $k$ from $0$ to $n-1$, compute $c_k$ by scanning all $n^2$ entries and counting those with $(j-i) \bmod n = k$ and $A_{ij}=1$.
\item Track the minimum of $n + S - 2c_k$ over all $k$.
\end{algosteps}
\COMPLEXITY{For each test, $n$ rescans of $n^2$ cells.}
\[
\begin{aligned}
T(n) &= \Theta(n \cdot n^2) = \Theta(n^3),\\
S(n) &= \Theta(1) \text{ extra beyond storing the matrix or reading row by row.}
\end{aligned}
\]
\CORRECTNESS{For any fixed pair of row/column shifts $(r,c)$, the main diagonal of the shifted matrix corresponds to wrap-diagonal $k=(c-r)\bmod n$ in the original. Flips needed are $(n-c_k)$ to make all $n$ diagonal entries ones plus $(S-c_k)$ to clear all remaining ones. Minimizing flips over choices of $(r,c)$ is equivalent to maximizing $c_k$ over residues $k$, hence minimizing $n+S-2c_k$. Exhaustively checking all $k$ is therefore correct.}
\EDGECASES{
\begin{bullets}
\item $n=1$: answer is $1$ if $A_{00}=0$, else $0$.
\item All zeros matrix: answer is $n$.
\item All ones matrix: answer is $2n-2c_k$ minimized at $c_k=n$, yielding $n$ if no diagonal has all ones; for a permutation matrix diagonal, $0$.
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, grid))
    return cases

def flips_baseline(n, grid):
    # total ones
    S = sum(row.count('1') for row in grid)
    best = 10**18
    for k in range(n):
        ck = 0
        for i in range(n):
            for j in range(n):
                if grid[i][j] == '1' and (j - i) % n == k:
                    ck += 1
        cost = n + S - 2 * ck
        if cost < best:
            best = cost
    return best

def solve_case(n, grid):
    return flips_baseline(n, grid)

def solve_all(cases):
    out_lines = []
    for n, grid in cases:
        out_lines.append(str(solve_case(n, grid)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Simple asserts for baseline
    assert flips_baseline(1, [['1']]) == 0
    assert flips_baseline(1, [['0']]) == 1
    assert flips_baseline(2, [list("11"), list("11")]) == 2
    assert flips_baseline(2, [list("01"), list("10")]) == 0
    # Do not run main() in asserts; leave to execution environment.
    pass
\end{minted}
\VALIDATION{Checked trivial $n=1$, all-ones $2\times 2$, and a perfect wrap-diagonal case which needs $0$ flips.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Aggregate Counts per Wrap-Diagonal}
\WHICHFORMULA{Compute all $c_k$ in a single pass by mapping each one at $(i,j)$ to $k=(j-i)\bmod n$. Then answer is $\min_k \{n + S - 2c_k\} = n + S - 2\max_k c_k$.}
\ASSUMPTIONS{Indexing is zero-based; use modulo $n$ arithmetic to identify wrap-diagonals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan the matrix once; maintain $S$ and an array $c[0..n-1]$.
\item For each cell $(i,j)$ with $A_{ij}=1$, increment $S$ and $c[(j-i)\bmod n]$.
\item Let $m=\max_k c[k]$. Output $n + S - 2m$.
\end{algosteps}
\COMPLEXITY{One pass over all cells.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\\
S(n) &= \Theta(n) \text{ for the counts array}.
\end{aligned}
\]
\CORRECTNESS{This directly implements the proven cost formula and chooses the optimal wrap-diagonal by maximizing $c_k$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, grid))
    return cases

def flips_improved(n, grid):
    S = 0
    c = [0] * n
    for i in range(n):
        row = grid[i]
        for j, ch in enumerate(row):
            if ch == '1':
                S += 1
                c[(j - i) % n] += 1
    m = max(c) if n > 0 else 0
    return n + S - 2 * m

def solve_case(n, grid):
    return flips_improved(n, grid)

def solve_all(cases):
    return "\n".join(str(solve_case(n, grid)) for n, grid in cases)

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Cross-check with a small brute force for tiny n
    def flips_bruteforce(n, grid):
        # Try all r,c shifts and count flips to identity
        best = 10**9
        A = grid
        for r in range(n):
            for c in range(n):
                flips = 0
                for i in range(n):
                    for j in range(n):
                        ai = (i - r) % n
                        aj = (j - c) % n
                        want = 1 if i == j else 0
                        have = 1 if A[ai][aj] == '1' else 0
                        if want != have:
                            flips += 1
                if flips < best:
                    best = flips
        return best
    # Randomized checks (deterministic seed)
    import random
    random.seed(123)
    for n in range(1, 5):
        for _ in range(50):
            grid = [[random.choice('01') for _ in range(n)] for _ in range(n)]
            assert flips_improved(n, grid) == flips_bruteforce(n, grid)
    # Fixed cases
    assert flips_improved(2, [list("11"), list("11")]) == 2
    assert flips_improved(2, [list("01"), list("10")]) == 0
    pass
\end{minted}
\VALIDATION{Cross-checked against explicit $(r,c)$ brute-force for $n \le 4$ with a fixed random seed and fixed hand-crafted cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single-Pass Counting of Wrap-Diagonals}
\WHICHFORMULA{Compute $S$ and $m=\max_k c_k$ in one scan; answer is $n + S - 2m$.}
\ASSUMPTIONS{All shifts are free and done before flips; indices wrap modulo $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $S=0$ and array $c[0..n-1]=0$.
\item For each $i,j$, if $A_{ij}=1$, do $S\mathrel{+}=1$ and $c[(j-i)\bmod n]\mathrel{+}=1$.
\item Output $n + S - 2 \cdot \max(c)$.
\end{algosteps}
\OPTIMALITY{No algorithm can use fewer than $\Theta(n^2)$ inspections in the worst case since an adversary can hide decisive information in any cell. This method is linear in the input size and thus optimal up to constant factors.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n^2), \\
S(n) &= \Theta(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, grid))
    return cases

def solve_case(n, grid):
    S = 0
    c = [0] * n
    for i in range(n):
        row = grid[i]
        for j, ch in enumerate(row):
            if ch == '1':
                S += 1
                c[(j - i) % n] += 1
    m = max(c) if n > 0 else 0
    return n + S - 2 * m

def solve_all(cases):
    return "\n".join(str(solve_case(n, grid)) for n, grid in cases)

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests
    assert solve_case(1, [['0']]) == 1
    assert solve_case(2, [list("11"), list("11")]) == 2
    assert solve_case(3, [list("010"), list("001"), list("100")]) == 0
    # No automatic main() call here.
    pass
\end{minted}
\VALIDATION{Three direct asserts covering smallest size, all-ones small matrix, and a perfect wrap-diagonal permutation matrix.}
\RESULT{For each test case, print the minimal number of flips after free cyclic shifts to obtain the identity matrix. If multiple shifts achieve the same minimum, any such shift is acceptable since only the number of flips is requested.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks at boundaries ($n=1$), dense extremes (all zeros, all ones), and randomized small matrices cross-checked against brute-force enumeration of shifts.}
\LINE{CROSS-CHECKS}{Compare the improved/optimal method with a brute-force $(r,c)$ search for $n \le 4$ over multiple random seeds; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate small sizes with varying densities (bias for ones at $0.0, 0.5, 1.0$) to stress both extremes and typical cases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_matrix(n, p_one, rng):
    return [[('1' if rng.random() < p_one else '0') for _ in range(n)] for _ in range(n)]

def brute_force_answer(n, grid):
    best = 10**9
    for r in range(n):
        for c in range(n):
            flips = 0
            for i in range(n):
                for j in range(n):
                    want = 1 if i == j else 0
                    ai = (i - r) % n
                    aj = (j - c) % n
                    have = 1 if grid[ai][aj] == '1' else 0
                    if want != have:
                        flips += 1
            best = min(best, flips)
    return best

def optimal_answer(n, grid):
    S = 0
    c = [0] * n
    for i in range(n):
        for j in range(n):
            if grid[i][j] == '1':
                S += 1
                c[(j - i) % n] += 1
    return n + S - 2 * max(c) if n > 0 else 0

def self_test():
    rng = random.Random(2025)
    # Boundary and extreme tests
    for n in range(1, 5):
        for p in [0.0, 0.5, 1.0]:
            for _ in range(30):
                g = gen_matrix(n, p, rng)
                assert optimal_answer(n, g) == brute_force_answer(n, g)
    # Specific adversarial-like patterns
    assert optimal_answer(2, [list("11"), list("11")]) == 2
    assert optimal_answer(2, [list("01"), list("10")]) == 0

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, grid))
    return cases

def solve_case(n, grid):
    S = 0
    c = [0] * n
    for i in range(n):
        row = grid[i]
        for j, ch in enumerate(row):
            if ch == '1':
                S += 1
                c[(j - i) % n] += 1
    m = max(c) if n > 0 else 0
    return n + S - 2 * m

def solve_all(cases):
    return "\n".join(str(solve_case(n, grid)) for n, grid in cases)

def main():
    data = sys.stdin.read()
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Basic sanity asserts
    assert solve_case(1, [['0']]) == 1
    assert solve_case(1, [['1']]) == 0
    assert solve_case(2, [list("11"), list("11")]) == 2
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Align the wrap-around diagonal with the most ones to the main diagonal, then flips needed are $n + S - 2 \cdot \max c_k$.}
\WHY{Common CF pattern: free cyclic shifts reduce a 2D optimization to classifying cells by $(j-i)\bmod n$. Recognizing the invariant accelerates the solution from $\Theta(n^3)$ to $\Theta(n^2)$.}
\CHECKLIST{
\begin{bullets}
\item Convert to zero-based indexing to use $(j-i)\bmod n$ cleanly.
\item Count total ones $S$ and per-diagonal counts $c_k$ in one pass.
\item Compute $m=\max_k c_k$ and answer $n + S - 2m$.
\item Print per test case.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ with $A_{00}=0$ or $1$.
\item All zeros matrix $\Rightarrow$ answer $= n$.
\item All ones matrix $\Rightarrow$ answer $= n + n - 2m$; $m$ can be at most $n$.
\item Matrices with exactly one wrap-diagonal of ones (a cyclic permutation matrix) $\Rightarrow 0$.
\item Non-square inputs do not appear; $n$ is always square by statement.
\item Sparse matrices with a single one far off-diagonal.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mixing one-based and zero-based indices breaks $(j-i)\bmod n$.
\item Forgetting modulo for negative residues; use Python's nonnegative modulo or add $n$ before mod in other languages.
\item Reading input: ignore or tolerate blank lines; token-based parsing is simpler.
\item Overflow in other languages if using 32-bit accumulators for large sums; here safe in Python.
\item Confusing xor-operations as usable during shifting; flips happen only after shifts.
\item Miscounting $S$ or double-counting cells on the chosen diagonal.
\end{bullets}
}
\FAILMODES{A naive approach that tries independent row and column shifts to maximize the main diagonal ones can be $\Theta(n^3)$ or worse if recomputing counts from scratch; also, trying to locally adjust rows/columns greedily fails because the effect intertwines across the torus. The diagonal residue method avoids both issues.}
\ELI{Think of the matrix drawn on a donut: moving it up or left just rotates the donut. The only thing that matters is which slanted ring you line up with the main diagonal. Pick the ring with the most ones; then only a minimal number of bits need flipping.}
\NotePages{3}

\end{document}