% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Strange Game On Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/873/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Ivan is playing a strange game.

He has a matrix $a$ with $n$ rows and $m$ columns. Each element of the matrix is equal to either $0$ or $1$. Rows and columns are $1$-indexed. Ivan can replace any number of ones in this matrix with zeroes. After that, his score in the game will be calculated as follows:
\begin{enumerate}
\item Initially Ivan's score is $0$;
\item In each column, Ivan will find the topmost $1$ (that is, if the current column is $j$, then he will find minimum $i$ such that $a_{i,j}=1$). If there are no $1$'s in the column, this column is skipped;
\item Ivan will look at the next $\min(k,\,n-i+1)$ elements in this column (starting from the element he found) and count the number of $1$'s among these elements. This number will be added to his score.
\end{enumerate}

Of course, Ivan wants to maximize his score in this strange game. Also he does not want to change many elements, so he will replace the minimum possible number of ones with zeroes. Help him to determine the maximum possible score he can get and the minimum possible number of replacements required to achieve that score.

Input: The first line contains three integer numbers $n$, $m$ and $k$ ($1 \le k \le n \le 100$, $1 \le m \le 100$).

Then $n$ lines follow, the $i$-th of them contains $m$ integer numbers — the elements of $i$-th row of matrix $a$. Each number is either $0$ or $1$.

Output: Print two numbers: the maximum possible score Ivan can get and the minimum number of replacements required to get this score.

Note: In the first example Ivan will replace the element $a_{1,2}$.}
\BREAKDOWN{Optimize each column independently: choose a position for the topmost $1$ by deleting some ones above it; the score contribution is the number of ones in the next $k$ cells from that position. Maximize total score, and among all ways to get that score, minimize total deletions.}
\ELI{Per column, slide a window starting at some existing $1$; pick the start that yields the most ones in the next $k$ cells, breaking ties by deleting as few ones above as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,m,k$ with $1 \le k \le n \le 100$, $1 \le m \le 100$; then an $n \times m$ binary matrix $a$ with entries in $\{0,1\}$.}
\OUTPUTS{Two integers: (1) the maximum achievable score; (2) the minimum number of $1 \to 0$ replacements required to achieve that maximum score. Printed on one line separated by a space.}
\SAMPLES{
Example 1:
\begin{verbatim}
Input
3 2 2
1 0
1 1
1 0
Output
3 0
\end{verbatim}
Example 2:
\begin{verbatim}
Input
4 3 3
1 0 1
0 1 0
1 1 0
0 0 0
Output
5 1
\end{verbatim}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each column $j\in\{1,\ldots,m\}$, let $S_j$ be the set of row indices $i$ with $a_{i,j}=1$. Choosing deletions fixes a topmost remaining $1$ at some $p\in S_j$ (or no $1$). The contribution from column $j$ is $w_j(p)=\sum_{t=p}^{\min(n,p+k-1)} a_{t,j}$, and the deletions in column $j$ equal $c_j(p)=\sum_{t=1}^{p-1} a_{t,j}$.}
\varmapStart
\var{n,m}{matrix dimensions}
\var{k}{window height bound}
\var{a_{i,j}}{binary matrix entry}
\var{p}{chosen topmost $1$ row in a column}
\var{w_j(p)}{score contribution from column $j$ if topmost $1$ is at $p$}
\var{c_j(p)}{deletions above $p$ in column $j$}
\varmapEnd
\GOVERN{
\[
\text{Maximize}\quad \sum_{j=1}^{m} \max_{p\in S_j} w_j(p)
\quad\text{and among maximizers minimize}\quad
\sum_{j=1}^{m} \arg\min_{p\in P^\star_j} c_j(p),
\]
\begin{BreakableEquation*}
P^\star_j \coloneqq \operatorname*{arg\,max}_{p\in S_j} w_j(p).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Columns are independent because deletions in one column do not affect others. Deleting within the $k$-window never helps maximize score, so optimal deletions for a chosen $p$ are exactly those above $p$.}
\INVARIANTS{
\begin{bullets}
\item For a fixed column and choice $p$, the topmost $1$ is at $p$ iff all ones above $p$ are deleted.
\item The window length is exactly $\min(k,n-p+1)$ by rule; it never exceeds matrix bottom.
\item If a column has no $1$, its optimal contribution is $0$ score and $0$ deletions.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all candidate topmost positions $p$ where $a_{p,j}=1$ in each column. For each $p$, scan the $k$-window to count ones, and scan above $p$ to count deletions. Take the $p$ with maximal window count; tie-break by minimal deletions.}
\ASSUMPTIONS{Solve each column independently; no cross-column coupling. Window counts and deletions are computed by naive loops.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each column $j$, collect indices $p$ with $a_{p,j}=1$.
\item For each such $p$, compute $w_j(p)$ by iterating rows $p$ to $\min(n,p+k-1)$; compute $c_j(p)$ by iterating rows $1$ to $p-1$.
\item Select $p$ maximizing $w_j(p)$; in case of ties, minimize $c_j(p)$. Accumulate score and deletions across columns.
\end{algosteps}
\COMPLEXITY{For each column, at most $n$ candidates and $O(n)$ work per candidate.}
\[
\begin{aligned}
T(n) &\le m \cdot \bigl(\underbrace{n}_{\text{candidates}} \cdot \underbrace{(k + n)}_{\text{window + above}}\bigr)
= O(m n (n+k)) \le O(m n^2),\\
S(n) &= O(1) \text{ beyond the input.}
\end{aligned}
\]
\CORRECTNESS{The enumeration checks all feasible topmost positions per column and respects the scoring rule. Since columns are independent, summing per-column optima yields the global optimum. Tie-breaking by minimal deletions achieves the least number of changes among global maximizers.}
\EDGECASES{Columns with all zeros, $k=1$, $k=n$, topmost $1$ near bottom where window truncates, multiple $p$ with equal window counts.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
    return n, m, k, a

def solve_case(n, m, k, a):
    total_score = 0
    total_del = 0
    for j in range(m):
        best_w = 0
        best_c = 0
        found = False
        for p in range(n):
            if a[p][j] == 1:
                # count deletions above p
                c = 0
                for r in range(p):
                    if a[r][j] == 1:
                        c += 1
                # count window ones
                w = 0
                end = min(n, p + k)
                for r in range(p, end):
                    if a[r][j] == 1:
                        w += 1
                if (not found) or (w > best_w) or (w == best_w and c < best_c):
                    best_w, best_c = w, c
                    found = True
        # If no 1 in column, contribute (0,0)
        total_score += best_w
        total_del += best_c
    return total_score, total_del

def solve_all():
    n, m, k, a = read_input()
    s, d = solve_case(n, m, k, a)
    print(s, d)

def _unit_tests():
    # Column-wise reasoning tests
    n, m, k = 3, 2, 2
    a = [
        [1, 0],
        [1, 1],
        [1, 0],
    ]
    assert solve_case(n, m, k, a) == (3, 0)
    # Tie on score, prefer fewer deletions
    n, m, k = 4, 1, 3
    a = [
        [1],
        [0],
        [1],
        [1],
    ]
    # Best is start at row 0 (score 2, deletions 0) vs row 2 (score 2, deletions 1)
    assert solve_case(n, m, k, a) == (2, 0)

if __name__ == "__main__":
    # _unit_tests()  # uncomment to run local tests
    solve_all()
\end{minted}
\VALIDATION{Checked two tiny cases by hand and with asserts to ensure tie-breaking is correct and window truncation near bottom is handled.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use prefix sums per column to compute both window counts and deletions in $O(1)$ per candidate $p$. This reduces each column to $O(n)$.}
\ASSUMPTIONS{For column $j$, prefix sum $P[r]=\sum_{t=0}^{r-1} a_{t,j}$ allows $w_j(p)=P[\min(n,p+k)]-P[p]$ and $c_j(p)=P[p]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each column, build prefix sums $P$ of its entries.
\item For each $p$ with $a_{p,j}=1$, compute $w_j(p)$ and $c_j(p)$ using $P$ in $O(1)$.
\item Select the best $p$ as before; accumulate totals.
\end{algosteps}
\COMPLEXITY{Per column $O(n)$ candidate positions with $O(1)$ evaluation each.}
\[
\begin{aligned}
T(n) &= O(mn),\quad S(n)=O(n) \text{ for a working prefix (reused per column).}
\end{aligned}
\]
\CORRECTNESS{Prefix sums are an exact re-expression of the naive counts; the maximizing and tie-breaking logic is unchanged, so optimality is preserved.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
    return n, m, k, a

def col_best(col, k):
    n = len(col)
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i + 1] = pref[i] + col[i]
    if pref[n] == 0:
        return 0, 0
    best_w = -1
    best_c = 10**9
    for p in range(n):
        if col[p] == 1:
            c = pref[p]
            end = min(n, p + k)
            w = pref[end] - pref[p]
            if (w > best_w) or (w == best_w and c < best_c):
                best_w, best_c = w, c
    return best_w, best_c

def solve_case(n, m, k, a):
    total_score = 0
    total_del = 0
    for j in range(m):
        col = [a[i][j] for i in range(n)]
        w, c = col_best(col, k)
        total_score += w
        total_del += c
    return total_score, total_del

def solve_all():
    n, m, k, a = read_input()
    s, d = solve_case(n, m, k, a)
    print(s, d)

def _unit_tests():
    # No ones in a column
    n, m, k = 2, 2, 2
    a = [
        [0, 0],
        [0, 1],
    ]
    assert solve_case(n, m, k, a) == (1, 0)
    # Window truncated at bottom
    n, m, k = 3, 1, 5
    a = [
        [0],
        [1],
        [1],
    ]
    # Best is start at row 1: window [1..2] has 2 ones, deletions 0
    assert solve_case(n, m, k, a) == (2, 0)

if __name__ == "__main__":
    # _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Edge checks include empty columns, long $k$, and tie-break conditions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{For each column independently, choose $p\in S_j$ maximizing $w_j(p)$ computed by prefix sums; among those, minimize $c_j(p)$. Sum over columns.}
\ASSUMPTIONS{Independence of columns; deletions inside the scoring window only reduce score and are never needed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each column $j$, build prefix sums of its entries.
\item Enumerate all $p$ with $a_{p,j}=1$; compute $w_j(p)$ and $c_j(p)$ in $O(1)$ each.
\item Pick the maximizing $p$ with minimal $c_j(p)$; add to totals.
\end{algosteps}
\OPTIMALITY{Lower bound: No column can contribute more than the maximum count of ones in any length-$k$ vertical window starting at a $1$. The algorithm attains this bound per column, hence globally. Among all choices achieving that maximum, it selects the one with the least deletions $c_j(p)$, yielding minimal changes.}
\COMPLEXITY{Linear in matrix size.}
\[
\begin{aligned}
T(n,m,k) &= O(nm),\quad S(n,m,k)=O(n) \text{ for a working buffer per column.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
    return n, m, k, a

def solve_case(n, m, k, a):
    total_score = 0
    total_del = 0
    for j in range(m):
        # build prefix for column j
        pref = [0] * (n + 1)
        for i in range(n):
            pref[i + 1] = pref[i] + a[i][j]
        if pref[n] == 0:
            continue
        best_w = -1
        best_c = 10**9
        for p in range(n):
            if a[p][j] == 1:
                c = pref[p]
                end = min(n, p + k)
                w = pref[end] - pref[p]
                if (w > best_w) or (w == best_w and c < best_c):
                    best_w, best_c = w, c
        total_score += best_w
        total_del += best_c
    return total_score, total_del

def solve_all():
    n, m, k, a = read_input()
    s, d = solve_case(n, m, k, a)
    print(s, d)

def _unit_tests():
    # Basic sample-like check
    n, m, k = 3, 2, 2
    a = [
        [1, 0],
        [1, 1],
        [1, 0],
    ]
    assert solve_case(n, m, k, a) == (3, 0)
    # Column with multiple 1s, tie on score, prefer fewer deletions
    n, m, k = 4, 1, 3
    a = [
        [1],
        [0],
        [1],
        [1],
    ]
    assert solve_case(n, m, k, a) == (2, 0)
    # All zeros matrix
    n, m, k = 2, 3, 1
    a = [
        [0, 0, 0],
        [0, 0, 0],
    ]
    assert solve_case(n, m, k, a) == (0, 0)

if __name__ == "__main__":
    # _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts cover: typical mixed case, tie-breaking correctness, and all-zero matrix.}
\RESULT{Print the maximum total score and, among all ways to achieve it, the minimum number of $1\to 0$ replacements. No special tie-breaking beyond this is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test helper on crafted columns: empty, single $1$, multiple $1$'s with ties, window truncated at bottom, and random small matrices cross-checked with a slow baseline.}
\LINE{CROSS-CHECKS}{Compare baseline $O(mn^2)$ vs optimized $O(mn)$ for small $n,m$; ensure identical score and minimal deletions across random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate columns of length $n$ with patterns: all zeros, all ones, staircase ones near bottom, alternating bits, and random bits with fixed density.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def slow_column_best(col, k):
    n = len(col)
    best_w = 0
    best_c = 0
    found = False
    for p in range(n):
        if col[p] == 1:
            c = sum(col[:p])
            w = sum(col[p:min(n, p + k)])
            if (not found) or (w > best_w) or (w == best_w and c < best_c):
                best_w, best_c = w, c
                found = True
    return best_w, best_c

def fast_column_best(col, k):
    n = len(col)
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i + 1] = pref[i] + col[i]
    if pref[n] == 0:
        return 0, 0
    best_w = -1
    best_c = 10**9
    for p in range(n):
        if col[p] == 1:
            c = pref[p]
            w = pref[min(n, p + k)] - pref[p]
            if (w > best_w) or (w == best_w and c < best_c):
                best_w, best_c = w, c
    return best_w, best_c

def cross_check():
    random.seed(0)
    for n in range(1, 8):
        for k in range(1, n + 1):
            for _ in range(200):
                col = [1 if random.random() < 0.4 else 0 for __ in range(n)]
                assert slow_column_best(col, k) == fast_column_best(col, k)

# cross_check()  # uncomment to run
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
    return n, m, k, a

def solve_case(n, m, k, a):
    total_score = 0
    total_del = 0
    for j in range(m):
        pref = [0] * (n + 1)
        for i in range(n):
            pref[i + 1] = pref[i] + a[i][j]
        if pref[n] == 0:
            continue
        best_w = -1
        best_c = 10**9
        for p in range(n):
            if a[p][j] == 1:
                c = pref[p]
                end = min(n, p + k)
                w = pref[end] - pref[p]
                if (w > best_w) or (w == best_w and c < best_c):
                    best_w, best_c = w, c
        total_score += best_w
        total_del += best_c
    return total_score, total_del

def solve_all():
    n, m, k, a = read_input()
    s, d = solve_case(n, m, k, a)
    print(s, d)

def _tests():
    # Minimal deterministic checks
    n, m, k = 1, 1, 1
    a = [[0]]
    assert solve_case(n, m, k, a) == (0, 0)
    n, m, k = 1, 1, 1
    a = [[1]]
    assert solve_case(n, m, k, a) == (1, 0)
    n, m, k = 3, 2, 2
    a = [
        [1, 0],
        [1, 1],
        [1, 0],
    ]
    assert solve_case(n, m, k, a) == (3, 0)

if __name__ == "__main__":
    # _tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Optimize per column: pick the topmost $1$ to maximize ones in the next $k$ cells, tie-breaking by minimal deletions above.}
\WHY{Common CF pattern: independent-column optimization with window counts; tests correctness of modeling and tie-breaking.}
\CHECKLIST{
\begin{bullets}
\item Build per-column prefix sums.
\item Enumerate positions $p$ with $a_{p,j}=1$.
\item Compute window count $w$ and deletions $c$ in $O(1)$.
\item Maximize $w$; tie-break with minimal $c$.
\item Sum $w$ and $c$ over columns; print.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Column with no $1$ at all $\to$ add $(0,0)$.
\item $k=1$ $\to$ $w$ is always $1$ for any valid $p$.
\item $k=n$ or very large $\to$ window truncates at bottom.
\item Multiple $p$ with same $w$ $\to$ choose smaller $c$.
\item All ones in a column $\to$ best is topmost row.
\item Single column or single row matrices.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to bound window end by $n$.
\item Counting deletions incorrectly (must be ones above $p$, not all above).
\item Considering starts at $p$ where $a_{p,j}=0$ (invalid).
\item Accidentally deleting ones within the scoring window in the model (never helps score).
\item Mixing $0$-indexed and $1$-indexed intuition when coding.
\item Not resetting per-column best between columns.
\end{bullets}
}
\FAILMODES{A naive global deletion strategy across columns is unnecessary and can overcomplicate. Also, scanning whole windows without prefix sums risks $O(n^2)$ time; while it still passes here, it is brittle for larger bounds.}
\ELI{Treat each column as a mini-game: choose which $1$ becomes the first visible one by erasing some above it; then count how many $1$'s lie in the next $k$ cells. Do this independently for all columns and add up the results, erasing as few ones as possible when there are ties.}
\NotePages{3}

\end{document}