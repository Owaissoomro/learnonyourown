% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tree Factory}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1225/F}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{Bytelandian Tree Factory produces trees for all kinds of industrial applications. You have been tasked with optimizing the production of a certain type of tree for an especially large and important order.

The tree in question is a rooted tree with $n$ vertices labelled with distinct integers from $0$ to $n - 1$. The vertex labelled $0$ is the root of the tree, and for any non-root vertex $v$ the label of its parent $p(v)$ is less than the label of $v$.

All trees at the factory are made from bamboo blanks. A bamboo is a rooted tree such that each vertex has exactly one child, except for a single leaf vertex with no children. The vertices of a bamboo blank can be labelled arbitrarily before its processing is started.

To process a bamboo into another tree a single type of operation can be made: choose an arbitrary non-root vertex $v$ such that its parent $p(v)$ is not a root either. The operation consists of changing the parent of $v$ to its parent's parent $p(p(v))$. Note that parents of all other vertices remain unchanged, in particular, the subtree of $v$ does not change.

Efficiency is crucial, hence you have to minimize the number of operations to make the desired tree from a bamboo blank. Construct any optimal sequence of operations to produce the desired tree.

Note that the labelling of the resulting tree has to coincide with the labelling of the desired tree. Formally, the labels of the roots have to be equal, and for non-root vertices with the same label the labels of their parents should be the same.

It is guaranteed that for any test present in this problem an answer exists, and further, an optimal sequence contains at most $10^6$ operations. Note that any hack that does not meet these conditions will be invalid.

Input:
The first line contains a single integer $n$ — the number of vertices in the tree ($2 \le n \le 10^5$).

The second line contains $n - 1$ integers $p(1), \ldots, p(n - 1)$ — indices of parent vertices of $1, \ldots, n - 1$ respectively ($0 \le p(i) < i$).

Output:
In the first line, print $n$ distinct integers $id_1, \ldots, id_n$ — the initial labelling of the bamboo blank starting from the root vertex ($0 \le id_i < n$).

In the second line, print a single integer $k$ — the number of operations in your sequence ($0 \le k \le 10^6$).

In the third line print $k$ integers $v_1, \ldots, v_k$ describing operations in order. The $i$-th operation consists of changing $p(v_i)$ to $p(p(v_i))$. Each operation should be valid, i.e. neither $v_i$ nor $p(v_i)$ can be the root of the tree at the moment.}
\BREAKDOWN{Find a bamboo labelling (a linear extension of the tree where parent precedes child) and a sequence of ``lift to grandparent'' operations to reach the exact target parent mapping with the minimum possible number of operations, and output both the chosen labelling and the sequence.}
\ELI{Choose an order to place nodes on the initial chain that minimizes how far each child must travel to reach its parent, then fix nodes from bottom to top by repeatedly lifting a node to its grandparent until its parent is the desired one.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.
\begin{bullets}
\item $n$ (int): number of vertices, $2 \le n \le 10^5$.
\item Array $p[1..n-1]$ (ints): parent of vertex $i$ is $p[i]$, with $0 \le p[i] < i$. Set $p[0] = -1$ for the root.
\end{bullets}
}
\OUTPUTS{
\begin{bullets}
\item Line 1: $n$ distinct integers $id_1, \ldots, id_n$ — labels placed along the bamboo from root to leaf. Must have $id_1 = 0$.
\item Line 2: integer $k$ — number of operations in the sequence.
\item Line 3: $k$ integers $v_1, \ldots, v_k$ — labels of vertices to ``lift'' in order. If $k=0$, print an empty line.
\end{bullets}
}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input:
\[
\begin{aligned}
n&=2\\
p&=\{0\}
\end{aligned}
\]
Output (one valid optimal):
\begin{BreakableEquation*}
\text{ids: } 0~1;\quad k=0;\quad \text{ops: }~\text{(empty line)}.
\end{BreakableEquation*}
\item Input:
\[
\begin{aligned}
n&=4\\
p&=\{0,0,1\}
\end{aligned}
\]
One optimal output (not unique):
\begin{BreakableEquation*}
\text{ids: } 0~1~3~2;\quad k=2;\quad \text{ops: } 2~2.
\end{BreakableEquation*}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the initial bamboo be a chain whose nodes appear in order $id_1, id_2, \ldots, id_n$, with root $id_1=0$. For every non-root vertex $v$, the number of required lifts equals the number of chain vertices strictly between $p(v)$ and $v$.}
\varmapStart
\var{V}{set of labels $\{0,\ldots,n-1\}$}
\var{p(v)}{desired parent in the target tree; $p(0)=-1$}
\var{\mathrm{pos}(v)}{position of $v$ along the bamboo; $\mathrm{pos}(0)=1$; parent precedes child}
\var{k}{number of operations output}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Total operations }k \;=\; \sum_{v\ne 0} \bigl(\mathrm{pos}(v)-\mathrm{pos}(p(v))-1\bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item The labelling order must satisfy $\mathrm{pos}(0)=1$ and $\mathrm{pos}(p(v))<\mathrm{pos}(v)$ for all $v\ne 0$.
\item Each operation lifts one vertex $v$ one step closer to the root along the bamboo ancestor chain.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item Operations never change the subtree of the lifted vertex $v$.
\item Once a vertex $v$ attains its desired parent, future operations on its ancestors do not change its parent.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Fix the bamboo labelling to be the natural order $[0,1,2,\ldots,n-1]$. Then $k=\sum_{i=1}^{n-1}(i-p(i)-1)$ operations suffice by lifting each vertex until it meets its target parent.}
\ASSUMPTIONS{We accept the potentially very large operation count; correctness is prioritized over optimality.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $id_i=i-1$ for $i=1,\ldots,n$.
\item Initialize the chain parent array $\mathrm{cur}[id_i]=id_{i-1}$ for $i\ge 2$, and $\mathrm{cur}[0]=-1$.
\item Process vertices in decreasing chain order $i=n,\ldots,2$; for $v=id_i$, while $\mathrm{cur}[v]\ne p(v)$, replace $\mathrm{cur}[v]\leftarrow \mathrm{cur}(\mathrm{cur}[v])$ and record $v$.
\end{algosteps}
\COMPLEXITY{Let $K$ be the total number of operations; then $T(n)=\Theta(n+K)$, $S(n)=\Theta(n)$.}
\[
\begin{aligned}
K &= \sum_{v\ne 0} \bigl(\mathrm{pos}(v)-\mathrm{pos}(p(v))-1\bigr) \\
  &= \sum_{i=1}^{n-1} (i - p(i) - 1).
\end{aligned}
\]
\CORRECTNESS{Processing from the leaf end of the chain ensures that lifting a vertex $v$ cannot overshoot its desired parent because ancestors have not yet been lifted. Once $v$ reaches $p(v)$, later ancestor lifts preserve $v$'s parent.}
\EDGECASES{Star trees cause $K=\Theta(n^2)$; still correct but not optimal and can exceed practical bounds.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [-1] * n
    for i in range(1, n):
        p[i] = next(it)
    return n, p

def baseline_construct(n: int, p: List[int]) -> Tuple[List[int], List[int]]:
    assert n >= 2 and p[0] == -1
    ids = list(range(n))  # bamboo order: 0,1,2,...,n-1
    # current parent along bamboo chain
    cur = [-1] * n
    for i in range(1, n):
        cur[ids[i]] = ids[i-1]
    ops: List[int] = []
    # process from tail to head (excluding root)
    for i in range(n-1, 0, -1):
        v = ids[i]
        while cur[v] != p[v]:
            # must be valid: parent(v) is not root at the moment
            assert cur[v] != ids[0], "Would attempt invalid lift with parent being root"
            cur[v] = cur[cur[v]]
            ops.append(v)
    # verify target
    for v in range(1, n):
        assert cur[v] == p[v]
    return ids, ops

def solve_case_baseline(n: int, p: List[int]) -> str:
    ids, ops = baseline_construct(n, p)
    out = []
    out.append(" ".join(map(str, ids)))
    out.append(str(len(ops)))
    out.append(" ".join(map(str, ops)))
    return "\n".join(out)

def solve_all():
    n, p = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case_baseline(n, p))

if __name__ == "__main__":
    # simple asserts
    def _check(n: int, parr: List[int]):
        ids, ops = baseline_construct(n, parr)
        # recompute by simulation to ensure operations valid
        root = ids[0]
        cur = [-1] * n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert v != root and cur[v] != root
            cur[v] = cur[cur[v]]
        for v in range(1, n):
            assert cur[v] == parr[v]
    _check(2, [-1, 0])
    _check(4, [-1, 0, 0, 1])
    # Do not auto-run solve_all(); CF judge will call it with stdin.
    pass
\end{minted}
\VALIDATION{Checked two tiny trees, and verified that after applying the produced operations, the parent array equals the input parent array.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Minimize the total operations
\[
k = \sum_{v\ne 0} \bigl(\mathrm{pos}(v)-\mathrm{pos}(p(v))-1\bigr)
= \sum_{u} c(u)\,\mathrm{pos}(u) - (n-1),
\]
where $c(u) = \mathbf{1}_{u\ne 0} - \deg(u)$. This becomes ordering jobs with precedence constraints to minimize $\sum c(u)\,\mathrm{pos}(u)$. For a rooted tree (out-tree precedence), greedily take the available vertex of maximum $c(u)$.}
\ASSUMPTIONS{Precedence is a rooted tree: each node (except root) has exactly one predecessor. Among available vertices (whose parent is scheduled), selecting the maximum weight $c(u)$ next is optimal for the linear objective.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $\deg(u)$ and $c(u)=\mathbf{1}_{u\ne 0}-\deg(u)$.
\item Priority queue of available vertices, ordered by $c(u)$ descending; seed with root $0$.
\item Pop the maximum, append to bamboo order, and push its children; repeat to obtain $\mathrm{pos}$ and the list $ids$.
\item Simulate lifting from tail to head exactly as in the baseline to realize the target with minimal operations.
\end{algosteps}
\COMPLEXITY{PQ scheduling in $O(n\log n)$, plus simulation in $O(n+K)$ where $K$ is the minimal total. Overall $O(n\log n + K)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n + K),\quad S(n)=O(n). \\
K_{\min} &= \min_{\mathrm{pos}} \sum_{u} c(u)\,\mathrm{pos}(u)-(n-1).
\end{aligned}
\]
\CORRECTNESS{Each lift reduces the sum of chain gaps by $1$, and processing from tail to head ensures no overshoot. Optimality follows from the greedy scheduling for out-tree precedence minimizing a linear ordering cost: among candidates with satisfied predecessors, placing larger $c(u)$ earlier decreases $\sum c(u)\mathrm{pos}(u)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import heapq
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [-1] * n
    for i in range(1, n):
        p[i] = next(it)
    return n, p

def greedy_bamboo_order(n: int, p: List[int]) -> List[int]:
    children = [[] for _ in range(n)]
    deg = [0] * n
    for v in range(1, n):
        u = p[v]
        children[u].append(v)
        deg[u] += 1
    c = [0] * n
    for u in range(n):
        c[u] = (1 if u != 0 else 0) - deg[u]
    # max-heap via negation
    heap = [(-c[0], 0)]
    order: List[int] = []
    while heap:
        negw, u = heapq.heappop(heap)
        order.append(u)
        for v in children[u]:
            heapq.heappush(heap, (-c[v], v))
    assert len(order) == n and order[0] == 0
    return order

def construct_minimal(n: int, p: List[int]) -> Tuple[List[int], List[int]]:
    assert n >= 2 and p[0] == -1
    ids = greedy_bamboo_order(n, p)
    # current parent along bamboo chain
    cur = [-1] * n
    for i in range(1, n):
        cur[ids[i]] = ids[i-1]
    ops: List[int] = []
    # process from tail to head (excluding root)
    root = ids[0]
    for i in range(n-1, 0, -1):
        v = ids[i]
        while cur[v] != p[v]:
            # operation valid only if parent is not root
            assert cur[v] != root, "Invalid lift (parent is root) before reaching target"
            cur[v] = cur[cur[v]]
            ops.append(v)
    # verify target
    for v in range(1, n):
        assert cur[v] == p[v]
    return ids, ops

def solve_case_improved(n: int, p: List[int]) -> str:
    ids, ops = construct_minimal(n, p)
    out = []
    out.append(" ".join(map(str, ids)))
    out.append(str(len(ops)))
    out.append(" ".join(map(str, ops)))
    return "\n".join(out)

def solve_all():
    n, p = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case_improved(n, p))

if __name__ == "__main__":
    # sanity checks on small handcrafted trees
    def _apply(ids: List[int], ops: List[int]) -> List[int]:
        n = len(ids)
        cur = [-1] * n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert v != ids[0] and cur[v] != ids[0]
            cur[v] = cur[cur[v]]
        return cur

    def _check(p: List[int]):
        n = len(p)
        ids, ops = construct_minimal(n, p)
        cur = _apply(ids, ops)
        assert all(cur[v] == p[v] for v in range(1, n))

    _check([-1, 0])
    _check([-1, 0, 0, 1])
    _check([-1, 0, 1, 1, 3])  # a small chain with a branch
    # Do not auto-run solve_all(); CF judge will call it with stdin.
    pass
\end{minted}
\VALIDATION{Checked three small trees. Verified that the produced sequence attains the parent array exactly and that operations are valid at each step.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Minimize $\sum_{u} c(u)\,\mathrm{pos}(u)$ with precedence ``parent before child'' where $c(u)=\mathbf{1}_{u\ne 0}-\deg(u)$. For an out-tree and unit costs, the greedy policy ``among available vertices, pick the maximum $c(u)$'' is optimal for any linear position cost (adding a constant to $c$ if needed).}
\ASSUMPTIONS{Rooted tree (each node has at most one predecessor), unit processing time, and position-based linear cost. The root must be first: $\mathrm{pos}(0)=1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build children lists and degrees; compute $c(u)=\mathbf{1}_{u\ne 0}-\deg(u)$.
\item Use a max-priority queue of available vertices initialized with $0$; pop max $c$, append to order, push its children; repeat to get $ids$ and $\mathrm{pos}$.
\item Initialize the bamboo chain with parents along $ids$.
\item For $i=n,\ldots,2$, while the current parent of $v=ids[i]$ differs from $p(v)$, perform a lift on $v$; record $v$.
\end{algosteps}
\OPTIMALITY{Each lift decreases the total gap sum $\sum_{v\ne 0}(\mathrm{pos}(v)-\mathrm{pos}(p(v)))$ by $1$ until reaching the target. The greedy schedule minimizes $\sum_{u}c(u)\mathrm{pos}(u)$ among all topological orders for an out-tree precedence, hence it minimizes $k=\sum_{v\ne 0}(\mathrm{pos}(v)-\mathrm{pos}(p(v))-1)$.}
\COMPLEXITY{$O(n\log n + K)$ time and $O(n)$ space; $K$ is the minimal number of operations produced.}
\[
\begin{aligned}
T(n) &= O(n\log n + K),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import heapq
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [-1] * n
    for i in range(1, n):
        p[i] = next(it)
    return n, p

def greedy_bamboo_order(n: int, p: List[int]) -> List[int]:
    children = [[] for _ in range(n)]
    deg = [0] * n
    for v in range(1, n):
        u = p[v]
        children[u].append(v)
        deg[u] += 1
    c = [0] * n
    for u in range(n):
        c[u] = (1 if u != 0 else 0) - deg[u]
    heap = [(-c[0], 0)]  # max-heap by -c
    order: List[int] = []
    while heap:
        negw, u = heapq.heappop(heap)
        order.append(u)
        for v in children[u]:
            heapq.heappush(heap, (-c[v], v))
    assert len(order) == n and order[0] == 0
    return order

def construct_sequence(n: int, p: List[int]) -> Tuple[List[int], List[int]]:
    ids = greedy_bamboo_order(n, p)
    cur = [-1] * n
    for i in range(1, n):
        cur[ids[i]] = ids[i-1]
    ops: List[int] = []
    root = ids[0]
    for i in range(n-1, 0, -1):
        v = ids[i]
        while cur[v] != p[v]:
            assert cur[v] != root
            cur[v] = cur[cur[v]]
            ops.append(v)
    # final verification
    for v in range(1, n):
        assert cur[v] == p[v]
    return ids, ops

def solve_case(n: int, p: List[int]) -> str:
    ids, ops = construct_sequence(n, p)
    out = []
    out.append(" ".join(map(str, ids)))
    out.append(str(len(ops)))
    out.append(" ".join(map(str, ops)))
    return "\n".join(out)

def solve_all():
    n, p = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case(n, p))

if __name__ == "__main__":
    # 3 asserts / I/O mini-tests
    def _apply(ids: List[int], ops: List[int]) -> List[int]:
        n = len(ids)
        cur = [-1] * n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert v != ids[0] and cur[v] != ids[0]
            cur[v] = cur[cur[v]]
        return cur

    # Test 1: simple chain (already a bamboo)
    n1, p1 = 3, [-1, 0, 1]
    ids1, ops1 = construct_sequence(n1, p1)
    assert _apply(ids1, ops1) == p1

    # Test 2: small branch
    n2, p2 = 4, [-1, 0, 0, 1]
    ids2, ops2 = construct_sequence(n2, p2)
    assert _apply(ids2, ops2) == p2

    # Test 3: another shape
    n3, p3 = 5, [-1, 0, 1, 1, 3]
    ids3, ops3 = construct_sequence(n3, p3)
    assert _apply(ids3, ops3) == p3
    # Ready for judge input
    pass
\end{minted}
\VALIDATION{Three asserts apply the constructed sequence to the bamboo and verify the final parent array equals the input target.}
\RESULT{Outputs an optimal bamboo labelling and a valid sequence of lifts that achieves the target tree with the provably minimal number of operations.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check simulation correctness by reconstructing the current parent array after applying the output operations. Cover chains, stars (small), and mixed branching.}
\LINE{CROSS-CHECKS}{Compare the baseline vs. improved operation counts on tiny trees (baseline $\ge$ improved).}
\LINE{EDGE-CASE GENERATOR}{Deterministic constructors for tiny $n$ to validate invariants: chains, stars, balanced binaries.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple

def gen_chain(n: int) -> List[int]:
    p = [-1] + [i-1 for i in range(1, n)]
    return p

def gen_star(n: int) -> List[int]:
    p = [-1] + [0]*(n-1)
    return p

def gen_binary_like(n: int) -> List[int]:
    p = [-1] * n
    for v in range(1, n):
        p[v] = (v-1)//2
    return p

def reference_solution(n: int, p: List[int]) -> Tuple[List[int], List[int]]:
    # Final reference algorithm (same as Approach C)
    import heapq
    children = [[] for _ in range(n)]
    deg = [0] * n
    for v in range(1, n):
        u = p[v]; children[u].append(v); deg[u] += 1
    c = [(1 if u != 0 else 0) - deg[u] for u in range(n)]
    heap = [(-c[0], 0)]
    order = []
    while heap:
        negw, u = heapq.heappop(heap); order.append(u)
        for v in children[u]:
            heapq.heappush(heap, (-c[v], v))
    cur = [-1] * n
    for i in range(1, n):
        cur[order[i]] = order[i-1]
    ops = []
    root = order[0]
    for i in range(n-1, 0, -1):
        v = order[i]
        while cur[v] != p[v]:
            assert cur[v] != root
            cur[v] = cur[cur[v]]
            ops.append(v)
    for v in range(1, n):
        assert cur[v] == p[v]
    return order, ops

def selftest():
    for n in range(2, 9):
        p = gen_chain(n)
        ids, ops = reference_solution(n, p)
        # apply
        cur = [-1]*n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert cur[v] != ids[0]
            cur[v] = cur[cur[v]]
        assert all(cur[v] == p[v] for v in range(1, n))
    for n in range(2, 9):
        p = gen_star(n)
        ids, ops = reference_solution(n, p)
        cur = [-1]*n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert cur[v] != ids[0]
            cur[v] = cur[cur[v]]
        assert all(cur[v] == p[v] for v in range(1, n))
    for n in range(2, 9):
        p = gen_binary_like(n)
        ids, ops = reference_solution(n, p)
        cur = [-1]*n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert cur[v] != ids[0]
            cur[v] = cur[cur[v]]
        assert all(cur[v] == p[v] for v in range(1, n))

if __name__ == "__main__":
    selftest()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys
import heapq
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [-1] * n
    for i in range(1, n):
        p[i] = next(it)
    return n, p

def greedy_bamboo_order(n: int, p: List[int]) -> List[int]:
    children = [[] for _ in range(n)]
    deg = [0] * n
    for v in range(1, n):
        u = p[v]
        children[u].append(v)
        deg[u] += 1
    c = [0] * n
    for u in range(n):
        c[u] = (1 if u != 0 else 0) - deg[u]
    heap = [(-c[0], 0)]
    order: List[int] = []
    while heap:
        negw, u = heapq.heappop(heap)
        order.append(u)
        for v in children[u]:
            heapq.heappush(heap, (-c[v], v))
    assert len(order) == n and order[0] == 0
    return order

def construct_sequence(n: int, p: List[int]) -> Tuple[List[int], List[int]]:
    ids = greedy_bamboo_order(n, p)
    cur = [-1] * n
    for i in range(1, n):
        cur[ids[i]] = ids[i-1]
    ops: List[int] = []
    root = ids[0]
    for i in range(n-1, 0, -1):
        v = ids[i]
        while cur[v] != p[v]:
            assert cur[v] != root
            cur[v] = cur[cur[v]]
            ops.append(v)
    for v in range(1, n):
        assert cur[v] == p[v]
    return ids, ops

def solve_case(n: int, p: List[int]) -> str:
    ids, ops = construct_sequence(n, p)
    out = []
    out.append(" ".join(map(str, ids)))
    out.append(str(len(ops)))
    out.append(" ".join(map(str, ops)))
    return "\n".join(out)

def solve_all():
    n, p = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_case(n, p))

if __name__ == "__main__":
    # asserts
    def _apply(ids: List[int], ops: List[int]) -> List[int]:
        n = len(ids)
        cur = [-1] * n
        for i in range(1, n):
            cur[ids[i]] = ids[i-1]
        for v in ops:
            assert v != ids[0] and cur[v] != ids[0]
            cur[v] = cur[cur[v]]
        return cur

    for (n, p) in [
        (2, [-1, 0]),
        (4, [-1, 0, 0, 1]),
        (5, [-1, 0, 1, 1, 3]),
    ]:
        ids, ops = construct_sequence(n, p)
        assert _apply(ids, ops) == p
    # ready to run
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick a bamboo order that minimizes the sum of gaps between each child and its parent, then lift nodes from tail to head to close those gaps.}
\WHY{This tests greedy scheduling under precedence constraints and careful constructive simulation in tree transformations.}
\CHECKLIST{
\begin{bullets}
\item Build children, degrees, and weights $c(u)=\mathbf{1}_{u\ne 0}-\deg(u)$.
\item Greedy PQ over available vertices to get $ids$.
\item Initialize chain parents along $ids$.
\item Iterate from tail to head; lift until parent matches target.
\item Validate operations and final parent array.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All chain (already bamboo): $k=0$.
\item Star centered at root: large $k$; still correct.
\item Deep skinny path with one extra branch near the root.
\item Root with exactly one child (smallest nontrivial).
\item Node whose desired parent is root.
\item Balanced versus skewed branching degrees.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Performing lifts from head to tail can overshoot desired parents.
\item Forgetting to ensure the root label is first in $ids$.
\item Miscomputing $c(u)$ by including the root's $+1$ term.
\item Using a min-heap without negating weights in Python.
\item Not verifying operation validity: $p(v)$ must not be the root at the moment of a lift.
\item Printing no third line when $k=0$ (print an empty line).
\end{bullets}
}
\FAILMODES{Baseline order $[0,1,\ldots,n-1]$ can lead to quadratic $k$ and may exceed $10^6$ on some trees; the greedy order avoids unnecessary gaps and is optimal.}
\ELI{Lay all nodes on a line so each parent appears before its children in the best way possible (using a priority by a simple score). Then, from the end of the line, bubble each node up toward its parent one grandparent at a time until it sticks.}
\NotePages{3}

\end{document}