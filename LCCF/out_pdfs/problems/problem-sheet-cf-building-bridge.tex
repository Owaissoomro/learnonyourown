% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Building Bridge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/247/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Two villages are separated by a river that flows from the north to the south. The villagers want to build a bridge across the river to make it easier to move across the villages.

The river banks can be assumed to be vertical straight lines $x=a$ and $x=b$ $(0<a<b)$.

The west village lies in a steppe at point $O=(0,0)$. There are $n$ pathways leading from the village to the river, they end at points $A_i=(a,y_i)$. The villagers there are plain and simple, so their pathways are straight segments as well.

The east village has reserved and cunning people. Their village is in the forest on the east bank of the river, but its exact position is not clear. There are $m$ twisted paths leading from this village to the river and ending at points $B_i=(b,y'_i)$. The lengths of all these paths are known, the length of the path that leads from the eastern village to point $B_i$ equals $l_i$.

The villagers want to choose exactly one point on the left bank of river $A_i$, exactly one point on the right bank $B_j$ and connect them by a straight-line bridge so as to make the total distance between the villages (the sum of $|OA_i|+|A_iB_j|+l_j$, where $|XY|$ is the Euclidean distance between points $X$ and $Y$) minimum. The Euclidean distance between points $(x_1,y_1)$ and $(x_2,y_2)$ equals
\begin{BreakableEquation*}
\sqrt{(x_{1}-x_{2})^{2}+(y_{1}-y_{2})^{2}}.
\end{BreakableEquation*}

Help them and find the required pair of points.

Input:
The first line contains integers $n,m,a,b$ $(1 \le n,m \le 10^{5},~0<a<b<10^{6})$.

The second line contains $n$ integers in ascending order: the $i$-th integer determines the coordinate of point $A_i$ and equals $y_i$ $(|y_i| \le 10^{6})$.

The third line contains $m$ integers in ascending order: the $i$-th integer determines the coordinate of point $B_i$ and equals $y'_i$ $(|y'_i| \le 10^{6})$.

The fourth line contains $m$ more integers: the $i$-th of them determines the length of the path that connects the eastern village and point $B_i$, and equals $l_i$ $(1 \le l_i \le 10^{6})$.

It is guaranteed that there is such a point $C$ with abscissa at least $b$, that $|B_iC| \le l_i$ for all $i$ $(1 \le i \le m)$. It is guaranteed that no two points $A_i$ coincide. It is guaranteed that no two points $B_i$ coincide.

Output:
Print two integers — the numbers of points on the left (west) and right (east) banks, respectively, between which you need to build a bridge. You can assume that the points on the west bank are numbered from $1$ to $n$, in the order in which they are given in the input. Similarly, the points on the east bank are numbered from $1$ to $m$ in the order in which they are given in the input.

If there are multiple solutions, print any of them. The solution will be accepted if the final length of the path differs from the answer of the jury by no more than $10^{-6}$ in absolute or relative value.}
\BREAKDOWN{Minimize over pairs $(i,j)$ the quantity $\sqrt{a^{2}+y_i^{2}}+\sqrt{(b-a)^{2}+(y_i-y'_j)^{2}}+l_j$. Observe that for fixed $y$, the best $j$ is the lower envelope of $m$ convex functions. Use the 1D additively weighted Voronoi structure: sites at $y'_j$ with weights $l_j$ under metric $d(y,s)=\sqrt{(b-a)^{2}+(y-s)^{2}}$. The argmin index is monotone in $y$, enabling an envelope build and a linear scan for the $n$ queries $y_i$.}
\ELI{Each east point $B_j$ induces a convex ``bowl'' in $y$; their pointwise minimum gives, for every west $A_i$, which $B_j$ is cheapest to bridge to. Build this minimum once, then scan all $A_i$ to pick the best pair.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,m,a,b$. Arrays $y_1<\cdots<y_n$, $y'_1<\cdots<y'_m$, and $l_1,\ldots,l_m$. Ranges as in the statement: $1 \le n,m \le 10^{5}$, $0<a<b<10^{6}$, $|y_i|,|y'_j| \le 10^{6}$, $1 \le l_j \le 10^{6}$.}
\OUTPUTS{Two $1$-based indices $i^\star, j^\star$ that minimize $\sqrt{a^{2}+y_i^{2}}+\sqrt{(b-a)^{2}+(y_i-y'_j)^{2}}+l_j$. Any minimizer is accepted.}
\SAMPLES{Example 1:
Input
n m a b
2 2 1 3
-1 2
0 3
5 1

One optimal output (indices): 2 2

Example 2:
Input
3 3 2 5
-2 0 4
-1 1 6
3 2 7

One optimal output (indices): 2 2}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $d=b-a>0$. For each west bank candidate $A_i=(a,y_i)$ and east bank candidate $B_j=(b,y'_j)$ with weight $l_j$, define
\begin{BreakableEquation*}
F(i,j)=\sqrt{a^{2}+y_i^{2}}+\sqrt{d^{2}+(y_i-y'_j)^{2}}+l_j.
\end{BreakableEquation*}
We want $(i^\star,j^\star)\in\arg\min_{1\le i\le n,~1\le j\le m} F(i,j).
$}
\varmapStart
\var{a,b}{river-bank abscissas with $0<a<b$}
\var{d}{bank gap $d=b-a$}
\var{y_i}{west bank ordinates (sorted)}
\var{y'_j}{east bank ordinates (sorted)}
\var{l_j}{east path lengths (weights)}
\var{F(i,j)}{total cost for pair $(i,j)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{i} \Bigl[\sqrt{a^{2}+y_i^{2}} + \underbrace{\min_{j}\bigl(l_j+\sqrt{d^{2}+(y_i-y'_j)^{2}}\bigr)}_{=:~h(y_i)}\Bigr].
\end{BreakableEquation*}
}
\ASSUMPTIONS{Arrays $y_i$ and $y'_j$ are strictly increasing. All inputs fit in 64-bit integers; computations use double-precision floating point.}
\INVARIANTS{For fixed $y$, the function $j\mapsto l_j+\sqrt{d^{2}+(y-y'_j)^{2}}$ attains its minimum at an index that is nondecreasing in $y$. Pairwise comparison between two sites $j<k$ has at most one intersection if $|l_k-l_j|<y'_k-y'_j$, and otherwise one dominates the other everywhere.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $F(i,j)$ for every pair and take the best.}
\ASSUMPTIONS{None beyond input constraints; uses double-precision math.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For all $i=1\ldots n$ and $j=1\ldots m$, compute $F(i,j)$.
\item Track the minimum value and indices $(i,j)$.
\item Output the indices of the minimum.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(nm)$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n,m) &= n \times m \text{ evaluations of one square root and hypot} \\
       &= \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration guarantees finding a global minimum.}
\EDGECASES{Single-element arrays ($n=1$ or $m=1$), large coordinates, ties in the objective.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math, random

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    yps = [int(next(it)) for _ in range(m)]
    ls = [int(next(it)) for _ in range(m)]
    return n, m, a, b, ys, yps, ls

def total_cost_pair(a, d, yi, ypj, lj):
    # sqrt(a^2 + yi^2) + sqrt(d^2 + (yi - ypj)^2) + lj
    return math.hypot(a, yi) + math.hypot(d, yi - ypj) + lj

def solve_case_brutal(n, m, a, b, ys, yps, ls):
    d = b - a
    best = float('inf')
    bi = bj = 1
    for i in range(n):
        base = math.hypot(a, ys[i])
        for j in range(m):
            v = base + math.hypot(d, ys[i] - yps[j]) + ls[j]
            if v < best:
                best = v
                bi, bj = i + 1, j + 1
    return bi, bj

def solve_all_brutal():
    args = read_input()
    if args is None:
        return
    n, m, a, b, ys, yps, ls = args
    i, j = solve_case_brutal(n, m, a, b, ys, yps, ls)
    print(i, j)

def _self_check_small():
    # Deterministic small test
    n, m, a, b = 2, 2, 1, 3
    ys = [-1, 2]
    yps = [0, 3]
    ls = [5, 1]
    i, j = solve_case_brutal(n, m, a, b, ys, yps, ls)
    assert 1 <= i <= n and 1 <= j <= m
    # Random cross-check against itself (trivial sanity)
    for _ in range(20):
        n = random.randint(1, 5)
        m = random.randint(1, 5)
        a = random.randint(1, 5)
        b = a + random.randint(1, 5)
        ys = sorted(random.randint(-5, 5) for __ in range(n))
        yps = sorted(random.randint(-5, 5) for __ in range(m))
        ls = [random.randint(1, 7) for __ in range(m)]
        i, j = solve_case_brutal(n, m, a, b, ys, yps, ls)
        assert 1 <= i <= n and 1 <= j <= m

if __name__ == "__main__":
    _self_check_small()
    # solve_all_brutal()  # Disabled for baseline
\end{minted}
\VALIDATION{Tiny cases and random small instances covered in asserts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Lower Envelope of Weighted Euclidean Distances}
\WHICHFORMULA{For each $y$ we need $h(y)=\min_j\bigl(l_j+\sqrt{d^{2}+(y-y'_j)^{2}}\bigr)$. The functions are convex, symmetric around $y'_j$, and pairwise differences are strictly monotone in $y$. Thus, along the real line, the argmin index forms contiguous intervals in increasing $j$. We can build this 1D additively weighted Voronoi diagram by maintaining a stack of candidates and computing intersection points.}
\ASSUMPTIONS{The arrays $y'_j$ are strictly increasing. We use double-precision and bisection to locate unique intersections where $|l_k-l_j|<y'_k-y'_j$; if $|l_k-l_j| \ge y'_k-y'_j$, one of the two is globally dominated.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $d=b-a$.
\item Process $j=1\ldots m$ in increasing $y'_j$; maintain a stack of indices and an array of starting abscissas (breakpoints) where each index becomes optimal.
\item When adding a new $j$, repeatedly compare with the last stack element $k$:
  \begin{itemize}
  \item If $l_j-l_k \le -(y'_j-y'_k)$, then $j$ dominates $k$ everywhere; pop $k$ and continue.
  \item Else if $l_j-l_k \ge (y'_j-y'_k)$, then $k$ dominates $j$; discard $j$.
  \item Else, find the unique $y^\star$ solving $l_k+\sqrt{d^{2}+(y-y'_k)^{2}}=l_j+\sqrt{d^{2}+(y-y'_j)^{2}}$ by bisection. If $y^\star \le$ start of $k$, pop $k$; else push $j$ with start $y^\star$ and stop.
  \end{itemize}
\item With the resulting breakpoints, answer the $n$ queries $y_i$ by a single left-to-right scan over $y_i$ and the piecewise-constant optimal $j$.
\item Track the minimum $\sqrt{a^{2}+y_i^{2}}+h(y_i)$ and record $(i,j)$.
\end{algosteps}
\COMPLEXITY{Building the envelope takes $O(m \log \varepsilon^{-1})$ time due to bisection per accepted intersection and $O(m)$ memory. Querying all $y_i$ is $O(n)$ by a single scan. Overall $O((n+m)\log \varepsilon^{-1})$ time and $O(n+m)$ space.}
\[
\begin{aligned}
T(n,m) &\approx O\bigl(m \log(1/\varepsilon) + n\bigr), \quad S(n,m)=O(n+m). \\
\end{aligned}
\]
\CORRECTNESS{Pairwise differences between any two sites $j<k$,
\begin{BreakableEquation*}
\phi_{jk}(y)=\sqrt{d^{2}+(y-y'_j)^{2}}-\sqrt{d^{2}+(y-y'_k)^{2}},
\end{BreakableEquation*}
have derivative $\phi'_{jk}(y)=\tfrac{y-y'_j}{\sqrt{d^{2}+(y-y'_j)^{2}}}-\tfrac{y-y'_k}{\sqrt{d^{2}+(y-y'_k)^{2}}}>0$, hence are strictly increasing. Therefore, for given weights, equalities $l_k-l_j=\phi_{jk}(y)$ have at most one solution if $|l_k-l_j|<y'_k-y'_j$; otherwise one function dominates everywhere. The stack algorithm is the standard construction of a lower envelope of functions with single crossings and preserves correctness.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math, random

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    yps = [int(next(it)) for _ in range(m)]
    ls = [int(next(it)) for _ in range(m)]
    return n, m, a, b, ys, yps, ls

def cost_piece(d, y, ypj, lj):
    return math.hypot(d, y - ypj) + lj

def diff_two(d, y, ypj, lj, ypk, lk):
    # f_j(y) - f_k(y)
    return (math.hypot(d, y - ypj) + lj) - (math.hypot(d, y - ypk) + lk)

def intersect_y(d, ypj, lj, ypk, lk):
    # Solve for y: cost_piece(d, y, ypj, lj) == cost_piece(d, y, ypk, lk)
    # Precondition: |(lk - lj)| < (ypk - ypj). Use bisection with a wide bracket.
    lo = -1e12
    hi = 1e12
    f_lo = diff_two(d, lo, ypj, lj, ypk, lk)
    f_hi = diff_two(d, hi, ypj, lj, ypk, lk)
    # f_lo < 0 and f_hi > 0 under the above condition
    for _ in range(80):
        mid = (lo + hi) * 0.5
        fm = diff_two(d, mid, ypj, lj, ypk, lk)
        if fm <= 0:
            lo, f_lo = mid, fm
        else:
            hi, f_hi = mid, fm
    return (lo + hi) * 0.5

def build_envelope(yps, ls, d):
    # Returns (idxs, starts). idxs are indices into yps/ls (0-based).
    # starts[k] is the smallest y for which idxs[k] is optimal.
    idxs = []
    starts = []
    for j in range(len(yps)):
        # Try to insert j
        if not idxs:
            idxs.append(j)
            starts.append(-float('inf'))
            continue
        while True:
            k = idxs[-1]
            D = yps[j] - yps[k]
            W = ls[j] - ls[k]
            if W <= -D:
                # j dominates k everywhere
                idxs.pop(); starts.pop()
                if not idxs:
                    idxs.append(j); starts.append(-float('inf'))
                    break
                else:
                    continue
            if W >= D:
                # k dominates j everywhere
                break
            # They intersect uniquely
            ystar = intersect_y(d, yps[k], ls[k], yps[j], ls[j])
            if ystar <= starts[-1]:
                # k is never optimal
                idxs.pop(); starts.pop()
                if not idxs:
                    idxs.append(j); starts.append(-float('inf'))
                    break
            else:
                idxs.append(j); starts.append(ystar)
                break
    return idxs, starts

def solve_case_improved(n, m, a, b, ys, yps, ls):
    d = b - a
    idxs, starts = build_envelope(yps, ls, d)
    # Scan ys increasing
    p = 0
    best = float('inf')
    bi = bj = 1
    for i, y in enumerate(ys):
        while p + 1 < len(starts) and starts[p + 1] <= y:
            p += 1
        j = idxs[p]
        val = math.hypot(a, y) + math.hypot(d, y - yps[j]) + ls[j]
        if val < best:
            best = val
            bi, bj = i + 1, j + 1
    return bi, bj

def solve_all_improved():
    args = read_input()
    if args is None:
        return
    n, m, a, b, ys, yps, ls = args
    i, j = solve_case_improved(n, m, a, b, ys, yps, ls)
    print(i, j)

def _cross_check():
    rnd = random.Random(0)
    for _ in range(200):
        n = rnd.randint(1, 12)
        m = rnd.randint(1, 12)
        a = rnd.randint(1, 20)
        b = a + rnd.randint(1, 20)
        ys = sorted(rnd.randint(-30, 30) for __ in range(n))
        yps = sorted(rnd.randint(-30, 30) for __ in range(m))
        ls = [rnd.randint(1, 40) for __ in range(m)]
        bi1, bj1 = solve_case_improved(n, m, a, b, ys, yps, ls)
        # brute
        d = b - a
        best = float('inf'); bi2 = bj2 = None
        for i in range(n):
            for j in range(m):
                v = math.hypot(a, ys[i]) + math.hypot(d, ys[i] - yps[j]) + ls[j]
                if v < best - 1e-12:
                    best = v; bi2 = i + 1; bj2 = j + 1
        # Either indices or value must match
        v1 = math.hypot(a, ys[bi1-1]) + math.hypot(d, ys[bi1-1] - yps[bj1-1]) + ls[bj1-1]
        assert abs(v1 - best) < 1e-7

if __name__ == "__main__":
    _cross_check()
    # solve_all_improved()  # Disabled in improved block
\end{minted}
\VALIDATION{Randomized cross-check against the brute force on small sizes; deterministic sanity assertions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Weighted 1D Voronoi + Linear Scan}
\WHICHFORMULA{Build the lower envelope of $f_j(y)=l_j+\sqrt{d^{2}+(y-y'_j)^{2}}$ in $O(m \log \varepsilon^{-1})$ time via a monotone stack and bisection at unique crossings, then scan all $y_i$ in order to pick the best pair.}
\ASSUMPTIONS{Sorted $y_i$ and $y'_j$. Double precision is sufficient to fit the $10^{-6}$ tolerance.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Construct the envelope $(\text{idxs},\text{starts})$ as in Approach B.
\item Walk $y_i$ left-to-right, keep a pointer to the current envelope piece, and evaluate the cost.
\item Track and report the minimizing $(i,j)$.
\end{algosteps}
\OPTIMALITY{Each pair of sites intersects at most once and may dominate entirely. The envelope contains at most $m$ pieces, and we traverse it once when answering queries. Any algorithm must at least read all inputs, implying $\Omega(n+m)$ time; our solution is tight up to a factor $\log \varepsilon^{-1}$ from bisection, which is bounded and negligible in practice.}
\COMPLEXITY{$O(m \log \varepsilon^{-1}+n)$ time, $O(m)$ space.}
\[
\begin{aligned}
T(n,m) &= O(m \log \varepsilon^{-1}) + O(n), \quad S(n,m)=O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math, random

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    yps = [int(next(it)) for _ in range(m)]
    ls = [int(next(it)) for _ in range(m)]
    return n, m, a, b, ys, yps, ls

def diff_two(d, y, ypj, lj, ypk, lk):
    return (math.hypot(d, y - ypj) + lj) - (math.hypot(d, y - ypk) + lk)

def intersect_y(d, ypj, lj, ypk, lk):
    lo = -1e12
    hi = 1e12
    f_lo = diff_two(d, lo, ypj, lj, ypk, lk)
    f_hi = diff_two(d, hi, ypj, lj, ypk, lk)
    # Ensure bracket is correct
    if f_lo > f_hi:
        lo, hi = hi, lo
        f_lo, f_hi = f_hi, f_lo
    for _ in range(80):
        mid = (lo + hi) * 0.5
        fm = diff_two(d, mid, ypj, lj, ypk, lk)
        if fm <= 0:
            lo, f_lo = mid, fm
        else:
            hi, f_hi = mid, fm
    return (lo + hi) * 0.5

def build_envelope(yps, ls, d):
    idxs = []
    starts = []
    for j in range(len(yps)):
        if not idxs:
            idxs.append(j)
            starts.append(-float('inf'))
            continue
        while True:
            k = idxs[-1]
            D = yps[j] - yps[k]
            W = ls[j] - ls[k]
            if W <= -D:
                # j dominates k everywhere
                idxs.pop(); starts.pop()
                if not idxs:
                    idxs.append(j); starts.append(-float('inf'))
                    break
                continue
            if W >= D:
                # k dominates j everywhere
                break
            # Unique intersection
            ystar = intersect_y(d, yps[k], ls[k], yps[j], ls[j])
            if ystar <= starts[-1]:
                idxs.pop(); starts.pop()
                if not idxs:
                    idxs.append(j); starts.append(-float('inf'))
                    break
                continue
            idxs.append(j); starts.append(ystar)
            break
    return idxs, starts

def solve_case(n, m, a, b, ys, yps, ls):
    d = b - a
    idxs, starts = build_envelope(yps, ls, d)
    p = 0
    best = float('inf'); bi = bj = 1
    for i, y in enumerate(ys):
        while p + 1 < len(starts) and starts[p + 1] <= y:
            p += 1
        j = idxs[p]
        val = math.hypot(a, y) + math.hypot(d, y - yps[j]) + ls[j]
        if val < best:
            best = val
            bi, bj = i + 1, j + 1
    return bi, bj

def solve_all():
    args = read_input()
    if args is None:
        return
    n, m, a, b, ys, yps, ls = args
    i, j = solve_case(n, m, a, b, ys, yps, ls)
    print(i, j)

def _tests():
    # Cross-check against brute force on small randoms
    rnd = random.Random(1)
    for _ in range(200):
        n = rnd.randint(1, 10)
        m = rnd.randint(1, 10)
        a = rnd.randint(1, 10)
        b = a + rnd.randint(1, 10)
        ys = sorted(rnd.randint(-20, 20) for __ in range(n))
        yps = sorted(rnd.randint(-20, 20) for __ in range(m))
        ls = [rnd.randint(1, 30) for __ in range(m)]
        bi, bj = solve_case(n, m, a, b, ys, yps, ls)
        d = b - a
        best = float('inf'); gi = gj = None
        for i in range(n):
            for j in range(m):
                v = math.hypot(a, ys[i]) + math.hypot(d, ys[i] - yps[j]) + ls[j]
                if v < best - 1e-12:
                    best = v; gi = i + 1; gj = j + 1
        v_ans = math.hypot(a, ys[bi-1]) + math.hypot(d, ys[bi-1] - yps[bj-1]) + ls[bj-1]
        assert abs(v_ans - best) < 1e-7
    # Simple fixed test
    n, m, a, b = 2, 2, 1, 3
    ys = [-1, 2]; yps = [0, 3]; ls = [5, 1]
    i, j = solve_case(n, m, a, b, ys, yps, ls)
    assert 1 <= i <= n and 1 <= j <= m

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 checks: (1) randomized brute-force cross-check on small cases, (2) a fixed tiny case, (3) end-to-end read/solve/print path.}
\RESULT{Outputs any optimal pair $(i^\star,j^\star)$; ties are broken arbitrarily by first appearance during scanning.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit assertions comparing against brute force for small random inputs; deterministic fixed cases; verifying domination and intersection logic; ensuring monotone scan across breakpoints returns nondecreasing $j$.}
\LINE{CROSS-CHECKS}{Compare Approach A (brute force) vs. Approach C (envelope) on small random instances; ensure objective values match within $10^{-7}$.}
\LINE{EDGE-CASE GENERATOR}{Generates degenerate patterns: identical $l_j$, large gaps $y'_k-y'_j$, domination cases with $|l_k-l_j|\ge y'_k-y'_j$, and extreme coordinates.}
\begin{minted}{python}
import math, random

def gen_cases():
    rnd = random.Random(42)
    cases = []
    # Minimal sizes
    cases.append((1, 1, 1, 2, [0], [0], [1]))
    # Equal weights, spread y'
    cases.append((3, 4, 2, 7, [-5, 0, 4], [-10, -1, 3, 20], [5, 5, 5, 5]))
    # Domination heavy
    cases.append((4, 5, 3, 9, [-7, -3, 2, 8], [-8, -2, 0, 1, 12], [100, 1, 2, 3, 4]))
    # Random smalls
    for _ in range(10):
        n = rnd.randint(1, 6)
        m = rnd.randint(1, 6)
        a = rnd.randint(1, 10)
        b = a + rnd.randint(1, 10)
        ys = sorted(rnd.randint(-20, 20) for __ in range(n))
        yps = sorted(rnd.randint(-20, 20) for __ in range(m))
        ls = [rnd.randint(1, 30) for __ in range(m)]
        cases.append((n, m, a, b, ys, yps, ls))
    return cases

def brute(n, m, a, b, ys, yps, ls):
    d = b - a
    best = float('inf'); bi = bj = None
    for i in range(n):
        for j in range(m):
            v = math.hypot(a, ys[i]) + math.hypot(d, ys[i] - yps[j]) + ls[j]
            if v < best:
                best = v; bi = i + 1; bj = j + 1
    return bi, bj, best

def run_ref(n, m, a, b, ys, yps, ls):
    # Reuse final solve_case
    d = b - a
    def diff_two(d, y, ypj, lj, ypk, lk):
        return (math.hypot(d, y - ypj) + lj) - (math.hypot(d, y - ypk) + lk)
    def intersect_y(d, ypj, lj, ypk, lk):
        lo = -1e12; hi = 1e12
        f_lo = diff_two(d, lo, ypj, lj, ypk, lk)
        f_hi = diff_two(d, hi, ypj, lj, ypk, lk)
        if f_lo > f_hi:
            lo, hi = hi, lo
            f_lo, f_hi = f_hi, f_lo
        for _ in range(80):
            mid = (lo + hi) * 0.5
            fm = diff_two(d, mid, ypj, lj, ypk, lk)
            if fm <= 0:
                lo = mid
            else:
                hi = mid
        return (lo + hi) * 0.5
    def build_envelope(yps, ls, d):
        idxs = []; starts = []
        for j in range(len(yps)):
            if not idxs:
                idxs.append(j); starts.append(-float('inf')); continue
            while True:
                k = idxs[-1]
                D = yps[j] - yps[k]
                W = ls[j] - ls[k]
                if W <= -D:
                    idxs.pop(); starts.pop()
                    if not idxs:
                        idxs.append(j); starts.append(-float('inf'))
                        break
                    continue
                if W >= D:
                    break
                ystar = intersect_y(d, yps[k], ls[k], yps[j], ls[j])
                if ystar <= starts[-1]:
                    idxs.pop(); starts.pop()
                    if not idxs:
                        idxs.append(j); starts.append(-float('inf'))
                        break
                    continue
                idxs.append(j); starts.append(ystar)
                break
        return idxs, starts
    idxs, starts = build_envelope(yps, ls, d)
    p = 0; best = float('inf'); bi = bj = 1
    for i, y in enumerate(ys):
        while p + 1 < len(starts) and starts[p + 1] <= y:
            p += 1
        j = idxs[p]
        v = math.hypot(a, y) + math.hypot(d, y - yps[j]) + ls[j]
        if v < best:
            best = v; bi = i + 1; bj = j + 1
    return bi, bj, best

def main_test():
    for case in gen_cases():
        bi, bj, best = brute(*case)
        ri, rj, rbest = run_ref(*case)
        assert abs(best - rbest) < 1e-7

if __name__ == "__main__":
    main_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    yps = [int(next(it)) for _ in range(m)]
    ls = [int(next(it)) for _ in range(m)]
    return n, m, a, b, ys, yps, ls

def diff_two(d, y, ypj, lj, ypk, lk):
    return (math.hypot(d, y - ypj) + lj) - (math.hypot(d, y - ypk) + lk)

def intersect_y(d, ypj, lj, ypk, lk):
    lo = -1e12
    hi = 1e12
    f_lo = diff_two(d, lo, ypj, lj, ypk, lk)
    f_hi = diff_two(d, hi, ypj, lj, ypk, lk)
    if f_lo > f_hi:
        lo, hi = hi, lo
        f_lo, f_hi = f_hi, f_lo
    for _ in range(80):
        mid = (lo + hi) * 0.5
        fm = diff_two(d, mid, ypj, lj, ypk, lk)
        if fm <= 0:
            lo, f_lo = mid, fm
        else:
            hi, f_hi = mid, fm
    return (lo + hi) * 0.5

def build_envelope(yps, ls, d):
    idxs = []
    starts = []
    for j in range(len(yps)):
        if not idxs:
            idxs.append(j)
            starts.append(-float('inf'))
            continue
        while True:
            k = idxs[-1]
            D = yps[j] - yps[k]
            W = ls[j] - ls[k]
            if W <= -D:
                idxs.pop(); starts.pop()
                if not idxs:
                    idxs.append(j); starts.append(-float('inf'))
                    break
                continue
            if W >= D:
                break
            ystar = intersect_y(d, yps[k], ls[k], yps[j], ls[j])
            if ystar <= starts[-1]:
                idxs.pop(); starts.pop()
                if not idxs:
                    idxs.append(j); starts.append(-float('inf'))
                    break
                continue
            idxs.append(j); starts.append(ystar)
            break
    return idxs, starts

def solve_case(n, m, a, b, ys, yps, ls):
    d = b - a
    idxs, starts = build_envelope(yps, ls, d)
    p = 0
    best = float('inf'); bi = bj = 1
    for i, y in enumerate(ys):
        while p + 1 < len(starts) and starts[p + 1] <= y:
            p += 1
        j = idxs[p]
        val = math.hypot(a, y) + math.hypot(d, y - yps[j]) + ls[j]
        if val < best:
            best = val
            bi, bj = i + 1, j + 1
    return bi, bj

def solve_all():
    args = read_input()
    if args is None:
        return
    n, m, a, b, ys, yps, ls = args
    i, j = solve_case(n, m, a, b, ys, yps, ls)
    print(i, j)

def _asserts():
    # Tiny deterministic test
    n, m, a, b = 2, 2, 1, 3
    ys = [-1, 2]
    yps = [0, 3]
    ls = [5, 1]
    i, j = solve_case(n, m, a, b, ys, yps, ls)
    assert 1 <= i <= n and 1 <= j <= m
    # Cross-check against brute force on small randoms
    import random
    rnd = random.Random(7)
    for _ in range(100):
        n = rnd.randint(1, 8)
        m = rnd.randint(1, 8)
        a = rnd.randint(1, 10)
        b = a + rnd.randint(1, 10)
        ys = sorted(rnd.randint(-15, 15) for __ in range(n))
        yps = sorted(rnd.randint(-15, 15) for __ in range(m))
        ls = [rnd.randint(1, 20) for __ in range(m)]
        di = dj = None
        di, dj = solve_case(n, m, a, b, ys, yps, ls)
        # brute
        d = b - a
        best = float('inf'); bi = bj = None
        for ii in range(n):
            for jj in range(m):
                v = math.hypot(a, ys[ii]) + math.hypot(d, ys[ii] - yps[jj]) + ls[jj]
                if v < best:
                    best = v; bi = ii + 1; bj = jj + 1
        v_ans = math.hypot(a, ys[di-1]) + math.hypot(d, ys[di-1] - yps[dj-1]) + ls[dj-1]
        assert abs(v_ans - best) < 1e-7

if __name__ == "__main__":
    _asserts()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize $\sqrt{a^{2}+y_i^{2}}+\min_j\bigl(l_j+\sqrt{(b-a)^{2}+(y_i-y'_j)^{2}}\bigr)$ by building a 1D weighted Voronoi envelope and scanning.}
\WHY{Combines geometry, convexity, and data-structure thinking; tests ability to derive monotonicity and implement a robust envelope.}
\CHECKLIST{
\begin{bullets}
\item Sort inputs; confirm monotonic $y_i$, $y'_j$.
\item Precompute $d=b-a$.
\item Build envelope: dominance tests, then intersection by bisection.
\item Store indices and breakpoints; first breakpoint is $-\infty$.
\item Single pass over $y_i$ to find best $j$ and global best pair.
\item Print $1$-based indices.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ or $m=1$.
\item Very large $|y_i|$ or $|y'_j|$ near $10^{6}$.
\item Dominations: $|l_k-l_j| \ge y'_k-y'_j$.
\item Ties at a breakpoint $y_i \approx$ start; either index acceptable.
\item Colocated $y_i$ or $y'_j$ are disallowed by statement but keep code general.
\item Precision: ensure bisection iterations sufficient; use \texttt{math.hypot}.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using neighbor-only two-pointer without handling domination can miss a better far site.
\item Numerical overflow with huge bracketing; prefer moderate brackets but ensure sign change.
\item Forgetting that the first envelope start is $-\infty$ may skip early $y_i$.
\item Off-by-one when converting to $1$-based indices.
\item Not popping dominated candidates can bloat the envelope and slow queries.
\item Using squared distances mixes linear and square-root terms incorrectly; do not square the whole objective naively.
\end{bullets}
}
\FAILMODES{Brute force times out at $10^{10}$ operations; naive greedy on $j$ can fail when a site two steps ahead becomes optimal while the immediate neighbor is always worse; imprecise intersection causes wrong breakpoints. The envelope with bisection withstands all these.}
\ELI{Each east point creates a ``cost hill'' in $y$; the cheapest hill at each $y$ forms stripes. Find where hills swap being cheapest, then for each west point, pick the stripe it falls in. The best bridge is the pair with the smallest total.}
\NotePages{3}

\end{document}