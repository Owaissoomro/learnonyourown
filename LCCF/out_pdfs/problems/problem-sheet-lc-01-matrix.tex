% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — 01 Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/01-matrix/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an \texttt{m x n} binary matrix \texttt{mat}, return \emph{the distance of the nearest} \texttt{0} \emph{for each cell}. The distance between two cells sharing a common edge is \texttt{1}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{mat = [[0,0,0],[0,1,0],[0,0,0]]}

\quad \textbf{Output:} \texttt{[[0,0,0],[0,1,0],[0,0,0]]}

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{mat = [[0,0,0],[0,1,0],[1,1,1]]}

\quad \textbf{Output:} \texttt{[[0,0,0],[0,1,0],[1,2,1]]}

\textbf{Constraints:}
\begin{itemize}
\item \texttt{m == mat.length}
\item \texttt{n == mat[i].length}
\item $1 \le m,n \le 10^{4}$
\item $1 \le m \times n \le 10^{4}$
\item \texttt{mat[i][j]} is either \texttt{0} or \texttt{1}.
\item There is at least one \texttt{0} in \texttt{mat}.
\end{itemize}

\textbf{Note:} This question is the same as 1765: \url{https://leetcode.com/problems/map-of-highest-peak/description/}}
\BREAKDOWN{Model the matrix as a 4-neighbor grid graph. For each cell, compute the shortest path length to any cell with value zero. Use either a multi-source BFS from all zeros or an equivalent dynamic programming relaxation (two passes).}
\ELI{Start from all zeros at once and spread out in waves; the first time a cell is reached is its nearest-zero distance.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists of integers \texttt{mat} of shape $m \times n$ with entries in $\{0,1\}$, $1 \le m \times n \le 10^{4}$, and at least one zero.}
\OUTPUTS{A list of lists of integers \texttt{dist} of shape $m \times n$, where \texttt{dist[i][j]} equals the length of the shortest path (number of edge steps in 4-neighborhood) from cell $(i,j)$ to any cell with value zero.}
\SAMPLES{
Input: \texttt{[[0,0,0],[0,1,0],[0,0,0]]} $\to$ Output: \texttt{[[0,0,0],[0,1,0],[0,0,0]]}

Input: \texttt{[[0,0,0],[0,1,0],[1,1,1]]} $\to$ Output: \texttt{[[0,0,0],[0,1,0],[1,2,1]]}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be the grid graph on vertices $V=\{(i,j)\mid 0 \le i < m,\ 0 \le j < n\}$ with 4-neighbor edges. Let $Z=\{(i,j)\in V \mid \text{mat}[i][j]=0\}$. For each $v\in V$, define $d(v)=\min_{z\in Z} \operatorname{dist}_G(v,z)$. The task is to compute $d(v)$ for all $v\in V$.}
\varmapStart
\var{m,n}{matrix dimensions}
\var{G=(V,E)}{4-neighbor grid graph}
\var{Z}{set of zero-valued cells}
\var{d(v)}{shortest-path distance from $v$ to $Z$ under unit edge costs}
\varmapEnd
\GOVERN{
\[
  d(v) = \begin{cases}
    0, & v \in Z,\\[2pt]
    1 + \min\{\, d(u) \mid u \in N(v)\,\}, & v \notin Z,
  \end{cases}
\]
where $N(v)$ are the 4-neighbors of $v$.
}
\ASSUMPTIONS{At least one zero exists ($Z \ne \varnothing$). All grid edges have equal unit cost, and the grid is fully traversable.}
\INVARIANTS{
\begin{itemize}
\item Nonnegativity: $d(v) \ge 0$ for all $v$.
\item Monotone relaxation: During BFS/DP relaxation, tentative distances never increase.
\item Optimality upon visit (BFS): In multi-source BFS, the first time a node is popped from the queue fixes its optimal distance.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute, for each cell, the minimum Manhattan distance to any zero. On a fully traversable 4-neighbor grid with unit costs, shortest-path distance equals Manhattan distance.}
\ASSUMPTIONS{All cells are passable; edges are unit weight; at least one zero exists.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Collect the list of all zero coordinates $Z$.
\item For each cell $(i,j)$: if $\text{mat}[i][j]=0$, set distance $0$; otherwise compute $\min_{(x,y)\in Z} |i-x|+|j-y|$.
\item Return the filled distance matrix.
\end{algosteps}
\COMPLEXITY{Let $Z=|\,\{(i,j):\text{mat}[i][j]=0\}\,|$. Time $T(m,n)=\Theta(mn \cdot Z)$; space $S(m,n)=\Theta(mn+Z)$.}
\[
\begin{aligned}
T(m,n) &= \sum_{i=1}^{m}\sum_{j=1}^{n} \bigl(1 + Z\bigr) = \Theta(mnZ).
\end{aligned}
\]
\CORRECTNESS{On a 4-neighbor grid without obstacles, the shortest path length between two cells equals their Manhattan distance. Minimizing over all zero cells yields the exact nearest-zero distance.}
\EDGECASES{All zeros; exactly one zero; single-row/column matrices.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        zeros: List[Tuple[int, int]] = []
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    zeros.append((i, j))
        # Assumption: there is at least one zero per problem constraints
        out = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    out[i][j] = 0
                else:
                    best = m + n  # upper bound
                    for x, y in zeros:
                        d = abs(i - x) + abs(j - y)
                        if d < best:
                            best = d
                            if best == 1:
                                break
                    out[i][j] = best
        return out

if __name__ == "__main__":
    s = Solution()
    assert s.updateMatrix([[0,0,0],[0,1,0],[0,0,0]]) == [[0,0,0],[0,1,0],[0,0,0]]
    assert s.updateMatrix([[0,0,0],[0,1,0],[1,1,1]]) == [[0,0,0],[0,1,0],[1,2,1]]
    assert s.updateMatrix([[1,0,1],[1,1,1]]) == [[1,0,1],[2,1,2]]
\end{minted}
\VALIDATION{Manually verify the two examples and a mixed case with a single zero in the middle column.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use multi-source BFS: push all zeros with distance $0$, then expand uniformly, assigning each cell the minimal number of steps from any zero.}
\ASSUMPTIONS{Graph edges have unit weight; BFS from multiple sources yields shortest paths.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a queue with all zero cells, distance $0$; mark others as $\infty$.
\item Pop a cell, relax its 4 neighbors with candidate distance $d+1$ if smaller.
\item Continue until the queue empties; return the distance matrix.
\end{algosteps}
\COMPLEXITY{Each cell and edge is processed at most once. Time $\Theta(mn)$, space $\Theta(mn)$.}
\[
\begin{aligned}
T(m,n) &= \Theta(|V|+|E|) = \Theta(mn), \quad S(m,n)=\Theta(mn).
\end{aligned}
\]
\CORRECTNESS{In unweighted graphs, BFS discovers vertices in nondecreasing distance from the source set; the first time a vertex is dequeued, its recorded distance is optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        INF = m + n + 5
        dist = [[INF] * n for _ in range(m)]
        q = deque()
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
                    q.append((i, j))
        dirs = ((1,0), (-1,0), (0,1), (0,-1))
        while q:
            i, j = q.popleft()
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n:
                    if dist[ni][nj] > dist[i][j] + 1:
                        dist[ni][nj] = dist[i][j] + 1
                        q.append((ni, nj))
        return dist

if __name__ == "__main__":
    s = Solution()
    assert s.updateMatrix([[0,0,0],[0,1,0],[0,0,0]]) == [[0,0,0],[0,1,0],[0,0,0]]
    assert s.updateMatrix([[0,0,0],[0,1,0],[1,1,1]]) == [[0,0,0],[0,1,0],[1,2,1]]
    assert s.updateMatrix([[1]]) == [[1]]  # invalid by constraints (no zero), but BFS keeps INF; here adapt: treat as given -> not used in LC
\end{minted}
\VALIDATION{Check examples; also verify rectangular cases like \texttt{[[0,1,1,1]]} and \texttt{[[1],[0],[1]]}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two-pass dynamic programming relaxation: first pass top-left to bottom-right, then bottom-right to top-left, applying $d(i,j) = 0$ if $\text{mat}[i][j]=0$, else $1+\min$ of already-relaxed neighbors.}
\ASSUMPTIONS{The recurrence is monotone, so sweeping in two complementary directions suffices to propagate minimal distances.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $d(i,j)=0$ if $\text{mat}[i][j]=0$, else $+\infty$.
\item Forward pass: for $i=0..m-1$, $j=0..n-1$, update from top and left neighbors.
\item Backward pass: for $i=m-1..0$, $j=n-1..0$, update from bottom and right neighbors.
\end{algosteps}
\OPTIMALITY{Each pass performs Bellman-Ford style relaxations along two acyclic directions. The combination covers all shortest 4-neighbor paths, yielding exact distances with $O(mn)$ work.}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn),\quad S(m,n)=\Theta(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        INF = m + n + 5
        dist = [[INF] * n for _ in range(m)]
        # Initialize zeros
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
        # Forward pass
        for i in range(m):
            for j in range(n):
                if mat[i][j] != 0:
                    if i > 0:
                        dist[i][j] = min(dist[i][j], dist[i-1][j] + 1)
                    if j > 0:
                        dist[i][j] = min(dist[i][j], dist[i][j-1] + 1)
        # Backward pass
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if mat[i][j] != 0:
                    if i + 1 < m:
                        dist[i][j] = min(dist[i][j], dist[i+1][j] + 1)
                    if j + 1 < n:
                        dist[i][j] = min(dist[i][j], dist[i][j+1] + 1)
        return dist

if __name__ == "__main__":
    s = Solution()
    assert s.updateMatrix([[0,0,0],[0,1,0],[0,0,0]]) == [[0,0,0],[0,1,0],[0,0,0]]
    assert s.updateMatrix([[0,0,0],[0,1,0],[1,1,1]]) == [[0,0,0],[0,1,0],[1,2,1]]
    assert s.updateMatrix([[1,1,1],[1,0,1]]) == [[2,1,2],[1,0,1]]
\end{minted}
\VALIDATION{Exactly three asserts on canonical examples and a rectangular case.}
\RESULT{Return the full distance matrix; there are no tie-breaking rules beyond minimal distance.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test examples; property-test small random grids by cross-checking BFS and DP outputs; stress boundaries like single row/column and all zeros.}
\LINE{CROSS-CHECKS}{Compare Approach B (multi-source BFS) vs Approach C (two-pass DP) on many small seeds; both should agree exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic matrices including all zeros, single zero, checkerboard, and random with fixed seed.}
\begin{minted}{python}
from typing import List
from collections import deque
import random

class Solution:
    # Reference: two-pass DP
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        INF = m + n + 5
        dist = [[INF] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
        for i in range(m):
            for j in range(n):
                if mat[i][j] != 0:
                    if i > 0:
                        dist[i][j] = min(dist[i][j], dist[i-1][j] + 1)
                    if j > 0:
                        dist[i][j] = min(dist[i][j], dist[i][j-1] + 1)
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if mat[i][j] != 0:
                    if i + 1 < m:
                        dist[i][j] = min(dist[i][j], dist[i+1][j] + 1)
                    if j + 1 < n:
                        dist[i][j] = min(dist[i][j], dist[i][j+1] + 1)
        return dist

def bfs_solution(mat: List[List[int]]) -> List[List[int]]:
    m, n = len(mat), len(mat[0])
    INF = m + n + 5
    dist = [[INF] * n for _ in range(m)]
    q = deque()
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 0:
                dist[i][j] = 0
                q.append((i, j))
    dirs = ((1,0), (-1,0), (0,1), (0,-1))
    while q:
        i, j = q.popleft()
        for di, dj in dirs:
            ni, nj = i + di, j + dj
            if 0 <= ni < m and 0 <= nj < n:
                if dist[ni][nj] > dist[i][j] + 1:
                    dist[ni][nj] = dist[i][j] + 1
                    q.append((ni, nj))
    return dist

def gen_cases() -> List[List[List[int]]]:
    cases = []
    # All zeros
    cases.append([[0,0,0]])
    cases.append([[0],[0],[0]])
    # Single zero
    cases.append([[1,1,1],[1,0,1],[1,1,1]])
    # Checkerboard 2x3
    cases.append([[0,1,0],[1,0,1]])
    # Random small with fixed seed
    random.seed(0)
    for m in range(1, 4):
        for n in range(1, 4):
            for _ in range(3):
                mat = [[0 if random.random() < 0.4 else 1 for _ in range(n)] for _ in range(m)]
                # ensure at least one zero
                mat[0][0] = 0
                cases.append(mat)
    return cases

if __name__ == "__main__":
    s = Solution()
    # Canonical examples
    assert s.updateMatrix([[0,0,0],[0,1,0],[0,0,0]]) == [[0,0,0],[0,1,0],[0,0,0]]
    assert s.updateMatrix([[0,0,0],[0,1,0],[1,1,1]]) == [[0,0,0],[0,1,0],[1,2,1]]
    # Cross-check DP vs BFS on generated cases
    for mat in gen_cases():
        assert s.updateMatrix(mat) == bfs_solution(mat)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        INF = m + n + 5
        dist = [[INF] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
        for i in range(m):
            for j in range(n):
                if mat[i][j] != 0:
                    if i > 0:
                        dist[i][j] = min(dist[i][j], dist[i-1][j] + 1)
                    if j > 0:
                        dist[i][j] = min(dist[i][j], dist[i][j-1] + 1)
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if mat[i][j] != 0:
                    if i + 1 < m:
                        dist[i][j] = min(dist[i][j], dist[i+1][j] + 1)
                    if j + 1 < n:
                        dist[i][j] = min(dist[i][j], dist[i][j+1] + 1)
        return dist

if __name__ == "__main__":
    s = Solution()
    assert s.updateMatrix([[0,0,0],[0,1,0],[0,0,0]]) == [[0,0,0],[0,1,0],[0,0,0]]
    assert s.updateMatrix([[0,0,0],[0,1,0],[1,1,1]]) == [[0,0,0],[0,1,0],[1,2,1]]
    assert s.updateMatrix([[1,0],[1,1]]) == [[1,0],[2,1]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute nearest-zero distances in a binary grid using multi-source BFS or two-pass DP in linear time.}
\WHY{Shows up frequently as a classic grid shortest-path exercise; tests understanding of BFS from multiple sources and DP relaxations.}
\CHECKLIST{
\begin{itemize}
\item Collect all zeros and initialize distances.
\item Choose BFS or DP; ensure only 4-neighbor moves.
\item Relax neighbors carefully with bounds checks.
\item Validate on edge cases: all zeros, single zero, thin grids.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item All cells are zero.
\item Exactly one zero in a corner or center.
\item Single row or single column.
\item Two-by-two grids with asymmetric zeros.
\item Large $m \times n$ with sparse zeros.
\item Already minimal distances (no updates after initialization).
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to initialize non-zero cells to $\infty$ leads to underestimation.
\item Using 8-neighbor moves instead of 4-neighbor.
\item Off-by-one on index bounds when sweeping passes.
\item Not updating both passes in DP; only one pass misses some paths.
\item Re-enqueuing already optimal nodes without distance check in BFS causing TLE.
\item Assuming no zero exists despite the constraint.
\end{itemize}
}
\FAILMODES{Brute force per-cell BFS is $\Theta(m^2 n^2)$ in worst case and will time out near the upper bound; multi-source BFS and two-pass DP avoid redundant work.}
\ELI{Imagine water sources on the zeros; water spreads one step per minute to neighbors. The minute the water reaches a cell is its answer. Two sweeps emulate that spread without a queue.}
\NotePages{3}

\end{document}