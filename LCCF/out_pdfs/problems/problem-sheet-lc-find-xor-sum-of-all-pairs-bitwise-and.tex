% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find XOR Sum of All Pairs Bitwise AND}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-xor-sum-of-all-pairs-bitwise-and/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{The \textbf{XOR sum} of a list is the bitwise XOR of all its elements. If the list only contains one element, then its \textbf{XOR sum} will be equal to this element.

For example, the \textbf{XOR sum} of \texttt{[1,2,3,4]} is equal to \texttt{1 XOR 2 XOR 3 XOR 4 = 4}, and the \textbf{XOR sum} of \texttt{[3]} is equal to \texttt{3}.

You are given two 0-indexed arrays \texttt{arr1} and \texttt{arr2} that consist only of non-negative integers. Consider the list containing the result of \texttt{arr1[i] AND arr2[j]} (bitwise AND) for every \((i, j)\) pair where \(0 \le i < \texttt{arr1.length}\) and \(0 \le j < \texttt{arr2.length}\). Return the \emph{XOR sum of the aforementioned list}.

Example 1:

Input: \(\texttt{arr1} = [1,2,3], \texttt{arr2} = [6,5]\)

Output: \(\,0\)

Explanation: The list \(=\) \([\texttt{1 AND 6}, \texttt{1 AND 5}, \texttt{2 AND 6}, \texttt{2 AND 5}, \texttt{3 AND 6}, \texttt{3 AND 5}] = [0,1,2,0,2,1]\). The XOR sum \(= 0 \text{ XOR } 1 \text{ XOR } 2 \text{ XOR } 0 \text{ XOR } 2 \text{ XOR } 1 = 0\).

Example 2:

Input: \(\texttt{arr1} = [12], \texttt{arr2} = [4]\)

Output: \(\,4\)

Explanation: The list \(=\) \([\texttt{12 AND 4}] = [4]\). The XOR sum \(= 4\).

Constraints:
\begin{bullets}
\item \(1 \le \texttt{arr1.length}, \texttt{arr2.length} \le 10^5\)
\item \(0 \le \texttt{arr1[i]}, \texttt{arr2[j]} \le 10^9\)
\end{bullets}}
\BREAKDOWN{Compute \(\bigoplus_{i,j} (\texttt{arr1}[i] \mathbin{\&} \texttt{arr2}[j])\) efficiently. Observe bitwise independence and parity to avoid \(O(nm)\).}
\ELI{Each bit in the answer is 1 iff that bit appears an odd number of times in the pairwise ANDs, which happens exactly when that bit appears an odd number of times in both arrays; hence XOR\(_1\) \& XOR\(_2\).}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two arrays of integers: \(\texttt{arr1}\) and \(\texttt{arr2}\).
\begin{bullets}
\item Types: lists of non-negative 32-bit integers.
\item Lengths: \(1 \le n,m \le 10^5\).
\item Values: \(0 \le \texttt{arr1[i]}, \texttt{arr2[j]} \le 10^9\).
\end{bullets}}
\OUTPUTS{A single integer equal to \(\displaystyle \bigoplus_{i=0}^{n-1}\bigoplus_{j=0}^{m-1} (\texttt{arr1}[i] \mathbin{\&} \texttt{arr2}[j])\).}
\SAMPLES{
\begin{bullets}
\item \(\texttt{arr1}=[1,2,3],~\texttt{arr2}=[6,5] \rightarrow 0\).
\item \(\texttt{arr1}=[12],~\texttt{arr2}=[4] \rightarrow 4\).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(A=\{a_i\}_{i=0}^{n-1}\), \(B=\{b_j\}_{j=0}^{m-1}\). We seek
\begin{BreakableEquation*}
S \triangleq \bigoplus_{i=0}^{n-1}\bigoplus_{j=0}^{m-1} (a_i \mathbin{\&} b_j).
\end{BreakableEquation*}
Per-bit independence allows us to analyze each bit \(k\) separately.}
\varmapStart
\var{n,m}{Lengths of arrays \(A\) and \(B\)}
\var{a_i,b_j}{Elements of arrays \(A\) and \(B\)}
\var{k}{Bit index \(0 \le k < 32\)}
\var{c^A_k}{Count of ones at bit \(k\) across \(A\)}
\var{c^B_k}{Count of ones at bit \(k\) across \(B\)}
\var{x}{\(\bigoplus_i a_i\)}
\var{y}{\(\bigoplus_j b_j\)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S
&= \bigoplus_{i,j} (a_i \mathbin{\&} b_j)
= \sum_{k\ge 0} \left( \left[\text{bit }k\text{ of }S\right] \cdot 2^k \right), \\
\left[\text{bit }k\text{ of }S\right]
&\equiv \left(c^A_k \bmod 2\right) \cdot \left(c^B_k \bmod 2\right) \pmod{2}, \\
&\implies S = \left(\bigoplus_i a_i\right) \mathbin{\&} \left(\bigoplus_j b_j\right) = x \mathbin{\&} y.
\end{aligned}
\]
}
\ASSUMPTIONS{Standard fixed-width non-negative integers; XOR and AND operate bitwise; no overflow concerns in Python due to unbounded ints.}
\INVARIANTS{
\begin{bullets}
\item Parity of ones per bit is preserved by XOR accumulation.
\item The bit \(k\) of \(a_i \mathbin{\&} b_j\) is 1 iff both bits \(k\) in \(a_i\) and \(b_j\) are 1.
\item XOR over multiset equals parity count per value/bit.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute the definition \(S=\bigoplus_{i,j}(a_i \mathbin{\&} b_j)\) by nested loops.}
\ASSUMPTIONS{None beyond constraints; this is primarily for verification and tiny inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \(\texttt{ans}=0\).
\item For each \(a\in \texttt{arr1}\), for each \(b\in \texttt{arr2}\), update \(\texttt{ans} \mathrel{\widehat{=}} (a \mathbin{\&} b)\).
\item Return \(\texttt{ans}\).
\end{algosteps}
\COMPLEXITY{Time \(T(n,m)=\Theta(nm)\); Space \(S(n,m)=\Theta(1)\).}
\[
\begin{aligned}
T(n,m) &= \sum_{i=1}^{n}\sum_{j=1}^{m} 1 = nm.
\end{aligned}
\]
\CORRECTNESS{Directly follows the problem definition by enumerating every pair.}
\EDGECASES{
\begin{bullets}
\item Single-element arrays.
\item All zeros in one array yield result 0.
\item Large identical values; XOR cancellations across even multiplicities.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        ans = 0
        for a in arr1:
            for b in arr2:
                ans ^= (a & b)
        return ans

# basic asserts (small sizes only for baseline)
if __name__ == "__main__":
    sol = Solution()
    assert sol.getXORSum([1,2,3], [6,5]) == 0
    assert sol.getXORSum([12], [4]) == 4
    assert sol.getXORSum([0,0], [7,11]) == 0
\end{minted}
\VALIDATION{Compared with improved/optimal methods on tiny random inputs; baseline must match.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-Bit Parity Aggregation}
\WHICHFORMULA{Use parity of ones per bit: bit \(k\) in the answer is 1 iff both \(c^A_k\) and \(c^B_k\) are odd.}
\ASSUMPTIONS{Word size bounded by max value bits; we iterate up to \(B=32\) bits for \(10^9\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \(\texttt{ans}=0\).
\item For each bit \(k\in[0,B)\):
\begin{bullets}
\item Compute parity \(\texttt{pa}=\bigoplus_i ((\texttt{arr1}[i]\gg k)\,\&\,1)\).
\item Compute parity \(\texttt{pb}=\bigoplus_j ((\texttt{arr2}[j]\gg k)\,\&\,1)\).
\item If \(\texttt{pa}\,\&\,\texttt{pb}=1\), set bit \(k\) in \(\texttt{ans}\).
\end{bullets}
\item Return \(\texttt{ans}\).
\end{algosteps}
\COMPLEXITY{Time \(O((n+m)B)\) with \(B\le 32\); Space \(O(1)\).}
\[
\begin{aligned}
T(n,m) &= O((n+m)\cdot B).
\end{aligned}
\]
\CORRECTNESS{By the parity-product characterization of each bit's contribution to the XOR over all pairwise ANDs.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        # Up to 32 bits for inputs <= 1e9
        B = 32
        ans = 0
        for k in range(B):
            pa = 0
            for a in arr1:
                pa ^= ((a >> k) & 1)
            pb = 0
            for b in arr2:
                pb ^= ((b >> k) & 1)
            if (pa & pb) == 1:
                ans |= (1 << k)
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.getXORSum([1,2,3], [6,5]) == 0
    assert sol.getXORSum([12], [4]) == 4
    # cross-check a random-like small case
    assert sol.getXORSum([7,1], [3,5,2]) == ((7 ^ 1) & (3 ^ 5 ^ 2))
\end{minted}
\VALIDATION{Cross-check with baseline on small arrays; verify bit limit suffices for given constraints.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{XOR Linearity over AND Pairs}
\WHICHFORMULA{Final identity: \(\displaystyle \bigoplus_{i,j} (a_i \mathbin{\&} b_j) = \left(\bigoplus_i a_i\right) \mathbin{\&} \left(\bigoplus_j b_j\right)\).}
\ASSUMPTIONS{Bitwise operations over non-negative integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \(x=\bigoplus_i a_i\).
\item Compute \(y=\bigoplus_j b_j\).
\item Return \(x \mathbin{\&} y\).
\end{algosteps}
\OPTIMALITY{Runs in linear time with a single pass over each array and constant extra space; this matches the information-theoretic minimum to read the inputs.}
\COMPLEXITY{Time \(O(n+m)\); Space \(O(1)\).}
\[
\begin{aligned}
T(n,m) &= O(n+m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        x = 0
        for a in arr1:
            x ^= a
        y = 0
        for b in arr2:
            y ^= b
        return x & y

if __name__ == "__main__":
    sol = Solution()
    # 1) Provided examples
    assert sol.getXORSum([1,2,3], [6,5]) == 0
    assert sol.getXORSum([12], [4]) == 4
    # 2) Edge: zeros
    assert sol.getXORSum([0,0,0], [0,1,2]) == 0
\end{minted}
\VALIDATION{Three asserts shown: two from the prompt and one zero-edge.}
\RESULT{Returns a single integer equal to \((\bigoplus \texttt{arr1}) \mathbin{\&} (\bigoplus \texttt{arr2})\).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests covering:
\begin{bullets}
\item Prompt examples and trivial cases.
\item Arrays with all zeros; arrays with single element.
\item Random small arrays cross-checked between baseline and optimal.
\end{bullets}}
\LINE{CROSS-CHECKS}{Verify \(\text{Baseline} = \text{Improved} = \text{Optimal}\) on dozens of tiny cases; spot-check high-bit values near \(10^9\).}
\LINE{EDGE-CASE GENERATOR}{Produce small random arrays, include degenerates like all zeros, all ones (within bit bound), and alternating patterns.}
\begin{minted}{python}
from typing import List
import random

def brute(arr1: List[int], arr2: List[int]) -> int:
    ans = 0
    for a in arr1:
        for b in arr2:
            ans ^= (a & b)
    return ans

def optimal(arr1: List[int], arr2: List[int]) -> int:
    x = 0
    for a in arr1:
        x ^= a
    y = 0
    for b in arr2:
        y ^= b
    return x & y

if __name__ == "__main__":
    random.seed(0)
    # Deterministic small checks
    for _ in range(100):
        n = random.randint(1, 6)
        m = random.randint(1, 6)
        arr1 = [random.randint(0, 31) for _ in range(n)]
        arr2 = [random.randint(0, 31) for _ in range(m)]
        assert brute(arr1, arr2) == optimal(arr1, arr2)
    # boundary-like patterns
    assert optimal([0]*5, [0,1,2,3]) == 0
    assert optimal([31,31], [31]) == brute([31,31], [31])
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        x = 0
        for a in arr1:
            x ^= a
        y = 0
        for b in arr2:
            y ^= b
        return x & y

if __name__ == "__main__":
    sol = Solution()
    assert sol.getXORSum([1,2,3], [6,5]) == 0
    assert sol.getXORSum([12], [4]) == 4
    assert sol.getXORSum([0,0,0], [0,1,2]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer equals \((\bigoplus \texttt{arr1}) \mathbin{\&} (\bigoplus \texttt{arr2})\).}
\WHY{Highlights per-bit parity reasoning and XOR linearity, a recurring idea in bit-manipulation interviews.}
\CHECKLIST{
\begin{bullets}
\item Think per-bit; count parity, not counts.
\item Recognize pairwise XOR over ANDs reduces to XORs then AND.
\item Ensure bit width sufficient for constraints.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item One array all zeros.
\item One-element arrays.
\item Large identical values repeating even times (XOR cancels).
\item Mixed zeros and highs.
\item Max bit near \(10^9\) (ensure iterate up to 30–32 bits if needed).
\item Empty arrays are disallowed by constraints but would be identity 0 if they occurred.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Implementing brute force on large inputs leads to TLE.
\item Using sum instead of XOR for parity.
\item Limiting bits too little and missing high bits.
\item Overflow concerns in fixed-width languages (not an issue in Python, but mask appropriately in others).
\item Confusing AND/OR in the final identity.
\item Forgetting that parity multiplies across arrays for AND-pair XOR.
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Approaches that count frequencies but not parity will be wrong.
\item Greedy or sorting methods do not apply; bitwise structure is key.
\end{bullets}}
\ELI{Look at each bit position independently. A bit survives the XOR of all pairwise ANDs only when it shows up an odd number of times in both arrays. That is exactly the same as taking the XOR of each array and then ANDing the results.}
\NotePages{3}

\end{document}