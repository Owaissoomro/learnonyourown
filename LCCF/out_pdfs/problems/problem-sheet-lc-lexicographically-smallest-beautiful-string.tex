% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Smallest Beautiful String}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographically-smallest-beautiful-string/}}
\LINE{DIFFICULTY / RATING}{Hard}
\STATEMENT{A string is \textbf{beautiful} if:
\begin{itemize}
\item It consists of the first \texttt{k} letters of the English lowercase alphabet.
\item It does not contain any substring of length $2$ or more which is a palindrome.
\end{itemize}
You are given a beautiful string \texttt{s} of length \texttt{n} and a positive integer \texttt{k}. Return the lexicographically smallest string of length \texttt{n}, which is larger than \texttt{s} and is \textbf{beautiful}. If there is no such string, return an empty string.

A string \texttt{a} is lexicographically larger than a string \texttt{b} (of the same length) if in the first position where \texttt{a} and \texttt{b} differ, \texttt{a} has a character strictly larger than the corresponding character in \texttt{b}.
\begin{itemize}
\item For example, \texttt{"abcd"} is lexicographically larger than \texttt{"abcc"} because the first position they differ is at the fourth character, and \texttt{d} is greater than \texttt{c}.
\end{itemize}

\textbf{Example 1:}
\begin{verbatim}
Input:  s = "abcz", k = 26
Output: "abda"
Explanation: The string "abda" is beautiful and lexicographically larger than the string "abcz".
It can be proven that there is no string that is lexicographically larger than the string "abcz",
beautiful, and lexicographically smaller than the string "abda".
\end{verbatim}

\textbf{Example 2:}
\begin{verbatim}
Input:  s = "dc", k = 4
Output: ""
Explanation: It can be proven that there is no string that is lexicographically larger
than the string "dc" and is beautiful.
\end{verbatim}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le n = \texttt{s.length} \le 10^5$
\item $4 \le k \le 26$
\item \texttt{s} is a beautiful string.
\end{itemize}}
\BREAKDOWN{We must find the next lexicographic string over the first $k$ letters that avoids palindromic substrings of length at least $2$. Equivalently, forbid adjacent equal letters and forbid $s[i]=s[i-2]$. Increment from the right, fix a position, and greedily rebuild the suffix with the smallest valid letters.}
\ELI{Bump a character from the end as little as possible so it still does not match the previous two letters, then fill the rest with the smallest letters that also avoid matching the previous one or two.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Python/LC function \texttt{smallestBeautifulString(self, s: str, k: int) -\textgreater{} str} where:
\begin{itemize}
\item \texttt{s}: a beautiful string, $\lvert s\rvert=n$, over alphabet $\{ \texttt{a},\ldots,\texttt{a}+k-1\}$.
\item \texttt{k}: integer with $4 \le k \le 26$.
\end{itemize}}
\OUTPUTS{Return the lex smallest beautiful string of length $n$ that is strictly larger than \texttt{s}. If none exists, return the empty string \texttt{""}.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{s="abcz"}, \texttt{k=26} $\Rightarrow$ Output: \texttt{"abda"}.
\item Input: \texttt{s="dc"}, \texttt{k=4} $\Rightarrow$ Output: \texttt{""}.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{0,1,\ldots,k-1\}$ represent letters \texttt{a}..\texttt{a}$+k-1$. Given $s\in A^n$ that is beautiful. Find $t\in A^n$ such that $t$ is beautiful, $t>s$ in lex order, and among all such strings $t$ is lexicographically minimal. Beauty constraints reduce to local checks: for all $i$, $t_i\ne t_{i-1}$ and $t_i\ne t_{i-2}$ whenever indices exist.}
\varmapStart
\var{n}{length of the string}
\var{k}{alphabet size, first $k$ lowercase letters}
\var{s}{given beautiful string}
\var{t}{target beautiful string, lexicographically minimal among those $>s$}
\var{i}{pivot index where we increase a character}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Beauty:}\quad \forall i\in\{0,\ldots,n-1\}:\ \left(i\ge1\Rightarrow t_i\ne t_{i-1}\right)\ \land\ \left(i\ge2\Rightarrow t_i\ne t_{i-2}\right).\\
&\text{Order:}\quad t>s\ \text{in lex order}.\\
&\text{Minimality:}\quad \nexists u\in A^n:\ \big(u\ \text{beautiful}\big)\ \land\ s<u<t.
\end{aligned}
\]
}
\ASSUMPTIONS{Zero-based indexing. The input string \texttt{s} is guaranteed beautiful. Alphabet letters map \texttt{a}\,$\leftrightarrow\,0$, \ldots, \texttt{a}$+k-1 \leftrightarrow\,k-1$.}
\INVARIANTS{
\begin{itemize}
\item When filling a suffix greedily from left to right, choosing the smallest letter that avoids the previous one and two maintains beauty.
\item Any change at position $i$ with $t_i>s_i$ and minimal suffix thereafter yields the smallest valid $t$ with that pivot $i$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate successive strings in lex order by base-$k$ counting from \texttt{s}+1 and test the beauty predicate $t_i\ne t_{i-1}$ and $t_i\ne t_{i-2}$.}
\ASSUMPTIONS{Feasible only for tiny $n$ in testing; used as a correctness oracle on small instances.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Convert \texttt{s} to base-$k$ digits.
\item Repeatedly increment the number; on each increment, map back to a string and test beauty locally.
\item Return the first string that passes; if overflow, return empty string.
\end{algosteps}
\COMPLEXITY{Worst-case exponential enumeration.}
\[
\begin{aligned}
T(n) &\in \Theta(k^n\cdot n)\ \text{(testing each candidate costs }O(n)\text{)}.\\
S(n) &\in O(n).
\end{aligned}
\]
\CORRECTNESS{Lex order enumeration guarantees the first beautiful candidate encountered is the lexicographically smallest greater-than-\texttt{s} beautiful string, if any exists.}
\EDGECASES{Single-character strings; near-maximum string where carry ripples to the front; small $k$ such as $k=4$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution_Baseline:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        n = len(s)
        a = [ord(ch) - 97 for ch in s]  # 0..k-1
        def is_beautiful(chars):
            for i in range(len(chars)):
                if i >= 1 and chars[i] == chars[i-1]:
                    return False
                if i >= 2 and chars[i] == chars[i-2]:
                    return False
            return True
        # increment once before checking, since we need strictly larger than s
        def incr(arr):
            i = len(arr) - 1
            while i >= 0:
                arr[i] += 1
                if arr[i] < k:
                    return True
                arr[i] = 0
                i -= 1
            return False  # overflow
        b = a[:]
        while incr(b):
            if is_beautiful(b):
                return "".join(chr(x + 97) for x in b)
        return ""

# Tiny sanity checks for the baseline (keep problem-scale small)
if __name__ == "__main__":
    solb = Solution_Baseline()
    assert solb.smallestBeautifulString("ab", 4) == "ac"
    assert solb.smallestBeautifulString("dc", 4) == ""
    # Verify beauty predicate effect on minimal sizes
    out = solb.smallestBeautifulString("abcz", 26)
    assert out == "abda"
\end{minted}
\VALIDATION{Checked sample cases and a small custom case. The baseline is used only for tiny $n$ due to exponential behavior.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Right-to-Left Pivot With Greedy Suffix}
\WHICHFORMULA{Find the rightmost index $i$ where we can increase $s_i$ to some letter $>$ current and still avoid conflicts with $s_{i-1}$ and $s_{i-2}$. Then rebuild the suffix $i+1\ldots n-1$ greedily using the smallest valid letters.}
\ASSUMPTIONS{Beauty reduces to forbidding equalities at distance $1$ and $2$. Greedy suffix fill is optimal once the pivot is fixed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan $i$ from $n-1$ down to $0$.
\item For each $i$, try letters from $\texttt{s[i]}+1$ up to $\texttt{a}+k-1$ that do not equal $t_{i-1}$ or $t_{i-2}$.
\item If a valid letter is found, set $t_i$ to it, then fill $j=i+1\ldots n-1$ with the smallest letter each time that avoids $t_{j-1}$ and $t_{j-2}$. Return the string.
\item If no $i$ works, return empty string.
\end{algosteps}
\COMPLEXITY{Linear in $n$ with a small constant ($\le 26$ trials per position).}
\[
\begin{aligned}
T(n) &\in O(n\cdot k)\subseteq O(n),\quad S(n)\in O(1)\ \text{extra}.
\end{aligned}
\]
\CORRECTNESS{Among all strings that differ first at position $i$, choosing the smallest feasible letter at $i$ and then the lexicographically smallest valid suffix yields the minimal $t$ for that pivot. Scanning $i$ from right to left ensures we pick the latest possible pivot, making the whole $t$ minimal among all $>s$.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution_Improved:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        a = list(s)
        n = len(a)
        base = ord('a')

        def ok(pos: int, ch: str) -> bool:
            if pos >= 1 and a[pos-1] == ch:
                return False
            if pos >= 2 and a[pos-2] == ch:
                return False
            return True

        for i in range(n - 1, -1, -1):
            for code in range(ord(a[i]) + 1, base + k):
                ch = chr(code)
                # Temporarily set and test local feasibility
                if (i >= 1 and a[i-1] == ch) or (i >= 2 and a[i-2] == ch):
                    continue
                a[i] = ch
                # Greedily fill the suffix with the smallest valid letters
                feasible = True
                for j in range(i + 1, n):
                    placed = False
                    for cand in range(base, base + k):
                        cj = chr(cand)
                        if (j >= 1 and a[j-1] == cj) or (j >= 2 and a[j-2] == cj):
                            continue
                        a[j] = cj
                        placed = True
                        break
                    if not placed:
                        feasible = False
                        break
                if feasible:
                    return "".join(a)
                # otherwise try next code
            # restore a[i] to original before moving left (not strictly needed)
            a[i] = s[i]
        return ""

# Deterministic checks
if __name__ == "__main__":
    soli = Solution_Improved()
    assert soli.smallestBeautifulString("abcz", 26) == "abda"
    assert soli.smallestBeautifulString("dc", 4) == ""
    # Small random-like checks
    assert soli.smallestBeautifulString("ab", 4) == "ac"
\end{minted}
\VALIDATION{Validated on the samples and an extra small case. The greedy suffix fill always chooses the smallest feasible letter, ensuring minimality post-pivot.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Rightmost Increment + Local Constraints}
\WHICHFORMULA{Use the same pivot-from-right idea with immediate local checks, which is optimal under the constraint that only distances $1$ and $2$ matter.}
\ASSUMPTIONS{Since any longer palindrome implies a violation at length $2$ or $3$, it suffices to enforce $t_i\ne t_{i-1}$ and $t_i\ne t_{i-2}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate $i$ from $n-1$ down to $0$.
\item For candidate letters $c$ from current $+1$ to $\texttt{a}+k-1$, skip if $c$ equals $t_{i-1}$ or $t_{i-2}$.
\item Fix $t_i=c$, then for $j=i+1\ldots n-1$ assign the smallest letter not equal to $t_{j-1}$ nor $t_{j-2}$. Return the result.
\end{algosteps}
\OPTIMALITY{No algorithm can asymptotically beat $O(n)$ time for reading/writing the output. This method does $O(1)$ work per position with a bounded alphabet ($k\le 26$), hence linear and optimal up to constants.}
\COMPLEXITY{Linear in $n$.}
\[
\begin{aligned}
T(n) &\in O(n\cdot k) \text{ with } k\le 26, \\
S(n) &\in O(1) \text{ extra}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        a = list(s)
        n = len(a)
        base = ord('a')

        def conflict(pos: int, ch: str) -> bool:
            return (pos >= 1 and a[pos-1] == ch) or (pos >= 2 and a[pos-2] == ch)

        for i in range(n - 1, -1, -1):
            for code in range(ord(a[i]) + 1, base + k):
                ch = chr(code)
                if conflict(i, ch):
                    continue
                a[i] = ch
                # Fill suffix greedily
                good = True
                for j in range(i + 1, n):
                    placed = False
                    for cand in range(base, base + k):
                        cj = chr(cand)
                        if (j >= 1 and a[j-1] == cj) or (j >= 2 and a[j-2] == cj):
                            continue
                        a[j] = cj
                        placed = True
                        break
                    if not placed:
                        good = False
                        break
                if good:
                    return "".join(a)
                # else try next candidate for position i
            a[i] = s[i]
        return ""

# Exactly 3 asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.smallestBeautifulString("abcz", 26) == "abda"
    assert sol.smallestBeautifulString("dc", 4) == ""
    assert sol.smallestBeautifulString("z", 26) == ""  # already max single char
\end{minted}
\VALIDATION{Three asserts: both samples and a single-character edge case.}
\RESULT{Returns the lexicographically smallest beautiful string strictly larger than \texttt{s}, or \texttt{""} if none exists.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests covering samples, edge lengths (1, 2, 3), and small exhaustive cross-checks against the baseline for small $n$ and $k$.}
\LINE{CROSS-CHECKS}{Compare outputs from baseline enumeration and the optimal greedy on small instances to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate all strings of length $n\le 5$ over $k\le 4$, filter beautiful ones, and test the solver from each starting point.}
\begin{minted}{python}
from itertools import product

def is_beautiful(s: str) -> bool:
    for i, ch in enumerate(s):
        if i >= 1 and s[i] == s[i-1]:
            return False
        if i >= 2 and s[i] == s[i-2]:
            return False
    return True

def oracle_next(s: str, k: int) -> str:
    # Enumerate next strings naively (baseline)
    a = [ord(c) - 97 for c in s]
    n = len(a)
    def incr(b):
        i = n - 1
        while i >= 0:
            b[i] += 1
            if b[i] < k:
                return True
            b[i] = 0
            i -= 1
        return False
    b = a[:]
    while incr(b):
        cand = "".join(chr(x + 97) for x in b)
        if is_beautiful(cand):
            return cand
    return ""

def solver_next(s: str, k: int) -> str:
    return Solution().smallestBeautifulString(s, k)

if __name__ == "__main__":
    # Exhaustive cross-check for tiny sizes
    for n in range(1, 5):
        for k in range(4, 5):  # keep k minimal per constraints, still non-trivial
            alphabet = [chr(ord('a') + i) for i in range(k)]
            for tup in product(alphabet, repeat=n):
                st = "".join(tup)
                if not is_beautiful(st):
                    continue
                o = oracle_next(st, k)
                g = solver_next(st, k)
                assert o == g, (n, k, st, o, g)

    # Sample confirmations
    assert solver_next("abcz", 26) == "abda"
    assert solver_next("dc", 4) == ""
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        a = list(s)
        n = len(a)
        base = ord('a')

        def bad(pos: int, ch: str) -> bool:
            return (pos >= 1 and a[pos-1] == ch) or (pos >= 2 and a[pos-2] == ch)

        for i in range(n - 1, -1, -1):
            for code in range(ord(a[i]) + 1, base + k):
                ch = chr(code)
                if bad(i, ch):
                    continue
                a[i] = ch
                # Fill the suffix with the smallest valid letters
                ok = True
                for j in range(i + 1, n):
                    placed = False
                    for cand in range(base, base + k):
                        cj = chr(cand)
                        if (j >= 1 and a[j-1] == cj) or (j >= 2 and a[j-2] == cj):
                            continue
                        a[j] = cj
                        placed = True
                        break
                    if not placed:
                        ok = False
                        break
                if ok:
                    return "".join(a)
                # else try next character at i
            a[i] = s[i]
        return ""

if __name__ == "__main__":
    sol = Solution()
    assert sol.smallestBeautifulString("abcz", 26) == "abda"
    assert sol.smallestBeautifulString("dc", 4) == ""
    assert sol.smallestBeautifulString("z", 26) == ""
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the smallest lexicographic beautiful string strictly larger than the given beautiful string by pivoting from the right and greedily filling the suffix.}
\WHY{Tests understanding of lex order, greedy construction with local constraints, and string manipulation under adjacency rules common in interview DP/greedy problems.}
\CHECKLIST{
\begin{itemize}
\item Map letters to the first $k$ lowercase letters only.
\item Iterate from right to left to find a pivot.
\item Skip candidates equal to the previous one or two letters.
\item After fixing the pivot, greedily fill the suffix with smallest valid letters.
\item If no pivot works, return empty string.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $n=1$ and \texttt{s} already at the maximum letter.
\item Carry-like behavior when many trailing positions are near maximum feasible choices.
\item Minimal $k=4$ still guarantees feasibility for suffix fill if a pivot is found.
\item Patterns like \texttt{abab...} that tightly constrain options.
\item Long runs near the end that block immediate increments.
\item Strings close to the global maximum over the alphabet.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting to check equality with the character two positions back.
\item Accidentally using negative indices in Python and reading from the end.
\item Not restoring or correctly handling \texttt{a[i]} when trying multiple candidates.
\item Off-by-one in the candidate range; ensure inclusive upper bound \texttt{chr(ord('a')+k-1)}.
\item Filling suffix without rechecking both constraints.
\item Mishandling the empty-string return when no pivot exists.
\end{itemize}}
\FAILMODES{Brute force times out at scale; naive backtracking without greedy suffix may explore exponential branches. The provided method avoids branching by deterministic suffix fill.}
\ELI{Look from the end and try to make a small increase that does not repeat the last two letters. Once you do, finish the rest with the smallest choices that keep avoiding repeats at distance $1$ and $2$. If you cannot increase any position without breaking the rule, answer is empty.}
\NotePages{3}

\end{document}