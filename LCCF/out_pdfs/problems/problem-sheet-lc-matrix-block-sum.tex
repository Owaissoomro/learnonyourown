% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Matrix Block Sum}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/matrix-block-sum/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an $m \times n$ matrix \texttt{mat} and an integer $k$, return a matrix \texttt{answer} where each \texttt{answer[i][j]} is the sum of all elements \texttt{mat[r][c]} for indices $(r, c)$ satisfying
\begin{BreakableEquation*}
i - k \le r \le i + k,\quad j - k \le c \le j + k,
\end{BreakableEquation*}
and $(r, c)$ is a valid position in the matrix (i.e., $0 \le r < m$ and $0 \le c < n$).

Examples:
\begin{bullets}
\item Input: \texttt{mat = [[1,2,3],[4,5,6],[7,8,9]]}, \texttt{k = 1}. Output: \texttt{[[12,21,16],[27,45,33],[24,39,28]]}.
\item Input: \texttt{mat = [[1,2,3],[4,5,6],[7,8,9]]}, \texttt{k = 2}. Output: \texttt{[[45,45,45],[45,45,45],[45,45,45]]}.
\end{bullets}
Constraints:
\begin{bullets}
\item $m = \texttt{len(mat)}$, $n = \texttt{len(mat[i])}$.
\item $1 \le m, n, k \le 100$.
\item $1 \le \texttt{mat[i][j]} \le 100$.
\end{bullets}}
\BREAKDOWN{Compute, for each cell $(i, j)$, the sum over the axis-aligned square of radius $k$ clamped to the matrix bounds. A naive approach sums directly per cell; an optimal solution uses a 2D prefix sum to answer each rectangle sum in $O(1)$.}
\ELI{Precompute cumulative sums so each neighborhood sum becomes a few additions and subtractions.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Matrix \texttt{mat} of shape $m \times n$ with integers in $[1, 100]$; integer $k$ with $1 \le k \le 100$.}
\OUTPUTS{Matrix \texttt{answer} of shape $m \times n$ where \texttt{answer[i][j]} equals the sum of \texttt{mat[r][c]} over all valid $(r, c)$ with $i - k \le r \le i + k$ and $j - k \le c \le j + k$.}
\SAMPLES{
\begin{bullets}
\item \textbf{Input:} \texttt{mat = [[1,2,3],[4,5,6],[7,8,9]]}, \texttt{k = 1}. \textbf{Output:} \texttt{[[12,21,16],[27,45,33],[24,39,28]]}.
\item \textbf{Input:} \texttt{mat = [[1,2,3],[4,5,6],[7,8,9]]}, \texttt{k = 2}. \textbf{Output:} \texttt{[[45,45,45],[45,45,45],[45,45,45]]}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M \in \mathbb{Z}^{m \times n}$. For each $(i, j)$ with $0 \le i < m$, $0 \le j < n$, define clamped bounds
\[
r_1(i) = \max(0, i - k),\quad r_2(i) = \min(m - 1, i + k),\quad
c_1(j) = \max(0, j - k),\quad c_2(j) = \min(n - 1, j + k).
\]
The desired output is $A \in \mathbb{Z}^{m \times n}$ with
\begin{BreakableEquation*}
A_{i,j} = \sum_{r=r_1(i)}^{r_2(i)} \sum_{c=c_1(j)}^{c_2(j)} M_{r,c}.
\end{BreakableEquation*}
Use the 2D prefix-sum (integral image) $P \in \mathbb{Z}^{(m+1)\times(n+1)}$ with $P_{0,\cdot} = P_{\cdot,0} = 0$ and
\begin{BreakableEquation*}
P_{i+1,j+1} = M_{i,j} + P_{i,j+1} + P_{i+1,j} - P_{i,j}.
\end{BreakableEquation*}
Then any axis-aligned rectangle sum can be answered in $O(1)$.}
\varmapStart
\var{m, n}{matrix dimensions}
\var{k}{Chebyshev radius for the square neighborhood}
\var{M_{r,c}}{input value at row $r$, column $c$}
\var{P_{a,b}}{2D prefix sum over rows $0..a-1$, cols $0..b-1$}
\var{A_{i,j}}{required block sum centered at $(i, j)$ (with clamping)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
P_{i+1,j+1} &= M_{i,j} + P_{i,j+1} + P_{i+1,j} - P_{i,j},\\
\mathrm{RectSum}(r_1,c_1,r_2,c_2) &= P_{r_2+1,c_2+1} - P_{r_1,c_2+1} - P_{r_2+1,c_1} + P_{r_1,c_1},\\
A_{i,j} &= \mathrm{RectSum}\bigl(r_1(i), c_1(j), r_2(i), c_2(j)\bigr).
\end{aligned}
\]
}
\ASSUMPTIONS{Zero-based indexing; $m, n \ge 1$. Prefix sum array $P$ uses one-based padding to avoid boundary branches.}
\INVARIANTS{
\begin{bullets}
\item $P$ is monotone nondecreasing in each coordinate when $M \ge 0$.
\item For any valid rectangle, inclusion--exclusion with $P$ returns the exact sum by construction.
\item Clamping ensures the neighborhood stays within $[0, m-1]\times[0, n-1]$.
\end{bullets}}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly sum all cells in the $(2k+1)\times(2k+1)$ window intersected with the matrix bounds for each $(i, j)$.}
\ASSUMPTIONS{None beyond valid input; clamp the window to matrix bounds before iterating.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell $(i, j)$, compute clamped bounds $r_1, r_2, c_1, c_2$.
\item Initialize $s \leftarrow 0$ and double-loop $r \in [r_1, r_2]$, $c \in [c_1, c_2]$, accumulate $M_{r,c}$.
\item Store $s$ in $A_{i,j}$ and continue.
\end{algosteps}
\COMPLEXITY{Let $B = \min(m, 2k+1)\cdot \min(n, 2k+1)$. Then $T(m,n) = \Theta(mnB)$ and $S(m,n) = \Theta(mn)$ for the output (or $O(1)$ extra if writing in-place).}
\[
\begin{aligned}
T(m,n) &= \sum_{i=0}^{m-1}\sum_{j=0}^{n-1} \bigl(\min(m,2k+1)\cdot\min(n,2k+1)\bigr) \\
&= \Theta\bigl(mn\cdot \min(m,2k+1)\cdot \min(n,2k+1)\bigr).
\end{aligned}
\]
\CORRECTNESS{Every required term is included exactly once by iterating the clamped rectangle; no terms outside the matrix are considered due to clamping.}
\EDGECASES{
\begin{bullets}
\item $k=0$ yields $A=M$.
\item $k$ large enough that the window covers the full matrix returns the same value for all cells.
\item Single-row or single-column matrices.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            r1 = max(0, i - k)
            r2 = min(m - 1, i + k)
            for j in range(n):
                c1 = max(0, j - k)
                c2 = min(n - 1, j + k)
                s = 0
                for r in range(r1, r2 + 1):
                    for c in range(c1, c2 + 1):
                        s += mat[r][c]
                ans[i][j] = s
        return ans

# tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.matrixBlockSum([[1,2,3],[4,5,6],[7,8,9]], 1) == [[12,21,16],[27,45,33],[24,39,28]]
    assert sol.matrixBlockSum([[1,2,3],[4,5,6],[7,8,9]], 2) == [[45,45,45],[45,45,45],[45,45,45]]
    assert sol.matrixBlockSum([[5]], 3) == [[5]]
\end{minted}
\VALIDATION{Checked against the two examples and a $1\times 1$ matrix with $k>0$ (clamps to the only cell).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Row Prefix Sums + Vertical Accumulation}
\WHICHFORMULA{Use per-row prefix sums to compute any row segment sum in $O(1)$, then sum across the $\le 2k+1$ rows in the window.}
\ASSUMPTIONS{Precompute row-wise prefix sums $R[i][j] = \sum_{c=0}^{j-1} M_{i,c}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build row prefix sums $R$ of shape $m \times (n+1)$.
\item For each $(i, j)$, compute clamped $r_1, r_2, c_1, c_2$.
\item Accumulate $s \leftarrow \sum_{r=r_1}^{r_2}\bigl(R[r][c_2+1]-R[r][c_1]\bigr)$ and set $A_{i,j} \leftarrow s$.
\end{algosteps}
\COMPLEXITY{Row prefix build is $O(mn)$. Each query takes $O(\min(m,2k+1))$, so $T(m,n)=\Theta(mn\cdot \min(m,2k+1))$ and $S(m,n)=\Theta(mn)$ for $R$ plus output.}
\[
\begin{aligned}
T(m,n) &= O(mn) + \sum_{i,j} O(\min(m,2k+1)) = \Theta(mn\cdot \min(m,2k+1)).
\end{aligned}
\]
\CORRECTNESS{Each row segment sum is exact by prefix differences; summing these over all rows in the window equals the rectangle sum by linearity.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        # Row-wise prefix sums: R[i][j] = sum_{c=0}^{j-1} mat[i][c]
        R = [[0] * (n + 1) for _ in range(m)]
        for i in range(m):
            run = 0
            for j in range(n):
                run += mat[i][j]
                R[i][j + 1] = run

        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            r1 = max(0, i - k)
            r2 = min(m - 1, i + k)
            for j in range(n):
                c1 = max(0, j - k)
                c2 = min(n - 1, j + k)
                s = 0
                for r in range(r1, r2 + 1):
                    s += R[r][c2 + 1] - R[r][c1]
                ans[i][j] = s
        return ans

# tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.matrixBlockSum([[1,2,3],[4,5,6],[7,8,9]], 1) == [[12,21,16],[27,45,33],[24,39,28]]
    assert sol.matrixBlockSum([[1,2],[3,4]], 1) == [[10,10],[10,10]]
    assert sol.matrixBlockSum([[5,1,2]], 2) == [[8,8,8]]
\end{minted}
\VALIDATION{Verified on examples and edge cases: full-row window on a single-row matrix and a $2\times 2$ matrix with $k=1$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{2D Prefix Sum (Integral Image)}
\WHICHFORMULA{Build a padded 2D prefix sum $P$ so any axis-aligned rectangle sum is $P[x_2,y_2]-P[x_1,y_2]-P[x_2,y_1]+P[x_1,y_1]$.}
\ASSUMPTIONS{Use one-based padding in $P$ to avoid conditionals at borders.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $P$ in $O(mn)$ using $P_{i+1,j+1} = M_{i,j} + P_{i,j+1} + P_{i+1,j} - P_{i,j}$.
\item For each $(i, j)$, compute clamped $r_1, r_2, c_1, c_2$.
\item Answer with $\mathrm{RectSum}(r_1,c_1,r_2,c_2)$ via $P$ in $O(1)$.
\end{algosteps}
\OPTIMALITY{Each output requires at least $\Omega(1)$ time to write; after an $O(mn)$ preprocessing, we achieve $O(1)$ per cell, hence total $\Theta(mn)$ which is optimal up to constant factors.}
\COMPLEXITY{$T(m,n)=\Theta(mn)$, $S(m,n)=\Theta(mn)$ for $P$ plus output storage.}
\[
\begin{aligned}
T(m,n) &= O(mn)~(\text{build}) + O(mn)~(\text{queries}) = \Theta(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        # 2D prefix sums with 1-based padding
        P = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            row_sum = 0
            for j in range(n):
                row_sum += mat[i][j]
                P[i + 1][j + 1] = P[i][j + 1] + row_sum

        def rect_sum(r1: int, c1: int, r2: int, c2: int) -> int:
            # inclusive rectangle; convert to 1-based indices for P
            return P[r2 + 1][c2 + 1] - P[r1][c2 + 1] - P[r2 + 1][c1] + P[r1][c1]

        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            r1 = max(0, i - k)
            r2 = min(m - 1, i + k)
            for j in range(n):
                c1 = max(0, j - k)
                c2 = min(n - 1, j + k)
                ans[i][j] = rect_sum(r1, c1, r2, c2)
        return ans

# tests (exactly three)
if __name__ == "__main__":
    sol = Solution()
    assert sol.matrixBlockSum([[1,2,3],[4,5,6],[7,8,9]], 1) == [[12,21,16],[27,45,33],[24,39,28]]
    assert sol.matrixBlockSum([[1,2,3],[4,5,6],[7,8,9]], 2) == [[45,45,45],[45,45,45],[45,45,45]]
    assert sol.matrixBlockSum([[5]], 10) == [[5]]
\end{minted}
\VALIDATION{Three asserts: both official examples and a single-cell matrix with large $k$.}
\RESULT{Return the $m \times n$ matrix of clamped $k$-neighborhood sums. No tie-breaking is involved.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on provided examples; randomized small matrices cross-checked against a brute-force oracle; edge cases such as $k=0$, $k$ large, single row/column, and non-square matrices.}
\LINE{CROSS-CHECKS}{Compare outputs of the optimal solution to the brute-force baseline on many random instances with fixed seed for determinism.}
\LINE{EDGE-CASE GENERATOR}{Generate small shapes ($1\times n$, $m\times 1$, $2\times 2$), extreme $k$ values ($0$ and $\ge \max(m,n)$), and uniform matrices to test constant-sum behavior.}
\begin{minted}{python}
from typing import List, Tuple
import random

def brute(mat: List[List[int]], k: int) -> List[List[int]]:
    m = len(mat)
    n = len(mat[0]) if m > 0 else 0
    ans = [[0] * n for _ in range(m)]
    for i in range(m):
        r1 = max(0, i - k)
        r2 = min(m - 1, i + k)
        for j in range(n):
            c1 = max(0, j - k)
            c2 = min(n - 1, j + k)
            s = 0
            for r in range(r1, r2 + 1):
                for c in range(c1, c2 + 1):
                    s += mat[r][c]
            ans[i][j] = s
    return ans

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        P = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            row_sum = 0
            for j in range(n):
                row_sum += mat[i][j]
                P[i + 1][j + 1] = P[i][j + 1] + row_sum

        def rect_sum(r1: int, c1: int, r2: int, c2: int) -> int:
            return P[r2 + 1][c2 + 1] - P[r1][c2 + 1] - P[r2 + 1][c1] + P[r1][c1]

        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            r1 = max(0, i - k)
            r2 = min(m - 1, i + k)
            for j in range(n):
                c1 = max(0, j - k)
                c2 = min(n - 1, j + k)
                ans[i][j] = rect_sum(r1, c1, r2, c2)
        return ans

def rand_case(m: int, n: int, vmax: int) -> List[List[int]]:
    return [[random.randint(1, vmax) for _ in range(n)] for _ in range(m)]

if __name__ == "__main__":
    random.seed(7)
    sol = Solution()
    # Basic sanity
    assert sol.matrixBlockSum([[1,2,3],[4,5,6],[7,8,9]], 1) == [[12,21,16],[27,45,33],[24,39,28]]
    # Cross-check random cases
    for _ in range(100):
        m = random.randint(1, 5)
        n = random.randint(1, 5)
        k = random.randint(0, 6)
        mat = rand_case(m, n, 9)
        assert sol.matrixBlockSum(mat, k) == brute(mat, k)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        # Build 2D prefix sums with one-based padding
        P = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            row_sum = 0
            for j in range(n):
                row_sum += mat[i][j]
                P[i + 1][j + 1] = P[i][j + 1] + row_sum

        def rect_sum(r1: int, c1: int, r2: int, c2: int) -> int:
            return P[r2 + 1][c2 + 1] - P[r1][c2 + 1] - P[r2 + 1][c1] + P[r1][c1]

        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            r1 = max(0, i - k)
            r2 = min(m - 1, i + k)
            for j in range(n):
                c1 = max(0, j - k)
                c2 = min(n - 1, j + k)
                ans[i][j] = rect_sum(r1, c1, r2, c2)
        return ans

# quick self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.matrixBlockSum([[5]], 0) == [[5]]
    assert sol.matrixBlockSum([[1,2],[3,4]], 1) == [[10,10],[10,10]]
    assert sol.matrixBlockSum([[1,1,1],[1,1,1]], 5) == [[6,6,6],[6,6,6]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute, for each cell, the sum over its clamped $k$-radius square using a 2D prefix sum.}
\WHY{2D range-sum queries with many outputs are common in interviews; integral images are a classic tool for $O(1)$ queries after linear-time preprocessing.}
\CHECKLIST{
\begin{bullets}
\item Define $P$ with one-based padding.
\item Build $P$ with inclusion--exclusion.
\item For each $(i,j)$, clamp $(r_1,r_2,c_1,c_2)$ to bounds.
\item Compute rectangle sum via $P$ in $O(1)$.
\item Verify on small examples.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $k=0$ should return the original matrix.
\item $k$ so large the window covers the entire matrix.
\item Single-row or single-column matrices.
\item Non-square matrices, e.g., $m \ne n$.
\item Minimal sizes: $m=1$ or $n=1$.
\item Uniform matrices: output uniform as well.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in prefix indices; ensure $P$ is $(m+1)\times(n+1)$.
\item Forgetting to clamp bounds can cause index errors.
\item Integer overflow in languages with fixed-size ints (not an issue in Python, but relevant in others).
\item Mixing up row/column order when indexing $P$.
\item Recomputing row sums instead of leveraging prefix sums.
\item Using naive $O(k^2)$ per cell when $k$ can be large.
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Brute force becomes too slow if $k$ and $m,n$ are near 100; 2D prefix sum remains linear.
\item Row-only prefix approach is still $O(k)$ per cell; 2D prefix removes this factor.
\end{bullets}}
\ELI{Build a running total table where each entry stores the sum of everything above and to the left. Then any box sum is just four table lookups and a couple of adds/subtracts, done for every cell.}
\NotePages{3}

\end{document}