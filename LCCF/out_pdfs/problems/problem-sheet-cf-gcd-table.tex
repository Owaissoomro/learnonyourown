% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — GCD Table}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/338/D}}
\LINE{DIFFICULTY / RATING}{2900}
\STATEMENT{Consider a table $G$ of size $n \times m$ such that $G(i, j) = \gcd(i, j)$ for all $1 \le i \le n$, $1 \le j \le m$. $\gcd(a, b)$ is the greatest common divisor of numbers $a$ and $b$.

You have a sequence of positive integer numbers $a_1, a_2, \ldots, a_k$. We say that this sequence occurs in table $G$ if it coincides with consecutive elements in some row, starting from some position. More formally, such numbers $1 \le i \le n$ and $1 \le j \le m - k + 1$ should exist that $G(i, j + l - 1) = a_l$ for all $1 \le l \le k$.

Determine if the sequence $a$ occurs in table $G$.

Input:
The first line contains three space-separated integers $n$, $m$ and $k$ ($1 \le n, m \le 10^{12}$; $1 \le k \le 10000$). The second line contains $k$ space-separated integers $a_1, a_2, \ldots, a_k$ ($1 \le a_i \le 10^{12}$).

Output:
Print a single word ``YES'', if the given sequence occurs in table $G$, otherwise print ``NO''.

Note:
Sample 1. The tenth row of table $G$ starts from sequence $\{1, 2, 1, 2, 5, 2, 1, 2, 1, 10\}$. As you can see, elements from fifth to ninth coincide with sequence $a$.

Sample 2. This time the width of table $G$ equals $8$. Sequence $a$ does not occur there.}
\BREAKDOWN{Characterize when a sequence equals a contiguous block of $\gcd(i, j)$ along a row. Reduce to number-theoretic constraints over $i$ and $j$; solve feasibility with CRT, bounds, and coprimality checks.}
\ELI{Force $i$ to be a multiple of all $a_l$, align $j$ via CRT so each position is multiple of $a_l$, and ensure no extra common factors sneak into the $\gcd$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.\\
-- Integers $n, m, k$ with $1 \le n, m \le 10^{12}$ and $1 \le k \le 10^4$.\\
-- Sequence $a_1, \ldots, a_k$ with $1 \le a_i \le 10^{12}$.}
\OUTPUTS{Print exactly ``YES'' if there exist integers $i$ and $j$ satisfying $1 \le i \le n$, $1 \le j \le m - k + 1$ and $\gcd(i, j + l - 1) = a_l$ for all $l=1..k$; otherwise print ``NO''.}
\SAMPLES{Example 1: $n=10, m=10, a=[5,2,1,2,1] \Rightarrow$ YES (row $i=10$, columns $5..9$).\\
Example 2: $n=10, m=8, a=[5,2,1,2,1] \Rightarrow$ NO (segment would exceed width).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{We need $i, j$ such that for all $l=1..k$,
\begin{BreakableEquation*}
\gcd(i, j+l-1) = a_l.
\end{BreakableEquation*}
Equivalently, $a_l \mid i$ and $a_l \mid (j+l-1)$ and $\gcd\!\bigl(\tfrac{i}{a_l}, \tfrac{j+l-1}{a_l}\bigr) = 1$ for all $l$.}
\varmapStart
\var{n,m}{table dimensions}
\var{k}{pattern length}
\var{a_l}{desired $\gcd$ at offset $l$}
\var{L}{overall lcm: $L=\mathrm{lcm}(a_1,\ldots,a_k)$}
\var{A}{CRT modulus: $A=\mathrm{lcm}(a_1,\ldots,a_k)$}
\var{r}{CRT solution for $j \equiv 1-l \pmod{a_l}$}
\var{b_l}{quotients $b_l=\tfrac{r+l-1}{a_l}$}
\varmapEnd
\GOVERN{
\[
  \begin{aligned}
  &\text{Existence} \iff \Bigl(\exists j \text{ s.t. } j \equiv 1-l \pmod{a_l}\ \forall l\Bigr) \\
  &\quad \wedge\ L \le n \wedge \text{there exists } j \in [1, m-k+1]\ \text{with } j \equiv r \pmod{A} \\
  &\quad \wedge\ \gcd\!\Bigl(\tfrac{L}{a_l}, \tfrac{r+l-1}{a_l}\Bigr)=1\ \forall l.
  \end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based. When CRT is used with non-coprime moduli, we require pairwise consistency: for all $p,q$, $r_p \equiv r_q \pmod{\gcd(a_p,a_q)}$.}
\INVARIANTS{For fixed $i$, the row sequence $j \mapsto \gcd(i, j)$ is periodic with period $i$ since $\gcd(i, j) = \gcd(i, j \bmod i)$. If $\gcd(i, j)=a$, then $a \mid i$ and $a \mid j$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate rows for small sizes: for each $i \le n$, slide a window across $j=1..m-k+1$ and check $\gcd(i, j+l-1) = a_l$.}
\ASSUMPTIONS{Only feasible for tiny inputs; used here as a correctness oracle for tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i$ from $1$ to $n$:
\item For each $j$ from $1$ to $m-k+1$:
\item Check whether $\gcd(i, j+l-1)=a_l$ for all $l=1..k$; if ever true, answer YES.
\end{algosteps}
\COMPLEXITY{Brute force costs $O(n (m-k+1) k \log U)$ with $U=\max(n,m)$.}
\[
\begin{aligned}
T(n) &= O\bigl(n (m-k+1) k \log U\bigr), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration guarantees a correct YES iff the pattern occurs.}
\EDGECASES{Handle $k=1$; ensure $m-k+1 \ge 1$; reject immediately if not.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from math import gcd

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it); k = next(it)
    a = [next(it) for _ in range(k)]
    return n, m, k, a

def occurs_bruteforce(n, m, a):
    k = len(a)
    if m - k + 1 < 1:
        return False
    for i in range(1, n + 1):
        for j in range(1, m - k + 1 + 1):
            ok = True
            for l in range(k):
                if gcd(i, j + l) != a[l]:
                    ok = False
                    break
            if ok:
                return True
    return False

def solve_case(n, m, k, a):
    return "YES" if occurs_bruteforce(n, m, a) else "NO"

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, k, a = inp
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    # Tiny self-checks for the brute solver
    assert solve_case(3, 5, 1, [1]) == "YES"  # row i=1 has all ones
    assert solve_case(2, 3, 2, [1, 1]) == "YES"  # i=1, any j with length 2
    # Example inspired by the statement
    assert solve_case(10, 10, 5, [5, 2, 1, 2, 1]) == "YES"
    # Narrow width: impossible
    assert solve_case(10, 8, 5, [5, 2, 1, 2, 1]) == "NO"
    # Inconsistent short pattern
    assert solve_case(5, 10, 2, [2, 4]) in ("YES", "NO")  # brute decides
    # Do not run solve_all() in tests
    pass
\end{minted}
\VALIDATION{Checked basic positives, negatives, and width restriction.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{CRT Alignment + Minimal Divisibility}
\WHICHFORMULA{Impose $a_l \mid i$ so $i$ must be a multiple of $L=\mathrm{lcm}(a_1,\ldots,a_k)$. Align $j$ by solving $j \equiv 1-l \pmod{a_l}$ with generalized CRT; ensure $j$ lies within range.}
\ASSUMPTIONS{We only check existence of a consistent residue $j$ modulo $A=\mathrm{lcm}(a_l)$ and that $L \le n$, and that a representative $j$ fits $[1, m-k+1]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L=\mathrm{lcm}(a_1,\ldots,a_k)$; if $L>n$, answer NO.
\item Solve $j \equiv 1-l \pmod{a_l}$ by CRT; if inconsistent, answer NO.
\item Let $j_\min$ be the smallest positive representative; if $j_\min>m-k+1$, answer NO; else tentatively YES.
\end{algosteps}
\COMPLEXITY{CRT merge over $k$ congruences runs in $O(k \log U)$ arithmetic with $U=\max a_i$.}
\[
\begin{aligned}
T(n) &= O\bigl(k \log U\bigr), \quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{If a sequence occurs, $a_l \mid i$ for all $l$, hence $L \mid i$; also $a_l \mid (j+l-1)$ yields the CRT system. Existence within the range is a simple interval congruence feasibility.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import gcd

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it); k = next(it)
    a = [next(it) for _ in range(k)]
    return n, m, k, a

def lcm_cap(a, b, cap):
    g = gcd(a, b)
    # Check overflow vs cap via division-first
    t = a // g
    if t > cap // b:
        return cap + 1
    return t * b

def crt_pair(r1, m1, r2, m2):
    # Solve x ≡ r1 (mod m1), x ≡ r2 (mod m2)
    # Returns (r, m) or (None, None)
    g = gcd(m1, m2)
    diff = r2 - r1
    if diff % g != 0:
        return (None, None)
    m1_g = m1 // g
    m2_g = m2 // g
    # Find inverse of m1_g modulo m2_g
    inv = pow(m1_g, -1, m2_g)
    t = (diff // g) % m2_g
    k = (t * inv) % m2_g
    r = (r1 + k * m1) % (m1 * m2_g)
    m = m1 * m2_g
    return (r, m)

def solve_case(n, m, k, a):
    # Step 1: LCM cap
    L = 1
    for v in a:
        L = lcm_cap(L, v, n)
        if L > n:
            return "NO"
    # Step 2: CRT for j ≡ 1 - l (mod a_l)
    r, mod = 0, 1  # start with x ≡ 0 (mod 1)
    for idx, v in enumerate(a, start=1):
        r2 = (1 - idx) % v
        r, mod = crt_pair(r, mod, r2, v)
        if r is None:
            return "NO"
    # Step 3: choose smallest positive j
    high = m - k + 1
    if high < 1:
        return "NO"
    j_min = r if r != 0 else mod
    if j_min > high:
        return "NO"
    return "YES"

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, k, a = inp
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    # Quick tests for improved approach on small cases
    assert solve_case(10, 10, 5, [5, 2, 1, 2, 1]) == "YES"
    assert solve_case(10, 8, 5, [5, 2, 1, 2, 1]) == "NO"
    assert solve_case(3, 10, 2, [2, 3]) == "NO"  # L=6>n
    assert solve_case(100, 100, 2, [2, 4]) in ("YES", "NO")  # depends on CRT
    pass
\end{minted}
\VALIDATION{Verified LCM bound and CRT feasibility; examples mirror the statement and boundary constraints.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Generalized CRT + Coprimality Filter}
\WHICHFORMULA{Final necessary and sufficient conditions:
\[
  \begin{aligned}
  &L=\mathrm{lcm}(a_1,\ldots,a_k) \le n, \\
  &\exists r \pmod{A}\ \text{s.t. } r \equiv 1-l \pmod{a_l}\ \forall l, \\
  &\gcd\!\Bigl(\tfrac{L}{a_l}, \tfrac{r+l-1}{a_l}\Bigr)=1\ \forall l, \\
  &\text{and the smallest positive } j \equiv r \pmod{A} \text{ obeys } j \le m-k+1.
  \end{aligned}
\]
Pick $i=L$ (and $j$ as above).}
\ASSUMPTIONS{All $a_l \ge 1$. Generalized CRT handles non-coprime moduli; gcd test ensures $\gcd(i/a_l, (j+l-1)/a_l)=1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L=\mathrm{lcm}(a_1,\ldots,a_k)$ with early exit if $L>n$.
\item Solve $j \equiv 1-l \pmod{a_l}$ for $r \pmod{A}$ by iterative CRT; fail if inconsistent.
\item For each $l$, set $b_l=\tfrac{r+l-1}{a_l}$ and require $\gcd(b_l, L/a_l)=1$.
\item Let $j_{\min} = r$ if $r>0$ else $A$. Check $1 \le j_{\min} \le m-k+1$; if so, answer YES; else NO.
\end{algosteps}
\OPTIMALITY{These conditions are both necessary (from divisibility and $\gcd$ definition) and sufficient (construct $i=L$, $j$). No weaker method can bypass CRT consistency or the coprimality barrier.}
\COMPLEXITY{Compute $L$ and CRT in $O(k \log U)$; coprimality scanning is $O(k \log U)$; total $O(k \log U)$ time and $O(1)$ space.}
\[
\begin{aligned}
T(n) &= O\bigl(k \log U\bigr),\quad U=\max a_i, \\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import gcd

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it); k = next(it)
    a = [next(it) for _ in range(k)]
    return n, m, k, a

def lcm_cap(a, b, cap):
    g = gcd(a, b)
    t = a // g
    # If t * b > cap, cap out
    if t > cap // b:
        return cap + 1
    return t * b

def crt_pair(r1, m1, r2, m2):
    # Solve x ≡ r1 (mod m1), x ≡ r2 (mod m2).
    g = gcd(m1, m2)
    diff = r2 - r1
    if diff % g != 0:
        return (None, None)
    m1_g = m1 // g
    m2_g = m2 // g
    inv = pow(m1_g, -1, m2_g)
    k = ((diff // g) * inv) % m2_g
    r = (r1 + k * m1) % (m1 * m2_g)
    m = m1 * m2_g
    return (r, m)

def solve_case(n, m, k, a):
    # 1) i must be multiple of L=lcm(a), else impossible
    L = 1
    for v in a:
        L = lcm_cap(L, v, n)
        if L > n:
            return "NO"
    # 2) Find j ≡ 1-l (mod a_l) via generalized CRT
    r, mod = 0, 1
    for idx, v in enumerate(a, start=1):
        need = (1 - idx) % v
        r, mod = crt_pair(r, mod, need, v)
        if r is None:
            return "NO"
    # 3) Coprimality: gcd( (r+l-1)/a_l, L/a_l ) must be 1
    for idx, v in enumerate(a, start=1):
        num = r + idx - 1
        if num % v != 0:
            return "NO"  # defensive; should not happen if CRT correct
        b = num // v
        if gcd(b, L // v) != 1:
            return "NO"
    # 4) Fit j into width
    high = m - k + 1
    if high < 1:
        return "NO"
    j_min = r if r != 0 else mod
    if j_min > high:
        return "NO"
    return "YES"

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, k, a = inp
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    # Exactly 3 asserts (mini-tests)
    assert solve_case(10, 10, 5, [5, 2, 1, 2, 1]) == "YES"
    assert solve_case(10, 8, 5, [5, 2, 1, 2, 1]) == "NO"
    assert solve_case(3, 10, 2, [2, 3]) == "NO"
    # Uncomment to run with stdin:
    # solve_all()
\end{minted}
\VALIDATION{The three asserts cover: a positive case, a width-bound negative, and an LCM-exceeds-$n$ negative.}
\RESULT{Output ``YES'' iff the sequence occurs; otherwise ``NO''. Pick $i=L$ and the smallest positive $j \equiv r \pmod{A}$ within bounds.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test CRT consistency, LCM cap, and coprimality filter. Use tiny handcrafted cases where brute force can cross-check the optimal solver.}
\LINE{CROSS-CHECKS}{For small $n,m$, verify the optimal solver matches brute force on random patterns. Ensure negative cases from inconsistent CRT and $L>n$ are detected.}
\LINE{EDGE-CASE GENERATOR}{Generate random $a$ with shared factors to stress generalized CRT; include cases with $a_l=1$, $k=1$, and tight $m=k$.}
\begin{minted}{python}
import random
from math import gcd

def brute(n, m, a):
    from math import gcd as G
    k = len(a)
    if m - k + 1 < 1:
        return False
    for i in range(1, n + 1):
        for j in range(1, m - k + 2):
            ok = True
            for l in range(k):
                if G(i, j + l) != a[l]:
                    ok = False
                    break
            if ok:
                return True
    return False

def optimal(n, m, a):
    # Mirror of final solve_case
    def lcm_cap(a_, b_, cap):
        g = gcd(a_, b_)
        t = a_ // g
        if t > cap // b_:
            return cap + 1
        return t * b_
    def crt_pair(r1, m1, r2, m2):
        g = gcd(m1, m2)
        d = r2 - r1
        if d % g != 0:
            return (None, None)
        m1g = m1 // g
        m2g = m2 // g
        inv = pow(m1g, -1, m2g)
        k = ((d // g) * inv) % m2g
        r = (r1 + k * m1) % (m1 * m2g)
        return (r, m1 * m2g)
    L = 1
    for v in a:
        L = lcm_cap(L, v, n)
        if L > n:
            return False
    r, mod = 0, 1
    for idx, v in enumerate(a, 1):
        need = (1 - idx) % v
        r, mod = crt_pair(r, mod, need, v)
        if r is None:
            return False
    for idx, v in enumerate(a, 1):
        num = r + idx - 1
        if num % v != 0:
            return False
        if gcd(num // v, L // v) != 1:
            return False
    high = m - len(a) + 1
    if high < 1:
        return False
    j_min = r if r != 0 else mod
    return j_min <= high

def random_tests():
    for _ in range(200):
        n = random.randint(1, 30)
        m = random.randint(1, 30)
        k = random.randint(1, 5)
        a = [random.randint(1, 12) for _ in range(k)]
        b = brute(n, m, a)
        o = optimal(n, m, a)
        assert b == o, (n, m, a, b, o)
    return True

if __name__ == "__main__":
    assert random_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from math import gcd

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it); k = next(it)
    a = [next(it) for _ in range(k)]
    return n, m, k, a

def lcm_cap(a, b, cap):
    g = gcd(a, b)
    t = a // g
    if t > cap // b:
        return cap + 1
    return t * b

def crt_pair(r1, m1, r2, m2):
    g = gcd(m1, m2)
    diff = r2 - r1
    if diff % g != 0:
        return (None, None)
    m1_g = m1 // g
    m2_g = m2 // g
    inv = pow(m1_g, -1, m2_g)
    k = ((diff // g) * inv) % m2_g
    r = (r1 + k * m1) % (m1 * m2_g)
    m = m1 * m2_g
    return (r, m)

def solve_case(n, m, k, a):
    L = 1
    for v in a:
        L = lcm_cap(L, v, n)
        if L > n:
            return "NO"
    r, mod = 0, 1
    for idx, v in enumerate(a, start=1):
        need = (1 - idx) % v
        r, mod = crt_pair(r, mod, need, v)
        if r is None:
            return "NO"
    for idx, v in enumerate(a, start=1):
        num = r + idx - 1
        if num % v != 0:
            return "NO"
        if gcd(num // v, L // v) != 1:
            return "NO"
    high = m - k + 1
    if high < 1:
        return "NO"
    j_min = r if r != 0 else mod
    if j_min > high:
        return "NO"
    return "YES"

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, m, k, a = inp
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    # Sanity asserts
    assert solve_case(10, 10, 5, [5, 2, 1, 2, 1]) == "YES"
    assert solve_case(10, 8, 5, [5, 2, 1, 2, 1]) == "NO"
    assert solve_case(3, 10, 2, [2, 3]) == "NO"
    # Run if input is provided
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to CRT on $j$ and LCM on $i$, then filter by coprimality and bounds.}
\WHY{Combines generalized CRT with number-theoretic characterization of $\gcd$, a frequent theme in advanced interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Compute $L=\mathrm{lcm}(a)$ with early cap; check $L \le n$.
\item Solve $j \equiv 1-l \pmod{a_l}$ via CRT; ensure consistency.
\item Verify $\gcd\!\bigl((r+l-1)/a_l, L/a_l\bigr)=1$ for all $l$.
\item Fit smallest positive $j$ into $[1, m-k+1]$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $m-k+1 < 1$ implies NO.
\item $k=1$: need $a_1 \le n$ and $1 \le j \le m$ with $j \equiv 0 \pmod{a_1}$.
\item Large shared factors among $a_l$: CRT consistency requires $\gcd(a_p, a_q) \mid (p-q)$.
\item $L$ just above $n$: immediate NO.
\item $r=0$: smallest positive $j$ is $A$ (not $0$).
\item Very large $a_l$: arithmetic must be done with big integers.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the coprimality check $\gcd\bigl((r+l-1)/a_l, L/a_l\bigr)=1$.
\item Treating CRT moduli as coprime when they are not.
\item Using $j=r$ when $r=0$ (invalid as column indices start at $1$).
\item Overflow when computing $\mathrm{lcm}$ without capping/division-first.
\item Off-by-one in width check: require $j \le m-k+1$.
\item Mixing $0$-based and $1$-based indices in congruences.
\end{bullets}
}
\FAILMODES{Approaches that only check CRT and $L \le n$ but skip coprimality produce false positives. Greedy alignment without CRT fails on inconsistent remainders.}
\ELI{Make the row index a multiple of all desired gcds, line up the starting column so each position is a multiple of the target, and ensure there are no extra common factors sneaking into the gcd. If all of that fits within the grid, answer YES.}
\NotePages{3}

\end{document}