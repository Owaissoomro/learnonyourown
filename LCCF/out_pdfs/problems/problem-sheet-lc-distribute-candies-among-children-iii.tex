% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Distribute Candies Among Children III}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/distribute-candies-among-children-iii/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given three integers $n$, $k$, and $limit$. Count the number of $k$-tuples of nonnegative integers $(x_1,x_2,\ldots,x_k)$ such that
\begin{BreakableEquation*}
x_1 + x_2 + \cdots + x_k = n,\quad \text{and}\quad 0 \le x_i \le limit \text{ for all } i.
\end{BreakableEquation*}
Return the number of such distributions as an integer.}
\BREAKDOWN{This is a bounded compositions counting problem. Reduce it to counting nonnegative integer solutions with upper bounds and use inclusion--exclusion or bounded DP.}
\ELI{Count how many ways to split $n$ identical candies among $k$ bins if no bin gets more than $limit$; use inclusion--exclusion to subtract the overflows.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{$n$ is the total number of candies; $k$ is the number of children; $limit$ is the maximum candies per child. All are integers with $n \ge 0$, $k \ge 1$, $limit \ge 0$.}
\OUTPUTS{An integer: the number of $k$-tuples $(x_1,\ldots,x_k)$ with $x_i \in \{0,1,\ldots,limit\}$ whose sum is $n$. If $n > k \cdot limit$, the answer is $0$.}
\SAMPLES{Example 1: $n=3$, $k=2$, $limit=3 \Rightarrow 4$ ways: $(0,3)$, $(1,2)$, $(2,1)$, $(3,0)$. Example 2: $n=5$, $k=3$, $limit=2 \Rightarrow 3$ ways: permutations of $(2,2,1)$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Count integer points in the box $[0,limit]^k$ that lie on the hyperplane $x_1+\cdots+x_k=n$.}
\varmapStart
\var{n}{total candies}
\var{k}{number of children}
\var{limit}{per-child upper bound}
\var{x_i}{candies assigned to child $i$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \sum_{j=0}^{\left\lfloor \dfrac{n}{limit+1} \right\rfloor} (-1)^j \binom{k}{j}\binom{n - j(limit+1) + k - 1}{\,k - 1\,},
\end{BreakableEquation*}
interpreting $\binom{a}{b}=0$ when $a<b$ or $b<0$. If $n>k\cdot limit$, the sum is $0$.}
\ASSUMPTIONS{Candies are identical; children are distinct; all bounds are integral; when $n=0$, exactly one distribution exists: all zeros.}
\INVARIANTS{Sum conservation: $\sum_i x_i = n$. Feasibility box: $0 \le x_i \le limit$. Symmetry across children: value depends only on $k$, not on labels.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============
% (If you add any Formula pages above, no extra notes are required unless desired.)

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Recursive enumeration with pruning: assign candies to children one by one, trying all $0\ldots limit$, and ensure the remaining sum is feasible.}
\ASSUMPTIONS{Works for small $k$ and $n$; uses memoization to avoid recomputing subproblems $(i,rem)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define $f(i, rem)$ as the number of ways to assign candies to children $i, i+1, \ldots, k-1$ summing to $rem$.
\item Recurse by choosing $t$ for child $i$ in $[0,\min(limit, rem)]$ and summing $f(i+1, rem-t)$.
\item Use memoization and early infeasibility pruning: if $rem<0$ or $rem>(k-i)\cdot limit$, return $0$.
\end{algosteps}
\COMPLEXITY{With memoization, states are $O(k\cdot n)$ and each transition loops up to $\min(limit, rem)$, so worst case $O(k\cdot n \cdot \min(limit,n))$ time and $O(k\cdot n)$ space.}
\[
\begin{aligned}
T(n,k,limit) &\le \sum_{i=0}^{k-1}\sum_{rem=0}^{n} \min(limit,rem) \;\;\in\; O\big(k\cdot n\cdot \min(limit,n)\big).
\end{aligned}
\]
\CORRECTNESS{The recursion enumerates all feasible assignments exactly once by fixing children in order and trying every $t$ in range. Pruning preserves correctness because impossible residual sums cannot be completed under the upper bound.}
\EDGECASES{$n=0$ returns $1$; $limit=0$ returns $[n=0]$; $k=1$ returns $[0 \le n \le limit]$; if $n>k\cdot limit$, return $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode LC: class Solution with exact signature + asserts
from functools import lru_cache

class Solution:
    def distributeCandies(self, n: int, limit: int, k: int) -> int:
        # Early infeasibility
        if n < 0 or limit < 0 or k <= 0:
            return 0
        if n > k * limit:
            return 0
        # Memoized DFS
        @lru_cache(maxsize=None)
        def dfs(i: int, rem: int) -> int:
            # i: current child index [0..k], rem: remaining candies
            if i == k:
                return 1 if rem == 0 else 0
            # Prune by feasibility bounds
            max_possible = (k - i) * limit
            if rem < 0 or rem > max_possible:
                return 0
            ways = 0
            upper = min(limit, rem)
            for t in range(upper + 1):
                ways += dfs(i + 1, rem - t)
            return ways

        return dfs(0, n)

# Basic asserts
s = Solution()
assert s.distributeCandies(3, 3, 2) == 4
assert s.distributeCandies(5, 2, 3) == 3
assert s.distributeCandies(0, 0, 5) == 1
\end{minted}
\VALIDATION{Small sanity checks above ensure base cases and a nontrivial bounded case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized DP via Prefix Sums}
\WHICHFORMULA{Dynamic programming on the sum, optimized by prefix sums to convert inner loops into $O(1)$ range sums.}
\ASSUMPTIONS{We build $dp[i][s]$ = ways using first $i$ children to sum to $s$; bounds allow filling with $O(k\cdot n)$ when $n$ is moderate.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[0][0]=1$, $dp[0][s>0]=0$.
\item For each child $i=1..k$, compute prefix sums $P[s]=\sum_{t=0}^{s} dp[i-1][t]$.
\item Use $dp[i][s]=P[s]-P[s-limit-1]$ if $s \ge limit+1$, else $dp[i][s]=P[s]$.
\end{algosteps}
\COMPLEXITY{Each layer computes prefix sums and a linear pass on $s=0..n$: overall $O(k\cdot n)$ time and $O(n)$ space with rolling arrays, faster than naive transitions.}
\[
\begin{aligned}
T(n,k) &= \Theta(k\cdot n),\quad S(n) = \Theta(n).
\end{aligned}
\]
\CORRECTNESS{The range-sum identity counts all choices $x_i\in[0,limit]$ summing to $s$ by summing prior ways for residuals $s-x_i$, exactly the bounded convolution.}
\textbf{Code (Improved)}
\begin{minted}{python}
# LeetCode LC: class Solution with exact signature + asserts
class Solution:
    def distributeCandies(self, n: int, limit: int, k: int) -> int:
        if n < 0 or limit < 0 or k <= 0:
            return 0
        if n > k * limit:
            return 0
        # dp_prev[s]: ways using i children to make sum s (rolling)
        dp_prev = [0] * (n + 1)
        dp_prev[0] = 1
        for _ in range(k):
            # prefix sums of dp_prev
            pref = [0] * (n + 1)
            run = 0
            for s in range(n + 1):
                run += dp_prev[s]
                pref[s] = run
            dp_cur = [0] * (n + 1)
            for s in range(n + 1):
                # dp_cur[s] = sum_{t=max(0, s-limit)}^{s} dp_prev[t]
                lo = s - limit - 1
                if lo >= 0:
                    dp_cur[s] = pref[s] - pref[lo]
                else:
                    dp_cur[s] = pref[s]
            dp_prev = dp_cur
        return dp_prev[n]

# Basic asserts
s = Solution()
assert s.distributeCandies(3, 3, 2) == 4
assert s.distributeCandies(5, 2, 3) == 3
assert s.distributeCandies(7, 10, 3) == 36  # unconstrained equals C(7+3-1, 3-1)=C(9,2)=36
\end{minted}
\VALIDATION{Added an unconstrained case with large limit to match stars-and-bars $\binom{n+k-1}{k-1}$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Inclusion--Exclusion}
\WHICHFORMULA{Apply inclusion--exclusion on violations $x_i \ge limit+1$ and closed-form binomial counts for nonnegative solutions.}
\ASSUMPTIONS{Children are symmetric; combinations $\binom{a}{b}$ can be computed in $O(b)$ time using multiplicative formula; Python big integers handle exact counts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n>k\cdot limit$, return $0$ immediately.
\item For $j=0$ to $\left\lfloor \tfrac{n}{limit+1}\right\rfloor$: choose $j$ overflowing children in $\binom{k}{j}$ ways.
\item For each $j$, reduce the sum by $j(limit+1)$ and count unconstrained solutions: $\binom{n - j(limit+1) + k - 1}{k - 1}$, alternating sign $(-1)^j$.
\end{algosteps}
\OPTIMALITY{Any exact algorithm must at least read the inputs; this method runs in $O(k)$ terms with $O(k)$-time binomials per term, independent of $n$ when constants are large, and is tight for large $n$ compared to DP.}
\COMPLEXITY{Let $J=\left\lfloor \tfrac{n}{limit+1}\right\rfloor$. Each term computes two binomials in $O(k)$ time worst-case, giving $O(J\cdot k)$ time and $O(1)$ extra space.}
\[
\begin{aligned}
T(n,k,limit) &= O\!\left(k \cdot \left\lfloor \frac{n}{limit+1}\right\rfloor \right),\quad S=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# LeetCode LC: class Solution with exact signature + asserts
class Solution:
    def distributeCandies(self, n: int, limit: int, k: int) -> int:
        if n < 0 or limit < 0 or k <= 0:
            return 0
        if n > k * limit:
            return 0

        def nCr(n: int, r: int) -> int:
            if r < 0 or r > n:
                return 0
            r = min(r, n - r)
            num = 1
            den = 1
            # multiplicative formula to avoid large factorials
            for i in range(1, r + 1):
                num *= (n - r + i)
                den *= i
            return num // den

        ans = 0
        max_j = n // (limit + 1) if limit + 1 > 0 else 0
        for j in range(0, max_j + 1):
            sign = -1 if j % 2 else 1
            rem = n - j * (limit + 1)
            ways_choose = nCr(k, j)
            ways_fill = nCr(rem + k - 1, k - 1)
            ans += sign * ways_choose * ways_fill
        return ans

# Exactly 3 asserts
s = Solution()
assert s.distributeCandies(3, 3, 2) == 4
assert s.distributeCandies(5, 2, 3) == 3
# Unconstrained: limit >= n => stars and bars
assert s.distributeCandies(7, 100, 4) == 120  # C(7+4-1, 4-1) = C(10,3) = 120
\end{minted}
\VALIDATION{Three asserts covering bounded, tight bound, and effectively unbounded regimes.}
\RESULT{Returns the exact count of bounded compositions; ties are not applicable because the output is a count, not a choice.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-check inclusion--exclusion vs DP on many small random cases; verify base cases and boundary conditions like $n=0$, $limit=0$, and $n=k\cdot limit$.}
\LINE{CROSS-CHECKS}{For small $n,k,limit$, ensure Approach B and C produce the same value. For very large $limit$, compare with stars-and-bars $\binom{n+k-1}{k-1}$.}
\LINE{EDGE-CASE GENERATOR}{Generate triples $(n,k,limit)$ with $n$ small, $limit$ in $\{0,1,n,2n\}$, and $k$ in $\{1,2,3,4,5\}$ to exercise edge conditions.}
\begin{minted}{python}
import random
from functools import lru_cache

# Deterministic generators for boundaries, degenerates, adversarials
def brute_dp(n: int, limit: int, k: int) -> int:
    if n > k * limit:
        return 0
    dp = [0] * (n + 1)
    dp[0] = 1
    for _ in range(k):
        pref = [0] * (n + 1)
        run = 0
        for s in range(n + 1):
            run += dp[s]
            pref[s] = run
        ndp = [0] * (n + 1)
        for s in range(n + 1):
            lo = s - limit - 1
            ndp[s] = pref[s] - (pref[lo] if lo >= 0 else 0)
        dp = ndp
    return dp[n]

def incl_excl(n: int, limit: int, k: int) -> int:
    if n > k * limit:
        return 0
    def nCr(n: int, r: int) -> int:
        if r < 0 or r > n:
            return 0
        r = min(r, n - r)
        num = 1
        den = 1
        for i in range(1, r + 1):
            num *= (n - r + i)
            den *= i
        return num // den
    ans = 0
    max_j = n // (limit + 1) if limit + 1 > 0 else 0
    for j in range(max_j + 1):
        rem = n - j * (limit + 1)
        ans += ( -1 if j % 2 else 1 ) * nCr(k, j) * nCr(rem + k - 1, k - 1)
    return ans

random.seed(0)
for n in range(0, 9):
    for k in range(1, 6):
        for limit in [0, 1, 2, n, 2*n+1]:
            a = brute_dp(n, limit, k)
            b = incl_excl(n, limit, k)
            assert a == b, (n, k, limit, a, b)
# Spot checks
assert incl_excl(7, 100, 4) == 120
assert incl_excl(10, 3, 3) == brute_dp(10, 3, 3)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def distributeCandies(self, n: int, limit: int, k: int) -> int:
        if n < 0 or limit < 0 or k <= 0:
            return 0
        if n > k * limit:
            return 0

        def nCr(n: int, r: int) -> int:
            if r < 0 or r > n:
                return 0
            r = min(r, n - r)
            num = 1
            den = 1
            for i in range(1, r + 1):
                num *= (n - r + i)
                den *= i
            return num // den

        ans = 0
        max_j = n // (limit + 1) if limit + 1 > 0 else 0
        for j in range(0, max_j + 1):
            sign = -1 if j % 2 else 1
            rem = n - j * (limit + 1)
            ans += sign * nCr(k, j) * nCr(rem + k - 1, k - 1)
        return ans

# smoke tests
s = Solution()
assert s.distributeCandies(3, 3, 2) == 4
assert s.distributeCandies(5, 2, 3) == 3
assert s.distributeCandies(7, 100, 4) == 120
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count bounded compositions of $n$ into $k$ parts of size at most $limit$.}
\WHY{A classic inclusion--exclusion application; appears in combinatorics-heavy interviews and dynamic programming practice.}
\CHECKLIST{Ensure feasibility $n \le k\cdot limit$; choose method (DP vs inclusion--exclusion) based on sizes; compute binomials carefully; handle base cases.}
\EDGECASES{All zeros $n=0$; single child $k=1$; zero limit; $n=k\cdot limit$; effectively unbounded $limit \ge n$; very large $k$ with tiny $n$; $limit=1$ binary case; $n>k\cdot limit$ infeasible.}
\PITFALLS{Forgetting to return $0$ when $n>k\cdot limit$; off-by-one in $limit+1$; not treating $\binom{a}{b}=0$ for invalid $a,b$; integer division in binomial formula; overflow in languages without big integers; slow DP without prefix sums.}
\FAILMODES{Naive enumeration explodes exponentially; DP $O(k\cdot n\cdot limit)$ times out when all are large; incorrect inclusion--exclusion signs produce negative or wrong counts.}
\ELI{We are counting ways to split candies with a cap per child. First count all splits without caps, then subtract those where some children exceed the cap. This alternating add/subtract gives the exact answer fast.}
\NotePages{3}

\end{document}