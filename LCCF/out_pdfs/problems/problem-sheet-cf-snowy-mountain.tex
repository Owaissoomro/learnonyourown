% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Snowy Mountain}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1652/G}}
\LINE{DIFFICULTY / RATING}{2900}
\STATEMENT{There are $n$ locations on a snowy mountain range (numbered from $1$ to $n$), connected by $n-1$ trails in the shape of a tree. Each trail has length $1$. Some of the locations are base lodges. The height $h_i$ of each location is equal to the distance to the nearest base lodge (a base lodge has height $0$).

There is a skier at each location, each skier has initial kinetic energy $0$. Each skier wants to ski along as many trails as possible. Suppose that the skier is skiing along a trail from location $i$ to $j$. Skiers are not allowed to ski uphill (i.e., if $h_i < h_j$). It costs one unit of kinetic energy to ski along flat ground (i.e., if $h_i = h_j$), and a skier gains one unit of kinetic energy by skiing downhill (i.e., if $h_i > h_j$). For each location, compute the length of the longest sequence of trails that the skier starting at that location can ski along without their kinetic energy ever becoming negative. Skiers are allowed to visit the same location or trail multiple times.

Input:
The first line contains a single integer $n$ ($2 \le n \le 2 \cdot 10^5$).

The second line contains $n$ integers $l_1, l_2, \ldots, l_n$ ($0 \le l_i \le 1$). If $l_i = 1$, location $i$ is a base lodge; if $l_i = 0$, location $i$ is not a base lodge. It is guaranteed that there is at least $1$ base lodge.

Each of the next $n-1$ lines contains two integers $u, v$ ($1 \leq u, v \leq n$, $u \ne v$), meaning that there is a trail that connects the locations $u$ and $v$. It is guaranteed that the given trails form a tree.

Output:
Print $n$ integers: the $i$-th integer is equal to the length of the longest sequence of trails that the skier starting at location $i$ can ski along without their kinetic energy ever becoming negative.

Note:
In the first test, $h = [0, 0, 1, 1, 2, 3]$. The skier starting from $6$ can ski along at most $5$ trails, in the path $6 \rightarrow 5 \rightarrow 4 \rightarrow 3 \rightarrow 4 \rightarrow 2$ (notice that a skier can ski multiple times along the same trail and can visit more than once the same location):

- at the location $6$, the kinetic energy is $0$;
- at the location $5$, the kinetic energy increases by $1$ (because $h_5 < h_6$), so it becomes $1$;
- at the location $4$, the kinetic energy increases by $1$ (because $h_4 < h_5$), so it becomes $2$;
- at the location $3$, the kinetic energy decreases by $1$ (because $h_3 = h_4$), so it becomes $1$;
- at the location $4$, the kinetic energy decreases by $1$ (because $h_4 = h_3$), so it becomes $0$;
- at the location $2$, the kinetic energy increases by $1$ (because $h_2 < h_4$), so it becomes $1$.

There isn't any sequence of trails of length greater than $5$ such that the kinetic energy is always non-negative.

Moreover,

- the optimal path for the skier starting from $1$ is $1$ (no trails);
- the optimal path for the skier starting from $2$ is $2$ (no trails);
- the optimal path for the skier starting from $3$ is $3 \rightarrow 1$;
- the optimal path for the skier starting from $4$ is $4 \rightarrow 2$;
- the optimal path for the skier starting from $5$ is $5 \rightarrow 4 \rightarrow 3 \rightarrow 1$.

In the second test, $h = [3, 2, 2, 1, 1, 1, 0, 0, 0]$. The skier starting from $1$ can ski along at most $5$ trails, in the path $1 \rightarrow 3 \rightarrow 2 \rightarrow 5 \rightarrow 4 \rightarrow 7$.

- at the location $1$, the kinetic energy is $0$;
- at the location $3$, the kinetic energy increases by $1$ (because $h_3 < h_1$), so it becomes $1$;
- at the location $2$, the kinetic energy decreases by $1$ (because $h_2 = h_3$), so it becomes $0$;
- at the location $5$, the kinetic energy increases by $1$ (because $h_5 < h_2$), so it becomes $1$;
- at the location $4$, the kinetic energy decreases by $1$ (because $h_4 = h_5$), so it becomes $0$;
- at the location $7$, the kinetic energy increases by $1$ (because $h_7 < h_4$), so it becomes $1$.

There isn't any sequence of trails of length greater than $5$ such that the kinetic energy is always non-negative.

In the third test, for the skier starting from vertex $1$, the optimal path is $1 \rightarrow 2 \rightarrow 5 \rightarrow 4 \rightarrow 3 \rightarrow 6 \rightarrow 11 \rightarrow 10 \rightarrow 11$.

Here are pictures of the first, second, and third test, with the base lodges shown in red.}
\BREAKDOWN{Compute multi-source distances $h$ from base lodges; then for each start node, determine how far downward one can reach a level that contains at least one equal-height edge, since each downward step yields energy that can be spent on equal-height traversals. The optimal length turns out to be $h[u] + f[u]$, where $f[u]$ is the maximal number of downward steps needed to reach any level that has an equal-height edge reachable from $u$ without going uphill.}
\ELI{Go downhill to earn energy, then spend it by sliding back and forth along any flat edge you can find as low as possible; the answer equals all downhill steps plus how much of that energy you can actually spend.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A tree on $n$ nodes ($2 \le n \le 2 \cdot 10^5$). A binary array $l$ marking base lodges ($\ge 1$ base). $n-1$ undirected edges.}
\OUTPUTS{Print $n$ integers: for each node $i$, the maximum number of trails in a walk starting at $i$, never going to higher $h$, and never letting the energy balance drop below $0$.}
\SAMPLES{Example 1 (small):
- $n=3$, bases at $\{1\}$, edges: $(1,2),(2,3)$. Heights: $[0,1,2]$. There are no equal-height edges. Output: $[0,1,2]$.
- $n=4$, bases at $\{1,2\}$, edges: $(1,3),(2,3),(3,4)$. Heights: $[0,0,1,2]$. There is an equal-height edge between $1$ and $2$ (level $0$). Output: $[0,0,2,4]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree, $B \subseteq V$ the base lodges, and $h:V\to \mathbb{Z}_{\ge 0}$ the multi-source shortest-path distance to $B$ (unit edges). A valid move from $u$ to $v$ requires $h(v) \le h(u)$ and $|h(u)-h(v)| \le 1$. Moving to $v$ with $h(v)=h(u)$ costs $1$ energy, and moving to $v$ with $h(v)=h(u)-1$ yields $+1$ energy. Starting with energy $0$, we seek the maximum-length walk whose energy prefix-sum never goes negative.}
\varmapStart
\var{n}{number of nodes}
\var{B}{set of base lodges}
\var{h(u)}{distance of $u$ to $B$}
\var{E_{\mathrm{eq}}}{set of edges $\{u,v\}\in E$ with $h(u)=h(v)$}
\var{C_d}{connected components induced by $E_{\mathrm{eq}}$ on level $d$}
\var{g(C)}{maximal downward levels from component $C$ to reach any component containing an equal edge}
\var{f(u)}{maximal downward levels from $u$ to reach any node incident to an equal-height edge}
\var{A(u)}{answer for node $u$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } \mathcal{C} = \bigcup_{d \ge 0} C_d \text{ be equal-level components. Define a DAG on } \mathcal{C} \text{ with } C \to C'
\\[-1pt]
&\text{iff } \exists (u,v)\in E \text{ with } u\in C,\ v\in C',\ h(v)=h(u)-1.\\
&\text{Let } \text{good}(C) = \mathbf{1}\{\lvert C\rvert \ge 2\}.\\
&g(C) = \max\big( \text{good}(C)\cdot 0,\ 1 + \max_{C' \in \text{child}(C)} g(C') \big),\ \text{with } \max \emptyset = -\infty.\\
&f(u) = \max(0, g(C(u))).\\
&A(u) = h(u) + f(u).
\end{aligned}
\]
}
\ASSUMPTIONS{Edges are unit weight; $h$ is a valid layering so $|h(u)-h(v)| \le 1$ for every edge. Equal-level connectivity partitions each level into components. The component-DAG is acyclic since edges always go from level $d$ to $d-1$.}
\INVARIANTS{Energy along any walk equals (down-steps) $-$ (flat-steps); never negative implies total flats $\le$ total downs before the last level where a flat edge exists. Compressing equal-level edges preserves reachability without uphill moves.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate all non-increasing walks with an energy counter; track the maximum length without energy going negative.}
\ASSUMPTIONS{Tree size small; revisit allowed; terminate via pruning on energy and remaining height.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $h$ by multi-source BFS.
\item For each start $u$, perform DFS over neighbors $v$ with $h(v)\le h(u)$; update energy by $\pm 1$ accordingly; prune when energy $<0$.
\item Track the maximum depth reached.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in the worst case; even with pruning, the state space is unbounded due to revisits and energy variation. Not viable for $n \le 2\cdot 10^5$.}
\[
\begin{aligned}
T(n) &\approx \Omega(2^{n}) \\
     &\text{(revisits and cycles on equal-level edges blow up the search).}
\end{aligned}
\]
\CORRECTNESS{By construction explores all valid walks, but not computationally feasible.}
\EDGECASES{No equal-height edges; all nodes bases; stars and paths.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Brute-force (for illustration only; not for large n). Includes CF-style API and tests.
from collections import deque, defaultdict
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    l = [int(next(it)) for _ in range(n)]
    edges = [[] for _ in range(n)]
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges[u].append(v)
        edges[v].append(u)
    return n, l, edges

def heights_from_bases(n, bases, edges):
    INF = 10**9
    dist = [INF]*n
    dq = deque()
    for i in range(n):
        if bases[i]:
            dist[i] = 0
            dq.append(i)
    while dq:
        u = dq.popleft()
        for v in edges[u]:
            if dist[v] > dist[u] + 1:
                dist[v] = dist[u] + 1
                dq.append(v)
    return dist

def solve_all(data=None):
    n, l, edges = read_input(data)
    h = heights_from_bases(n, l, edges)

    sys.setrecursionlimit(1 << 25)
    best = [0]*n
    # Danger: this is exponential; used only on toy inputs in tests.
    def dfs(u, energy, last_h, seen, depth, limit=20):
        # limit to avoid infinite loops in brute-force demonstration
        best_val = depth
        if depth >= limit:
            return best_val
        for v in edges[u]:
            if h[v] > last_h:  # uphill forbidden
                continue
            delta = 0
            if h[v] == last_h:
                if energy == 0:
                    continue
                delta = -1
            else:
                delta = +1
            best_val = max(best_val, dfs(v, energy + delta, h[v], seen, depth + 1, limit))
        return best_val

    ans = []
    for u in range(n):
        ans.append(dfs(u, 0, h[u], set(), 0, limit=20))
    out = " ".join(map(str, ans))
    print(out)
    return out

def main():
    solve_all()

if __name__ == "__main__":
    # Tiny asserts on trivial cases only (since brute-force is unsafe for large graphs)
    # 1) Single edge, base at 0
    data = """2
1 0
1 2
"""
    assert solve_all(data.split()) == "0 1"
    # 2) Path of 3, base at 0: heights [0,1,2], no equal edges
    data = """3
1 0 0
1 2
2 3
"""
    assert solve_all(data.split()) == "0 1 2"
    # 3) Bases adjacent: 1-2 both bases; 2-3-4 chain
    data = """4
1 1 0 0
1 2
2 3
3 4
"""
    # Brute-force limited to depth 20; expected up to 4 from node 4
    assert solve_all(data.split()).split()[:2] == ["0","0"]
    # Do not run main() by default here
    pass
\end{minted}
\VALIDATION{The asserts cover tiny trees and presence/absence of equal-height edges.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Compress Equal Levels; Longest-Drop DP to a Good Component}
\WHICHFORMULA{Equal-level edges form components. Build a DAG of components from level $d$ to $d-1$. Let a component be good if it has an equal edge (size $\ge 2$). For each component $C$, compute $g(C)$: the maximum number of downward steps to any good component reachable from $C$. Then $A(u)=h(u)+g(C(u))$ clipped below at $h(u)$ if no good is reachable.}
\ASSUMPTIONS{Tree; unit edges; $h$ computed by multi-source BFS; equal components via DSU; DP bottom-up by increasing level.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $h$ by multi-source BFS from all bases.
\item Build DSU unions on edges with equal $h$ to form components; mark component sizes and heights.
\item Build component DAG: for each original edge with $|h(u)-h(v)|=1$, add an edge from higher-$h$ component to lower-$h$ component.
\item DP by level $d=0..h_{\max}$: $g(C)=\max\big(\mathbf{1}\{\text{size}\ge2\}\cdot 0,\ 1+\max g(\text{children})\big)$ with $-\infty$ for missing children.
\item For each node $u$: $A(u)=h(u)+\max(0,g(C(u)))$.
\end{algosteps}
\COMPLEXITY{Near-linear time and memory.}
\[
\begin{aligned}
T(n) &= O(n) \text{ (BFS)} + O(n \alpha(n)) \text{ (DSU)} + O(n) \text{ (DAG + DP)} \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Any valid walk cannot go uphill; energy can only be spent on equal-level edges, hence the total number of flat traversals you can realize equals the number of downhill steps taken before you drop below the last level that still has an equal edge reachable. Compressing equal edges preserves the availability of flats per level. The DP computes the lowest level containing any equal edge reachable without uphill, maximizing spendable flats and thus total length $h+f$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Component compression + bottom-up DP. CF-style API and assertions.
from collections import deque, defaultdict
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.sz[a] < self.sz[b]:
            a, b = b, a
        self.p[b] = a
        self.sz[a] += self.sz[b]
        return True

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    l = [int(next(it)) for _ in range(n)]
    edges = [[] for _ in range(n)]
    raw_edges = []
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges[u].append(v)
        edges[v].append(u)
        raw_edges.append((u, v))
    return n, l, edges, raw_edges

def multi_source_heights(n, bases, edges):
    INF = 10**9
    h = [INF]*n
    dq = deque()
    for i, b in enumerate(bases):
        if b:
            h[i] = 0
            dq.append(i)
    while dq:
        u = dq.popleft()
        for v in edges[u]:
            if h[v] > h[u] + 1:
                h[v] = h[u] + 1
                dq.append(v)
    return h

def solve_all(data=None):
    n, l, edges, raw_edges = read_input(data)
    h = multi_source_heights(n, l, edges)
    # DSU on equal-height edges
    dsu = DSU(n)
    for u, v in raw_edges:
        if h[u] == h[v]:
            dsu.union(u, v)
    root_to_id = {}
    comp_id = [None]*n
    comp_size = []
    comp_height = []
    cid = 0
    for u in range(n):
        r = dsu.find(u)
        if r not in root_to_id:
            root_to_id[r] = cid
            comp_size.append(0)
            comp_height.append(h[u])
            cid += 1
        comp_id[u] = root_to_id[r]
        comp_size[root_to_id[r]] += 1
    C = cid
    # Build component DAG edges: high -> low
    child = [[] for _ in range(C)]
    for u, v in raw_edges:
        if h[u] == h[v]:
            continue
        if h[u] > h[v]:
            hi, lo = comp_id[u], comp_id[v]
        else:
            hi, lo = comp_id[v], comp_id[u]
        if hi != lo:
            child[hi].append(lo)
    # Group comps by height
    maxh = max(h)
    comps_by_h = [[] for _ in range(maxh + 1)]
    for c in range(C):
        comps_by_h[comp_height[c]].append(c)
    NEG_INF = -10**9
    g = [NEG_INF]*C
    # DP bottom-up by level
    for d in range(0, maxh + 1):
        for c in comps_by_h[d]:
            best_child = NEG_INF
            for ch in child[c]:
                if g[ch] > best_child:
                    best_child = g[ch]
            val = NEG_INF
            if comp_size[c] >= 2:
                val = max(val, 0)
            if best_child > NEG_INF//2:
                val = max(val, 1 + best_child)
            g[c] = val
    # Answers
    ans = [0]*n
    for u in range(n):
        fu = g[comp_id[u]]
        if fu < 0:
            fu = 0
        ans[u] = h[u] + fu
    out = " ".join(map(str, ans))
    print(out)
    return out

def main():
    solve_all()

if __name__ == "__main__":
    # Tests
    # 1) Path of 3, base at 1: h=[0,1,2], no equal edges -> ans=[0,1,2]
    data = """3
1 0 0
1 2
2 3
"""
    assert solve_all(data.split()) == "0 1 2"
    # 2) Two adjacent bases at 1-2; chain 2-3-4: h=[0,0,1,2], equal at level 0 -> node 4 gives 4
    data = """4
1 1 0 0
1 2
2 3
3 4
"""
    assert solve_all(data.split()) == "0 0 2 4"
    # 3) Star centered at 1 (base), leaves no equal edges -> ans equals heights
    data = """5
1 0 0 0 0
1 2
1 3
1 4
1 5
"""
    assert solve_all(data.split()) == "0 1 1 1 1"
\end{minted}
\VALIDATION{Covers: no equal edges; equal at level $0$; and a star with only one base.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Equal-Component DAG DP (Provably Optimal)}
\WHICHFORMULA{Equal components compact all flat traversals; the component-DAG encodes all possible non-increasing moves between levels. Let $g(C)$ be the maximal drop to any good component; then the answer is $A(u)=h(u)+\max(0,g(C(u)))$.}
\ASSUMPTIONS{Tree; unit edges; $h$ is a layering; components per level via DSU; DAG edges only decrease level.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Multi-source BFS from bases to get $h$.
\item DSU to form equal-level components and their sizes.
\item Build DAG edges high $\to$ low for $|h(u)-h(v)|=1$.
\item Bottom-up DP over levels: $g(C)=\max(0\text{ if good}, 1+\max g(\text{children}))$.
\item Output $h[u]+\max(0,g(C(u)))$ for each node $u$.
\end{algosteps}
\OPTIMALITY{Lower bound: every walk has at most $h(u)$ downhill steps; at most one flat per downhill step is realizable before dropping below the last level with any equal edge reachable; thus $A(u) \le h(u) + f(u)$. Upper bound: the DP constructs a walk that performs exactly $f(u)$ flats by oscillating on a flat edge at the lowest reachable level(s) and uses all downhill steps necessary, achieving equality.}
\COMPLEXITY{Linearithmic due to DSU inverse Ackermann.}
\[
\begin{aligned}
T(n) &= O(n \alpha(n)),\quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final reference solution for CF 1652G-style problem statement.
from collections import deque
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.sz[a] < self.sz[b]:
            a, b = b, a
        self.p[b] = a
        self.sz[a] += self.sz[b]
        return True

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    l = [int(next(it)) for _ in range(n)]
    edges = [[] for _ in range(n)]
    raw_edges = []
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges[u].append(v); edges[v].append(u)
        raw_edges.append((u, v))
    return n, l, edges, raw_edges

def bfs_heights(n, bases, edges):
    INF = 10**9
    h = [INF]*n
    dq = deque()
    for i, b in enumerate(bases):
        if b:
            h[i] = 0
            dq.append(i)
    while dq:
        u = dq.popleft()
        for v in edges[u]:
            if h[v] > h[u] + 1:
                h[v] = h[u] + 1
                dq.append(v)
    return h

def solve_all(data=None):
    n, l, edges, raw_edges = read_input(data)
    h = bfs_heights(n, l, edges)
    # Union equal-level edges
    dsu = DSU(n)
    for u, v in raw_edges:
        if h[u] == h[v]:
            dsu.union(u, v)
    root_to_id = {}
    comp_id = [0]*n
    comp_size = []
    comp_height = []
    cid = 0
    for u in range(n):
        r = dsu.find(u)
        if r not in root_to_id:
            root_to_id[r] = cid
            comp_size.append(0)
            comp_height.append(h[u])
            cid += 1
        comp_id[u] = root_to_id[r]
        comp_size[comp_id[u]] += 1
    C = cid
    # DAG edges high -> low
    child = [[] for _ in range(C)]
    for u, v in raw_edges:
        if h[u] == h[v]: continue
        if h[u] > h[v]:
            hi, lo = comp_id[u], comp_id[v]
        else:
            hi, lo = comp_id[v], comp_id[u]
        if hi != lo:
            child[hi].append(lo)
    maxh = max(h) if n > 0 else 0
    comps_by_h = [[] for _ in range(maxh + 1)]
    for c in range(C):
        d = comp_height[c]
        comps_by_h[d].append(c)
    NEG_INF = -10**9
    g = [NEG_INF]*C
    for d in range(0, maxh + 1):
        for c in comps_by_h[d]:
            best = NEG_INF
            for ch in child[c]:
                if g[ch] > best:
                    best = g[ch]
            val = NEG_INF
            if comp_size[c] >= 2:
                val = max(val, 0)
            if best > NEG_INF//2:
                val = max(val, 1 + best)
            g[c] = val
    ans = [0]*n
    for u in range(n):
        fu = g[comp_id[u]]
        if fu < 0:
            fu = 0
        ans[u] = h[u] + fu
    out = " ".join(map(str, ans))
    print(out)
    return out

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    # 1) Path of 3, base at 1
    data = """3
1 0 0
1 2
2 3
"""
    assert solve_all(data.split()) == "0 1 2"
    # 2) Two adjacent bases at 1-2; chain 2-3-4
    data = """4
1 1 0 0
1 2
2 3
3 4
"""
    assert solve_all(data.split()) == "0 0 2 4"
    # 3) Star centered at base
    data = """5
1 0 0 0 0
1 2
1 3
1 4
1 5
"""
    assert solve_all(data.split()) == "0 1 1 1 1"
\end{minted}
\VALIDATION{Three deterministic mini-tests exercise no-equal case, equal-at-level-zero case, and a star.}
\RESULT{For each node $u$, the printed integer equals $h[u] + f[u]$, where $f[u]$ is the maximal number of downward steps to reach any level that contains an equal-height edge reachable from $u$ without uphill; if none exists, $f[u]=0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small trees: paths, stars, adjacent bases; randomized trees with random base sets verifying $A(u)\in [h(u), 2h(u)]$ and spot-checking by limited brute-force.}
\LINE{CROSS-CHECKS}{Compare brute-force (depth-limited) with DP on tiny trees; ensure monotonicity $A(u)\le 2h(u)$ and $A(u)\ge h(u)$.}
\LINE{EDGE-CASE GENERATOR}{Produce trees with: no equal edges; all edges equal at some levels; multiple bases including adjacent; single base.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_path(n, base_idx=0):
    l = [0]*n
    l[base_idx] = 1
    edges = [(i, i+1) for i in range(1, n)]
    return n, l, edges

def gen_star(n, center=1):
    l = [0]*n
    l[center-1] = 1
    edges = [(center, i) for i in range(1, n+1) if i != center]
    return n, l, edges

def gen_two_adjacent_bases_chain(n):
    # 1-2 are bases, path to n
    l = [0]*n
    l[0] = l[1] = 1
    edges = [(i, i+1) for i in range(1, n)]
    return n, l, edges
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF-ready implementation (same as in Approach C).
from collections import deque
import sys

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.sz[a] < self.sz[b]:
            a, b = b, a
        self.p[b] = a
        self.sz[a] += self.sz[b]
        return True

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    l = [int(next(it)) for _ in range(n)]
    edges = [[] for _ in range(n)]
    raw_edges = []
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges[u].append(v); edges[v].append(u)
        raw_edges.append((u, v))
    return n, l, edges, raw_edges

def bfs_heights(n, bases, edges):
    INF = 10**9
    h = [INF]*n
    dq = deque()
    for i, b in enumerate(bases):
        if b:
            h[i] = 0
            dq.append(i)
    while dq:
        u = dq.popleft()
        for v in edges[u]:
            if h[v] > h[u] + 1:
                h[v] = h[u] + 1
                dq.append(v)
    return h

def solve_all(data=None):
    n, l, edges, raw_edges = read_input(data)
    h = bfs_heights(n, l, edges)
    dsu = DSU(n)
    for u, v in raw_edges:
        if h[u] == h[v]:
            dsu.union(u, v)
    root_to_id = {}
    comp_id = [0]*n
    comp_size = []
    comp_height = []
    cid = 0
    for u in range(n):
        r = dsu.find(u)
        if r not in root_to_id:
            root_to_id[r] = cid
            comp_size.append(0)
            comp_height.append(h[u])
            cid += 1
        comp_id[u] = root_to_id[r]
        comp_size[comp_id[u]] += 1
    C = cid
    child = [[] for _ in range(C)]
    for u, v in raw_edges:
        if h[u] == h[v]: continue
        if h[u] > h[v]:
            hi, lo = comp_id[u], comp_id[v]
        else:
            hi, lo = comp_id[v], comp_id[u]
        if hi != lo:
            child[hi].append(lo)
    maxh = max(h) if n > 0 else 0
    comps_by_h = [[] for _ in range(maxh + 1)]
    for c in range(C):
        comps_by_h[comp_height[c]].append(c)
    NEG_INF = -10**9
    g = [NEG_INF]*C
    for d in range(0, maxh + 1):
        for c in comps_by_h[d]:
            best = NEG_INF
            for ch in child[c]:
                if g[ch] > best:
                    best = g[ch]
            val = NEG_INF
            if comp_size[c] >= 2:
                val = max(val, 0)
            if best > NEG_INF//2:
                val = max(val, 1 + best)
            g[c] = val
    ans = [0]*n
    for u in range(n):
        fu = g[comp_id[u]]
        if fu < 0:
            fu = 0
        ans[u] = h[u] + fu
    out = " ".join(map(str, ans))
    print(out)
    return out

def main():
    solve_all()

if __name__ == "__main__":
    # Simple sanity asserts
    data = """3
1 0 0
1 2
2 3
"""
    assert solve_all(data.split()) == "0 1 2"
    data = """4
1 1 0 0
1 2
2 3
3 4
"""
    assert solve_all(data.split()) == "0 0 2 4"
    data = """5
1 0 0 0 0
1 2
1 3
1 4
1 5
"""
    assert solve_all(data.split()) == "0 1 1 1 1"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compress equal-height edges into components; DP down the level-DAG to find the lowest reachable level that still has a flat edge, then $A(u)=h(u)+$ that drop.}
\WHY{This pattern appears in problems where moves do not increase a potential (height), and one move type is ``free'' within level sets (flat edges). Component compression simplifies reachability and cycles.}
\CHECKLIST{%
- Compute $h$ via multi-source BFS from bases.%
- DSU-union along edges with equal $h$.%
- Build DAG edges from higher to lower components.%
- DP bottom-up per level to compute $g(C)$.%
- Output $h[u]+\max(0,g(C(u)))$.}
\EDGECASES{%
- No equal-height edges anywhere $\Rightarrow$ answers are just $h(u)$.%
- Multiple adjacent bases at level $0$ produce $A(u)=2h(u)$ for nodes whose downward chain reaches that component.%
- Long path with a single equal edge at an intermediate level.%
- Disconnected equal components per level with branching to lower levels.%
- Single base and star tree.%
- All nodes bases (then $h\equiv 0$ and all answers $0$).}
\PITFALLS{%
- Forgetting that $|h(u)-h(v)|\le 1$ on tree edges; do not add edges skipping levels.%
- Treating ``any node in a component'' as good: must check component size $\ge 2$.%
- Double-counting edges between components (harmless but watch performance).%
- Using a shortest-distance to nearest flat edge instead of farthest drop; the answer needs the \emph{lowest} reachable flat level.%
- Off-by-one in DP base case at level $0$.%
- Not clamping $g(C)<0$ to $0$ for the final answer.}
\FAILMODES{Naive DFS may loop and explode due to revisits on flat edges; shortest-distance variants may underestimate by taking the nearest flat instead of the lowest one. The component-DAG DP avoids both by monotone levels and acyclicity.}
\ELI{You earn one coin each time you go down a step. You can spend coins only when there is a flat edge at your current level. To spend as many coins as possible, reach the lowest level that still has a flat and spend them there. The DP computes how low that is for every start.}
\NotePages{3}

\end{document}