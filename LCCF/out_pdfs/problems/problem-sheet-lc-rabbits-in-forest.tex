% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rabbits in Forest}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/rabbits-in-forest/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{There is a forest with an unknown number of rabbits. We asked $n$ rabbits, ``How many rabbits have the same color as you?'' and collected the answers in an integer array \texttt{answers} where \texttt{answers[i]} is the answer of the $i$th rabbit.\\
Given the array \texttt{answers}, return the minimum number of rabbits that could be in the forest.\\[4pt]
Examples:\\
1) Input: \texttt{answers = [1,1,2]}. Output: \texttt{5}. Explanation: The two rabbits that answered ``1'' could both be the same color, say red. The rabbit that answered ``2'' cannot be red or the answers would be inconsistent. Say the rabbit that answered ``2'' was blue. Then there should be $2$ other blue rabbits in the forest that did not answer into the array. The smallest possible number is therefore $5$: three that answered plus two that did not.\\
2) Input: \texttt{answers = [10,10,10]}. Output: \texttt{11}.\\[4pt]
Constraints: $1 \le \lvert\texttt{answers}\rvert \le 1000$ and $0 \le \texttt{answers[i]} < 1000$.}
\BREAKDOWN{Group identical reports. A report $y$ implies groups of size $y+1$ (rabbits of one color). Count how many such groups are needed to cover all rabbits that reported $y$, then sum across all distinct $y$.}
\ELI{If $y$ rabbits of the same color are claimed besides the reporter, then that color's group size is $y+1$; pack reporters into full groups of that size and add up those group sizes.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{answers} of integers with length $n$ where $1 \le n \le 1000$ and each element satisfies $0 \le \texttt{answers[i]} < 1000$.}
\OUTPUTS{An integer equal to the minimum possible total number of rabbits in the forest consistent with the reports.}
\SAMPLES{Example A: \texttt{answers=[1,1,2]} $\to$ \texttt{5}.\\
Example B: \texttt{answers=[0,0,1,1,1]} $\to$ \texttt{6}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each reported number $y \in \{0,1,2,\ldots\}$, let $f_y$ be the frequency of that report in \texttt{answers}. A report $y$ indicates a color class of size $g=y+1$. The minimal number of rabbits consistent with all reports is obtained by covering $f_y$ reporters with as few size-$g$ color classes as possible and summing across all distinct $y$.}
\varmapStart
\var{y}{a reported count of same-color rabbits besides the reporter}
\var{g=y+1}{group size (rabbits of one color with report $y$)}
\var{f_y}{number of rabbits that reported $y$}
\var{R}{minimum total number of rabbits}
\varmapEnd
\GOVERN{
\[
  R \;=\; \sum_{y \,\text{distinct in}\, \texttt{answers}} (y+1)\,\Big\lceil \frac{f_y}{\,y+1\,} \Big\rceil.
\]
}
\ASSUMPTIONS{Each color class is internally consistent: all rabbits of one color give the same report $y$, implying exactly $y+1$ rabbits in that color. Reports are truthful and consistent across rabbits of the same color.}
\INVARIANTS{
- For any report $y$, rabbits with that report can be partitioned into disjoint color classes of size exactly $y+1$.\\
- Using fewer than $\lceil f_y/(y+1) \rceil$ classes for some $y$ would force a class to contain more than $y+1$ rabbits, contradicting the meaning of $y$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sort \texttt{answers} and greedily form groups: when you see a value $y$, start a new color class of size $y+1$ and consume up to $y$ more identical $y$'s for that class. This realizes the ceiling in the governing formula by packing as tightly as possible in order.}
\ASSUMPTIONS{Sorting is allowed; $n \le 1000$ so $O(n \log n)$ is fine.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \texttt{answers}.
\item Scan left to right. When encountering a value $y$, add $y+1$ to the total and skip up to $y$ following equal values (consuming this class).
\item Repeat until the array is exhausted.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $T(n)=O(n\log n)$, $S(n)=O(1)$ extra beyond sorting (or $O(n)$ if not sorting in-place).}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(n) \\
     &= O(n \log n).
\end{aligned}
\]
\CORRECTNESS{Each time we see $y$, we must allocate a full color class of size $y+1$ that includes this reporter. Packing up to $y$ more identical $y$'s into this class avoids creating extra classes, thus minimizing the count. Any remaining $y$'s must start new classes.}
\EDGECASES{All zeros; large identical $y$; mixtures where the last group is partially filled; $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        n = len(answers)
        if n == 0:
            return 0
        a = sorted(answers)
        i = 0
        total = 0
        while i < n:
            y = a[i]
            group = y + 1
            total += group
            # consume up to 'group' rabbits reporting the same y
            take = 0
            while i < n and take < group and a[i] == y:
                i += 1
                take += 1
        return total

# Asserts (LC-style quick checks)
s = Solution()
assert s.numRabbits([1, 1, 2]) == 5
assert s.numRabbits([10, 10, 10]) == 11
assert s.numRabbits([0, 0, 1, 1, 1]) == 6
assert s.numRabbits([0]) == 1
\end{minted}
\VALIDATION{The asserts cover grouping identical values, zeros, and a mixed case with partial last group.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Counting with a Hash Map}
\WHICHFORMULA{Compute frequencies $f_y$ with a counter. For each distinct $y$, add $(y+1)\cdot \lceil f_y/(y+1) \rceil$ using integer arithmetic: groups$=(f_y+y)//(y+1)$.}
\ASSUMPTIONS{Hash map counting is $O(n)$ and avoids sorting.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies $f_y$ for each distinct $y$ in \texttt{answers}.
\item For each $y$, compute groups $= \big\lceil f_y/(y+1) \big\rceil = (f_y + y)//(y+1)$.
\item Accumulate $(y+1)\times\text{groups}$ into the total.
\end{algosteps}
\COMPLEXITY{Counting and summation are linear: $T(n)=O(n)$, $S(n)=O(m)$ where $m$ is the number of distinct reports ($m \le n$).}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(m) \le O(n).
\end{aligned}
\]
\CORRECTNESS{By the model, any solution must cover $f_y$ reporters with classes of size $y+1$; the minimal number of classes is $\lceil f_y/(y+1) \rceil$. Summing their sizes yields the minimum feasible total.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from collections import Counter

class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        freq = Counter(answers)
        total = 0
        for y, c in freq.items():
            group = y + 1
            groups = (c + y) // group  # ceil(c / group)
            total += groups * group
        return total

# Asserts
s = Solution()
assert s.numRabbits([1, 1, 2]) == 5
assert s.numRabbits([10, 10, 10]) == 11
assert s.numRabbits([0, 0, 1, 1, 1]) == 6
assert s.numRabbits([2, 2, 2, 2]) == 6  # 4 reports of 2 -> groups=ceil(4/3)=2 => 2*3=6
\end{minted}
\VALIDATION{Checks include multiple full groups and mixed cases; integer ceiling formula validated on $\{2,2,2,2\}$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Ceiling-by-Group Computation (Provably Optimal)}
\WHICHFORMULA{Use the closed-form sum $R=\sum_y (y+1)\cdot \lceil f_y/(y+1)\rceil$ with frequency counting.}
\ASSUMPTIONS{Reports are truthful and consistent per color; colors are indistinguishable except via $y$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a frequency map for \texttt{answers}.
\item For each distinct report $y$, compute the number of necessary color classes as $\lceil f_y/(y+1) \rceil$.
\item Accumulate the total rabbits as the sum over classes times their sizes.
\end{algosteps}
\OPTIMALITY{Lower bound: for fixed $y$, any color class can host at most $y+1$ reporters of that $y$, so at least $\lceil f_y/(y+1) \rceil$ classes are necessary. Upper bound: the construction that packs up to $y+1$ per class achieves exactly that number of classes. Summing across independent $y$ partitions gives a tight bound; hence the method is optimal.}
\COMPLEXITY{$T(n)=O(n)$ for counting and summation; $S(n)=O(m)$ for $m$ distinct values.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(m) \le O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import Counter

class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        total = 0
        for y, c in Counter(answers).items():
            g = y + 1
            total += ((c + y) // g) * g  # groups * group size
        return total

# Exactly 3 asserts
s = Solution()
assert s.numRabbits([1, 1, 2]) == 5
assert s.numRabbits([0, 0, 0, 0]) == 4
assert s.numRabbits([3]) == 4
\end{minted}
\VALIDATION{Covers mixed, all-zero, and single-element cases.}
\RESULT{Return the minimum total number of rabbits consistent with the given reports; ties cannot occur since the sum is uniquely determined by frequencies.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for edge cases: all zeros; all identical large $y$; mixtures; smallest $n=1$; random small arrays to cross-check sorting-based and counting-based methods.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (sorted greedy) and Approach B/C (hash map formula) on exhaustive small domains for $n \le 5$, $y \in [0,3]$.}
\LINE{EDGE-CASE GENERATOR}{Deterministic generators for degenerate cases (all same $y$), alternating patterns, and partial final group cases.}
\begin{minted}{python}
from typing import List
from collections import Counter
import itertools

def solve_sorted(answers: List[int]) -> int:
    a = sorted(answers)
    i, n = 0, len(a)
    total = 0
    while i < n:
        y = a[i]
        g = y + 1
        total += g
        take = 0
        while i < n and take < g and a[i] == y:
            i += 1
            take += 1
    return total

def solve_count(answers: List[int]) -> int:
    total = 0
    for y, c in Counter(answers).items():
        g = y + 1
        total += ((c + y) // g) * g
    return total

def exhaustive_cross_check():
    # Exhaust over n <= 5, values in [0,3]
    vals = [0, 1, 2, 3]
    for n in range(1, 6):
        for arr in itertools.product(vals, repeat=n):
            a = list(arr)
            s1 = solve_sorted(a)
            s2 = solve_count(a)
            assert s1 == s2, (a, s1, s2)

def edge_generators():
    yield [0] * 7
    yield [3] * 4
    yield [1, 1, 1]           # partial final group for y=1
    yield [2, 2, 2, 2]        # two groups of size 3
    yield [0, 1, 1, 2, 2, 2]  # mixed

def run_tests():
    # Basic samples
    assert solve_count([1, 1, 2]) == 5
    assert solve_count([10, 10, 10]) == 11
    # Cross-check exhaustive small cases
    exhaustive_cross_check()
    # Edge generators
    for case in edge_generators():
        assert solve_sorted(case) == solve_count(case)

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from collections import Counter

class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        total = 0
        for y, c in Counter(answers).items():
            g = y + 1
            total += ((c + y) // g) * g
        return total

# Reference asserts
s = Solution()
assert s.numRabbits([1, 1, 2]) == 5
assert s.numRabbits([0, 0, 1, 1, 1]) == 6
assert s.numRabbits([10, 10, 10]) == 11
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Group identical reports $y$ into classes of size $y+1$; sum class sizes using a ceiling.}
\WHY{A classic frequency-to-groups packing problem; tests reasoning about ceilings, grouping, and minimality proofs.}
\CHECKLIST{
- Count frequencies $f_y$. 
- For each $y$, compute groups $=(f_y+y)//(y+1)$.
- Accumulate groups $\times (y+1)$.
- Double-check $y=0$ handling.
}
\EDGECASES{
- All zeros. 
- Single element. 
- Many identical large $y$. 
- Mixed where last group is partially filled. 
- Alternating values. 
- Max length $n=1000$.
}
\PITFALLS{
- Forgetting to round up groups for partial final group. 
- Off-by-one when consuming $y$ more rabbits after the first. 
- Misinterpreting $y$ as total group size instead of $y+1$. 
- Overflow not an issue in Python but be wary in other languages. 
- Assuming colors are limited by the number of reports rather than group ceilings. 
- Not accounting that some rabbits may not appear in \texttt{answers}.
}
\FAILMODES{A naive ``sum of $y+1$ for each reporter'' overcounts; conversely, packing all same $y$ into a single group undercounts when $f_y > y+1$. The ceiling-based grouping avoids both errors.}
\ELI{Each rabbit who says $y$ belongs to a color group of size $y+1$. You can seat at most $y+1$ such reporters per group, so you need enough groups to seat everyone, rounding up. Add the sizes of those groups to get the minimum total rabbits.}
\NotePages{3}

\end{document}