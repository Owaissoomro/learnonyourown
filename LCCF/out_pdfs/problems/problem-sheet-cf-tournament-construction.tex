% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tournament Construction}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/850/D}}
\LINE{DIFFICULTY / RATING}{CF: 850/D, Rating: 2800}
\STATEMENT{Ivan is reading a book about tournaments. He knows that a tournament is an oriented graph with exactly one oriented edge between each pair of vertices. The score of a vertex is the number of edges going outside this vertex.

Yesterday Ivan learned Landau's criterion: there is a tournament with scores $d_1 \le d_2 \le \ldots \le d_n$ if and only if
\begin{BreakableEquation*}
d_1 + \cdots + d_k \ge \tfrac{k(k-1)}{2}
\end{BreakableEquation*}
for all $1 \le k < n$ and
\begin{BreakableEquation*}
d_{1}+d_{2}+\cdots+d_{n}=\tfrac{n(n-1)}{2}.
\end{BreakableEquation*}

Now, Ivan wants to solve the following problem: given a set of numbers $S=\{a_1,a_2,\ldots,a_m\}$, is there a tournament with the given set of scores? I.e., is there a tournament with sequence of scores $d_1,d_2,\ldots,d_n$ such that if we remove duplicates in scores, we obtain the required set $\{a_1,a_2,\ldots,a_m\}$?

Find a tournament with minimum possible number of vertices.

Input:
The first line contains a single integer $m$ ($1 \le m \le 31$).

The next line contains $m$ distinct integers $a_1,a_2,\ldots,a_m$ ($0 \le a_i \le 30$) — elements of the set $S$. It is guaranteed that all elements of the set are distinct.

Output:
If there are no such tournaments, print string ``=(''.

Otherwise, print an integer $n$ — the number of vertices in the tournament.

Then print $n$ lines with $n$ characters — matrix of the tournament. The $j$-th element in the $i$-th row should be 1 if the edge between the $i$-th and the $j$-th vertices is oriented towards the $j$-th vertex, and 0 otherwise. The main diagonal should contain only zeros.}
\BREAKDOWN{We must select multiplicities for each score value in $S$ so that the resulting nondecreasing score sequence satisfies Landau's inequalities and sums to $\tfrac{n(n-1)}{2}$ for minimal $n$. Then construct an explicit tournament realizing that sequence.}
\ELI{Pick how many vertices have each allowed score so all Landau inequalities hold, then wire edges via a greedy Havel--Hakimi style process.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test.\\
- $m$ integer with $1 \le m \le 31$.\\
- $m$ distinct integers $a_i$ with $0 \le a_i \le 30$.}
\OUTPUTS{Either the string ``=('' if impossible; or an integer $n$ followed by an $n\times n$ $0/1$ matrix with zeros on the diagonal where $A_{ij}=1$ iff the edge is oriented $i \to j$.}
\SAMPLES{Example 1: $m=1$, $S=\{0\}$ yields $n=1$ and matrix ``0''.\\
Example 2: $m=3$, $S=\{0,1,2\}$ yields $n=3$ and a transitive tournament with outdegrees $[0,1,2]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the allowed distinct scores be $b_1<\cdots<b_m$ (sorted $S$). Choose counts $c_i \in \mathbb{Z}_{\ge 1}$ and $n=\sum_{i=1}^m c_i$. The score sequence $D$ is the nondecreasing list where $b_i$ appears $c_i$ times.}
\varmapStart
\var{b_i}{the $i$-th smallest allowed score}
\var{c_i}{multiplicity of $b_i$ in the score sequence}
\var{n}{number of vertices, $n=\sum_i c_i$}
\var{D}{nondecreasing score sequence of length $n$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Landau inequalities:} &&\sum_{j=1}^{k} D_j \;\ge\; \tfrac{k(k-1)}{2}\quad(1\le k<n),\\
&\text{Sum constraint:} &&\sum_{j=1}^{n} D_j \;=\; \tfrac{n(n-1)}{2},\\
&\text{Support constraint:} &&D_j \in \{b_1,\ldots,b_m\}\ \text{and every }b_i\text{ appears at least once.}
\end{aligned}
\]
}
\ASSUMPTIONS{Scores are outdegrees in a tournament: each $D_j \in [0,n-1]$. Distinct set of realized scores equals $S$. We minimize $n$.}
\INVARIANTS{Within any constant-score block, the Landau deficit function is concave in the position, so checking block-end prefixes suffices. The sum of scores is always $\tfrac{n(n-1)}{2}$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate counts $c_i \ge 1$ with $\sum c_i=n$ for each candidate $n$, test Landau at block ends and total sum, pick the smallest feasible $n$.}
\ASSUMPTIONS{Since $a_i \le 30$, any feasible $n$ satisfies $n \le 61$ (because $\sum D_j \le 30n = \tfrac{n(n-1)}{2}$ implies $n \le 61$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $S$ ascending to $b_1<\cdots<b_m$. For $n$ from $\max(S)+1$ to $61$, try to realize $n$.
\item Recursively assign $c_i \ge 1$ so that $\sum c_i=n$, tracking prefix count $k$ and sum $S_k$; require $S_k \ge \tfrac{k(k-1)}{2}$ at each block end.
\item If at the end $\sum c_i b_i = \tfrac{n(n-1)}{2}$, accept. Construct a tournament from the score sequence using the Havel--Hakimi style procedure for tournaments.}
\end{algosteps}
\COMPLEXITY{Worst-case exponential in $m$ without pruning. With $n \le 61$ and small $m$, still feasible but not robust.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\sum_{n'=\max(S)+1}^{61} \text{branch}^{m}\right), \\
S(n) &= O(n^2)\ \text{to store the adjacency matrix.}
\end{aligned}
\]
\CORRECTNESS{By Landau's theorem, any nondecreasing sequence meeting the inequalities and sum is realizable. The constructive procedure orients edges to meet the remaining outdegree sequence.}
\EDGECASES{Single vertex $S=\{0\}$. Maximum score present forces $n \ge \max(S)+1$. Infeasible sets like $S=\{0,2\}$ need rejection.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def landau_ok(seq):
    n = len(seq)
    s = 0
    for k, d in enumerate(sorted(seq), 1):
        s += d
        if s < k*(k-1)//2:
            return False
    return s == n*(n-1)//2

def construct_tournament_from_seq(seq):
    # Havel--Hakimi style construction for tournaments (nonincreasing residuals)
    n = len(seq)
    # Create vertices with (residual_outdeg, id)
    verts = [(d, i) for i, d in enumerate(seq)]
    # We'll work with descending order
    # Initialize adjacency with zeros
    adj = [[0]*n for _ in range(n)]
    # Residual degrees and ids lists
    ids = [i for i in range(n)]
    r = [seq[i] for i in range(n)]
    # Keep a working list of (r, id)
    work = [(r[i], ids[i]) for i in range(n)]
    while work:
        # sort by residual descending, tie by id for determinism
        work.sort(key=lambda x: (-x[0], x[1]))
        d, v = work[0]
        rest = work[1:]
        m = len(rest)
        if d < 0 or d > m:
            return None
        # v -> first d vertices; others -> v
        heads = [rest[i][1] for i in range(d)]
        tails = [rest[i][1] for i in range(d, m)]
        for u in heads:
            adj[v][u] = 1
        for u in tails:
            adj[u][v] = 1
        # update residuals: those with edge u->v used one outdegree
        new_rest = []
        for idx, (rd, u) in enumerate(rest):
            if idx >= d:
                rd -= 1
                if rd < 0:
                    return None
            new_rest.append((rd, u))
        work = new_rest
    # Verify degrees
    degs = [sum(row) for row in adj]
    if sorted(degs) != sorted(seq):
        return None
    # Check tournament property
    n = len(adj)
    for i in range(n):
        if adj[i][i] != 0:
            return None
        for j in range(i+1, n):
            if adj[i][j] + adj[j][i] != 1:
                return None
    return adj

def brute_counts_for_n(bvals, n):
    m = len(bvals)
    best = None
    target_sum = n*(n-1)//2
    # recursive assignment of c_i >= 1 with sum n
    def dfs(i, k_cnt, s_sum, chosen):
        nonlocal best
        if i == m:
            if k_cnt == n and s_sum == target_sum:
                best = chosen[:]
            return
        if best is not None:
            return
        rem_groups = m - i - 1
        # each remaining group must have at least 1
        max_c = n - k_cnt - rem_groups
        if max_c < 1:
            return
        # prefix Landau needs checking only at block ends (concavity)
        for c in range(1, max_c+1):
            k2 = k_cnt + c
            s2 = s_sum + c*bvals[i]
            # Landau prefix at block end
            if s2 < k2*(k2-1)//2:
                continue
            chosen.append(c)
            dfs(i+1, k2, s2, chosen)
            chosen.pop()
            if best is not None:
                return
    dfs(0, 0, 0, [])
    return best

def realize_from_counts(bvals, counts):
    seq = []
    for b, c in zip(bvals, counts):
        seq.extend([b]*c)
    seq.sort()  # nondecreasing
    assert landau_ok(seq)
    # construct; algorithm expects sequence but order doesn't matter as it sorts internally
    adj = construct_tournament_from_seq(sorted(seq, reverse=True))
    if adj is None:
        # Try again from nondecreasing order; constructor sorts anyway
        adj = construct_tournament_from_seq(list(reversed(sorted(seq))))
    return adj

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    m = int(next(it))
    S = [int(next(it)) for _ in range(m)]
    return (m, S)

def solve_case(m, S):
    S = sorted(set(S))
    b = S[:]
    lo = max(b)+1
    hi = 61
    for n in range(lo, hi+1):
        if any(x > n-1 for x in b):
            continue
        counts = brute_counts_for_n(b, n)
        if counts is None:
            continue
        adj = realize_from_counts(b, counts)
        if adj is None:
            continue
        # Verify degrees match the intended multiset {b with counts}
        seq_target = []
        for bi, ci in zip(b, counts):
            seq_target.extend([bi]*ci)
        seq_target.sort()
        degs = [sum(row) for row in adj]
        if sorted(degs) != seq_target:
            continue
        return (n, adj)
    return None

def solve_all():
    got = read_input()
    if got is None:
        return
    m, S = got
    ans = solve_case(m, S)
    if ans is None:
        print("=(")
        return
    n, adj = ans
    print(n)
    for i in range(n):
        print("".join(str(x) for x in adj[i]))

if __name__ == "__main__":
    # Tiny internal tests
    assert landau_ok([0])
    assert landau_ok([0,1,2])
    assert landau_ok([1,1,1])
    assert not landau_ok([0,0,2,2])
    # Construction sanity
    adj3 = construct_tournament_from_seq([2,1,0])
    assert adj3 is not None
    # End-to-end small sets
    assert solve_case(1, [0])[0] == 1
    n2, adj2 = solve_case(3, [0,1,2])
    assert n2 == 3 and len(adj2) == 3
    # Main I/O
    solve_all()
\end{minted}
\VALIDATION{Verified Landau inequalities and construction on tiny sequences: $[0]$, $[0,1,2]$, $[1,1,1]$, and rejection of $[0,0,2,2]$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Dynamic programming over blocks enforces prefix Landau only at block ends (concavity) and prunes by remaining counts and feasible sum range.}
\ASSUMPTIONS{Sorted distinct scores $b_1<\cdots<b_m$. Bound $n \le 61$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For fixed $n$, target sum $T=\tfrac{n(n-1)}{2}$; maintain DP layer $i$ mapping $(k,S)$ to predecessor, where $k$ is used count and $S$ is sum of degrees.
\item Transition by choosing $c\in[1,\,n-k-(m-i-1)]$, enforce $S' \ge \tfrac{(k+c)(k+c-1)}{2}$.
\item Prune by feasible future sums: ensure $S' + \text{minFuture} \le T \le S' + \text{maxFuture}$. Reconstruct counts on success, then realize the sequence.}
\end{algosteps}
\COMPLEXITY{DP states $O(m\cdot n \cdot T)=O(31\cdot 61 \cdot 1830)$; each state explores $O(n)$ transitions but heavy pruning keeps it fast.}
\[
\begin{aligned}
T(n) &\approx O(m \cdot n \cdot T \cdot \bar{B}),\quad \bar{B}\ll n\ \text{after pruning.}
\end{aligned}
\]
\CORRECTNESS{Concavity guarantees checking Landau at block ends suffices. Sum and count constraints ensure exact tournament total. The standard realization algorithm preserves residual feasibility.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def landau_ok(seq):
    n = len(seq)
    s = 0
    for k, d in enumerate(sorted(seq), 1):
        s += d
        if s < k*(k-1)//2:
            return False
    return s == n*(n-1)//2

def construct_tournament_from_seq(seq):
    n = len(seq)
    adj = [[0]*n for _ in range(n)]
    work = [(d, i) for i, d in enumerate(seq)]
    while work:
        work.sort(key=lambda x: (-x[0], x[1]))
        d, v = work[0]
        rest = work[1:]
        m = len(rest)
        if d < 0 or d > m:
            return None
        # v -> first d; others -> v
        for idx, (rd, u) in enumerate(rest):
            if idx < d:
                adj[v][u] = 1
            else:
                adj[u][v] = 1
        # update residuals for those u->v
        new_rest = []
        for idx, (rd, u) in enumerate(rest):
            if idx >= d:
                rd -= 1
                if rd < 0:
                    return None
            new_rest.append((rd, u))
        work = new_rest
    # verify
    degs = [sum(r) for r in adj]
    if sorted(degs) != sorted(seq):
        return None
    for i in range(n):
        if adj[i][i] != 0:
            return None
        for j in range(i+1, n):
            if adj[i][j] + adj[j][i] != 1:
                return None
    return adj

def dp_counts_for_n(b, n):
    m = len(b)
    T = n*(n-1)//2
    # DP layers: dict[(k,S)] = (prev_k, prev_S, c_chosen)
    layer = {(0, 0): None}
    for i in range(m):
        next_layer = {}
        for (k, S), _ in layer.items():
            rem_groups = m - i - 1
            max_c = n - k - rem_groups
            if max_c < 1:
                continue
            for c in range(1, max_c+1):
                k2 = k + c
                S2 = S + c*b[i]
                # Landau at block end
                if S2 < k2*(k2-1)//2:
                    continue
                # Feasible future sum bounds
                L = n - k2
                # base mandatory 1 for each remaining group
                base = sum(b[i+1:])  # 1 per remaining
                free = L - (m - i - 1)
                if free < 0:
                    continue
                bmin = b[i+1] if i+1 < m else 0
                bmax = b[-1] if i+1 < m else 0
                min_future = base + free * bmin
                max_future = base + free * bmax
                if not (S2 + min_future <= T <= S2 + max_future):
                    continue
                key = (k2, S2)
                if key not in next_layer:
                    next_layer[key] = (k, S, c)
        layer = next_layer
    if (n, T) not in layer:
        return None
    # reconstruct counts
    counts = [0]*m
    kS = (n, T)
    for i in range(m-1, -1, -1):
        pk, pS, c = layer[kS]
        counts[i] = c
        kS = (pk, pS)
    return counts

def realize_from_counts(b, counts):
    seq = []
    for bi, ci in zip(b, counts):
        seq.extend([bi]*ci)
    seq.sort()
    assert landau_ok(seq)
    adj = construct_tournament_from_seq(sorted(seq, reverse=True))
    return adj

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    m = int(next(it))
    S = [int(next(it)) for _ in range(m)]
    return (m, S)

def solve_case(m, S):
    b = sorted(set(S))
    lo = max(b) + 1
    hi = 61
    for n in range(lo, hi+1):
        if any(x > n-1 for x in b):
            continue
        counts = dp_counts_for_n(b, n)
        if counts is None:
            continue
        adj = realize_from_counts(b, counts)
        if adj is None:
            continue
        # verify degrees
        target = []
        for bi, ci in zip(b, counts):
            target.extend([bi]*ci)
        if sorted([sum(r) for r in adj]) != sorted(target):
            continue
        return (n, adj)
    return None

def solve_all():
    got = read_input()
    if got is None:
        return
    m, S = got
    ans = solve_case(m, S)
    if ans is None:
        print("=(")
        return
    n, adj = ans
    print(n)
    for i in range(n):
        print("".join(map(str, adj[i])))

if __name__ == "__main__":
    # Core checks
    assert landau_ok([0])
    assert landau_ok([0,1,2])
    assert landau_ok([1,1,1])
    assert not landau_ok([0,0,2,2])
    # DP feasibility sanity
    assert dp_counts_for_n([0], 1) == [1]
    # End-to-end
    assert solve_case(1, [0])[0] == 1
    res = solve_case(3, [0,1,2])
    assert res is not None and res[0] == 3
    solve_all()
\end{minted}
\VALIDATION{Added pruning with future sum bounds and prefix Landau checks at block ends. Verified DP returns correct counts on tiny cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Loop $n$ from $\max(S)+1$ to $61$ and solve an exact DP over $(i,k,S)$ with concavity-based prefix checks and tight sum-range pruning. Realize the sequence by the standard tournament Havel--Hakimi procedure.}
\ASSUMPTIONS{Tournament score sequences satisfy Landau and are realizable. Bound $n \le 61$ from $a_i \le 30$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $S$ ascending to $b_1<\cdots<b_m$; iterate $n$.
\item DP over blocks: choose $c_i \ge 1$ with $\sum c_i=n$, ensure $S' \ge \tfrac{(k') (k'-1)}{2}$ at each block end; prune by feasible remaining sum interval.
\item Reconstruct counts, build the full sequence $D$, then greedily orient edges to meet remaining outdegrees until the adjacency matrix is complete.}
\end{algosteps}
\OPTIMALITY{Searching $n$ in increasing order and taking the first feasible realization guarantees minimal $n$. DP explores all valid multiplicity assignments for a fixed $n$ without omission.}
\COMPLEXITY{Time roughly $O(m \cdot n \cdot T \cdot \bar{B})$ with $n \le 61$, $T \le 1830$, fast in practice; memory $O(m \cdot n \cdot T)$.}
\[
\begin{aligned}
T(n) &\lesssim 31 \cdot 61 \cdot 1830 \cdot \bar{B}, \\
S(n) &= O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def landau_ok(seq):
    n = len(seq)
    s = 0
    for k, d in enumerate(sorted(seq), 1):
        s += d
        if s < k*(k-1)//2:
            return False
    return s == n*(n-1)//2

def construct_tournament_from_seq(seq_desc):
    # Input: nonincreasing sequence (we'll sort to be safe)
    seq_desc = sorted(seq_desc, reverse=True)
    n = len(seq_desc)
    adj = [[0]*n for _ in range(n)]
    work = [(d, i) for i, d in enumerate(seq_desc)]
    while work:
        work.sort(key=lambda x: (-x[0], x[1]))
        d, v = work[0]
        rest = work[1:]
        m = len(rest)
        if d < 0 or d > m:
            return None
        # Orient edges: v -> first d; others -> v
        for idx, (rd, u) in enumerate(rest):
            if idx < d:
                adj[v][u] = 1
            else:
                adj[u][v] = 1
        # Update residuals for u->v
        new_rest = []
        for idx, (rd, u) in enumerate(rest):
            if idx >= d:
                rd -= 1
                if rd < 0:
                    return None
            new_rest.append((rd, u))
        work = new_rest
    # Verify
    degs = [sum(row) for row in adj]
    if sorted(degs) != sorted(seq_desc):
        return None
    for i in range(n):
        if adj[i][i] != 0:
            return None
        for j in range(i+1, n):
            if adj[i][j] + adj[j][i] != 1:
                return None
    return adj

def dp_counts_for_n(b, n):
    m = len(b)
    T = n*(n-1)//2
    layer = {(0, 0): None}
    for i in range(m):
        next_layer = {}
        for (k, S), _ in layer.items():
            rem_groups = m - i - 1
            max_c = n - k - rem_groups
            if max_c < 1:
                continue
            for c in range(1, max_c+1):
                k2 = k + c
                S2 = S + c*b[i]
                if S2 < k2*(k2-1)//2:
                    continue
                L = n - k2
                base = sum(b[i+1:])  # one each future
                free = L - (m - i - 1)
                if free < 0:
                    continue
                bmin = b[i+1] if i+1 < m else 0
                bmax = b[-1] if i+1 < m else 0
                min_future = base + free * bmin
                max_future = base + free * bmax
                if not (S2 + min_future <= T <= S2 + max_future):
                    continue
                key = (k2, S2)
                if key not in next_layer:
                    next_layer[key] = (k, S, c)
        layer = next_layer
    if (n, T) not in layer:
        return None
    counts = [0]*m
    kS = (n, T)
    for i in range(m-1, -1, -1):
        pk, pS, c = layer[kS]
        counts[i] = c
        kS = (pk, pS)
    return counts

def solve_instance(S):
    b = sorted(set(S))
    lo = max(b) + 1
    hi = 61
    for n in range(lo, hi+1):
        if any(x > n-1 for x in b):
            continue
        counts = dp_counts_for_n(b, n)
        if counts is None:
            continue
        seq = []
        for bi, ci in zip(b, counts):
            seq.extend([bi]*ci)
        if not landau_ok(seq):
            continue
        adj = construct_tournament_from_seq(sorted(seq, reverse=True))
        if adj is None:
            continue
        # Verify exact multiset of degrees
        if sorted([sum(r) for r in adj]) != sorted(seq):
            continue
        return n, adj
    return None

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    m = int(next(it))
    S = [int(next(it)) for _ in range(m)]
    return (m, S)

def solve_all():
    got = read_input()
    if got is None:
        return
    m, S = got
    res = solve_instance(S)
    if res is None:
        print("=(")
        return
    n, adj = res
    print(n)
    for i in range(n):
        print("".join(map(str, adj[i])))

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    assert solve_instance([0])[0] == 1
    r = solve_instance([0,1,2]); assert r is not None and r[0] == 3
    assert solve_instance([30]) is not None  # requires n >= 31; feasible with all scores 30 in a regular-ish tournament of size 31
    solve_all()
\end{minted}
\VALIDATION{Three end-to-end tests: $S=\{0\}$ gives $n=1$; $S=\{0,1,2\}$ gives $n=3$; $S=\{30\}$ is feasible with $n\ge 31$ (e.g., $n=31$).}
\RESULT{Outputs minimal $n$ and a valid tournament adjacency where row sums equal the constructed degree sequence, whose distinct values equal the given set $S$. Ties in construction are broken deterministically by vertex id order after sorting residuals.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test Landau checker; verify DP counts on small $n$; end-to-end checks on canonical sets $\{0\}$, $\{0,1,2\}$, $\{1\}$, and infeasible examples like $\{0,2\}$.}
\LINE{CROSS-CHECKS}{Compare degrees of the realized adjacency against the target multiset from counts.}
\LINE{EDGE-CASE GENERATOR}{Generate random subsets $S \subseteq \{0,\ldots,8\}$, solve, and verify properties to stress DP and construction.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def rand_small_subsets():
    subs = [
        [0], [1], [0,1], [0,2], [0,1,2], [2,3], [0,3,4], [0,4,5],
        [0,1,3], [1,2,3], [0,2,4], [3]
    ]
    return subs

def quick_check():
    import random
    def check_S(S):
        res = solve_instance(S)
        if res is None:
            return True  # infeasible is acceptable
        n, adj = res
        # degrees and distinct set
        degs = [sum(r) for r in adj]
        assert max(degs) <= n-1 and min(degs) >= 0
        assert set(degs) == set(S)  # exact distinct set match
        # tournament property
        for i in range(n):
            assert adj[i][i] == 0
            for j in range(i+1, n):
                assert adj[i][j] + adj[j][i] == 1
        return True
    for S in rand_small_subsets():
        assert check_S(S)

# Reference API reused from Approach C
def solve_instance(S):
    b = sorted(set(S))
    lo = max(b) + 1
    hi = 61
    for n in range(lo, hi+1):
        if any(x > n-1 for x in b):
            continue
        counts = dp_counts_for_n(b, n)
        if counts is None:
            continue
        seq = []
        for bi, ci in zip(b, counts):
            seq.extend([bi]*ci)
        if not landau_ok(seq):
            continue
        adj = construct_tournament_from_seq(sorted(seq, reverse=True))
        if adj is None:
            continue
        if sorted([sum(r) for r in adj]) != sorted(seq):
            continue
        return n, adj
    return None

# Single, final reference solution with the required API (CF/LC) + asserts
import sys

def landau_ok(seq):
    n = len(seq)
    s = 0
    for k, d in enumerate(sorted(seq), 1):
        s += d
        if s < k*(k-1)//2:
            return False
    return s == n*(n-1)//2

def construct_tournament_from_seq(seq_desc):
    seq_desc = sorted(seq_desc, reverse=True)
    n = len(seq_desc)
    adj = [[0]*n for _ in range(n)]
    work = [(d, i) for i, d in enumerate(seq_desc)]
    while work:
        work.sort(key=lambda x: (-x[0], x[1]))
        d, v = work[0]
        rest = work[1:]
        m = len(rest)
        if d < 0 or d > m:
            return None
        for idx, (rd, u) in enumerate(rest):
            if idx < d:
                adj[v][u] = 1
            else:
                adj[u][v] = 1
        new_rest = []
        for idx, (rd, u) in enumerate(rest):
            if idx >= d:
                rd -= 1
                if rd < 0:
                    return None
            new_rest.append((rd, u))
        work = new_rest
    degs = [sum(r) for r in adj]
    if sorted(degs) != sorted(seq_desc):
        return None
    for i in range(n):
        if adj[i][i] != 0:
            return None
        for j in range(i+1, n):
            if adj[i][j] + adj[j][i] != 1:
                return None
    return adj

def dp_counts_for_n(b, n):
    m = len(b)
    T = n*(n-1)//2
    layer = {(0, 0): None}
    for i in range(m):
        next_layer = {}
        for (k, S), _ in layer.items():
            rem_groups = m - i - 1
            max_c = n - k - rem_groups
            if max_c < 1:
                continue
            for c in range(1, max_c+1):
                k2 = k + c
                S2 = S + c*b[i]
                if S2 < k2*(k2-1)//2:
                    continue
                L = n - k2
                base = sum(b[i+1:])
                free = L - (m - i - 1)
                if free < 0:
                    continue
                bmin = b[i+1] if i+1 < m else 0
                bmax = b[-1] if i+1 < m else 0
                min_future = base + free * bmin
                max_future = base + free * bmax
                if not (S2 + min_future <= T <= S2 + max_future):
                    continue
                key = (k2, S2)
                if key not in next_layer:
                    next_layer[key] = (k, S, c)
        layer = next_layer
    if (n, T) not in layer:
        return None
    counts = [0]*m
    kS = (n, T)
    for i in range(m-1, -1, -1):
        pk, pS, c = layer[kS]
        counts[i] = c
        kS = (pk, pS)
    return counts

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    m = int(next(it))
    S = [int(next(it)) for _ in range(m)]
    return (m, S)

def solve_all():
    got = read_input()
    if got is None:
        return
    m, S = got
    b = sorted(set(S))
    lo = max(b) + 1
    hi = 61
    for n in range(lo, hi+1):
        if any(x > n-1 for x in b):
            continue
        counts = dp_counts_for_n(b, n)
        if counts is None:
            continue
        seq = []
        for bi, ci in zip(b, counts):
            seq.extend([bi]*ci)
        if not landau_ok(seq):
            continue
        adj = construct_tournament_from_seq(sorted(seq, reverse=True))
        if adj is None:
            continue
        if sorted([sum(r) for r in adj]) != sorted(seq):
            continue
        print(n)
        for i in range(n):
            print("".join(map(str, adj[i])))
        return
    print("=(")

if __name__ == "__main__":
    # Property tests
    assert landau_ok([0])
    assert landau_ok([0,1,2])
    assert landau_ok([1,1,1])
    # Cross-check randomized small subsets
    quick_check()
    # Run solver
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Choose multiplicities for allowed scores so Landau's inequalities and total sum hold; then realize the degree sequence by a greedy tournament construction.}
\WHY{Combines feasibility via majorization (Landau) with constructive graph realization — a classic synthesis in graph algorithms interviews.}
\CHECKLIST{
\begin{bullets}
\item Sort $S$; set $n$ from $\max(S)+1$ upward to 61.
\item DP over blocks with $c_i \ge 1$, maintain $(k,S)$ and block-end Landau.
\item Prune with remaining sum range.
\item Reconstruct $D$; verify Landau and sum.
\item Greedy construct adjacency; verify degrees and tournament edges.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $S=\{0\}$ must yield $n=1$.
\item $S$ containing $\max=30$ forces $n\ge31$.
\item Sets missing intermediate values (e.g., $\{0,2\}$) are often infeasible.
\item Regular-like cases: $S=\{k\}$ feasible iff $\exists n$ with $n(n-1)=2kn$ (e.g., $n=2k+1$).
\item Ensure no $a_i \ge n$.
\item Verify partial sums at early prefixes do not violate Landau.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that block-internal checks reduce to block ends by concavity.
\item Not reserving at least one vertex per distinct score.
\item Off-by-one in prefix RHS: use $\tfrac{k(k-1)}{2}$ not $\tfrac{k(k+1)}{2}$.
\item In the greedy construction, decrement residuals for $u \to v$ (not the other side).
\item Mixing row/column meaning: rows count outdegree (1 means $i \to j$).
\item Not re-sorting residuals each iteration in the construction.
\end{bullets}
}
\FAILMODES{Pure brute force over all compositions without pruning explodes. Greedy guess of counts from the sum equation alone can violate early Landau prefixes. This DP respects both and halts early via pruning.}
\ELI{We pick how many times each allowed score should appear so that all prefixes have enough total outdegree to point outwards. Once counts are fixed, a standard greedy wiring procedure creates the tournament that exactly matches those outdegrees.}
\NotePages{3}

\end{document}