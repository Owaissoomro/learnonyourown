% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Alphabetic Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1608/G}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{You are given $m$ strings and a tree on $n$ nodes. Each edge has some letter written on it.

You have to answer $q$ queries. Each query is described by $4$ integers $u$, $v$, $l$ and $r$. The answer to the query is the total number of occurrences of $str(u,v)$ in strings with indices from $l$ to $r$. $str(u,v)$ is defined as the string that is made by concatenating letters written on the edges on the shortest path from $u$ to $v$ (in order that they are traversed).

Input:
The first line of the input contains three integers $n$, $m$ and $q$ ($2 \le n \le 10^5$, $1 \le m,q \le 10^5$).

The $i$-th of the following $n-1$ lines contains two integers $u_i, v_i$ and a lowercase Latin letter $c_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$), denoting the edge between nodes $u_i, v_i$ with a character $c_i$ on it.

It is guaranteed that these edges form a tree.

The following $m$ lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed $10^5$.

Then $q$ lines follow, each containing four integers $u$, $v$, $l$ and $r$ ($1 \le u,v \le n$, $u \ne v$, $1 \le l \le r \le m$), denoting the queries.

Output:
For each query print a single integer — the answer to the query.}
\BREAKDOWN{Map each tree path $(u,v)$ to its path string, then count (overlapping) occurrences across a subarray $[l,r]$ of dictionary strings. The challenge is fast path extraction and massive range counting.}
\ELI{Take the letters along the unique path from $u$ to $v$ and count how many times that word appears in some chosen strings.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ nodes, $m$ strings, $q$ queries.
\item $n-1$ edges: $u_i, v_i, c_i$ with lowercase $c_i$.
\item $m$ strings (lowercase).
\item $q$ queries $u, v, l, r$ asking for total overlapping occurrences of $str(u,v)$ in strings $l,\ldots,r$.
\end{bullets}}
\OUTPUTS{For each query, one integer on its own line — the total number of occurrences.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
4 3 2
1 2 a
2 3 b
3 4 a
aba
bac
abacaba
1 4 1 1
1 4 1 3
\end{verbatim}
Output
\begin{verbatim}
1
3
\end{verbatim}
Explanation: $str(1,4)=\text{``aba''}$ appears once in string 1 and three times in strings 1..3 total. The occurrences in ``abacaba'' are overlapping (positions 1..3 and 5..7).
\end{tcolorbox}

Example 2:
\begin{tcolorbox}
Input
\begin{verbatim}
2 2 2
1 2 z
z
zz
1 2 1 1
1 2 1 2
\end{verbatim}
Output
\begin{verbatim}
1
3
\end{verbatim}
Explanation: $str(1,2)=\text{``z''}$ occurs once in ``z'' and three times in ``zz'' with overlaps (positions 1 and 2).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree with edge labeling $\lambda:E\to\Sigma$ over lowercase alphabet $\Sigma$. For $u,v\in V$, the unique path $P(u,v)$ induces the word $w(u,v)$ by concatenating the labels along $P(u,v)$ in traversal order. Let the dictionary be $\{S_i\}_{i=1}^m$. For a query $(u,v,l,r)$ output
\begin{BreakableEquation*}
\mathrm{Ans}(u,v,l,r)=\sum_{i=l}^{r}\mathrm{occ}\big(S_i,\,w(u,v)\big),
\end{BreakableEquation*}
where $\mathrm{occ}(X,P)$ counts overlapping occurrences of pattern $P$ in text $X$.}
\varmapStart
\var{T}{given labeled tree}
\var{w(u,v)}{path word from $u$ to $v$}
\var{S_i}{dictionary strings}
\var{\mathrm{occ}(X,P)}{overlapping occurrence count of $P$ in $X$}
\var{q}{number of queries}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\mathrm{occ}(X,P)=\left|\{\,j\in[1,|X|-|P|+1]\ :\ X[j..j+|P|-1]=P\,\}\right|.
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item $T$ is a connected acyclic graph (tree), so $P(u,v)$ is unique.
\item Letters on edges are direction-agnostic; traversal order defines $w(u,v)$.
\item Overlapping matches are counted.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item For any fixed root, $w(u,v)=w(u,\mathrm{lca}(u,v)) \cdot \mathrm{rev}\big(w(v,\mathrm{lca}(u,v))\big)$ where $w(x,a)$ is the upward edge-label sequence.
\item $|w(u,v)|=\mathrm{dist}(u,v)$, the number of edges on $P(u,v)$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly extract $w(u,v)$ by climbing parent pointers to the LCA, then scan each $S_i$ for overlapping matches using naive search.}
\ASSUMPTIONS{We preprocess depth and binary-lifting parents for fast $\mathrm{lca}$, but collect characters along the path in $O(|w|)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root the tree at node $1$, compute depth, parent up-table, and the character to parent for each node.
\item For each query $(u,v,l,r)$, compute $a=\mathrm{lca}(u,v)$, gather upward characters from $u$ to $a$, and from $v$ to $a$ then reverse the latter; concatenate to form $w$.
\item For $i=l$ to $r$, count overlapping occurrences of $w$ in $S_i$ via repeated $\mathrm{find}$ advancing by $1$.
\end{algosteps}
\COMPLEXITY{Let $L=\sum_i |S_i|$ and $|w|$ be the path length.
\[
\begin{aligned}
\text{Preprocess} &:\ O(n\log n).\\
\text{Per query} &:\ O(|w| + \sum_{i=l}^{r} |S_i|).\\
\text{Worst-case total} &:\ O\big(n\log n + q\cdot(L + \overline{|w|})\big)\ \text{(too slow for limits, fine for small tests).}
\end{aligned}
\]}
\CORRECTNESS{Traversal order yields the correct path word; naive overlapping counting matches the definition by advancing start index by $1$ after each match.}
\EDGECASES{Adjacent nodes ($|w|=1$), repeated letters leading to overlaps, deep LCAs, and $l=r$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None):
    """
    Reads:
      n m q
      n-1 lines: u v c
      m lines: strings
      q lines: u v l r
    Returns a tuple (n, m, q, edges, strings, queries).
    """
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it)); q = int(next(it))
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it)); c = next(it)
        edges.append((u, v, c))
    strings = []
    for _ in range(m):
        strings.append(next(it))
    queries = []
    for _ in range(q):
        u = int(next(it)); v = int(next(it)); l = int(next(it)); r = int(next(it))
        queries.append((u, v, l, r))
    return n, m, q, edges, strings, queries

def build_lca(n: int, edges: List[Tuple[int, int, str]]):
    adj = [[] for _ in range(n + 1)]
    for u, v, c in edges:
        adj[u].append((v, c))
        adj[v].append((u, c))
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    char_to_parent = ['']*(n+1)
    # iterative DFS
    root = 1
    stack = [(root, 0, '')]
    visited = [False]*(n+1)
    visited[root] = True
    while stack:
        u, p, ch = stack.pop()
        up[0][u] = p
        char_to_parent[u] = ch
        for v, c in adj[u]:
            if v == p:
                continue
            if not visited[v]:
                visited[v] = True
                depth[v] = depth[u] + 1
                stack.append((v, u, c))
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    return adj, up, depth, char_to_parent

def lca(u: int, v: int, up: List[List[int]], depth: List[int]) -> int:
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def path_string(u: int, v: int, up: List[List[int]], depth: List[int], chpar: List[str]) -> str:
    a = lca(u, v, up, depth)
    part_u = []
    x = u
    while x != a:
        part_u.append(chpar[x])
        x = up[0][x]
    part_v = []
    y = v
    while y != a:
        part_v.append(chpar[y])
        y = up[0][y]
    part_v.reverse()
    return ''.join(part_u) + ''.join(part_v)

def count_overlaps(text: str, pat: str) -> int:
    if not pat:
        return 0
    cnt = 0
    i = 0
    while True:
        j = text.find(pat, i)
        if j == -1:
            break
        cnt += 1
        i = j + 1
    return cnt

def solve_all(n: int, m: int, q: int, edges: List[Tuple[int, int, str]], strings: List[str], queries: List[Tuple[int, int, int, int]]) -> List[int]:
    _, up, depth, chpar = build_lca(n, edges)
    ans = []
    for u, v, l, r in queries:
        pat = path_string(u, v, up, depth, chpar)
        total = 0
        for i in range(l-1, r):
            total += count_overlaps(strings[i], pat)
        ans.append(total)
    return ans

def solve_case():
    data = read_input()
    if data is None:
        return
    n, m, q, edges, strings, queries = data
    res = solve_all(n, m, q, edges, strings, queries)
    out = '\n'.join(map(str, res))
    sys.stdout.write(out)

def _self_test():
    # Small tree
    n = 4; m = 3; q = 2
    edges = [(1,2,'a'),(2,3,'b'),(3,4,'a')]
    strings = ["aba","bac","abacaba"]
    queries = [(1,4,1,1),(1,4,1,3)]
    res = solve_all(n, m, q, edges, strings, queries)
    assert res == [1, 3]
    # Path string correctness
    _, up, depth, chpar = build_lca(n, edges)
    assert path_string(1,4,up,depth,chpar) == "aba"
    assert path_string(4,1,up,depth,chpar) == "aba"
    # Overlap counting
    assert count_overlaps("aaaa", "aa") == 3
    assert count_overlaps("abc", "d") == 0

def main():
    data_stream = sys.stdin.buffer.peek(1) if hasattr(sys.stdin, "buffer") and hasattr(sys.stdin.buffer, "peek") else b''
    if not data_stream:
        _self_test()
    else:
        solve_case()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on two handcrafted queries with overlapping matches; helper asserts cover $\mathrm{lca}$-based path strings and overlap counting.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Keep $\mathrm{lca}$ in $O(1)$ with binary lifting, and still extract path in linear path length; prune counting by skipping strings shorter than $|w|$.}
\ASSUMPTIONS{Binary lifting table built once; skip any $S_i$ with $|S_i|<|w|$ since $\mathrm{occ}(S_i,w)=0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mathrm{lca}$ structures as in Approach A.
\item For each query, form $w=w(u,v)$; let $L=|w|$.
\item Sum counts only over $i\in[l,r]$ with $|S_i|\ge L$; use overlapping naive search.
\end{algosteps}
\COMPLEXITY{This trims constant factors and reduces futile scans:
\begin{BreakableEquation*}
T_{\text{query}} = O(|w| + \sum_{i=l}^{r}\max(0,|S_i|-|w|+1)).
\end{BreakableEquation*}
Still not scalable to worst-case, but better on average.}
\CORRECTNESS{Skipping short texts preserves correctness. $\mathrm{lca}$-based extraction remains valid.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None):
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it)); q = int(next(it))
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it)); c = next(it)
        edges.append((u, v, c))
    strings = [next(it) for _ in range(m)]
    queries = []
    for _ in range(q):
        u = int(next(it)); v = int(next(it)); l = int(next(it)); r = int(next(it))
        queries.append((u, v, l, r))
    return n, m, q, edges, strings, queries

def build_lca(n: int, edges: List[Tuple[int, int, str]]):
    adj = [[] for _ in range(n + 1)]
    for u, v, c in edges:
        adj[u].append((v, c))
        adj[v].append((u, c))
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    chpar = ['']*(n+1)
    root = 1
    stack = [(root, 0, '')]
    seen = [False]*(n+1)
    seen[root] = True
    while stack:
        u, p, ch = stack.pop()
        up[0][u] = p
        chpar[u] = ch
        for v, c in adj[u]:
            if v == p:
                continue
            if not seen[v]:
                seen[v] = True
                depth[v] = depth[u] + 1
                stack.append((v, u, c))
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    return up, depth, chpar

def lca(u: int, v: int, up: List[List[int]], depth: List[int]) -> int:
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def path_string(u: int, v: int, up: List[List[int]], depth: List[int], chpar: List[str]) -> str:
    a = lca(u, v, up, depth)
    part_u = []
    x = u
    while x != a:
        part_u.append(chpar[x])
        x = up[0][x]
    part_v = []
    y = v
    while y != a:
        part_v.append(chpar[y])
        y = up[0][y]
    part_v.reverse()
    return ''.join(part_u) + ''.join(part_v)

def count_overlaps(text: str, pat: str) -> int:
    if not pat:
        return 0
    if len(text) < len(pat):
        return 0
    cnt = 0; i = 0
    while True:
        j = text.find(pat, i)
        if j == -1:
            break
        cnt += 1
        i = j + 1
    return cnt

def solve_all(n: int, m: int, q: int, edges: List[Tuple[int, int, str]], strings: List[str], queries: List[Tuple[int, int, int, int]]) -> List[int]:
    up, depth, chpar = build_lca(n, edges)
    lens = [len(s) for s in strings]
    ans = []
    for u, v, l, r in queries:
        pat = path_string(u, v, up, depth, chpar)
        L = len(pat)
        total = 0
        for i in range(l-1, r):
            if lens[i] >= L:
                total += count_overlaps(strings[i], pat)
        ans.append(total)
    return ans

def _self_test():
    n = 4; m = 3; q = 2
    edges = [(1,2,'a'),(2,3,'b'),(3,4,'a')]
    strings = ["aba","bac","abacaba"]
    queries = [(1,4,1,1),(1,4,1,3)]
    res = solve_all(n, m, q, edges, strings, queries)
    assert res == [1, 3]
    n2 = 2; m2 = 2; q2 = 2
    edges2 = [(1,2,'z')]
    strings2 = ["z","zz"]
    queries2 = [(1,2,1,1),(1,2,1,2)]
    res2 = solve_all(n2, m2, q2, edges2, strings2, queries2)
    assert res2 == [1, 3]

def solve_case():
    data = read_input()
    if data is None:
        return
    n, m, q, edges, strings, queries = data
    res = solve_all(n, m, q, edges, strings, queries)
    print('\n'.join(map(str, res)))

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        sys.stdin = sys.__stdin__
        print(end='')  # ensure clean buffer
        n, m, q, edges, strings, queries = read_input(data)
        res = solve_all(n, m, q, edges, strings, queries)
        print('\n'.join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Same asserts as baseline and additional tiny case for pruning; handles overlapping matches.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{High-level: build a suffix automaton (SAM) over the concatenation of all $S_i$ with separators, plus the suffix-link tree. Reduce range queries to dynamic activations of end positions by string ID using a Fenwick tree over an Euler tour of the SAM tree. Decompose $w(u,v)$ as $A \cdot B$ with $A$ from $u\to\mathrm{lca}$ and $B$ from $\mathrm{lca}\to v$; track automaton states for both directions via two SAMs (forward and reversed) and combine counts with offline inclusion-exclusion over $[l,r]$.}
\ASSUMPTIONS{Offline processing: sort events by $r$ and subtract prefix up to $l-1$. HLD on the tree provides $O(\log n)$ updates while moving between query endpoints if needed; alternatively process all queries independently but reuse automaton states.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build SAM over $S_1\#S_2\#\cdots\#S_m\$ $; compute Euler tour order on suffix-link tree. For each end position, map to its SAM state and to its string ID.
\item Maintain a Fenwick tree keyed by Euler indices; sweeping the string index activates/deactivates occurrences for range prefix queries.
\item For each query, map $A$ and $B$ to SAM states (forward for $A$, reverse-SAM for reversed $B$), and compute counts via precomputed endpos aggregations; combine with an offline convolution over shared end positions along suffix-link ancestors to account for concatenation.
\end{algosteps}
\OPTIMALITY{The SAM endpos and suffix-link tree give minimal deterministic automata with linear size in total text length. Offline range addition/query reduces each query to $O(\log L)$ after linear preprocessing, achieving near-linear total time.}
\COMPLEXITY{With $L=\sum |S_i|$ and $Q=q$:
\begin{BreakableEquation*}
T \approx O(L) \text{ to build} + O(Q\log L)\ \text{to answer},\quad S=O(L).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None):
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it)); q = int(next(it))
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it)); c = next(it)
        edges.append((u, v, c))
    strings = [next(it) for _ in range(m)]
    queries = []
    for _ in range(q):
        u = int(next(it)); v = int(next(it)); l = int(next(it)); r = int(next(it))
        queries.append((u, v, l, r))
    return n, m, q, edges, strings, queries

def build_lca(n: int, edges: List[Tuple[int, int, str]]):
    adj = [[] for _ in range(n + 1)]
    for u, v, c in edges:
        adj[u].append((v, c))
        adj[v].append((u, c))
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    chpar = ['']*(n+1)
    root = 1
    stack = [(root, 0, '')]
    seen = [False]*(n+1)
    seen[root] = True
    while stack:
        u, p, ch = stack.pop()
        up[0][u] = p
        chpar[u] = ch
        for v, c in adj[u]:
            if v == p:
                continue
            if not seen[v]:
                seen[v] = True
                depth[v] = depth[u] + 1
                stack.append((v, u, c))
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    return up, depth, chpar

def lca(u: int, v: int, up: List[List[int]], depth: List[int]) -> int:
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def path_string(u: int, v: int, up: List[List[int]], depth: List[int], chpar: List[str]) -> str:
    a = lca(u, v, up, depth)
    pu = []
    x = u
    while x != a:
        pu.append(chpar[x])
        x = up[0][x]
    pv = []
    y = v
    while y != a:
        pv.append(chpar[y])
        y = up[0][y]
    pv.reverse()
    return ''.join(pu) + ''.join(pv)

def count_overlaps(text: str, pat: str) -> int:
    if not pat:
        return 0
    if len(text) < len(pat):
        return 0
    cnt = 0; i = 0
    while True:
        j = text.find(pat, i)
        if j == -1:
            break
        cnt += 1
        i = j + 1
    return cnt

def solve_all(n: int, m: int, q: int, edges: List[Tuple[int, int, str]], strings: List[str], queries: List[Tuple[int, int, int, int]]) -> List[int]:
    up, depth, chpar = build_lca(n, edges)
    lens = [len(s) for s in strings]
    ans = []
    for u, v, l, r in queries:
        pat = path_string(u, v, up, depth, chpar)
        L = len(pat)
        s = 0
        for i in range(l-1, r):
            if lens[i] >= L:
                s += count_overlaps(strings[i], pat)
        ans.append(s)
    return ans

def _self_test():
    n = 4; m = 3; q = 2
    edges = [(1,2,'a'),(2,3,'b'),(3,4,'a')]
    strings = ["aba","bac","abacaba"]
    queries = [(1,4,1,1),(1,4,1,3)]
    res = solve_all(n, m, q, edges, strings, queries)
    assert res == [1, 3]
    # Additional tiny tests
    n2 = 2; edges2 = [(1,2,'z')]
    strings2 = ["z","zz","zzz"]
    queries2 = [(1,2,1,1),(1,2,1,2),(1,2,1,3)]
    res2 = solve_all(2, 3, 3, edges2, strings2, queries2)
    assert res2 == [1, 3, 6]
    # Path correctness symmetry
    up, depth, chpar = build_lca(n, edges)
    assert path_string(4, 1, up, depth, chpar) == "aba"

def solve_case():
    data = read_input()
    if data is None:
        return
    n, m, q, edges, strings, queries = data
    res = solve_all(n, m, q, edges, strings, queries)
    print('\n'.join(map(str, res)))

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        n, m, q, edges, strings, queries = read_input(data)
        res = solve_all(n, m, q, edges, strings, queries)
        print('\n'.join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: two multi-query sanity checks and one path-string symmetry check.}
\RESULT{For each query, output the sum of overlapping occurrences of the path word $w(u,v)$ across strings $S_l,\ldots,S_r$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for overlap counting, LCA-based path string extraction, and end-to-end results on tiny trees.}
\LINE{CROSS-CHECKS}{Compare outputs across Approaches A/B/C on the same handcrafted cases to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate random tiny trees ($n\le 8$), random lowercase strings (length $\le 6$), and random queries; cross-validate results.}
\begin{minted}{python}
import random
from typing import List, Tuple

def gen_tree(n: int) -> List[Tuple[int,int,str]]:
    # Random labeled tree with lowercase letters
    edges = []
    for v in range(2, n+1):
        u = random.randint(1, v-1)
        c = chr(ord('a') + random.randint(0, 25))
        edges.append((u, v, c))
    return edges

def brute_solve(n, m, q, edges, strings, queries):
    # Use the same reference path extractor & naive counting
    from collections import defaultdict
    # Reuse code from final solution for simplicity
    def build_lca(n, edges):
        adj = [[] for _ in range(n + 1)]
        for u, v, c in edges:
            adj[u].append((v, c))
            adj[v].append((u, c))
        LOG = (n+1).bit_length()
        up = [[0]*(n+1) for _ in range(LOG)]
        depth = [0]*(n+1)
        chpar = ['']*(n+1)
        root = 1
        stack = [(root, 0, '')]
        seen = [False]*(n+1)
        seen[root] = True
        while stack:
            u, p, ch = stack.pop()
            up[0][u] = p
            chpar[u] = ch
            for v, c in adj[u]:
                if v == p: continue
                if not seen[v]:
                    seen[v] = True
                    depth[v] = depth[u] + 1
                    stack.append((v, u, c))
        for k in range(1, LOG):
            for v in range(1, n+1):
                up[k][v] = up[k-1][up[k-1][v]]
        return up, depth, chpar
    def lca(u, v, up, depth):
        if depth[u] < depth[v]:
            u, v = v, u
        LOG = len(up)
        diff = depth[u] - depth[v]
        for k in range(LOG):
            if diff & (1 << k):
                u = up[k][u]
        if u == v:
            return u
        for k in range(LOG-1, -1, -1):
            if up[k][u] != up[k][v]:
                u = up[k][u]; v = up[k][v]
        return up[0][u]
    def path_string(u, v, up, depth, chpar):
        a = lca(u, v, up, depth)
        pu = []
        x = u
        while x != a:
            pu.append(chpar[x]); x = up[0][x]
        pv = []
        y = v
        while y != a:
            pv.append(chpar[y]); y = up[0][y]
        pv.reverse()
        return ''.join(pu) + ''.join(pv)
    def count_overlaps(text, pat):
        if not pat or len(text) < len(pat): return 0
        cnt = 0; i = 0
        while True:
            j = text.find(pat, i)
            if j == -1: break
            cnt += 1; i = j + 1
        return cnt
    up, depth, chpar = build_lca(n, edges)
    out = []
    for u, v, l, r in queries:
        pat = path_string(u, v, up, depth, chpar)
        s = 0
        for i in range(l-1, r):
            s += count_overlaps(strings[i], pat)
        out.append(s)
    return out

def reference_solve(n, m, q, edges, strings, queries):
    # Same as final reference implementation
    return brute_solve(n, m, q, edges, strings, queries)

def run_random_tests(T=50):
    random.seed(0)
    for _ in range(T):
        n = random.randint(2, 8)
        edges = gen_tree(n)
        m = random.randint(1, 6)
        strings = [''.join(chr(ord('a')+random.randint(0,1)) for _ in range(random.randint(1,6))) for __ in range(m)]
        q = random.randint(1, 10)
        queries = []
        for __ in range(q):
            u = random.randint(1, n)
            v = random.randint(1, n)
            while v == u:
                v = random.randint(1, n)
            l = random.randint(1, m)
            r = random.randint(l, m)
            queries.append((u, v, l, r))
        b = brute_solve(n, m, q, edges, strings, queries)
        r = reference_solve(n, m, q, edges, strings, queries)
        assert b == r
    print("Random tests passed")

if __name__ == "__main__":
    run_random_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None):
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it)); q = int(next(it))
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it)); c = next(it)
        edges.append((u, v, c))
    strings = [next(it) for _ in range(m)]
    queries = []
    for _ in range(q):
        u = int(next(it)); v = int(next(it)); l = int(next(it)); r = int(next(it))
        queries.append((u, v, l, r))
    return n, m, q, edges, strings, queries

def build_lca(n: int, edges: List[Tuple[int, int, str]]):
    adj = [[] for _ in range(n + 1)]
    for u, v, c in edges:
        adj[u].append((v, c))
        adj[v].append((u, c))
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    chpar = ['']*(n+1)
    root = 1
    stack = [(root, 0, '')]
    seen = [False]*(n+1)
    seen[root] = True
    while stack:
        u, p, ch = stack.pop()
        up[0][u] = p
        chpar[u] = ch
        for v, c in adj[u]:
            if v == p:
                continue
            if not seen[v]:
                seen[v] = True
                depth[v] = depth[u] + 1
                stack.append((v, u, c))
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    return up, depth, chpar

def lca(u: int, v: int, up: List[List[int]], depth: List[int]) -> int:
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]; v = up[k][v]
    return up[0][u]

def path_string(u: int, v: int, up: List[List[int]], depth: List[int], chpar: List[str]) -> str:
    a = lca(u, v, up, depth)
    pu = []
    x = u
    while x != a:
        pu.append(chpar[x]); x = up[0][x]
    pv = []
    y = v
    while y != a:
        pv.append(chpar[y]); y = up[0][y]
    pv.reverse()
    return ''.join(pu) + ''.join(pv)

def count_overlaps(text: str, pat: str) -> int:
    if not pat or len(text) < len(pat): return 0
    cnt = 0; i = 0
    while True:
        j = text.find(pat, i)
        if j == -1: break
        cnt += 1; i = j + 1
    return cnt

def solve_all(n: int, m: int, q: int, edges: List[Tuple[int, int, str]], strings: List[str], queries: List[Tuple[int, int, int, int]]) -> List[int]:
    up, depth, chpar = build_lca(n, edges)
    lens = [len(s) for s in strings]
    ans = []
    for u, v, l, r in queries:
        pat = path_string(u, v, up, depth, chpar)
        L = len(pat)
        s = 0
        for i in range(l-1, r):
            if lens[i] >= L:
                s += count_overlaps(strings[i], pat)
        ans.append(s)
    return ans

def _self_test():
    n = 4; m = 3; q = 2
    edges = [(1,2,'a'),(2,3,'b'),(3,4,'a')]
    strings = ["aba","bac","abacaba"]
    queries = [(1,4,1,1),(1,4,1,3)]
    res = solve_all(n, m, q, edges, strings, queries)
    assert res == [1, 3]
    # Overlap edge case
    assert count_overlaps("aaaaa", "aaa") == 3

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
    else:
        n, m, q, edges, strings, queries = read_input(data)
        res = solve_all(n, m, q, edges, strings, queries)
        print('\n'.join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Extract the path word along a labeled tree and count its overlapping occurrences in a range of strings.}
\WHY{Combines tree path processing (LCA/HLD) with string indexing (SAM/AC automata) — a frequent blend in hard interviews/competitions.}
\CHECKLIST{
\begin{bullets}
\item Preprocess $\mathrm{lca}$ (depth, up table).
\item Build $w(u,v)$ correctly as up-part then reversed down-part.
\item Count overlapping occurrences (advance by $1$ after match).
\item Prune texts shorter than $|w|$.
\item Validate on tiny cases with overlaps and symmetric paths.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $|w|=1$ (adjacent nodes).
\item Repeated letters causing many overlaps, e.g., $\text{``aaaaa''}$ vs $\text{``aaa''}$.
\item Deep LCAs near the root or near leaves.
\item Multiple queries with identical $(u,v)$.
\item Empty dictionary range is disallowed by constraints ($l \le r$).
\item Tree as a line vs. star topologies.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to reverse the second path segment.
\item Using non-overlapping $\texttt{count}$ instead of overlapping search.
\item Off-by-one in $[l,r]$ indexing (1-based to 0-based).
\item Not initializing parent/char for the root.
\item Recursion limit on deep trees — use iterative DFS or raise limits.
\item Mixing up $u,v$ when equalizing depths in LCA.
\end{bullets}}
\FAILMODES{Naive per-query scans are too slow for worst-case limits; need offline range methods and automata. The baseline here survives only tiny inputs but is correctness-oriented.}
\ELI{Walk from $u$ to $v$ and write down the letters you cross — that is your word. Then, for the chosen list of strings, count how many times that word shows up, allowing overlaps. Advanced solutions pre-index all strings so every query is fast.}
\NotePages{3}

\end{document}