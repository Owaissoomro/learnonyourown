% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — String Reversal}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1430/E}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{You are given a string $s$. You have to reverse it — that is, the first letter should become equal to the last letter before the reversal, the second letter should become equal to the second-to-last letter before the reversal — and so on. For example, if your goal is to reverse the string ``abddea'', you should get the string ``aeddba''. To accomplish your goal, you can swap the neighboring elements of the string.

Your task is to calculate the minimum number of swaps you have to perform to reverse the given string.

Input:
The first line contains one integer $n$ ($2 \le n \le 200{,}000$) — the length of $s$.

The second line contains $s$ — a string consisting of $n$ lowercase Latin letters.

Output:
Print one integer — the minimum number of swaps of neighboring elements you have to perform to reverse the string.

Note:
In the first example, you have to swap the third and the fourth elements, so the string becomes ``aazaa''. Then you have to swap the second and the third elements, so the string becomes ``azaaa''. So, it is possible to reverse the string in two swaps.

Since the string in the second example is a palindrome, you do not have to do anything to reverse it.}
\BREAKDOWN{Transforming $s$ into its reversed string $t$ using adjacent swaps is equivalent to counting inversions of a suitable permutation that maps occurrences in $s$ to their target positions in $t$. We must construct this permutation carefully to account for duplicate letters and then count inversions efficiently.}
\ELI{Match each character in $s$ to where it must go in the reversed string, then count how many out-of-order pairs that creates; that count is the minimum adjacent swaps.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One test with:
\begin{bullets}
\item $n$ (integer), $2 \le n \le 200{,}000$.
\item $s$ (string of length $n$), lowercase Latin letters.
\end{bullets}}
\OUTPUTS{A single integer: the minimum number of neighboring swaps needed to transform $s$ into its reversed string.}
\SAMPLES{Examples:
\begin{bullets}
\item Input: $n=5$, $s=$ ``aazaa''. Output: $0$ (already a palindrome, reversing changes nothing).
\item Input: $n=6$, $s=$ ``abddea''. Output: $5$ (one optimal sequence achieves the reverse in $5$ swaps).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s$ be the input string and $t$ be its reverse. For each character $c \in \{a,\ldots,z\}$ let $P_c(t)$ denote the increasing list of indices at which $c$ occurs in $t$. Scanning $s$ left to right, map each $s_i$ to the earliest unused occurrence of $s_i$ in $t$, producing an array $A$ of length $n$ of target indices. The answer is the inversion count of $A$.}
\varmapStart
\var{s}{input string}
\var{t}{reversed string of $s$}
\var{n}{length of $s$ and $t$}
\var{A}{array of target indices in $t$ matched from $s$}
\var{I(A)}{inversion count of $A$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; I(A) \;=\; \left|\{(i,j)\mid 0\le i<j<n,\; A_i>A_j\}\right|.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Zero-based indexing. Characters are lowercase Latin letters. Equal letters are indistinguishable; hence mapping uses occurrence order within each letter.}
\INVARIANTS{
\begin{bullets}
\item Mapping preserves per-letter multiplicities: for each $c$, the number of mapped indices equals the count of $c$ in $s$ and $t$.
\item Choosing the earliest unused target index in $t$ for each $s_i$ yields a permutation (no duplicates) of $\{0,\ldots,n-1\}$.
\item The inversion count is invariant under any sequence of adjacent swaps realizing the transformation from $s$ to $t$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the reversal by pulling, for each position of $t$ from left to right, the first matching character from the current working string and bubble it left via adjacent swaps.}
\ASSUMPTIONS{Feasible only for small $n$ due to quadratic complexity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $t$ be the reverse of $s$ and $arr$ be a list of the characters of $s$.
\item For $i=0$ to $n-1$: find the smallest index $j\ge i$ such that $arr[j]=t[i]$, then swap adjacent elements to bring $arr[j]$ to position $i$, adding $j-i$ to the answer.
\item Return the accumulated swaps.
\end{algosteps}
\COMPLEXITY{Quadratic time and linear space.}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-1} O(n-i) \\
     &= O(n^2), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Each step realizes exactly the adjacent swaps to place the next required character, preserving relative order of the remaining characters and minimizing local swaps at that step. Summing over all steps yields the minimal total.}
\EDGECASES{All letters equal, already a palindrome, alternating letters, maximal length small cases.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = next(it)
    assert len(s) == n
    return n, s

def solve_case(n: int, s: str) -> int:
    # Brute-force bubble-pull method: O(n^2)
    t = s[::-1]
    arr = list(s)
    ans = 0
    for i in range(n):
        # find first position j >= i with arr[j] == t[i]
        j = i
        while j < n and arr[j] != t[i]:
            j += 1
        # bubble arr[j] to position i
        while j > i:
            arr[j], arr[j-1] = arr[j-1], arr[j]
            ans += 1
            j -= 1
    return ans

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s = parsed
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks for the baseline
        assert solve_all("5\naazaa\n") == "0"
        assert solve_all("6\nabddea\n") == "5"
        assert solve_all("1\nz\n".replace("1", "2").replace("z", "zz")) == "0"
        print("0")
        return
    out = solve_all(data)
    print(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Quick checks: palindrome yields $0$; unique letters of length $k$ need $k(k-1)/2$; mixed duplicates like ``abddea'' yields $5$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Map to Target Positions + Inversion Count via Fenwick Tree}
\WHICHFORMULA{Construct the target index array $A$ by matching each $s_i$ to the earliest unused position of the same letter in $t$; then the answer is $I(A)$. Count inversions in $O(n \log n)$ with a Fenwick tree.}
\ASSUMPTIONS{Alphabet is small (letters). Fenwick tree supports point updates and prefix sums in logarithmic time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $t=s^\text{rev}$ and queues $Q_c$ of positions of each letter $c$ in $t$ (in increasing order).
\item Scan $s$ left to right; for each $s_i=c$, pop $j=Q_c.\text{pop\_left}()$ and append $j$ to array $A$.
\item Count inversions of $A$ using a Fenwick tree on indices $0..n-1$: for each $A_i$, add $\text{seen}-\text{prefix}(A_i)$ to the answer and update the tree at $A_i$.
\end{algosteps}
\COMPLEXITY{Building queues is $O(n)$. Each Fenwick operation is $O(\log n)$, done $n$ times.}
\[
\begin{aligned}
T(n) &= O(n \log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{By construction, $A$ is a permutation that preserves per-letter occurrence order relative to $t$, which exactly models the minimal adjacent swaps. The inversion count of $A$ equals the minimal number of adjacent transpositions to reorder $s$ into $t$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque, defaultdict
import sys

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, idx: int, delta: int):
        i = idx + 1
        n = self.n
        while i <= n:
            self.bit[i] += delta
            i += i & -i
    def sum_pref(self, idx: int) -> int:
        # sum over [0..idx], if idx < 0 => 0
        if idx < 0:
            return 0
        i = idx + 1
        res = 0
        while i > 0:
            res += self.bit[i]
            i -= i & -i
        return res

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = next(it)
    assert len(s) == n
    return n, s

def solve_case(n: int, s: str) -> int:
    t = s[::-1]
    pos = defaultdict(deque)
    for j, ch in enumerate(t):
        pos[ch].append(j)
    A = [0]*n
    for i, ch in enumerate(s):
        A[i] = pos[ch].popleft()
    fw = Fenwick(n)
    inv = 0
    seen = 0
    for x in A:
        le = fw.sum_pref(x)  # number of seen values <= x
        inv += seen - le     # strictly greater are inversions
        fw.add(x, 1)
        seen += 1
    return inv

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s = parsed
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Deterministic self-tests
        assert solve_all("5\naazaa\n") == "0"
        assert solve_all("6\nabddea\n") == "5"
        # random-like crafted
        assert solve_all("4\nabca\n") == str(4)  # reverse "acba"; A = [3,1,2,0], inv = 4
        print("0")
        return
    print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers palindromes, duplicates, and mixed patterns; matches brute force on small cases and yields $O(n \log n)$ speed.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Occurrence Mapping + Inversion Count (Final)}
\WHICHFORMULA{Same as Approach B; this is optimal for $n \le 200{,}000$ with Fenwick or segment tree.}
\ASSUMPTIONS{Indices fit in 64-bit signed integer when summing inversions; use Python int for safety.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build queues of positions in the reversed string per character.
\item Map $s$ to target positions $A$ by popping from respective queues.
\item Count inversions of $A$ with a Fenwick tree.
\end{algosteps}
\OPTIMALITY{Any algorithm must, in effect, account for relative order conflicts between $s$ and $t$, which are $\Theta(n + I(A))$ in structure; counting inversions in $O(n \log n)$ is tight for comparison-based approaches on arbitrary inputs.}
\COMPLEXITY{$T(n)=O(n \log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, idx: int, delta: int):
        i = idx + 1
        n = self.n
        while i <= n:
            self.bit[i] += delta
            i += i & -i
    def sum_pref(self, idx: int) -> int:
        if idx < 0:
            return 0
        i = idx + 1
        res = 0
        while i > 0:
            res += self.bit[i]
            i -= i & -i
        return res

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = next(it)
    assert len(s) == n
    return n, s

def solve_case(n: int, s: str) -> int:
    t = s[::-1]
    pos = defaultdict(deque)
    for j, ch in enumerate(t):
        pos[ch].append(j)
    A = [0]*n
    for i, ch in enumerate(s):
        A[i] = pos[ch].popleft()
    # Count inversions in A
    fw = Fenwick(n)
    inv = 0
    seen = 0
    for x in A:
        le = fw.sum_pref(x)
        inv += seen - le
        fw.add(x, 1)
        seen += 1
    return inv

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s = parsed
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts
        assert solve_all("5\naazaa\n") == "0"
        assert solve_all("6\nabddea\n") == "5"
        assert solve_all("4\nabcd\n") == str(6)
        print("0")
        return
    print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: palindrome, mixed duplicates, and unique letters.}
\RESULT{Print the minimal number of adjacent swaps to transform $s$ into its reverse.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare the $O(n \log n)$ method against the quadratic baseline on small random strings; include edge cases: all equal letters, already reversed, alternating letters, and maximal alphabet usage.}
\LINE{CROSS-CHECKS}{For $n \le 200$, brute force and Fenwick answers must match exactly; for larger $n$, rely on properties: a string with all distinct letters needs $n(n-1)/2$ swaps; palindromes need $0$.}
\LINE{EDGE-CASE GENERATOR}{Generates strings of length up to 12 over small alphabets to exhaustively verify equivalence of methods.}
\begin{minted}{python}
import random
from collections import deque, defaultdict

def brute_min_swaps_to_reverse(s: str) -> int:
    t = s[::-1]
    arr = list(s)
    ans = 0
    n = len(arr)
    for i in range(n):
        j = i
        while j < n and arr[j] != t[i]:
            j += 1
        while j > i:
            arr[j], arr[j-1] = arr[j-1], arr[j]
            ans += 1
            j -= 1
    return ans

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, idx: int, delta: int):
        i = idx + 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum_pref(self, idx: int) -> int:
        if idx < 0:
            return 0
        i = idx + 1
        res = 0
        while i > 0:
            res += self.bit[i]
            i -= i & -i
        return res

def fenwick_min_swaps_to_reverse(s: str) -> int:
    n = len(s)
    t = s[::-1]
    pos = defaultdict(deque)
    for j, ch in enumerate(t):
        pos[ch].append(j)
    A = [pos[ch].popleft() for ch in s]
    fw = Fenwick(n)
    inv = 0
    seen = 0
    for x in A:
        le = fw.sum_pref(x)
        inv += seen - le
        fw.add(x, 1)
        seen += 1
    return inv

def edge_generator():
    # Deterministic set of tricky cases
    cases = [
        "", "a", "aa", "ab", "aba", "abba", "abcabc", "aazaa", "abddea",
        "abcd", "zzzza", "azbza", "thequickbrownfox"
    ]
    # Small exhaustive over alphabet 'ab' up to length 6
    alphabet = "ab"
    for n in range(1, 7):
        def rec(cur):
            if len(cur) == n:
                cases.append(cur)
                return
            for ch in alphabet:
                rec(cur + ch)
        rec("")
    return cases

def main():
    # Cross-check on edge cases
    for s in edge_generator():
        if not s:
            continue
        b = brute_min_swaps_to_reverse(s)
        f = fenwick_min_swaps_to_reverse(s)
        assert b == f, (s, b, f)
    # Randomized small tests
    random.seed(0)
    for _ in range(200):
        n = random.randint(1, 12)
        s = "".join(random.choice("abc") for _ in range(n))
        b = brute_min_swaps_to_reverse(s)
        f = fenwick_min_swaps_to_reverse(s)
        assert b == f, (s, b, f)
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, idx: int, delta: int):
        i = idx + 1
        n = self.n
        while i <= n:
            self.bit[i] += delta
            i += i & -i
    def sum_pref(self, idx: int) -> int:
        if idx < 0:
            return 0
        i = idx + 1
        res = 0
        while i > 0:
            res += self.bit[i]
            i -= i & -i
        return res

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = next(it)
    assert len(s) == n
    return n, s

def solve_case(n: int, s: str) -> int:
    t = s[::-1]
    pos = defaultdict(deque)
    for j, ch in enumerate(t):
        pos[ch].append(j)
    A = [0]*n
    for i, ch in enumerate(s):
        A[i] = pos[ch].popleft()
    fw = Fenwick(n)
    inv = 0
    seen = 0
    for x in A:
        le = fw.sum_pref(x)
        inv += seen - le
        fw.add(x, 1)
        seen += 1
    return inv

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s = parsed
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Quick sanity asserts
        assert solve_all("5\naazaa\n") == "0"
        assert solve_all("6\nabddea\n") == "5"
        assert solve_all("4\nabcd\n") == str(6)
        print("0")
        return
    print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Map each occurrence in $s$ to its destination in the reversed string and count inversions.}
\WHY{Common reduction in string and array reordering problems; tests ability to translate swaps into inversion counting and to implement Fenwick trees correctly.}
\CHECKLIST{
\begin{bullets}
\item Build reversed string and per-letter queues of indices.
\item Map $s$ to array $A$ of target indices.
\item Count inversions of $A$ via Fenwick or merge sort.
\item Use 64-bit or big integer for the answer.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All characters equal $\Rightarrow$ answer $0$.
\item String already a palindrome $\Rightarrow$ $0$.
\item All distinct letters $\Rightarrow$ $n(n-1)/2$.
\item Highly skewed counts (e.g., many of one letter, one of another).
\item Minimal $n=2$ cases.
\item Alternating patterns like ``ababab''.
\item Long $n$ near $200{,}000$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Mapping using wrong occurrence (e.g., popping from the back instead of front for $t$).
\item Off-by-one errors in Fenwick indices.
\item Overflow in languages with fixed-size integers.
\item Forgetting to zero-initialize Fenwick of size $n$.
\item Mixing 0-based and 1-based indices inconsistently.
\item Using $O(n^2)$ on large $n$ leading to time limit exceeded.
\end{bullets}}
\FAILMODES{Naive bubble simulation fails on $n \approx 200{,}000$ due to $O(n^2)$. Wrong occurrence mapping yields overcount (e.g., counting maximal inversions even for palindromes). The Fenwick-based approach survives all adversarial distributions by construction.}
\ELI{Reverse the string by planning where each letter needs to go, then count how many pairs of letters are in the wrong order. That count is exactly the number of steps of swapping neighbors you need.}
\NotePages{3}

\end{document}