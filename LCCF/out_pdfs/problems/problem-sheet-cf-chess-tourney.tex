% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Chess Tourney}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/845/A}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Berland annual chess tournament is coming!

Organizers have gathered $2\cdot n$ chess players who should be divided into two teams with $n$ people each. The first team is sponsored by BerOil and the second team is sponsored by BerMobile. Obviously, organizers should guarantee the win for the team of BerOil.

Thus, organizers should divide all $2\cdot n$ players into two teams with $n$ people each in such a way that the first team always wins.

Every chess player has its rating $r_i$. It is known that chess player with the greater rating always wins the player with the lower rating. If their ratings are equal then any of the players can win.

After teams assignment there will come a drawing to form $n$ pairs of opponents: in each pair there is a player from the first team and a player from the second team. Every chess player should be in exactly one pair. Every pair plays once. The drawing is totally random.

Is it possible to divide all $2\cdot n$ players into two teams with $n$ people each so that the player from the first team in every pair wins regardless of the results of the drawing?

Input:
The first line contains one integer $n$ ($1 \le n \le 100$).

The second line contains $2\cdot n$ integers $a_1, a_2, \ldots, a_{2n}$ ($1 \le a_i \le 1000$).

Output:
If it is possible to divide all $2\cdot n$ players into two teams with $n$ people each so that the player from the first team in every pair wins regardless of the results of the drawing, then print ``YES''. Otherwise print ``NO''.}
\BREAKDOWN{We need a partition into two size-$n$ teams such that every member of Team~1 strictly outrates every member of Team~2. Sorting reveals this is possible iff there is a strict gap between the $n$-th and $(n+1)$-th smallest ratings.}
\ELI{Sort the ratings; answer is YES iff the smallest player in the top half is strictly stronger than the strongest player in the bottom half.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
- Integer $n$ with $1 \le n \le 100$.\\
- A list of $2n$ integers $a_1,\ldots,a_{2n}$ with $1 \le a_i \le 1000$.
}
\OUTPUTS{Print a single line: ``YES'' if a partition ensures Team~1 always wins regardless of pairing, otherwise ``NO''.}
\SAMPLES{
Example 1\\
Input:\\
2\\
1 1 2 2\\
Output:\\
YES

Example 2\\
Input:\\
2\\
3 3 3 3\\
Output:\\
NO
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let multiset $A=\{a_1,\ldots,a_{2n}\}$. We seek a partition $(T_1,T_2)$ with $|T_1|=|T_2|=n$ such that $\forall x\in T_1,\forall y\in T_2:\ x>y$.}
\varmapStart
\var{n}{half the number of players}
\var{A}{multiset of $2n$ ratings}
\var{T_1,T_2}{two disjoint size-$n$ teams}
\var{a_{(i)}}{$i$-th order statistic of $A$ after sorting ascending}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\exists (T_1,T_2):~|T_1|=|T_2|=n\ \wedge\ \min T_1 > \max T_2
\end{BreakableEquation*}
Equivalently, writing the sorted sequence $a_{(1)}\le \cdots \le a_{(2n)}$,
\begin{BreakableEquation*}
\text{Answer}=\text{YES} \iff a_{(n)} < a_{(n+1)}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Ratings are integers; higher rating deterministically beats lower; equal ratings do not guarantee a win, hence strict inequalities are required for certainty.}
\INVARIANTS{
- If $\min T_1 \le \max T_2$, then there exists a pairing where a Team~1 player does not strictly outrate the opponent, breaking the guarantee.\\
- Sorting does not change feasibility; only order statistics matter.\\
- The optimal partition, if it exists, is ``bottom $n$ vs top $n$''.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Search all ${2n \choose n}$ partitions and check whether $\min T_1>\max T_2$.}
\ASSUMPTIONS{Feasible only for very small $n$; for larger $n$ we short-circuit to the order-statistics check.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each subset $S\subseteq \{1,\ldots,2n\}$ with $|S|=n$, set $T_1=\{a_i:i\in S\}$ and $T_2=A\setminus T_1$.
\item Compute $m_1=\min T_1$ and $M_2=\max T_2$; if $m_1>M_2$ return YES.
\item If no subset satisfies it, return NO.
\end{algosteps}
\COMPLEXITY{Brute force explores $\binom{2n}{n}$ subsets and each check is $O(n)$, yielding exponential time.}
\[
\begin{aligned}
T(n) &= \binom{2n}{n}\cdot O(n) \\
     &\approx \Theta\!\left(\frac{4^n}{\sqrt{n}}\right) \\
\end{aligned}
\]
\CORRECTNESS{The condition $\min T_1>\max T_2$ is necessary and sufficient for guaranteed wins against any pairing, so exhaustive search is exact.}
\EDGECASES{All ratings equal $\Rightarrow$ NO; $n=1$ with distinct ratings $\Rightarrow$ YES if the larger is placed in Team~1.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 845A - Chess Tourney (Baseline / Brute Force with safe shortcut)
from itertools import combinations
import sys
from typing import List, Tuple

def solve_case(n: int, arr: List[int]) -> str:
    # Safe shortcut: if n is large, use the optimal check to keep runtime bounded.
    if n > 12:
        b = sorted(arr)
        return "YES" if b[n] > b[n - 1] else "NO"
    idxs = list(range(2 * n))
    best = False
    for comb in combinations(idxs, n):
        t1 = [arr[i] for i in comb]
        t2 = [arr[i] for i in idxs if i not in comb]
        if min(t1) > max(t2):
            best = True
            break
    return "YES" if best else "NO"

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(2 * n)]
    return n, arr

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    ans = solve_case(n, arr)
    print(ans)

def _self_test():
    # Small sanity checks
    assert solve_case(1, [1, 2]) == "YES"
    assert solve_case(2, [1, 1, 2, 2]) == "YES"
    assert solve_case(2, [3, 3, 3, 3]) == "NO"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked by sanity asserts on tiny inputs; for $n>12$ the code uses the provably correct shortcut to avoid exponential blow-up.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sorting and Boundary Gap Check}
\WHICHFORMULA{Sort the $2n$ ratings and compare $a_{(n)}$ and $a_{(n+1)}$. If $a_{(n)}<a_{(n+1)}$, answer YES; else NO.}
\ASSUMPTIONS{Deterministic comparisons; strict inequality is required because equal ratings do not guarantee a win.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort the array $b$ in nondecreasing order.
\item Let $L=b_{n-1}$ (0-indexed) and $R=b_{n}$.
\item If $R>L$ print YES, else print NO.
\end{algosteps}
\COMPLEXITY{Sorting $2n$ values dominates.}
\[
\begin{aligned}
T(n) &= O(2n\log(2n)) = O(n\log n) \\
\end{aligned}
\]
\CORRECTNESS{If $b_n \le b_{n-1}$, then some top-half player is not strictly stronger than some bottom-half player, so the guarantee fails. If $b_n>b_{n-1}$, taking top $n$ vs bottom $n$ ensures every cross-team comparison is strictly in favor of Team~1.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 845A - Chess Tourney (Improved: sort + gap check)
import sys
from typing import List, Tuple

def solve_case(n: int, arr: List[int]) -> str:
    b = sorted(arr)
    return "YES" if b[n] > b[n - 1] else "NO"

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(2 * n)]
    return n, arr

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    print(solve_case(n, arr))

def _self_test():
    assert solve_case(1, [1, 2]) == "YES"
    assert solve_case(2, [1, 1, 2, 2]) == "YES"
    assert solve_case(2, [3, 3, 3, 3]) == "NO"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Verified on hand-crafted cases: strictly separated halves return YES; equal boundary or interleaving ratings return NO.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Order Statistics Threshold}
\WHICHFORMULA{Use the order-statistics threshold between the $n$-th and $(n+1)$-th elements after sorting to decide feasibility in $O(n\log n)$.}
\ASSUMPTIONS{Ratings totally orderable; ties disqualify certainty if they straddle the median boundary.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$ and the list of $2n$ ratings.
\item Sort ascending, compare positions $n-1$ and $n$ (0-indexed).
\item Output ``YES'' iff $b[n]>b[n-1]$, else ``NO''.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect at least all elements to distinguish adversarial inputs; sorting plus a single comparison is optimal in simplicity and time within typical comparison-based constraints for CF.}
\COMPLEXITY{$O(n\log n)$ time and $O(1)$ extra space aside from sorting in-place or $O(n)$ if creating a copy.}
\[
\begin{aligned}
T(n) &= O(n\log n) \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 845A - Chess Tourney (Final)
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(2 * n)]
    return n, arr

def solve_case(n: int, arr: List[int]) -> str:
    b = sorted(arr)
    return "YES" if b[n] > b[n - 1] else "NO"

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    print(solve_case(n, arr))

def _self_test():
    # Exactly 3 asserts
    assert solve_case(1, [5, 7]) == "YES"
    assert solve_case(2, [2, 2, 2, 2]) == "NO"
    assert solve_case(2, [1, 3, 5, 7]) == "YES"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Three asserts cover distinct/equal boundary cases and general separation.}
\RESULT{Print ``YES'' iff $\min(\text{top half})>\max(\text{bottom half})$ after sorting; otherwise print ``NO''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-check the optimal solver against a brute-force solver on small $n$; include boundary tests such as all equal, strictly increasing, and cases where the gap is exactly at the boundary.}
\LINE{CROSS-CHECKS}{Randomly generate small multisets for $n\le 5$ and assert the improved and brute answers match.}
\LINE{EDGE-CASE GENERATOR}{Produce extremes: $n=1$; duplicates straddling the boundary; all equal; already separated halves; alternating small/large values.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import combinations
import random

def brute_possible(n, arr):
    idxs = list(range(2*n))
    for comb in combinations(idxs, n):
        t1 = [arr[i] for i in comb]
        t2 = [arr[i] for i in idxs if i not in comb]
        if min(t1) > max(t2):
            return True
    return False

def fast_possible(n, arr):
    b = sorted(arr)
    return b[n] > b[n-1]

def gen_cases():
    cases = []
    # Boundaries
    cases.append((1, [1, 1]))
    cases.append((1, [1, 2]))
    # All equal
    cases.append((3, [5, 5, 5, 5, 5, 5]))
    # Strictly increasing
    cases.append((3, [1, 2, 3, 4, 5, 6]))
    # Duplicates straddling
    cases.append((3, [1, 2, 3, 3, 3, 4]))
    # Alternating pattern
    cases.append((3, [1, 4, 1, 4, 1, 4]))
    # Random small
    random.seed(0)
    for _ in range(10):
        n = random.randint(1, 5)
        arr = [random.randint(1, 7) for _ in range(2*n)]
        cases.append((n, arr))
    return cases

def run_tests():
    for n, arr in gen_cases():
        b = brute_possible(n, arr)
        f = fast_possible(n, arr)
        assert b == f, (n, arr, b, f)
    print("All cross-checks passed.")

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# CF 845A - Chess Tourney (Reference Solution)
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(2 * n)]
    return n, arr

def solve_case(n: int, arr: List[int]) -> str:
    b = sorted(arr)
    return "YES" if b[n] > b[n - 1] else "NO"

def solve_all() -> None:
    n, arr = read_input()
    if n == 0:
        return
    print(solve_case(n, arr))

def _self_test():
    assert solve_case(1, [2, 1]) == "YES"
    assert solve_case(2, [1, 2, 2, 3]) == "YES"
    assert solve_case(2, [3, 3, 3, 3]) == "NO"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _self_test()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort ratings and check the strict gap between positions $n$ and $n+1$ (1-indexed).}
\WHY{This is a classic CF trick: a global guarantee against any pairing requires a strict partition by strength; sorting exposes the necessary and sufficient separator.}
\CHECKLIST{
- Read $n$ and $2n$ ratings.\\
- Sort nondecreasing.\\
- Compare $b[n]$ vs $b[n-1]$ (0-indexed).\\
- Print ``YES'' if strictly greater, else ``NO''.
}
\EDGECASES{
- $n=1$ with equal ratings $\Rightarrow$ NO.\\
- $n=1$ with distinct ratings $\Rightarrow$ YES.\\
- All ratings equal $\Rightarrow$ NO.\\
- Exactly two distinct values with $n$ of each $\Rightarrow$ YES.\\
- Duplicates straddling the boundary $\Rightarrow$ NO.\\
- Already separated halves in input order $\Rightarrow$ still sort; answer YES.
}
\PITFALLS{
- Off-by-one between 0-indexed and 1-indexed positions.\\
- Forgetting strict inequality ($>$) and using $\ge$.\\
- Not sorting and attempting greedy partition by original order.\\
- Mishandling input size: must read exactly $2n$ integers.\\
- Printing quotes incorrectly; must output bare YES/NO without extra spaces.\\
- Assuming pairing matters; it does not if strict separation holds.
}
\FAILMODES{Any approach that tries to arrange players based on specific pairings fails because the drawing is random; only strict cross-team dominance ensures certainty. Sorting plus boundary check is immune to adversarial pairings.}
\ELI{To guarantee wins no matter how players are paired, every player on Team~1 must be stronger than every player on Team~2. Sorting makes this obvious: if there is a strict gap between the bottom half and the top half, choose top half as Team~1. Otherwise, it is impossible.}
\NotePages{3}

\end{document}