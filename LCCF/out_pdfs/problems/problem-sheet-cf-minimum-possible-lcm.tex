% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Possible LCM}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1154/G}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{You are given an array $a$ consisting of $n$ integers $a_1, a_2, \ldots, a_n$.

Your task is to find indices $i, j$ with $1 \le i < j \le n$ such that $\operatorname{lcm}(a_i,a_j)$ is as small as possible.

Here $\operatorname{lcm}(x,y)$ denotes the least common multiple of $x$ and $y$, i.e., the minimum positive integer divisible by both $x$ and $y$.

Input: The first line contains an integer $n$ with $2 \le n \le 10^6$. The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ with $1 \le a_i \le 10^7$.

Output: Print two integers $i$ and $j$ ($1 \le i < j \le n$) such that $\operatorname{lcm}(a_i,a_j)$ is minimum among all valid pairs. If there are multiple optimal answers, any of them may be printed.}
\BREAKDOWN{We need a pair of positions minimizing $a_i a_j / \gcd(a_i,a_j)$. Using number theory, the optimal pair must share a small common divisor. Track, for every $g$, two array elements that are multiples of $g$, then evaluate candidates.}
\ELI{Numbers that share a large common divisor produce smaller LCM; scan common divisors and keep the best two multiples to find the minimum.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $n$ ($2 \le n \le 10^6$).
- Array $a$ of length $n$ with $1 \le a_i \le 10^7$.}
\OUTPUTS{Two integers $i, j$ with $1 \le i < j \le n$ that minimize $\operatorname{lcm}(a_i,a_j)$. Any optimal pair is acceptable.}
\SAMPLES{Example 1:
- Input: $n=3$, $a=[4,2,8]$. Output: $1\ 2$ since $\operatorname{lcm}(4,2)=4$ is minimum.

Example 2:
- Input: $n=4$, $a=[6,2,3,6]$. Output: $1\ 4$ (or $1\ 2$ or $2\ 3$ etc.). The minimum possible LCM is $6$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given multiset $A=\{a_1,\ldots,a_n\}$, find indices $(i,j)$, $i<j$, minimizing
\begin{BreakableEquation*}
L(i,j)=\operatorname{lcm}(a_i,a_j)=\frac{a_i a_j}{\gcd(a_i,a_j)}.
\end{BreakableEquation*}
Equivalently, for each $g \in \mathbb{N}$ consider the set $M_g=\{k \in [n]: g \mid a_k\}$ and, if $|M_g|\ge 2$, minimize $\min_{i\ne j\in M_g} \tfrac{a_i a_j}{\gcd(a_i,a_j)}$.}
\varmapStart
\var{n}{number of elements}
\var{a_i}{$i$-th value}
\var{g}{candidate common divisor}
\var{M_g}{indices whose values are multiples of $g$}
\var{L(i,j)}{objective $\operatorname{lcm}(a_i,a_j)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{1\le i<j\le n} \frac{a_i a_j}{\gcd(a_i,a_j)}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $1$-based; values are positive integers; ties can be broken arbitrarily among minimizers.}
\INVARIANTS{
- For fixed $g$, picking the two smallest multiples of $g$ by value suffices to minimize the LCM within $M_g$.
- If some value $v$ occurs twice, then $\operatorname{lcm}(v,v)=v$ is a global candidate.
- $\operatorname{lcm}(x,y)\ge \max(x,y)$, so the answer is at least the minimum value present.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $L(i,j)=\dfrac{a_i a_j}{\gcd(a_i,a_j)}$ for all $i<j$ and pick the minimum.}
\ASSUMPTIONS{No preprocessing; uses built-in $\gcd$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize best value $+\infty$ and best pair $(1,2)$.
\item For each $1 \le i < j \le n$: compute $g=\gcd(a_i,a_j)$ and $L=a_i a_j / g$.
\item If $L$ improves the best, update the best pair.
\end{algosteps}
\COMPLEXITY{Quadratic time and constant extra space.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n-1}\sum_{j=i+1}^{n} 1 \\
     &= \frac{n(n-1)}{2} = \Theta(n^2),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Exhaustively evaluates the objective for every pair; the minimum found is correct by definition.}
\EDGECASES{Handles duplicates, equal numbers, and any tie by first occurrence update.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return arr

def best_pair_bruteforce(arr: List[int]) -> Tuple[int, int]:
    n = len(arr)
    assert n >= 2
    best_lcm = None
    best_pair = (1, 2)
    for i in range(n):
        ai = arr[i]
        for j in range(i + 1, n):
            aj = arr[j]
            g = math.gcd(ai, aj)
            l = (ai // g) * aj
            if best_lcm is None or l < best_lcm:
                best_lcm = l
                best_pair = (i + 1, j + 1)  # 1-based
    return best_pair

def solve_case(arr: List[int]) -> Tuple[int, int]:
    # Baseline: brute-force (only feasible for small n)
    return best_pair_bruteforce(arr)

def solve_all():
    arr = read_input()
    if not arr:
        return
    i, j = solve_case(arr)
    print(i, j)

def _self_test():
    # Tiny asserts (do not rely on stdin)
    assert best_pair_bruteforce([2, 3]) in {(1, 2)}
    assert best_pair_bruteforce([4, 2, 8]) in {(1, 2)}
    # Multiple options acceptable
    assert best_pair_bruteforce([6, 2, 3, 6]) in {(1, 4), (1, 2), (2, 3), (3, 4), (2, 4), (1, 3)}

if __name__ == "__main__":
    # Run internal tests, then proceed to normal solve if stdin provided
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Verified on tiny arrays to ensure correct LCM computation and 1-based indices.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Group by Divisors (Two Best Multiples per Divisor)}
\WHICHFORMULA{For each divisor $g$ that occurs among array values, track the two smallest values that are multiples of $g$. Any optimal pair must appear under some $g=\gcd(a_i,a_j)$.}
\ASSUMPTIONS{Enumerate divisors of each distinct value by trial up to $\sqrt{v}$; maintain buckets keeping only two best candidates by value per divisor.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Record up to two indices for every distinct value $v$ in the array.
\item Initialize a map $B$ from divisor $g$ to a list of up to two pairs $(v,\text{idx})$ with smallest $v$ seen.
\item For each distinct value $v$ with its stored indices, enumerate all divisors $d$ of $v$; for each $d$, insert $(v,\text{idx})$ into $B[d]$ maintaining only the two smallest $v$.
\item For each $g$ with $|B[g]| \ge 2$, compute the candidate LCM from its two entries and keep the global minimum.
\end{algosteps}
\COMPLEXITY{Let $m$ be the number of distinct values and $\tau(v)$ the divisor count of $v$. Then the work is about $\sum_{v}\tau(v)$ insertions.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\sum_{v\ \text{distinct}}\tau(v)\right),\quad S(n)=O(m).
\end{aligned}
\]
\CORRECTNESS{For optimal pair $(i,j)$ with $g=\gcd(a_i,a_j)$, both $a_i,a_j$ are multiples of $g$ and thus get inserted into bucket $B[g]$. Keeping the two smallest multiples per $g$ suffices to realize the minimum LCM within that bucket. The global minimum over all $g$ is found.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple, Dict, DefaultDict
from collections import defaultdict

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return arr

def _push_two_smallest(bucket: List[Tuple[int, int]], cand: Tuple[int, int]) -> None:
    # bucket holds up to two (value, index) pairs with smallest values
    bucket.append(cand)
    bucket.sort(key=lambda x: (x[0], x[1]))
    if len(bucket) > 2:
        bucket.pop()

def _divisors(v: int) -> List[int]:
    ds = []
    r = int(v**0.5)
    for d in range(1, r + 1):
        if v % d == 0:
            ds.append(d)
            if d * d != v:
                ds.append(v // d)
    return ds

def best_pair_by_divisors(arr: List[int]) -> Tuple[int, int]:
    n = len(arr)
    # Map value -> up to two indices where it occurs (first two occurrences)
    pos: Dict[int, List[int]] = defaultdict(list)
    for i, x in enumerate(arr, 1):
        if len(pos[x]) < 2:
            pos[x].append(i)

    # Buckets for divisors -> up to two smallest (value, index) pairs
    buckets: DefaultDict[int, List[Tuple[int, int]]] = defaultdict(list)

    for v, indices in pos.items():
        ds = _divisors(v)
        for idx in indices:
            for d in ds:
                _push_two_smallest(buckets[d], (v, idx))

    best_lcm = None
    best_pair = (1, 2)
    for g, items in buckets.items():
        if len(items) >= 2:
            (v1, i1), (v2, i2) = items[0], items[1]
            if i1 == i2:
                continue
            g12 = math.gcd(v1, v2)
            l = (v1 // g12) * v2
            if best_lcm is None or l < best_lcm:
                best_lcm = l
                # Ensure i < j
                if i1 < i2:
                    best_pair = (i1, i2)
                else:
                    best_pair = (i2, i1)

    return best_pair

def solve_case(arr: List[int]) -> Tuple[int, int]:
    return best_pair_by_divisors(arr)

def solve_all():
    arr = read_input()
    if not arr:
        return
    i, j = solve_case(arr)
    print(i, j)

def _self_test():
    assert best_pair_by_divisors([2, 3]) in {(1, 2)}
    assert best_pair_by_divisors([4, 2, 8]) in {(1, 2)}
    # Example where optimal pair uses equal values
    assert best_pair_by_divisors([6, 2, 3, 6]) in {(1, 4), (1, 2), (2, 3), (2, 4), (1, 3), (3, 4)}

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Checked on tiny arrays and duplicates; buckets maintain two smallest values per divisor, enabling correct reconstruction of indices.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sweep All Common Divisors via Multiples}
\WHICHFORMULA{Classical sieve-like sweep: for each $g$ from $1$ to $\max(a)$, consider all multiples of $g$ that appear in the array. Keep the two smallest values among those multiples, which minimize the LCM for that $g$. The best over $g$ is the answer.}
\ASSUMPTIONS{Store up to two positions per value; for each $g$, iterate multiples $m=g,2g,\ldots$ and merge their at-most-two candidates into two global bests for $g$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each value $v$, store up to two indices where $a_k=v$.
\item For $g=1$ to $\max(a)$:
  collect across multiples $m$ of $g$ the pairs $(m,\text{idx})$ from $m$'s positions, keeping only the two smallest $m$.
\item If two candidates exist for $g$, compute their LCM and update the global best.
\item Output the best pair of indices.
\end{algosteps}
\OPTIMALITY{Any optimal pair has $g=\gcd(a_i,a_j)$, and both $a_i$ and $a_j$ lie among multiples of $g$. Restricting to the two smallest multiples per $g$ is optimal within $g$, and scanning all $g$ captures the global optimum.}
\COMPLEXITY{With an efficient low-level language and boolean presence, this runs in about $O(M \log\log M)$ where $M=\max(a)$ by harmonic analysis of multiples. In Python it is suitable for moderate inputs; conceptually optimal for the constraints.}
\[
\begin{aligned}
T &\approx \sum_{g=1}^{M} \left\lfloor \frac{M}{g} \right\rfloor \quad\text{(but skipping absent values in practice)},\quad S=O(M)\ \text{for presence/positions}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return arr

def solve_array(arr: List[int]) -> Tuple[int, int]:
    n = len(arr)
    if n == 2:
        return (1, 2)
    maxv = max(arr)

    # positions[v] = up to two indices where value v occurs (1-based)
    positions = [None] * (maxv + 1)
    for i, x in enumerate(arr, 1):
        p = positions[x]
        if p is None:
            positions[x] = [i]
        else:
            if len(p) < 2:
                p.append(i)

    best_lcm = None
    best_pair = (1, 2)

    # Helper to maintain two smallest (value, idx) by value
    def push2(state: List[Tuple[int, int]], val: int, idx: int):
        state.append((val, idx))
        state.sort(key=lambda t: (t[0], t[1]))
        if len(state) > 2:
            state.pop()

    # Early candidate: any value with two occurrences yields lcm = value
    min_dup_val = None
    dup_pair = None
    for v in range(1, maxv + 1):
        p = positions[v]
        if p is not None and len(p) >= 2:
            if min_dup_val is None or v < min_dup_val:
                min_dup_val = v
                dup_pair = (p[0], p[1])
    if dup_pair is not None:
        best_lcm = min_dup_val
        best_pair = dup_pair if dup_pair[0] < dup_pair[1] else (dup_pair[1], dup_pair[0])

    # Sweep divisors g
    for g in range(1, maxv + 1):
        cand: List[Tuple[int, int]] = []
        # enumerate multiples
        for m in range(g, maxv + 1, g):
            p = positions[m]
            if p is None:
                continue
            if len(p) == 1:
                push2(cand, m, p[0])
            else:
                # two indices available
                push2(cand, m, p[0])
                push2(cand, m, p[1])
            if len(cand) == 2 and cand[1][0] == g:
                # Already minimal possible for this g; cannot improve within g
                pass
        if len(cand) >= 2:
            (v1, i1), (v2, i2) = cand[0], cand[1]
            if i1 != i2:
                g12 = math.gcd(v1, v2)
                l = (v1 // g12) * v2
                if best_lcm is None or l < best_lcm:
                    best_lcm = l
                    best_pair = (i1, i2) if i1 < i2 else (i2, i1)
    return best_pair

def solve_all():
    arr = read_input()
    if not arr:
        return
    i, j = solve_array(arr)
    print(i, j)

def _self_test():
    # Exactly 3 asserts
    assert solve_array([2, 3]) == (1, 2)
    assert solve_array([4, 2, 8]) in {(1, 2), (2, 1)}
    assert solve_array([6, 2, 3, 6]) in {(1, 4), (4, 1), (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (1, 3), (3, 1), (3, 4), (4, 3)}

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts on small arrays confirm correctness and 1-based index ordering.}
\RESULT{Print any optimal pair of indices $i<j$ that minimizes $\operatorname{lcm}(a_i,a_j)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for helper routines; random tiny arrays cross-checked between brute force and optimized methods; duplicates and co-prime mixes.}
\LINE{CROSS-CHECKS}{For small $n$, compare Baseline vs Improved vs Optimal outputs to ensure identical minima.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with: all equal values, pair of small co-primes, powers of two, and mixed primes vs composites.}
\begin{minted}{python}
import random, math
from typing import List, Tuple

def lcm(a: int, b: int) -> int:
    return (a // math.gcd(a, b)) * b

def brute(arr: List[int]) -> Tuple[int, int, int]:
    n = len(arr)
    best = (10**30, 1, 2)
    for i in range(n):
        for j in range(i + 1, n):
            val = lcm(arr[i], arr[j])
            if val < best[0]:
                best = (val, i + 1, j + 1)
    return best

def improved(arr: List[int]) -> Tuple[int, int, int]:
    # Use the divisors-bucket method from Approach B
    from collections import defaultdict
    pos = defaultdict(list)
    for i, x in enumerate(arr, 1):
        if len(pos[x]) < 2:
            pos[x].append(i)
    buckets = defaultdict(list)
    def push2(bucket, item):
        bucket.append(item)
        bucket.sort()
        if len(bucket) > 2:
            bucket.pop()
    def divisors(v):
        ds = []
        r = int(v**0.5)
        for d in range(1, r + 1):
            if v % d == 0:
                ds.append(d)
                if d * d != v:
                    ds.append(v // d)
        return ds
    for v, ids in pos.items():
        ds = divisors(v)
        for idx in ids:
            for d in ds:
                push2(buckets[d], (v, idx))
    best = (10**30, 1, 2)
    for d, items in buckets.items():
        if len(items) >= 2:
            (v1, i1), (v2, i2) = items[0], items[1]
            if i1 == i2:
                continue
            val = lcm(v1, v2)
            if val < best[0]:
                if i1 < i2:
                    best = (val, i1, i2)
                else:
                    best = (val, i2, i1)
    return best

def run_cross_checks():
    random.seed(0)
    for _ in range(200):
        n = random.randint(2, 8)
        arr = [random.randint(1, 50) for _ in range(n)]
        b = brute(arr)
        i = improved(arr)
        assert b[0] == i[0], (arr, b, i)

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference using the divisor-bucket method (robust in Python)
import sys, math
from typing import List, Tuple, Dict
from collections import defaultdict

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return arr

def divisors(v: int) -> List[int]:
    ds = []
    r = int(v**0.5)
    for d in range(1, r + 1):
        if v % d == 0:
            ds.append(d)
            if d * d != v:
                ds.append(v // d)
    return ds

def solve_case(arr: List[int]) -> Tuple[int, int]:
    n = len(arr)
    pos: Dict[int, List[int]] = defaultdict(list)
    for i, x in enumerate(arr, 1):
        if len(pos[x]) < 2:
            pos[x].append(i)
    buckets: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
    def push2(bucket: List[Tuple[int, int]], cand: Tuple[int, int]) -> None:
        bucket.append(cand)
        bucket.sort(key=lambda t: (t[0], t[1]))
        if len(bucket) > 2:
            bucket.pop()
    for v, ids in pos.items():
        ds = divisors(v)
        for idx in ids:
            for d in ds:
                push2(buckets[d], (v, idx))
    best_lcm = None
    best_pair = (1, 2)
    for d, items in buckets.items():
        if len(items) >= 2:
            (v1, i1), (v2, i2) = items[0], items[1]
            if i1 == i2:
                continue
            g = math.gcd(v1, v2)
            l = (v1 // g) * v2
            if best_lcm is None or l < best_lcm:
                best_lcm = l
                best_pair = (i1, i2) if i1 < i2 else (i2, i1)
    return best_pair

def main():
    arr = read_input()
    if not arr:
        return
    i, j = solve_case(arr)
    print(i, j)

def _self_test():
    assert solve_case([2, 3]) in {(1, 2)}
    assert solve_case([4, 2, 8]) in {(1, 2)}
    assert solve_case([6, 2, 3, 6]) in {(1, 4), (1, 2), (2, 3), (2, 4), (1, 3), (3, 4)}

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find a pair with minimum $\operatorname{lcm}$ by sweeping common divisors and keeping two smallest multiples per divisor.}
\WHY{Combines number theory with efficient bucketing; appears in array-gcd-lcm optimization and sieve-style problems.}
\CHECKLIST{
- Record up to two indices per value.
- For each divisor $g$, retain two smallest multiples with indices.
- Evaluate LCMs and update the global best.
- Output 1-based indices with $i<j$.}
\EDGECASES{
- Duplicated values (answer can be the same value twice).
- All co-prime values (answer uses two smallest numbers).
- Presence of $1$ (pair with $1$ often wins).
- Large range with sparse hits (avoid scanning absent data in practice).
- Very small $n=2$.
- Multiple optimal pairs (any acceptable).
- Equal candidates with different indices.
- Values near the upper bound.}
\PITFALLS{
- Forgetting to return indices from the original array.
- Not enforcing $i<j$ in output.
- Overflow if not using integer math carefully (avoid $a_i a_j$ before division in languages with fixed width).
- Missing the second index for duplicated values.
- Re-using the same index twice within one pair.
- Inefficient divisor enumeration or scanning all up to $\max(a)$ in Python on worst-case inputs.
- Incorrect early breaks that skip viable candidates.
- Not handling ties deterministically.}
\FAILMODES{Brute force times out for large $n$; naive multiple-scan over $[1,\max(a)]$ without pruning is too slow in Python. The divisor-bucket or sieve-in-C++ approaches avoid these pitfalls.}
\ELI{Pairs sharing a bigger common chunk make the combined number smaller. Track the best two numbers for each shared chunk and test them; the smallest result wins.}
\NotePages{3}

\end{document}