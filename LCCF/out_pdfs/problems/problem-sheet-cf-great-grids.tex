% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Great Grids}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1844/E}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{An $n \times m$ grid of characters is called great if it satisfies these three conditions:
\begin{bullets}
\item Each character is either `A', `B', or `C'.
\item Every $2 \times 2$ contiguous subgrid contains all three different letters.
\item Any two cells that share a common edge contain different letters.
\end{bullets}
Let $(x,y)$ denote the cell in the $x$-th row from the top and $y$-th column from the left.

You want to construct a great grid that satisfies $k$ constraints. Each constraint consists of two cells, $(x_{i,1},y_{i,1})$ and $(x_{i,2},y_{i,2})$, that share exactly one corner. You want your great grid to have the same letter in cells $(x_{i,1},y_{i,1})$ and $(x_{i,2},y_{i,2})$.

Determine whether there exists a great grid satisfying all the constraints.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^3$). The description of the test cases follows.

The first line of each test case contains three integers, $n$, $m$, and $k$ ($2 \le n,m \le 2 \cdot 10^3$, $1 \le k \le 4 \cdot 10^3$).

Each of the next $k$ lines contains four integers, $x_{i,1}$, $y_{i,1}$, $x_{i,2}$, and $y_{i,2}$ ($1 \le x_{i,1} < x_{i,2} \le n$, $1 \le y_{i,1},y_{i,2} \le m$). It is guaranteed that either $(x_{i,2},y_{i,2}) = (x_{i,1}+1,y_{i,1}+1)$ or $(x_{i,2},y_{i,2}) = (x_{i,1}+1,y_{i,1}-1)$.

The pairs of cells are pairwise distinct, i.e. for all $1 \le i < j \le k$, it is not true that $x_{i,1} = x_{j,1}$, $y_{i,1} = y_{j,1}$, $x_{i,2} = x_{j,2}$, and $y_{i,2} = y_{j,2}$.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^3$. It is guaranteed that the sum of $m$ over all test cases does not exceed $2 \cdot 10^3$. It is guaranteed that the sum of $k$ over all test cases does not exceed $4 \cdot 10^3$.

Output: For each test case, output ``YES'' if a great grid satisfying all the constraints exists and ``NO'' otherwise.

You can output the answer in any case (upper or lower). For example, the strings ``yEs'', ``yes'', ``Yes'', and ``YES'' will be recognized as positive responses.

Note: In the first test case, the following great grid satisfies all the constraints: BABCCBCAACAB

In the second test case, the two constraints imply that cells $(1,1)$ and $(2,2)$ have the same letter and cells $(1,2)$ and $(2,1)$ have the same letter, which makes it impossible for the only $2 \times 2$ subgrid to contain all three different letters.}
\BREAKDOWN{Characterize all great grids and reduce the constraints to a simple global choice. Show that every great grid is one of two families: colors by $(i+j) \bmod 3$ or by $(i-j) \bmod 3$. Then each constraint fixes which family is allowed; mixing both families is impossible.}
\ELI{All valid grids are periodic mod $3$ in either the sum or difference of coordinates; a constraint asking equality on one diagonal chooses one family. If constraints ask for both diagonals, it is impossible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case:
\begin{bullets}
\item Integers $n,m,k$ with $2 \le n,m \le 2000$, $1 \le k \le 4000$.
\item $k$ constraints: $(x_{i,1},y_{i,1},x_{i,2},y_{i,2})$ where $x_{i,2}=x_{i,1}+1$ and $y_{i,2}\in\{y_{i,1}-1,\,y_{i,1}+1\}$.
\end{bullets}}
\OUTPUTS{For each test case, print YES if a great grid exists satisfying all constraints; otherwise print NO.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input: one test case $n=3,m=3,k=1$ with constraint $(1,2,2,1)$.
\item Output: YES.
\end{bullets}
Example 2:
\begin{bullets}
\item Input: one test case $n=2,m=2,k=2$ with constraints $(1,1,2,2)$ and $(1,2,2,1)$.
\item Output: NO.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the grid be indexed by $(i,j)$ with $1 \le i \le n$, $1 \le j \le m$. A great grid is a map $G:\{1,\ldots,n\}\times\{1,\ldots,m\}\to\{A,B,C\}$ such that adjacent cells differ and every $2\times 2$ block uses all three letters. This is equivalent to one of two global colorings:
\begin{BreakableEquation*}
G(i,j)=\pi\big((i+j)\bmod 3\big)\quad\text{or}\quad G(i,j)=\pi\big((i-j)\bmod 3\big),
\end{BreakableEquation*}
for some permutation $\pi$ of $\{A,B,C\}$.}
\varmapStart
\var{G(i,j)}{letter in cell $(i,j)$}
\var{\pi}{permutation of $\{A,B,C\}$}
\var{S(i,j)}{$(i+j)\bmod 3$}
\var{D(i,j)}{$(i-j)\bmod 3$}
\var{C_i}{the $i$-th constraint pair of diagonal neighbors}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Adjacency: } G(i,j)\ne G(i+1,j),~G(i,j)\ne G(i,j+1).\\
&2\times 2\text{ diversity: every } \{(i,j),(i+1,j),(i,j+1),(i+1,j+1)\}\text{ uses exactly three letters.}\\
&\text{Diagonal-equality per family: }\\
&\quad \text{Sum-family }(S):~ G(i,j)=G(i+1,j-1)\text{ for all valid }(i,j).\\
&\quad \text{Diff-family }(D):~ G(i,j)=G(i+1,j+1)\text{ for all valid }(i,j).\\
&\text{Constraint }C_i=\big((x_{i,1},y_{i,1}),(x_{i,2},y_{i,2})\big):~G(x_{i,1},y_{i,1})=G(x_{i,2},y_{i,2}).
\end{aligned}
\]
}
\ASSUMPTIONS{Coordinates are $1$-indexed. Each constraint is a diagonal pair with $x_{i,2}=x_{i,1}+1$ and $y_{i,2}=y_{i,1}\pm 1$.}
\INVARIANTS{
\begin{bullets}
\item In the sum-family, $(i+j)\bmod 3$ is constant on anti-diagonally adjacent pairs and differs by $1$ on edges.
\item In the diff-family, $(i-j)\bmod 3$ is constant on main-diagonally adjacent pairs and differs by $1$ on edges.
\item Mixing both diagonal equalities in constraints is impossible, as no great grid has both equal diagonals in the same $2\times 2$ block.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try both canonical families $G(i,j)=\pi((i+j)\bmod 3)$ and $G(i,j)=\pi((i-j)\bmod 3)$; equality constraints depend only on the residue, not on $\pi$. So it suffices to check residues.}
\ASSUMPTIONS{We do not construct the full grid; we only evaluate whether each constraint preserves residue equality in either family.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each constraint pair, compute $(x_{i,1}+y_{i,1})-(x_{i,2}+y_{i,2}) \bmod 3$ and $(x_{i,1}-y_{i,1})-(x_{i,2}-y_{i,2}) \bmod 3$.
\item The sum-family is valid iff all sum-differences are $0 \bmod 3$.
\item The diff-family is valid iff all diff-differences are $0 \bmod 3$.
\item If either family is valid, answer YES; otherwise NO.
\end{algosteps}
\COMPLEXITY{Linear in $k$. No dependence on $n,m$ beyond reading input.}
\[
\begin{aligned}
T(n,m,k) &= O(k),\qquad S(n,m,k)=O(1).
\end{aligned}
\]
\CORRECTNESS{In the sum-family, equality holds exactly for anti-diagonally adjacent pairs, which is characterized by equal $(i+j)\bmod 3$. In the diff-family, equality holds exactly for main-diagonally adjacent pairs, which is characterized by equal $(i-j)\bmod 3$. Since constraints demand equality, checking residue equality for all constraints precisely decides feasibility.}
\EDGECASES{No constraints ($k=0$) gives YES. If both diagonal types appear among constraints, neither family can satisfy all simultaneously, so answer is NO.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        pairs = []
        for _ in range(k):
            x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
            pairs.append((x1, y1, x2, y2))
        cases.append((n, m, k, pairs))
    return cases

def solve_case(case):
    n, m, k, pairs = case
    def can_sum():
        for x1, y1, x2, y2 in pairs:
            if ((x1 + y1) - (x2 + y2)) % 3 != 0:
                return False
        return True
    def can_diff():
        for x1, y1, x2, y2 in pairs:
            if ((x1 - y1) - (x2 - y2)) % 3 != 0:
                return False
        return True
    return "YES" if (can_sum() or can_diff()) else "NO"

def solve_all(cases):
    return [solve_case(c) for c in cases]

def main():
    cases = read_input()
    if not cases:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

# --- tests (deterministic) ---
def _unit_tests():
    # NO: both diagonals constrained in the single 2x2
    case1 = (2, 2, 2, [(1, 1, 2, 2), (1, 2, 2, 1)])
    assert solve_case(case1) == "NO"
    # YES: only anti-diagonal equality needed
    case2 = (3, 3, 1, [(1, 2, 2, 1)])
    assert solve_case(case2) == "YES"
    # YES: only main-diagonal equality needed
    case3 = (3, 5, 2, [(1, 1, 2, 2), (2, 3, 3, 4)])
    assert solve_case(case3) == "YES"

if __name__ == "__main__":
    _unit_tests()
    main()
\end{minted}
\VALIDATION{Checked three asserts:
\begin{bullets}
\item Mixing both diagonals implies NO.
\item Pure anti-diagonal constraints imply YES.
\item Pure main-diagonal constraints imply YES.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Observe that constraints only demand equality along one of two diagonals. A single pass to detect whether both diagonal types appear suffices: if both appear, answer NO; else YES.}
\ASSUMPTIONS{Each constraint is either main-diagonal $(+1,+1)$ or anti-diagonal $(+1,-1)$ by problem guarantee.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize flags has\_main and has\_anti to False.
\item For each constraint, compute $\Delta y=y_{i,2}-y_{i,1}$.
\item If $\Delta y=+1$, set has\_main=True; if $\Delta y=-1$, set has\_anti=True.
\item If both flags are True, return NO; else YES.
\end{algosteps}
\COMPLEXITY{Single pass over $k$ constraints.}
\[
\begin{aligned}
T(n,m,k) &= O(k),\quad S(n,m,k)=O(1).
\end{aligned}
\]
\CORRECTNESS{Sum-family equals anti-diagonal pairs and forbids main-diagonal equality; diff-family equals main-diagonal pairs and forbids anti-diagonal equality. If constraints require both, no great grid exists. If only one type is required, choose the corresponding family and any letter permutation; all constraints are satisfied.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        pairs = []
        for _ in range(k):
            x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
            pairs.append((x1, y1, x2, y2))
        cases.append((n, m, k, pairs))
    return cases

def solve_case(case):
    n, m, k, pairs = case
    has_main = False  # dy = +1
    has_anti = False  # dy = -1
    for x1, y1, x2, y2 in pairs:
        dy = y2 - y1
        if dy == 1:
            has_main = True
        elif dy == -1:
            has_anti = True
        else:
            # Per problem, this shouldn't happen; if it does, it's invalid.
            return "NO"
        if has_main and has_anti:
            return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(c) for c in cases]

def main():
    cases = read_input()
    if not cases:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

# --- tests (deterministic) ---
def _unit_tests():
    # NO: both diagonal types present
    case1 = (2, 2, 2, [(1, 1, 2, 2), (1, 2, 2, 1)])
    assert solve_case(case1) == "NO"
    # YES: only anti-diagonal constraints
    case2 = (3, 3, 1, [(1, 2, 2, 1)])
    assert solve_case(case2) == "YES"
    # YES: only main-diagonal constraints
    case3 = (4, 4, 3, [(1, 1, 2, 2), (2, 2, 3, 3), (1, 3, 2, 4)])
    assert solve_case(case3) == "YES"

if __name__ == "__main__":
    _unit_tests()
    main()
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item Mixture of diagonal types $\Rightarrow$ NO.
\item Only one diagonal type across all constraints $\Rightarrow$ YES.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Characterize great grids as exactly two mod-$3$ families; a single pass over constraints decides feasibility.}
\ASSUMPTIONS{Constraints are diagonal-adjacent pairs as guaranteed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan constraints and set flags has\_main and has\_anti according to $y_{i,2}-y_{i,1} \in \{+1,-1\}$.
\item If both flags are set, output NO.
\item Otherwise, output YES (choose the corresponding family to construct a grid if needed).
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect each constraint at least once; this achieves $O(k)$ time and $O(1)$ memory, which is optimal.}
\COMPLEXITY{Linear in the number of constraints.}
\[
\begin{aligned}
T(n,m,k) &= \Theta(k),\quad S(n,m,k)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        pairs = []
        for _ in range(k):
            x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
            pairs.append((x1, y1, x2, y2))
        cases.append((n, m, k, pairs))
    return cases

def solve_case(case):
    n, m, k, pairs = case
    has_main = False  # pairs with (dx, dy) = (1, +1)
    has_anti = False  # pairs with (dx, dy) = (1, -1)
    for x1, y1, x2, y2 in pairs:
        dy = y2 - y1
        if dy == 1:
            has_main = True
        elif dy == -1:
            has_anti = True
        else:
            return "NO"  # invalid per constraints, but safe-guard
        if has_main and has_anti:
            return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(c) for c in cases]

def main():
    cases = read_input()
    if not cases:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

# --- tests (exactly 3 asserts) ---
def _unit_tests():
    # 1) Mixed constraints: impossible
    case1 = (2, 2, 2, [(1, 1, 2, 2), (1, 2, 2, 1)])
    assert solve_case(case1) == "NO"
    # 2) Only anti-diagonal constraints: possible
    case2 = (3, 3, 2, [(1, 2, 2, 1), (2, 3, 3, 2)])
    assert solve_case(case2) == "YES"
    # 3) Only main-diagonal constraints: possible
    case3 = (5, 4, 1, [(4, 2, 5, 3)])
    assert solve_case(case3) == "YES"

if __name__ == "__main__":
    _unit_tests()
    main()
\end{minted}
\VALIDATION{Three asserts cover mixed-type impossibility and both single-type possibilities.}
\RESULT{Answer YES iff all constraints are along the same diagonal direction across the grid; NO otherwise.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: no constraints; only main-diagonal constraints; only anti-diagonal constraints; mixed constraints; random constraints with enforced single-type.}
\LINE{CROSS-CHECKS}{Compare baseline residue-check vs. improved flag-check on small randomized inputs; they must produce identical YES/NO.}
\LINE{EDGE-CASE GENERATOR}{Creates cases near boundaries $n,m=2$, $k=1$; also maximal $k$ with single-type constraints to ensure linear scan correctness.}
\begin{minted}{python}
import random

def gen_case(n, m, k, mode):
    # mode: "main", "anti", or "mix"
    pairs = []
    used = set()
    while len(pairs) < k:
        x = random.randint(1, n-1)
        y = random.randint(1, m)
        if mode == "main":
            if y == m: 
                continue
            p = (x, y, x+1, y+1)
        elif mode == "anti":
            if y == 1:
                continue
            p = (x, y, x+1, y-1)
        else:  # mix
            if random.choice([True, False]):
                if y == m: 
                    continue
                p = (x, y, x+1, y+1)
            else:
                if y == 1:
                    continue
                p = (x, y, x+1, y-1)
        if p in used:
            continue
        used.add(p)
        pairs.append(p)
    return (n, m, k, pairs)

def reference_solve(case):
    # diagonal-type flag method
    n, m, k, pairs = case
    has_main = any((y2 - y1) == 1 for x1, y1, x2, y2 in pairs)
    has_anti = any((y2 - y1) == -1 for x1, y1, x2, y2 in pairs)
    return "NO" if (has_main and has_anti) else "YES"

def residue_solve(case):
    # baseline residue method
    n, m, k, pairs = case
    ok_sum = all(((x1 + y1) - (x2 + y2)) % 3 == 0 for x1, y1, x2, y2 in pairs)
    ok_diff = all(((x1 - y1) - (x2 - y2)) % 3 == 0 for x1, y1, x2, y2 in pairs)
    return "YES" if (ok_sum or ok_diff) else "NO"

def cross_check():
    for _ in range(200):
        n = random.randint(2, 8)
        m = random.randint(2, 8)
        k = random.randint(1, 20)
        mode = random.choice(["main", "anti", "mix"])
        case = gen_case(n, m, k, mode)
        a = reference_solve(case)
        b = residue_solve(case)
        assert a == b, (case, a, b)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        pairs = []
        for _ in range(k):
            x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
            pairs.append((x1, y1, x2, y2))
        cases.append((n, m, k, pairs))
    return cases

def solve_case(case):
    n, m, k, pairs = case
    has_main = False
    has_anti = False
    for x1, y1, x2, y2 in pairs:
        dy = y2 - y1
        if dy == 1:
            has_main = True
        elif dy == -1:
            has_anti = True
        else:
            return "NO"
        if has_main and has_anti:
            return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(c) for c in cases]

def main():
    cases = read_input()
    if not cases:
        return
    print("\n".join(solve_all(cases)))

# small sanity asserts
def _tests():
    assert solve_case((2, 2, 2, [(1, 1, 2, 2), (1, 2, 2, 1)])) == "NO"
    assert solve_case((3, 3, 1, [(1, 2, 2, 1)])) == "YES"
    assert solve_case((3, 5, 2, [(1, 1, 2, 2), (2, 3, 3, 4)])) == "YES"

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decide if all diagonal-equality constraints align with a single global family of $3$-colorings: sum or difference modulo $3$.}
\WHY{This tests recognizing hidden global structure and reducing constraints to a one-pass feasibility check under tight input bounds.}
\CHECKLIST{
\begin{bullets}
\item Recall two families: $(i+j)\bmod 3$ and $(i-j)\bmod 3$.
\item Equality holds on anti-diagonal for sum-family; on main-diagonal for diff-family.
\item Scan constraints: set has\_main/has\_anti flags.
\item If both flags set $\Rightarrow$ NO; else YES.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $k=0$ always YES.
\item Single constraint anywhere: always YES.
\item All constraints main-diagonal: YES.
\item All constraints anti-diagonal: YES.
\item Mixed diagonals even in disjoint areas: NO.
\item Minimal grid $2\times 2$ with both diagonals required: NO.
\item Large $n,m$ with small $k$: still $O(k)$.
\item Duplicate pair disallowed by input; ignore.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Confusing which diagonal is which: check $y_{2}-y_{1}=\pm 1$.
\item Overcomplicating with graph $3$-coloring; unnecessary.
\item Trying to construct the grid explicitly; wasteful and error-prone.
\item Forgetting modulo behavior if using residue checks.
\item Misreading guarantees ($x_{2}=x_{1}+1$ always).
\item Edge-sharing cells must differ; already enforced by families.
\end{bullets}}
\FAILMODES{Any approach that tries to satisfy both diagonals in any $2\times 2$ block fails because it would require four distinct letters. Our method avoids this by committing to a single family.}
\ELI{There are only two ways to paint the grid with three letters so that every $2\times 2$ has all three letters: by the sum or by the difference of coordinates mod $3$. Each constraint asks for equality on one diagonal; mixing diagonals is impossible, otherwise it is always possible.}
\NotePages{3}

\end{document}