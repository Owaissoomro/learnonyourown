% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Height of Binary Tree After Subtree Removal Queries}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given the \texttt{root} of a binary tree with $n$ nodes. Each node is assigned a unique value from $1$ to $n$. You are also given an array \texttt{queries} of size $m$.\\
You have to perform $m$ independent queries on the tree where in the $i$th query you do the following:
\begin{bullets}
\item Remove the subtree rooted at the node with the value \texttt{queries[i]} from the tree. It is guaranteed that \texttt{queries[i]} will not be equal to the value of the root.
\end{bullets}
Return an array \texttt{answer} of size $m$ where \texttt{answer[i]} is the height of the tree after performing the $i$th query.\\
Note:
\begin{bullets}
\item The queries are independent, so the tree returns to its initial state after each query.
\item The height of a tree is the number of edges in the longest simple path from the root to some node in the tree.
\end{bullets}
Examples:
\begin{bullets}
\item Input: \texttt{root = [1,3,4,2,null,6,5,null,null,null,null,null,7]}, \texttt{queries = [4]}\\
Output: \texttt{[2]}\\
Explanation: After removing the subtree rooted at node $4$, the height is $2$ (the path $1 \to 3 \to 2$).
\item Input: \texttt{root = [5,8,9,2,1,3,7,4,6]}, \texttt{queries = [3,2,4,8]}\\
Output: \texttt{[3,2,3,2]}\\
Explanation: 
\begin{bullets}
\item Removing the subtree rooted at node $3$ $\Rightarrow$ height $=3$ (path $5 \to 8 \to 2 \to 4$).
\item Removing the subtree rooted at node $2$ $\Rightarrow$ height $=2$ (path $5 \to 8 \to 1$).
\item Removing the subtree rooted at node $4$ $\Rightarrow$ height $=3$ (path $5 \to 8 \to 2 \to 6$).
\item Removing the subtree rooted at node $8$ $\Rightarrow$ height $=2$ (path $5 \to 9 \to 3$).
\end{bullets}
\end{bullets}
Constraints:
\begin{bullets}
\item The number of nodes in the tree is $n$.
\item $2 \le n \le 10^5$
\item $1 \le \text{Node.val} \le n$
\item All the values in the tree are unique.
\item $m = \texttt{queries.length}$
\item $1 \le m \le \min(n, 10^4)$
\item $1 \le \texttt{queries[i]} \le n$
\item \texttt{queries[i]} $\ne$ \texttt{root.val}
\end{bullets}}
\BREAKDOWN{Precompute depths and an Euler tour index for each node so that a subtree is a contiguous interval. For each query, the remaining height is the maximum depth among nodes outside that interval. Build solutions from naive scan to segment tree, then an $O(1)$ prefix/suffix method.}
\ELI{Cutting a subtree just removes a consecutive block of nodes in Euler order; the tallest remaining node decides the new height.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method signature: \texttt{treeQueries(self, root: Optional[TreeNode], queries: List[int]) -\textgreater{} List[int]}. Tree nodes have unique values in $[1,n]$.}
\OUTPUTS{For each query value $q$, output the height (in edges) of the tree after removing the subtree rooted at $q$. The queries are independent.}
\SAMPLES{Example 1: \texttt{root = [1,3,4,2,null,6,5,null,null,null,null,null,7]}, \texttt{queries = [4]} $\Rightarrow$ \texttt{[2]}.\\
Example 2: \texttt{root = [5,8,9,2,1,3,7,4,6]}, \texttt{queries = [3,2,4,8]} $\Rightarrow$ \texttt{[3,2,3,2]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a rooted binary tree with root $r$. Define depth $d(v)$ as the number of edges on the path from $r$ to $v$. Run a preorder Euler tour assigning indices $\operatorname{tin}(v)$ on entry and $\operatorname{tout}(v)$ after finishing $v$'s subtree. The subtree of $v$ corresponds to the interval $[\operatorname{tin}(v), \operatorname{tout}(v)]$. For the Euler order array $A$ of nodes and the parallel array $D$ of depths, the height after removing subtree of $q$ is}
\varmapStart
\var{r}{root of the tree}
\var{d(v)}{depth in edges from the root to node $v$}
\var{\operatorname{tin}(v), \operatorname{tout}(v)}{Euler preorder in/out indices}
\var{D[i]}{depth of the node with Euler index $i$}
\var{I_q}{interval $[\operatorname{tin}(q), \operatorname{tout}(q)]$ representing subtree of $q$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{height after removing } q \;=\; \max\{\, D[i] \mid i \notin I_q \,\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Binary tree, unique node values in $[1,n]$. Depth of remaining nodes is unchanged by removing a disjoint subtree. Euler tour uses preorder so that subtrees are contiguous intervals.}
\INVARIANTS{
\begin{bullets}
\item Subtree interval contiguity: $v$'s subtree nodes occupy exactly $[\operatorname{tin}(v), \operatorname{tout}(v)]$.
\item Depth monotonicity along a root path: removing a subtree does not change depths of other nodes.
\item Height equals maximum depth among remaining nodes.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the governing equation directly by scanning all Euler indices and taking the maximum depth outside the removed interval for each query.}
\ASSUMPTIONS{We can preprocess one DFS to build $D$, $\operatorname{tin}$, $\operatorname{tout}$; per query do an $O(n)$ scan.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS once to compute depth $d(v)$ for every node and Euler indices $\operatorname{tin},\operatorname{tout}$; build the depth array $D$ in Euler order.
\item For each query $q$, let $L=\operatorname{tin}(q)$, $R=\operatorname{tout}(q)$; scan all $i$ and track $\max(D[i])$ for $i<L$ or $i>R$.
\item Collect answers in order.
\end{algosteps}
\COMPLEXITY{$O(n)$ preprocessing, then $O(n)$ time per query, $O(n)$ memory.}
\[
\begin{aligned}
T(n,m) &= O(n) + \sum_{i=1}^{m} O(n) \\
       &= O(nm), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{By the invariants, removing $q$ deletes exactly indices in $[\operatorname{tin}(q),\operatorname{tout}(q)]$. The tallest remaining node has depth $\max\{D[i]: i \not\in [L,R]\}$, which we compute by scanning.}
\EDGECASES{When $q$ is the only child of root, the answer is the height contributed by the other branch. When the deepest node lies in the removed interval, the answer becomes the next-best surviving depth or $-1$ if nothing remains (but here $q \ne r$ so at least the root remains and height $\ge 0$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import Optional, List, Deque, Tuple, Dict, Set
from collections import deque

class TreeNode:
    __slots__ = ("val", "left", "right")
    def __init__(self, val: int = 0, left: "Optional[TreeNode]" = None, right: "Optional[TreeNode]" = None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_level(values: List[Optional[int]]) -> Optional[TreeNode]:
    if not values:
        return None
    nodes: List[Optional[TreeNode]] = [TreeNode(v) if v is not None else None for v in values]
    for i, node in enumerate(nodes):
        if node is None:
            continue
        li, ri = 2*i + 1, 2*i + 2
        if li < len(values):
            node.left = nodes[li]
        if ri < len(values):
            node.right = nodes[ri]
    return nodes[0]

class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        # Preprocess: Euler tour (preorder) indices and depths
        order: List[int] = []
        depths: List[int] = []
        tin: Dict[int, int] = {}
        tout: Dict[int, int] = {}
        idx = 0

        def dfs(node: Optional[TreeNode], d: int) -> None:
            nonlocal idx
            if not node:
                return
            tin[node.val] = idx
            order.append(node.val)
            depths.append(d)
            idx += 1
            dfs(node.left, d + 1)
            dfs(node.right, d + 1)
            tout[node.val] = idx - 1

        dfs(root, 0)
        n = len(order)
        ans: List[int] = []
        for q in queries:
            L, R = tin[q], tout[q]
            best = -1
            # Scan left part
            for i in range(0, L):
                if depths[i] > best:
                    best = depths[i]
            # Scan right part
            for i in range(R + 1, n):
                if depths[i] > best:
                    best = depths[i]
            ans.append(best)
        return ans

# Validations (examples)
root1 = build_tree_level([1,3,4,2,None,6,5,None,None,None,None,None,7])
assert Solution().treeQueries(root1, [4]) == [2]
root2 = build_tree_level([5,8,9,2,1,3,7,4,6])
assert Solution().treeQueries(root2, [3,2,4,8]) == [3,2,3,2]
\end{minted}
\VALIDATION{Checks on the two provided examples. Also implicitly checks that the height equals the maximum depth among surviving nodes since the DFS depth starts at $0$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Segment Tree on Euler Depths}
\WHICHFORMULA{Represent the tree as an Euler-order depth array $D$. A subtree removal masks a contiguous interval $[L,R]$. We need $\max(D[0..L\!-\!1], D[R\!+\!1..n\!-\!1])$, which can be answered with two segment tree max-queries per query.}
\ASSUMPTIONS{Single preprocessing DFS builds $D$, $\operatorname{tin}$, $\operatorname{tout}$. A static segment tree supports range-maximum queries in $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS to build Euler preorder index and depths array $D$.
\item Build a segment tree over $D$ for range-maximum queries.
\item For each query $q$ with interval $[L,R]$, compute $\max(\text{RMQ}(0,L\!-\!1), \text{RMQ}(R\!+\!1,n\!-\!1))$ handling empty ranges as $-1$.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n)$, building segment tree $O(n)$, answering each query in $O(\log n)$; total $O(n + m\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n,m) &= O(n) + O(n) + m\cdot O(\log n) \;=\; O(n + m\log n).
\end{aligned}
\]
\CORRECTNESS{Same reasoning as baseline. The segment tree is a faithful max aggregator over any subarray of $D$, so combining the two disjoint ranges yields the correct remaining height.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import Optional, List, Dict

class TreeNode:
    __slots__ = ("val", "left", "right")
    def __init__(self, val: int = 0, left: "Optional[TreeNode]" = None, right: "Optional[TreeNode]" = None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_level(values: List[Optional[int]]) -> Optional[TreeNode]:
    if not values:
        return None
    nodes: List[Optional[TreeNode]] = [TreeNode(v) if v is not None else None for v in values]
    for i, node in enumerate(nodes):
        if node is None:
            continue
        li, ri = 2*i + 1, 2*i + 2
        if li < len(values):
            node.left = nodes[li]
        if ri < len(values):
            node.right = nodes[ri]
    return nodes[0]

class SegTree:
    def __init__(self, arr: List[int]):
        n = 1
        self.N = len(arr)
        while n < self.N:
            n <<= 1
        self.size = n
        self.seg = [-1] * (2 * n)
        # build
        for i in range(self.N):
            self.seg[n + i] = arr[i]
        for i in range(n - 1, 0, -1):
            self.seg[i] = max(self.seg[i << 1], self.seg[i << 1 | 1])

    def range_max(self, l: int, r: int) -> int:
        if l > r or self.N == 0:
            return -1
        l += self.size
        r += self.size
        res = -1
        while l <= r:
            if (l & 1) == 1:
                res = max(res, self.seg[l])
                l += 1
            if (r & 1) == 0:
                res = max(res, self.seg[r])
                r -= 1
            l >>= 1
            r >>= 1
        return res

class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        # Preprocess: Euler preorder and depths
        order: List[int] = []
        depths: List[int] = []
        tin: Dict[int, int] = {}
        tout: Dict[int, int] = {}
        idx = 0

        def dfs(node: Optional[TreeNode], d: int) -> None:
            nonlocal idx
            if not node:
                return
            tin[node.val] = idx
            order.append(node.val)
            depths.append(d)
            idx += 1
            dfs(node.left, d + 1)
            dfs(node.right, d + 1)
            tout[node.val] = idx - 1

        dfs(root, 0)
        st = SegTree(depths)
        n = len(depths)
        ans: List[int] = []
        for q in queries:
            L, R = tin[q], tout[q]
            left = st.range_max(0, L - 1) if L > 0 else -1
            right = st.range_max(R + 1, n - 1) if R + 1 < n else -1
            ans.append(max(left, right))
        return ans

# Validations (examples)
root1 = build_tree_level([1,3,4,2,None,6,5,None,None,None,None,None,7])
assert Solution().treeQueries(root1, [4]) == [2]
root2 = build_tree_level([5,8,9,2,1,3,7,4,6])
assert Solution().treeQueries(root2, [3,2,4,8]) == [3,2,3,2]
\end{minted}
\VALIDATION{Verified on the two examples. Also implicitly tests empty-range handling in RMQ at boundaries.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prefix/Suffix Max over Euler Depths}
\WHICHFORMULA{Precompute prefix and suffix maxima of the Euler-depth array $D$. For $[L,R]$, answer is $\max(\text{pref}[L-1], \text{suf}[R+1])$ with out-of-bounds treated as $-1$. This yields $O(1)$ per query.}
\ASSUMPTIONS{Euler preorder makes each subtree a contiguous interval. Prefix/suffix maxima can be computed in $O(n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS to compute $\operatorname{tin}$, $\operatorname{tout}$, and depths array $D$ in Euler order.
\item Compute arrays $\text{pref}[i]=\max(D[0..i])$ and $\text{suf}[i]=\max(D[i..n-1])$.
\item For each query $q$ with $[L,R]$, return $\max(\text{pref}[L-1] \text{ if } L>0 \text{ else } -1,\ \text{suf}[R+1] \text{ if } R+1<n \text{ else } -1)$.
\end{algosteps}
\OPTIMALITY{Any solution must at least read each query. With $O(n)$ preprocessing, constant time per query is optimal up to lower-order factors for the static offline/online setting.}
\COMPLEXITY{Preprocessing $O(n)$ time, $O(n)$ space; each query answered in $O(1)$ time.}
\[
\begin{aligned}
T(n,m) &= O(n) + O(m), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import Optional, List, Dict

class TreeNode:
    __slots__ = ("val", "left", "right")
    def __init__(self, val: int = 0, left: "Optional[TreeNode]" = None, right: "Optional[TreeNode]" = None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_level(values: List[Optional[int]]) -> Optional[TreeNode]:
    if not values:
        return None
    nodes: List[Optional[TreeNode]] = [TreeNode(v) if v is not None else None for v in values]
    for i, node in enumerate(nodes):
        if node is None:
            continue
        li, ri = 2*i + 1, 2*i + 2
        if li < len(values):
            node.left = nodes[li]
        if ri < len(values):
            node.right = nodes[ri]
    return nodes[0]

class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        order: List[int] = []
        depths: List[int] = []
        tin: Dict[int, int] = {}
        tout: Dict[int, int] = {}
        idx = 0

        def dfs(node: Optional[TreeNode], d: int) -> None:
            nonlocal idx
            if not node:
                return
            tin[node.val] = idx
            order.append(node.val)
            depths.append(d)
            idx += 1
            dfs(node.left, d + 1)
            dfs(node.right, d + 1)
            tout[node.val] = idx - 1

        dfs(root, 0)
        n = len(depths)
        pref = [-1] * n
        suf = [-1] * n
        cur = -1
        for i in range(n):
            if depths[i] > cur:
                cur = depths[i]
            pref[i] = cur
        cur = -1
        for i in range(n - 1, -1, -1):
            if depths[i] > cur:
                cur = depths[i]
            suf[i] = cur

        ans: List[int] = []
        for q in queries:
            L, R = tin[q], tout[q]
            left = pref[L - 1] if L > 0 else -1
            right = suf[R + 1] if R + 1 < n else -1
            ans.append(max(left, right))
        return ans

# Validations (exactly 3 asserts)
root1 = build_tree_level([1,3,4,2,None,6,5,None,None,None,None,None,7])
assert Solution().treeQueries(root1, [4]) == [2]
root2 = build_tree_level([5,8,9,2,1,3,7,4,6])
assert Solution().treeQueries(root2, [3,2,4,8]) == [3,2,3,2]
root3 = build_tree_level([1,2,3,4,5,6,7])
assert Solution().treeQueries(root3, [2,3,4,7]) == [2,2,2,2]
\end{minted}
\VALIDATION{Three asserts: both given examples and a complete binary tree case to check symmetric removals.}
\RESULT{For each query node $q$, we return the maximum depth among nodes outside $q$'s subtree interval in Euler order, which equals the tree height after removing $q$'s subtree.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: provided examples; balanced trees; skewed trees; removals that exclude the deepest node and that remove the deepest node; boundary intervals at the start or end of Euler order.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline ($O(nm)$), Improved ($O(n + m\log n)$), and Optimal ($O(n+m)$) on small random trees to ensure identical answers.}
\LINE{EDGE-CASE GENERATOR}{Generate random trees with $n \in [1,50]$ using level arrays with \texttt{None} gaps; ensure values are unique $1..n$; pick random query sets; verify all approaches agree.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import Optional, List, Dict
import random

class TreeNode:
    __slots__ = ("val", "left", "right")
    def __init__(self, val: int = 0, left: "Optional[TreeNode]" = None, right: "Optional[TreeNode]" = None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_level(values: List[Optional[int]]) -> Optional[TreeNode]:
    if not values:
        return None
    nodes: List[Optional[TreeNode]] = [TreeNode(v) if v is not None else None for v in values]
    for i, node in enumerate(nodes):
        if node is None:
            continue
        li, ri = 2*i + 1, 2*i + 2
        if li < len(values):
            node.left = nodes[li]
        if ri < len(values):
            node.right = nodes[ri]
    return nodes[0]

def euler_depths(root: Optional[TreeNode]):
    tin: Dict[int, int] = {}
    tout: Dict[int, int] = {}
    order: List[int] = []
    depths: List[int] = []
    idx = 0
    def dfs(n: Optional[TreeNode], d: int):
        nonlocal idx
        if not n:
            return
        tin[n.val] = idx
        order.append(n.val)
        depths.append(d)
        idx += 1
        dfs(n.left, d+1)
        dfs(n.right, d+1)
        tout[n.val] = idx-1
    dfs(root, 0)
    return order, depths, tin, tout

def baseline_ans(root: Optional[TreeNode], queries: List[int]) -> List[int]:
    order, depths, tin, tout = euler_depths(root)
    n = len(depths)
    out = []
    for q in queries:
        L, R = tin[q], tout[q]
        best = -1
        for i in range(0, L):
            if depths[i] > best:
                best = depths[i]
        for i in range(R+1, n):
            if depths[i] > best:
                best = depths[i]
        out.append(best)
    return out

class SolutionRef:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        order, depths, tin, tout = euler_depths(root)
        n = len(depths)
        pref = [-1] * n
        suf = [-1] * n
        cur = -1
        for i in range(n):
            if depths[i] > cur:
                cur = depths[i]
            pref[i] = cur
        cur = -1
        for i in range(n-1, -1, -1):
            if depths[i] > cur:
                cur = depths[i]
            suf[i] = cur
        ans = []
        for q in queries:
            L, R = tin[q], tout[q]
            left = pref[L-1] if L > 0 else -1
            right = suf[R+1] if R+1 < n else -1
            ans.append(max(left, right))
        return ans

# Cross-check on a small deterministic tree
root = build_tree_level([1,2,3,4,5,None,7,None,None,9,None,None,None])
queries = [2,3,5,7]
assert baseline_ans(root, queries) == SolutionRef().treeQueries(root, queries)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import Optional, List, Dict

class TreeNode:
    __slots__ = ("val", "left", "right")
    def __init__(self, val: int = 0, left: "Optional[TreeNode]" = None, right: "Optional[TreeNode]" = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        # Euler preorder and depths
        order: List[int] = []
        depths: List[int] = []
        tin: Dict[int, int] = {}
        tout: Dict[int, int] = {}
        idx = 0

        def dfs(node: Optional[TreeNode], d: int) -> None:
            nonlocal idx
            if not node:
                return
            tin[node.val] = idx
            order.append(node.val)
            depths.append(d)
            idx += 1
            dfs(node.left, d + 1)
            dfs(node.right, d + 1)
            tout[node.val] = idx - 1

        dfs(root, 0)
        n = len(depths)
        if n == 0:
            return [0] * len(queries)
        pref = [-1] * n
        suf = [-1] * n
        # prefix max
        cur = -1
        for i in range(n):
            if depths[i] > cur:
                cur = depths[i]
            pref[i] = cur
        # suffix max
        cur = -1
        for i in range(n - 1, -1, -1):
            if depths[i] > cur:
                cur = depths[i]
            suf[i] = cur
        # answer queries
        ans: List[int] = []
        for q in queries:
            L, R = tin[q], tout[q]
            left = pref[L - 1] if L > 0 else -1
            right = suf[R + 1] if R + 1 < n else -1
            ans.append(max(left, right))
        return ans

# Asserts on examples (deterministic)
def build_tree_level(values: List[Optional[int]]) -> Optional[TreeNode]:
    if not values:
        return None
    nodes: List[Optional[TreeNode]] = [TreeNode(v) if v is not None else None for v in values]
    for i, node in enumerate(nodes):
        if node is None:
            continue
        li, ri = 2*i + 1, 2*i + 2
        if li < len(values):
            node.left = nodes[li]
        if ri < len(values):
            node.right = nodes[ri]
    return nodes[0]

root1 = build_tree_level([1,3,4,2,None,6,5,None,None,None,None,None,7])
assert Solution().treeQueries(root1, [4]) == [2]
root2 = build_tree_level([5,8,9,2,1,3,7,4,6])
assert Solution().treeQueries(root2, [3,2,4,8]) == [3,2,3,2]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Subtree removal translates to cutting out a contiguous Euler interval; the remaining height is the max depth outside that interval.}
\WHY{This pattern appears in queries on trees: subtree add/remove, path queries, and is a gateway to heavy-light decomposition and Euler tour tricks.}
\CHECKLIST{
\begin{bullets}
\item Do a single DFS to compute $\operatorname{tin},\operatorname{tout}$ and depths.
\item Build prefix and suffix maxima over depths in Euler order.
\item For each query $q$, compute $L=\operatorname{tin}(q)$, $R=\operatorname{tout}(q)$.
\item Answer is $\max(\text{pref}[L-1], \text{suf}[R+1])$ with boundary checks.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Query subtree at depth $1$ (child of root).
\item Removal interval at beginning ($L=0$) or end ($R=n-1$).
\item Skewed trees (linked list shape).
\item Balanced full trees.
\item When deepest node lies inside the removed subtree.
\item Multiple queries repeating the same node.
\item Tree with only two nodes ($n=2$).
\item Very large $n$ ensuring recursion stack fits (consider iterative DFS in production).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to set $\operatorname{tout}(v)$ after processing children.
\item Mixing 0-based Euler indices with 1-based assumptions.
\item Using node indices instead of node values for $\operatorname{tin}/\operatorname{tout}$ maps.
\item Off-by-one in prefix/suffix boundaries ($L-1$, $R+1$).
\item Confusing node value order with Euler order.
\item Measuring height in nodes instead of edges (depth starts at $0$ at root).
\item Python recursion limit on very deep trees (may need sys.setrecursionlimit in practice).
\item Not handling empty range for RMQ (should yield $-1$).
\end{bullets}
}
\FAILMODES{Approaches that recompute depths after each removal will time out. Approaches that try to remove nodes structurally instead of using Euler ranges are complicated and error-prone. The prefix/suffix method avoids dynamic updates by exploiting independence of queries.}
\ELI{Label nodes in a visiting order where each whole subtree forms one block. Cutting a subtree means skipping that block; the tallest remaining depth outside gives the new height. Precompute tallest-so-far from the left and from the right to answer instantly.}
\NotePages{3}

\end{document}