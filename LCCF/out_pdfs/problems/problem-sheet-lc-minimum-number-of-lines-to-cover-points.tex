% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Number of Lines to Cover Points}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an array \texttt{points} of length $n$, where \texttt{points[i] = [x\_i, y\_i]} are integer coordinates in the 2D plane. A straight line \emph{covers} a point if the point lies on that line. Return the minimum number of straight lines required to cover all the given points.

Conventions and clarifications:
\begin{bullets}
\item A line can be any straight line in the plane with any slope (including vertical).
\item If $n = 0$, the answer is $0$; if $n = 1$, the answer is $1$.
\item It is guaranteed (or you may assume) that points are pairwise distinct; if duplicates appear, treat them as a single point for coverage.
\item A single line may cover one or more points.
\end{bullets}}
\BREAKDOWN{We must choose a smallest set of lines whose union contains all points. The optimal solution only needs to consider lines determined by pairs of points (plus the option to cover a single remaining point with one line). This naturally reduces to a bitmask dynamic programming set cover over subsets of points.}
\ELI{Use as few lines as possible by repeatedly drawing a line through two uncovered points whenever possible; when only one point remains, one line finishes it.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{points} of $n$ integer pairs. Typical constraints for this interview variant:
\begin{bullets}
\item $0 \le n \le 12$ (small enough for bitmask DP).
\item Coordinates satisfy $\lvert x_i\rvert, \lvert y_i\rvert \le 10^9$.
\item Points may be unsorted and distinct.
\end{bullets}}
\OUTPUTS{An integer: the minimum number of straight lines needed to cover all points.}
\SAMPLES{
Example 1: \texttt{points = [[0,0],[1,1],[2,2]]} $\rightarrow$ output \texttt{1}. All three points are collinear.

Example 2: \texttt{points = [[0,0],[1,1],[2,1]]} $\rightarrow$ output \texttt{2}. One line can cover \texttt{[0,0]} and \texttt{[1,1]}, and another line covers \texttt{[2,1]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the universe be $U = \{1,2,\ldots,n\}$ indexing the points. For any pair $(i,j)$ with $i \ne j$, define the set $L_{ij} \subseteq U$ of all indices of points collinear with $i$ and $j$. Also allow singleton sets $\{i\}$ to represent a line drawn to cover only point $i$. The problem is:
\begin{BreakableEquation*}
\text{Minimize } \bigl\lvert \mathcal{S} \bigr\rvert \quad \text{subject to} \quad \bigcup_{S \in \mathcal{S}} S = U, \quad \mathcal{S} \subseteq \{L_{ij} : 1 \le i < j \le n\} \cup \bigl\{\{i\}\bigr\}_{i=1}^n.
\end{BreakableEquation*}}
\varmapStart
\var{n}{number of points}
\var{(x_i,y_i)}{coordinates of the $i$-th point}
\var{U}{index set of all points}
\var{L_{ij}}{set of indices collinear with points $i$ and $j$}
\var{\mathcal{S}}{chosen multiset of lines covering all points}
\var{M}{bitmask representing a subset of points (1 means included)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Objective:} && \min_{\mathcal{S}} \ \bigl\lvert \mathcal{S} \bigr\rvert \\
&\text{Coverage:} && \bigcup_{S \in \mathcal{S}} S = U \\
&\text{Feasible sets:} && S \in \{L_{ij}\}_{1\le i<j\le n} \cup \bigl\{\{i\}\bigr\}_{i=1}^n \\
&\text{Collinearity test:} && (x_j-x_i)(y_k-y_i) = (x_k-x_i)(y_j-y_i).
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Points are distinct; duplicates can be removed without changing the answer.
\item Any optimal solution uses only lines passing through at least two input points, except possibly lines covering a single remaining point.
\item Arithmetic uses exact integer cross products to avoid floating-point error.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item If all points in a subset are collinear, they can be covered by exactly one line.
\item Adding more points never decreases the minimum number of lines.
\item The DP over subsets respects monotonicity: if $A \subseteq B$, then $\text{DP}(A) \le \text{DP}(B)$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Depth-first search over subsets: repeatedly pick the first uncovered point $i$ and try either
(1) covering only $i$ with one line, or
(2) drawing a line through $i$ and some other uncovered $j$ to cover all points collinear with $(i,j)$. Take the minimum over branches.}
\ASSUMPTIONS{No memoization; recompute the covered set for each chosen pair on the fly. Suitable only for very small $n$ (e.g., $n \le 10$) for illustration.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Deduplicate points.
\item If $n \le 1$, return $n$.
\item Recurse on a bitmask of covered points:
\begin{bullets}
\item Find the first uncovered index $i$.
\item Option A: cover only $i$.
\item Option B: for each uncovered $j>i$, compute the set of points collinear with $(i,j)$ and cover them at once.
\end{bullets}
\item Return the minimum lines over all branches.
\end{algosteps}
\COMPLEXITY{Exponential in the worst case; roughly $O(3^n)$ states are explored without memoization due to recomputation. Memory is $O(n)$ for recursion depth.}
\[
\begin{aligned}
T(n) &\approx T(n-1) + \sum_{j} T\bigl(n - \#\text{on line}(i,j)\bigr) \\
&= \text{exponential in } n \text{ (worst case near } 3^n\text{).}
\end{aligned}
\]
\CORRECTNESS{Every solution can be expressed using lines determined by pairs plus singletons; the search enumerates all such choices in a structured manner and takes the minimum, so it finds the optimal number of lines.}
\EDGECASES{
\begin{bullets}
\item $n=0 \Rightarrow 0$.
\item $n=1 \Rightarrow 1$.
\item All points collinear $\Rightarrow 1$.
\item No three points collinear $\Rightarrow \lceil n/2 \rceil$ lines suffice by pairing, and the DFS will find the exact minimum.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def minimumLines(self, points: List[List[int]]) -> int:
        # Deduplicate to be safe
        pts = list(dict.fromkeys(map(tuple, points)))
        n = len(pts)
        if n <= 1:
            return n

        allmask = (1 << n) - 1

        def line_mask(i: int, j: int) -> int:
            xi, yi = pts[i]
            xj, yj = pts[j]
            mask = 0
            for k, (xk, yk) in enumerate(pts):
                if (xj - xi) * (yk - yi) == (xk - xi) * (yj - yi):
                    mask |= (1 << k)
            return mask

        def dfs(mask: int) -> int:
            if mask == allmask:
                return 0
            # pick first uncovered i
            i = 0
            while (mask >> i) & 1:
                i += 1
            # option 1: cover only i
            best = 1 + dfs(mask | (1 << i))
            # option 2: cover i together with j on a line
            for j in range(i + 1, n):
                if ((mask >> j) & 1) == 0:
                    m = line_mask(i, j)
                    best = min(best, 1 + dfs(mask | m))
            return best

        return dfs(0)

# Tiny sanity checks
s = Solution()
assert s.minimumLines([]) == 0
assert s.minimumLines([[0, 0]]) == 1
assert s.minimumLines([[0, 0], [1, 1]]) == 1
assert s.minimumLines([[0, 0], [1, 1], [2, 1]]) == 2
assert s.minimumLines([[0, 0], [1, 1], [2, 2]]) == 1
\end{minted}
\VALIDATION{The asserts cover empty, single, pair, a non-collinear triple needing $2$ lines, and a collinear triple needing $1$ line.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Top-Down DP with Memoization and Precomputed Line Masks}
\WHICHFORMULA{Memoize the DFS on masks and precompute, for each pair $(i,j)$, the bitmask of all points collinear with them to avoid recomputation. This reduces the constant factors and ensures we visit each subproblem once.}
\ASSUMPTIONS{Small $n$ so that $2^n$ memo states are feasible; integer cross products for exact collinearity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Deduplicate points; handle $n \le 1$ as trivial.
\item Precompute \texttt{cover[i][j]} bitmasks for all pairs.
\item Define $f(\text{mask})$ = minimal lines to cover the uncovered points; memoize results.
\item In $f$, pick the first uncovered $i$, try covering only $i$, and also try covering using any pair $(i,j)$; take the minimum.
\end{algosteps}
\COMPLEXITY{At most $2^n$ masks with $O(n)$ transitions per mask, giving $O(n \cdot 2^n)$ or $O(n^2 \cdot 2^n)$ including pair enumeration. Memory $O(2^n)$ for the memo.}
\[
\begin{aligned}
T(n) &\in O\bigl(n^2 \cdot 2^n\bigr), \quad S(n) \in O\bigl(2^n + n^2\bigr).
\end{aligned}
\]
\CORRECTNESS{Same search space as Approach A but with memoization. The precomputed pair masks preserve exact coverage sets; the DP optimal substructure follows from choosing the first uncovered index and optimally covering the rest.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict

class Solution:
    def minimumLines(self, points: List[List[int]]) -> int:
        pts = list(dict.fromkeys(map(tuple, points)))
        n = len(pts)
        if n <= 1:
            return n

        allmask = (1 << n) - 1

        # Precompute cover masks for each pair (i, j)
        cover = [[0] * n for _ in range(n)]
        for i in range(n):
            xi, yi = pts[i]
            for j in range(i + 1, n):
                xj, yj = pts[j]
                m = 0
                for k, (xk, yk) in enumerate(pts):
                    if (xj - xi) * (yk - yi) == (xk - xi) * (yj - yi):
                        m |= (1 << k)
                cover[i][j] = cover[j][i] = m

        from functools import lru_cache

        @lru_cache(maxsize=None)
        def f(mask: int) -> int:
            if mask == allmask:
                return 0
            # pick first uncovered i
            i = 0
            while (mask >> i) & 1:
                i += 1
            best = 1 + f(mask | (1 << i))  # cover only i
            for j in range(i + 1, n):
                if ((mask >> j) & 1) == 0:
                    best = min(best, 1 + f(mask | cover[i][j]))
            return best

        return f(0)

# Checks on edge and typical inputs
s = Solution()
assert s.minimumLines([]) == 0
assert s.minimumLines([[0, 0], [0, 1], [0, 2]]) == 1
assert s.minimumLines([[0, 0], [1, 1], [2, 1], [10, 10]]) == 2
\end{minted}
\VALIDATION{Covers empty, vertical-collinear triple (needs $1$), and a case with one diagonal line covering two points plus a second line for the remaining two, totaling $2$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Bottom-Up Bitmask DP with First-Bit Optimization}
\WHICHFORMULA{Compute dp over all masks of covered points. For each nonzero mask, let $i$ be the least-significant set bit index. Either cover only $i$ or cover $i$ together with any other set bit $j$ by removing the entire collinear set \texttt{cover[i][j]} from the mask. This yields an $O(n^2 2^n)$ bottom-up DP.}
\ASSUMPTIONS{Same as Approach B; we precompute \texttt{cover[i][j]}. Bottom-up ensures deterministic iteration and can be slightly faster in practice.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Deduplicate points; handle trivial $n$.
\item Precompute \texttt{cover[i][j]} masks for all pairs.
\item Initialize \texttt{dp[0] = 0}; for each mask from $1$ to \texttt{allmask}:
\begin{bullets}
\item Let $i$ be the first set bit in \texttt{mask}.
\item Initialize \texttt{dp[mask] = 1 + dp[mask without i]}.
\item For each $j$ set in \texttt{mask} with $j \ne i$, update \texttt{dp[mask] = min(dp[mask], 1 + dp[mask without (mask \& cover[i][j])])}.
\end{bullets}
\item Return \texttt{dp[allmask]}.
\end{algosteps}
\OPTIMALITY{Any optimal solution can start by taking a line that covers the first set bit $i$ in the current mask, either alone or together with some $j$. Trying all such $j$ explores all optimal first moves. The DP ensures globally minimal line count.}
\COMPLEXITY{Precompute \texttt{cover} in $O(n^3)$. DP has $2^n$ states, and each state tries up to $n$ partners $j$, each update is $O(1)$.}
\[
\begin{aligned}
T(n) &\in O(n^3 + n \cdot 2^n) \text{ using first-bit optimization, or } O(n^2 \cdot 2^n) \text{ if scanning pairs,} \\
S(n) &\in O(2^n + n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def minimumLines(self, points: List[List[int]]) -> int:
        # Deduplicate
        pts = list(dict.fromkeys(map(tuple, points)))
        n = len(pts)
        if n <= 1:
            return n

        allmask = (1 << n) - 1

        # Precompute cover masks for each pair (i, j)
        cover = [[0] * n for _ in range(n)]
        for i in range(n):
            xi, yi = pts[i]
            for j in range(i + 1, n):
                xj, yj = pts[j]
                m = 0
                for k, (xk, yk) in enumerate(pts):
                    if (xj - xi) * (yk - yi) == (xk - xi) * (yj - yi):
                        m |= (1 << k)
                cover[i][j] = cover[j][i] = m

        # Bottom-up DP
        dp = [0] * (1 << n)
        for mask in range(1, 1 << n):
            # find least significant set bit index i
            i = (mask & -mask).bit_length() - 1
            # Option 1: cover only i
            best = 1 + dp[mask ^ (1 << i)]
            # Option 2: cover i with any j also in mask
            rem = mask ^ (1 << i)
            jmask = rem
            while jmask:
                j = (jmask & -jmask).bit_length() - 1
                best = min(best, 1 + dp[mask ^ (mask & cover[i][j])])
                jmask ^= (1 << j)
            dp[mask] = best

        return dp[allmask]

# Exactly 3 asserts (mini-tests)
s = Solution()
assert s.minimumLines([[0, 0], [1, 1], [2, 2]]) == 1
assert s.minimumLines([[0, 0], [1, 1], [2, 1]]) == 2
assert s.minimumLines([[0, 0], [1, 0], [2, 0], [0, 1]]) == 2
\end{minted}
\VALIDATION{Three asserts: a collinear triple needs $1$ line; a non-collinear triple needs $2$ lines; a set of four with three collinear points plus one off-line can be covered with $2$ lines.}
\RESULT{Return the minimal number of straight lines covering all points; lines can be arbitrary (including vertical), and duplicates do not increase the count due to deduplication.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover trivial sizes ($n=0,1,2$), all-collinear sets, general position with no three collinear, mixtures of large and small slopes, vertical lines, and stability under duplicates.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (unmemoized) and Approach C (DP) on $n \le 10$ random instances; they must match. Use deterministic seeds for reproducibility.}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate sets (all identical, or identical $x$ or $y$), almost-collinear triples, and random integer grids within small bounds to exercise cross products.}
\begin{minted}{python}
from typing import List
import random

def gen_all_collinear(n: int) -> List[List[int]]:
    # y = 2x + 3
    return [[x, 2*x + 3] for x in range(n)]

def gen_vertical(n: int) -> List[List[int]]:
    # x = 5
    return [[5, y] for y in range(n)]

def gen_no_three_collinear(n: int, seed: int = 0) -> List[List[int]]:
    random.seed(seed)
    pts = set()
    while len(pts) < n:
        pts.add((random.randint(-5, 5), random.randint(-5, 5)))
    return [list(p) for p in pts]

# Reference solution == Approach C
class Solution:
    def minimumLines(self, points: List[List[int]]) -> int:
        pts = list(dict.fromkeys(map(tuple, points)))
        n = len(pts)
        if n <= 1:
            return n
        cover = [[0]*n for _ in range(n)]
        for i in range(n):
            xi, yi = pts[i]
            for j in range(i+1, n):
                xj, yj = pts[j]
                m = 0
                for k, (xk, yk) in enumerate(pts):
                    if (xj - xi) * (yk - yi) == (xk - xi) * (yj - yi):
                        m |= (1 << k)
                cover[i][j] = cover[j][i] = m
        dp = [0]*(1<<n)
        for mask in range(1, 1<<n):
            i = (mask & -mask).bit_length() - 1
            best = 1 + dp[mask ^ (1<<i)]
            rem = mask ^ (1<<i)
            jmask = rem
            while jmask:
                j = (jmask & -jmask).bit_length() - 1
                best = min(best, 1 + dp[mask ^ (mask & cover[i][j])])
                jmask ^= (1 << j)
            dp[mask] = best
        return dp[(1<<n)-1]

# Quick checks
s = Solution()
assert s.minimumLines([]) == 0
assert s.minimumLines([[0,0]]) == 1
assert s.minimumLines([[0,0],[1,1]]) == 1
assert s.minimumLines(gen_all_collinear(6)) == 1
assert s.minimumLines(gen_vertical(5)) == 1
pts = gen_no_three_collinear(6, seed=42)
ans = s.minimumLines(pts)
assert 3 <= ans <= 6  # sanity: at least ceil(n/2)=3, at most n
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumLines(self, points: List[List[int]]) -> int:
        # Remove duplicates to avoid inflating the count
        pts = list(dict.fromkeys(map(tuple, points)))
        n = len(pts)
        if n <= 1:
            return n

        # Precompute masks of points collinear with each pair (i, j)
        cover = [[0] * n for _ in range(n)]
        for i in range(n):
            xi, yi = pts[i]
            for j in range(i + 1, n):
                xj, yj = pts[j]
                m = 0
                for k, (xk, yk) in enumerate(pts):
                    if (xj - xi) * (yk - yi) == (xk - xi) * (yj - yi):
                        m |= (1 << k)
                cover[i][j] = cover[j][i] = m

        # Bottom-up DP over subsets of points
        dp = [0] * (1 << n)
        for mask in range(1, 1 << n):
            i = (mask & -mask).bit_length() - 1  # first set bit index
            # Option: cover only i
            best = 1 + dp[mask ^ (1 << i)]
            # Option: cover i with any j also in mask
            rem = mask ^ (1 << i)
            jmask = rem
            while jmask:
                j = (jmask & -jmask).bit_length() - 1
                best = min(best, 1 + dp[mask ^ (mask & cover[i][j])])
                jmask ^= (1 << j)
            dp[mask] = best

        return dp[(1 << n) - 1]

# Deterministic smoke tests
if __name__ == "__main__":
    s = Solution()
    assert s.minimumLines([]) == 0
    assert s.minimumLines([[0, 0]]) == 1
    assert s.minimumLines([[0, 0], [1, 1]]) == 1
    assert s.minimumLines([[0, 0], [1, 1], [2, 2]]) == 1
    assert s.minimumLines([[0, 0], [1, 1], [2, 1]]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to set cover over lines induced by point pairs; solve with bitmask DP by always including the first uncovered point in a chosen line.}
\WHY{Classic interview DP: subset DP with geometric precomputation; tests collinearity arithmetic and state compression skills.}
\CHECKLIST{
\begin{bullets}
\item Deduplicate points.
\item Precompute pairwise collinear masks via integer cross products.
\item DP over masks: pick first uncovered bit; try singleton and pair lines.
\item Return \texttt{dp[allmask]}.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Empty input $\Rightarrow 0$.
\item Single point $\Rightarrow 1$.
\item All points collinear $\Rightarrow 1$.
\item Vertical lines (undefined slope by division); use cross products.
\item Large coordinates; avoid overflow by using Python integers or 64-bit cross products.
\item Duplicates; remove first.
\item No three collinear; expect near $\lceil n/2 \rceil$.
\item Points arranged in parallel lines.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using floating-point slopes causing precision errors.
\item Forgetting to include the singleton option; may overcount lines or loop.
\item Recomputing collinearity per recursion step; severe time blow-up.
\item Wrong bit manipulations when removing covered points.
\item Mishandling empty or one-point masks.
\item Off-by-one while finding first uncovered bit.
\item Not symmetric \texttt{cover[i][j]} and \texttt{cover[j][i]}.
\item Not deduplicating points leads to unnecessary lines.
\end{bullets}}
\FAILMODES{Greedy strategies that always pick the line passing through the most remaining points can fail: they may block a later perfect pairing and yield a suboptimal total. The DP handles all branches.}
\ELI{Draw lines through pairs of uncovered points to cover as many as possible, and use DP to try all meaningful choices without repetition. This guarantees the smallest number of lines needed to hit every point.}
\NotePages{3}

\end{document}