% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sage's Birthday (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1419/D2}}
\LINE{DIFFICULTY / RATING}{1500}
\STATEMENT{This is the hard version of the problem. The difference between the versions is that in the easy version all prices $a_i$ are different. You can make hacks if and only if you solved both versions of the problem.

Today is Sage's birthday, and she will go shopping to buy ice spheres. All $n$ ice spheres are placed in a row and they are numbered from $1$ to $n$ from left to right. Each ice sphere has a positive integer price. In this version, some prices can be equal.

An ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.

You can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.

Input:
The first line contains a single integer $n$ $(1 \le n \le 10^5)$ — the number of ice spheres in the shop.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ $(1 \le a_i \le 10^9)$ — the prices of ice spheres.

Output:
In the first line print the maximum number of ice spheres that Sage can buy.

In the second line print the prices of ice spheres in the optimal order. If there are several correct answers, you can print any of them.

Note:
In the sample it is not possible to place the ice spheres in any order so that Sage would buy $4$ of them. If the spheres are placed in the order $(3, 1, 4, 2, 4, 2, 5)$, then Sage will buy one sphere for $1$ and two spheres for $2$ each.}
\BREAKDOWN{We want to maximize the number of indices $i$ with $2 \le i \le n-1$ such that $b_i < b_{i-1}$ and $b_i < b_{i+1}$ for a permutation $b$ of the input. Sorting and interleaving small and large values creates many strict valleys; duplicates require careful feasibility checks.}
\ELI{Sort the prices, put the $k$ smallest ones in positions $2,4,\ldots,2k$ and surround each by larger prices; pick the largest feasible $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.
\begin{bullets}
\item $n$ — integer, $1 \le n \le 10^5$.
\item Array $a$ of $n$ integers, $1 \le a_i \le 10^9$.
\end{bullets}
}
\OUTPUTS{
\begin{bullets}
\item First line: integer $k$ — the maximum number of cheap (strict local minimum) spheres achievable.
\item Second line: $n$ integers — one optimal permutation achieving exactly $k$ cheap spheres. Any one is acceptable.
\end{bullets}
}
\SAMPLES{
Example 1
\[
\begin{aligned}
\text{Input:}&\quad 5\\
&\quad 1~5~3~3~7\\
\text{Output:}&\quad 2\\
&\quad 3~1~5~3~7
\end{aligned}
\]
Here positions $2$ and $4$ (values $1$ and $3$) are strictly less than both neighbors.

Example 2
\[
\begin{aligned}
\text{Input:}&\quad 4\\
&\quad 2~2~2~2\\
\text{Output:}&\quad 0\\
&\quad 2~2~2~2
\end{aligned}
\]
All values equal implies no strict local minima.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given multiset $A=\{a_1,\ldots,a_n\}$, find a permutation $b \in A^n$ maximizing the count of indices $i$ with $2 \le i \le n-1$ such that $b_i < b_{i-1}$ and $b_i < b_{i+1}$.}
\varmapStart
\var{n}{number of spheres}
\var{A}{multiset of prices}
\var{b}{output permutation (sequence)}
\var{k}{number of cheap indices in $b$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
k(b) &= \left|\left\{\, i \in \{2,\ldots,n-1\} ~\middle|~ b_i < b_{i-1} \text{ and } b_i < b_{i+1} \,\right\}\right|,\\
k^\star &= \max_{b \text{ is a permutation of } A} k(b).
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based for exposition. Equality does not count as strictly less.}
\INVARIANTS{
\begin{bullets}
\item Any arrangement has at most $\left\lfloor \tfrac{n-1}{2} \right\rfloor$ cheap elements, since cheaps cannot be adjacent.
\item If $s$ is the nondecreasing sort of $A$ and $k$ satisfies $s_i < s_{i+k}$ for all $i=1,\ldots,k$, then placing $s_i$ at positions $2i$ and surrounding by elements from $\{s_{k+1},\ldots,s_n\}$ yields exactly $k$ cheap elements.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try the maximum possible $k=\left\lfloor \tfrac{n-1}{2} \right\rfloor$ and decrease until feasibility holds with the interleaving construction. Feasibility condition: for all $i \in \{1,\ldots,k\}$, $s_i < s_{i+k}$, where $s$ is the sorted array.}
\ASSUMPTIONS{Sorting is allowed. We build $b$ by the canonical weave: big, small, big, small, then append remaining bigs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $a$ into nondecreasing $s$.
\item Set $k \gets \left\lfloor \tfrac{n-1}{2} \right\rfloor$. While some $i \le k$ has $s_i \ge s_{i+k}$, decrement $k$.
\item Construct $b$ as: for $i=1..k$: append $s_{k+i}$, then $s_i$; finally append the remaining $s_{2k+1},\ldots,s_n$.
\end{algosteps}
\COMPLEXITY{Sorting $O(n \log n)$. The linear descent worst-case checks $O(n)$ times, each $O(k) \subseteq O(n)$, so $O(n^2)$ in the worst case. Space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n) + \sum_{t=0}^{O(n)} O(n) \\
     &= O(n^2) \quad \text{(worst case)}.
\end{aligned}
\]
\CORRECTNESS{If $s_i < s_{i+k}$ holds for all $i \le k$, then each small $s_i$ placed at position $2i$ is strictly less than its left neighbor $s_{k+i}$ and right neighbor $s_{k+i+1}$ (or $s_{2k}$ for $i=k$), hence contributes one cheap. Decreasing $k$ until the condition holds yields the maximum feasible by the upper bound $\left\lfloor \tfrac{n-1}{2} \right\rfloor$.}
\EDGECASES{All values equal $\Rightarrow k=0$. $n \le 2 \Rightarrow k=0$. Duplicates near the boundary of the split must satisfy strict inequality.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def count_cheap(arr: List[int]) -> int:
    n = len(arr)
    cnt = 0
    for i in range(1, n - 1):
        if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]:
            cnt += 1
    return cnt

def arrange_baseline(a: List[int]) -> Tuple[int, List[int]]:
    s = sorted(a)
    n = len(s)
    k = (n - 1) // 2
    def can(kv: int) -> bool:
        for i in range(kv):
            if s[i] >= s[i + kv]:
                return False
        return True
    while k > 0 and not can(k):
        k -= 1
    res = []
    bi, si = k, 0
    for i in range(k):
        res.append(s[bi]); bi += 1
        res.append(s[si]); si += 1
    while bi < n:
        res.append(s[bi]); bi += 1
    assert len(res) == n
    assert count_cheap(res) == k
    return k, res

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    return arrange_baseline(a)

def solve_all():
    ni = read_input()
    if ni is None:
        # Self-checks (no stdin): small deterministic tests
        assert arrange_baseline([2,2,2,2])[0] == 0
        k, b = arrange_baseline([1,5,3,3,7])
        assert k == count_cheap(b)
        k2, b2 = arrange_baseline([3,1,4,2,4,2,5])
        assert k2 == count_cheap(b2)
        print("OK")
        return
    n, a = ni
    k, b = solve_case(n, a)
    out = [str(k), " ".join(map(str, b))]
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Baseline prints exact $k$ and a valid arrangement. Deterministic asserts cover equal elements, a mixed multiset, and a sample-like multiset.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Replace the linear descent on $k$ with binary search over $k \in [0, \left\lfloor \tfrac{n-1}{2} \right\rfloor]$ using the same feasibility: $s_i < s_{i+k}$. Construction remains the same.}
\ASSUMPTIONS{The feasibility predicate is monotone in $k$: if some $k$ is feasible, then all smaller $k$ are feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $a$ into $s$.
\item Binary search $k$ in $[0, \left\lfloor \tfrac{n-1}{2} \right\rfloor]$ maximizing $k$ with $s_i < s_{i+k}$ for all $i=1..k$.
\item Construct the interleaved sequence as before.
\end{algosteps}
\COMPLEXITY{Sorting $O(n \log n)$; feasibility check $O(n)$; binary search adds a $\log n$ factor: $O(n \log n)$ total. Space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(\log n)\cdot O(n) = O(n \log n).
\end{aligned}
\]
\CORRECTNESS{Monotonicity holds: if $s_i < s_{i+k}$ for $i \le k$, then for any $k' < k$ we also have $s_i < s_{i+k'}$ for $i \le k'$ by sorted order. Thus binary search finds the maximal feasible $k$. The interleaving proof from Approach A applies unchanged.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def count_cheap(arr: List[int]) -> int:
    n = len(arr)
    return sum(1 for i in range(1, n - 1) if arr[i] < arr[i - 1] and arr[i] < arr[i + 1])

def arrange_binary_search(a: List[int]) -> Tuple[int, List[int]]:
    s = sorted(a)
    n = len(s)
    lo, hi, ans = 0, (n - 1) // 2, 0
    def can(kv: int) -> bool:
        for i in range(kv):
            if s[i] >= s[i + kv]:
                return False
        return True
    while lo <= hi:
        mid = (lo + hi) // 2
        if can(mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    k = ans
    res = []
    bi, si = k, 0
    for i in range(k):
        res.append(s[bi]); bi += 1
        res.append(s[si]); si += 1
    while bi < n:
        res.append(s[bi]); bi += 1
    assert len(res) == n
    assert count_cheap(res) == k
    return k, res

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    return arrange_binary_search(a)

def solve_all():
    ni = read_input()
    if ni is None:
        # Small exhaustive cross-checks vs brute force for n <= 7
        import itertools
        def brute(arr: List[int]) -> int:
            best = 0
            for p in set(itertools.permutations(arr)):
                c = count_cheap(list(p))
                if c > best:
                    best = c
            return best
        tests = [
            [2,2,2,2],
            [1,5,3,3,7],
            [3,1,4,2,4,2,5],
            [1],
            [1,2],
            [1,1,2,2,3,3,3]
        ]
        for t in tests:
            k, b = arrange_binary_search(t)
            assert k == count_cheap(b)
            if len(t) <= 7:
                assert k == brute(t)
        print("OK")
        return
    n, a = ni
    k, b = solve_case(n, a)
    out = [str(k), " ".join(map(str, b))]
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Cross-check on small arrays against brute force optimum; asserts that the constructed sequence has exactly $k$ cheap elements.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search the maximum $k$ with the strict-split condition on the sorted array, then interleave: $s_{k+1}, s_1, s_{k+2}, s_2, \ldots, s_{2k}, s_k$, followed by $s_{2k+1}, \ldots, s_n$.}
\ASSUMPTIONS{Works for all $n \ge 1$ and any multiset of integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort the input into nondecreasing $s$.
\item Binary search $k \in [0, \left\lfloor \tfrac{n-1}{2} \right\rfloor]$ s.t. $\forall i \in \{1,\ldots,k\}: s_i < s_{i+k}$.
\item Output the weaved sequence described above.
\end{algosteps}
\OPTIMALITY{Upper bound is $\left\lfloor \tfrac{n-1}{2} \right\rfloor$. The feasibility predicate is tight: whenever it holds, the construction achieves exactly $k$ cheap elements; when it fails for $k+1$, any arrangement must violate a strict inequality due to duplicates, so $k$ is maximal.}
\COMPLEXITY{Sorting dominates. Binary search does $O(\log n)$ checks, each $O(n)$, hence overall $O(n \log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n \log n), \quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def count_cheap(arr: List[int]) -> int:
    n = len(arr)
    return sum(1 for i in range(1, n - 1) if arr[i] < arr[i - 1] and arr[i] < arr[i + 1])

def arrange_optimal(a: List[int]) -> Tuple[int, List[int]]:
    s = sorted(a)
    n = len(s)
    lo, hi, ans = 0, (n - 1) // 2, 0
    def can(kv: int) -> bool:
        for i in range(kv):
            if s[i] >= s[i + kv]:
                return False
        return True
    while lo <= hi:
        mid = (lo + hi) // 2
        if can(mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    k = ans
    res = []
    bi, si = k, 0
    for i in range(k):
        res.append(s[bi]); bi += 1
        res.append(s[si]); si += 1
    while bi < n:
        res.append(s[bi]); bi += 1
    # Safety: exactly k strict local minima
    assert count_cheap(res) == k
    return k, res

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    return arrange_optimal(a)

def solve_all():
    ni = read_input()
    if ni is None:
        # Exactly 3 mini-tests
        k, b = arrange_optimal([2, 2, 2, 2])
        assert k == 0 and count_cheap(b) == 0
        k, b = arrange_optimal([1, 5, 3, 3, 7])
        assert k == count_cheap(b)
        k, b = arrange_optimal([3, 1, 4, 2, 4, 2, 5])
        assert k == count_cheap(b)
        print("OK")
        return
    n, a = ni
    k, b = solve_case(n, a)
    out = [str(k), " ".join(map(str, b))]
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts on diverse inputs ensure the construction is valid and the count matches.}
\RESULT{Print the maximal number of cheap elements and any one arrangement that attains it.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks for count function; property checks on small arrays versus brute force; random-like deterministic arrays with duplicates; boundary cases $n \in \{1,2\}$.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C outputs on small crafted cases to ensure same $k$ and valid arrangements.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with all equal values, strictly increasing, strictly decreasing, many duplicates, and minimal sizes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
def gens() -> List[List[int]]:
    return [
        [1],
        [1, 2],
        [2, 2, 2, 2],
        [1, 1, 2, 2, 3, 3],
        [5, 4, 3, 2, 1],
        [1, 3, 3, 3, 5, 5, 7],
        [10, 10, 9, 9, 9, 8, 8, 8, 7],
    ]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def count_cheap(arr: List[int]) -> int:
    n = len(arr)
    return sum(1 for i in range(1, n - 1) if arr[i] < arr[i - 1] and arr[i] < arr[i + 1])

def arrange_optimal(a: List[int]) -> Tuple[int, List[int]]:
    s = sorted(a)
    n = len(s)
    lo, hi, ans = 0, (n - 1) // 2, 0
    def can(kv: int) -> bool:
        for i in range(kv):
            if s[i] >= s[i + kv]:
                return False
        return True
    while lo <= hi:
        mid = (lo + hi) // 2
        if can(mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    k = ans
    res = []
    bi, si = k, 0
    for i in range(k):
        res.append(s[bi]); bi += 1
        res.append(s[si]); si += 1
    while bi < n:
        res.append(s[bi]); bi += 1
    assert len(res) == n
    assert count_cheap(res) == k
    return k, res

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    return arrange_optimal(a)

def main():
    ni = read_input()
    if ni is None:
        # Internal tests when no input is provided
        tests = [
            [2, 2, 2, 2],
            [1, 5, 3, 3, 7],
            [3, 1, 4, 2, 4, 2, 5],
        ]
        for t in tests:
            k, b = arrange_optimal(t)
            assert k == count_cheap(b)
        print("OK")
        return
    n, a = ni
    k, b = solve_case(n, a)
    print(k)
    print(*b)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort, binary search the number of valleys $k$ with $s_i < s_{i+k}$, then interleave big and small to realize exactly $k$ cheap elements.}
\WHY{Maximizing strict local minima under reordering is a classic arrangement problem; duplicates require strict inequalities and motivate a feasibility check.}
\CHECKLIST{
\begin{bullets}
\item Sort the array.
\item Binary search $k \in [0, \lfloor (n-1)/2 \rfloor]$ with $s_i < s_{i+k}$.
\item Weave big, small, big, small for $k$ pairs; append remaining bigs.
\item Output $k$ and the permutation.
\item Optional: verify $k$ equals the counted cheaps.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ or $n=2$ implies $k=0$.
\item All values equal $\Rightarrow k=0$.
\item Many duplicates near the split boundary can reduce feasible $k$.
\item Strict inequality required; equality invalidates a valley.
\item Very large $n$; ensure linear-time checks and no quadratic loops in final code.
\item Already sorted increasing or decreasing inputs.
\item When $n$ is odd/even, ensure indices do not run out in weaving.
\item Values at extremes $1$ and $10^9$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using non-strict $<$ vs $\le$ in the feasibility check.
\item Off-by-one in the condition $s_i < s_{i+k}$ (mixing $k$ and $k+1$).
\item Forgetting to ensure right neighbor exists for the last small: require $k \le \lfloor (n-1)/2 \rfloor$.
\item Building the sequence starting with a small value; that cannot be a cheap at position $1$.
\item Misprinting $k$ inconsistent with the final permutation.
\item Not handling $k=0$ gracefully.
\item Overflow of indices when $2k$ approaches $n$.
\item Mutating the original array inadvertently if reuse is needed.
\end{bullets}
}
\FAILMODES{Greedy without feasibility may place equal neighbors around a small, breaking strictness; naive alternating without checking duplicates may overcount. The binary-search feasibility plus weaving avoids these failures.}
\ELI{Pick how many valleys you want, check if the $k$-th smallest is strictly less than the $(2k)$-th smallest for all pairs, then place each small between two bigger numbers. This guarantees exactly that many bargains and no more.}
\NotePages{3}

\end{document}