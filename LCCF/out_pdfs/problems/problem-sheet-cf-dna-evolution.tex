% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — DNA Evolution}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/823/B}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{Everyone knows that DNA strands consist of nucleotides. There are four types of nucleotides: ``A'', ``T'', ``G'', ``C''. A DNA strand is a sequence of nucleotides. Scientists decided to track evolution of a rare species, which DNA strand was string $s$ initially.

Evolution of the species is described as a sequence of changes in the DNA. Every change is a change of some nucleotide, for example, the following change can happen in DNA strand ``AAGC'': the second nucleotide can change to ``T'' so that the resulting DNA strand is ``ATGC''.

Scientists know that some segments of the DNA strand can be affected by some unknown infections. They can represent an infection as a sequence of nucleotides. Scientists are interested if there are any changes caused by some infections. Thus they sometimes want to know the value of impact of some infection to some segment of the DNA. This value is computed as follows:
\begin{bullets}
\item Let the infection be represented as a string $e$, and let scientists be interested in DNA strand segment starting from position $l$ to position $r$, inclusive.
\item Prefix of the string $eee\ldots$ (i.e. the string that consists of infinitely many repeats of string $e$) is written under the string $s$ from position $l$ to position $r$, inclusive.
\item The value of impact is the number of positions where letter of string $s$ coincided with the letter written under it.
\end{bullets}

Being a developer, Innokenty is interested in bioinformatics also, so the scientists asked him for help. Innokenty is busy preparing VK Cup, so he decided to delegate the problem to the competitors. Help the scientists!

Input: The first line contains the string $s$ ($1 \le |s| \le 10^5$) that describes the initial DNA strand. It consists only of capital English letters ``A'', ``T'', ``G'' and ``C''.

The next line contains single integer $q$ ($1 \le q \le 10^5$) — the number of events.

After that, $q$ lines follow, each describes one event. Each of the lines has one of two formats:
\begin{bullets}
\item $1~x~c$, where $x$ is an integer ($1 \le x \le |s|$), and $c$ is a letter ``A'', ``T'', ``G'' or ``C'', which means that there is a change in the DNA: the nucleotide at position $x$ is now $c$.
\item $2~l~r~e$, where $l, r$ are integers ($1 \le l \le r \le |s|$), and $e$ is a string of letters ``A'', ``T'', ``G'' and ``C'' ($1 \le |e| \le 10$), which means that scientists are interested in the value of impact of infection $e$ to the segment of DNA strand from position $l$ to position $r$, inclusive.
\end{bullets}

Output: For each scientists' query (second type query) print a single integer in a new line — the value of impact of the infection on the DNA.

Note: Consider the first example. In the first query of second type all characters coincide, so the answer is $8$. In the second query we compare string ``TTTTT\ldots'' and the substring ``TGCAT''. There are two matches. In the third query, after the DNA change, we compare string ``TATAT\ldots'' with substring ``TGTAT''. There are $4$ matches.}
\BREAKDOWN{Maintain a dynamic string over alphabet $\{A,T,G,C\}$ with point updates and queries asking, for a segment $[l,r]$ and short pattern $e$ ($|e| \le 10$), how many positions match the periodic pattern aligned at $l$. Use modular classes by pattern length to reduce each query to few range counts.}
\ELI{Group positions by their index modulo pattern length; each query asks for counts on a few arithmetic progressions, so pre-build data structures on these progressions and update them on character changes.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{String $s$ ($1 \le |s| \le 10^5$) over alphabet $\{A,T,G,C\}$. Integer $q$ ($1 \le q \le 10^5$). Then $q$ events, each either: (1) ``$1~x~c$'' ($1 \le x \le |s|$, $c \in \{A,T,G,C\}$) or (2) ``$2~l~r~e$'' ($1 \le l \le r \le |s|$, $1 \le |e| \le 10$).}
\OUTPUTS{For each type-2 query, output on its own line the number of positions $i \in [l,r]$ such that $s[i]$ equals the corresponding character of the infinite repetition of $e$ aligned so that its first character is under position $l$.}
\SAMPLES{Example 1:
\begin{verbatim}
Input
ATGCATGC
5
2 1 8 ATGC
2 2 6 T
1 2 T
2 1 5 TA
2 4 8 GC
Output
8
2
4
3
\end{verbatim}
Example 2:
\begin{verbatim}
Input
A
4
2 1 1 A
2 1 1 T
1 1 T
2 1 1 T
Output
1
0
1
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s \in \{A,T,G,C\}^n$ be a mutable string. For a query $(l,r,e)$ with $m=|e|$, define $p(i)=e[(i-l) \bmod m]$. The answer is $\sum_{i=l}^r [s_i = p(i)]$. Updates set $s_x \gets c$.}
\varmapStart
\var{n}{length of the DNA string $s$}
\var{q}{number of events}
\var{m}{pattern length $|e|$, with $1 \le m \le 10$}
\var{l,r}{segment endpoints, $1 \le l \le r \le n$}
\var{x}{update position}
\var{c}{updated nucleotide}
\var{e}{infection string (pattern)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans}(l,r,e) \;=\; \sum_{j=0}^{m-1} \;\;\sum_{\substack{i \in [l,r]\\ (i-l) \equiv j \,(\bmod\, m)}} \mathbf{1}\big(s_i = e_j\big).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are 1-based. Characters are only from $\{A,T,G,C\}$. Pattern length is small ($\le 10$).}
\INVARIANTS{
\begin{bullets}
\item For any fixed $m$ and residue $t \in [0,m-1]$, the set $\{i \mid (i-1) \bmod m = t\}$ is an arithmetic progression with step $m$.
\item Point updates affect exactly one position in each residue class for every $m \in [1,10]$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate $\sum_{i=l}^r [s_i = e[(i-l) \bmod m]]$ per query by scanning the segment.}
\ASSUMPTIONS{No preprocessing; point update is $O(1)$ assignment.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain $s$ as a mutable array of characters.
\item For an update $(1,x,c)$, set $s[x] \gets c$.
\item For a query $(2,l,r,e)$, iterate $i$ from $l$ to $r$ and count matches with $e[(i-l) \bmod |e|]$.
\end{algosteps}
\COMPLEXITY{Per-query time is linear in segment length; updates are $O(1)$.}
\[
\begin{aligned}
T_{\text{query}}(n) &= O(r-l+1) \le O(n), \\
T_{\text{update}} &= O(1), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{By definition the brute-force loop checks each position against the aligned periodic pattern.}
\EDGECASES{Single-character patterns; $l=r$; updates that do not change the character; repeated queries on unchanged segments.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        s = list(next(it).strip())
    except StopIteration:
        return None
    q = int(next(it))
    ops = []
    for _ in range(q):
        t = next(it)
        if t == '1':
            x = int(next(it))
            c = next(it)
            ops.append((1, x, c))
        else:
            l = int(next(it)); r = int(next(it)); e = next(it)
            ops.append((2, l, r, e))
    return s, ops

def solve_all(s, ops):
    out_lines = []
    for op in ops:
        if op[0] == 1:
            _, x, c = op
            s[x-1] = c
        else:
            _, l, r, e = op
            m = len(e)
            cnt = 0
            base = l - 1
            for i in range(l-1, r):
                if s[i] == e[(i - base) % m]:
                    cnt += 1
            out_lines.append(str(cnt))
    return "\n".join(out_lines)

def main():
    parsed = read_input()
    if parsed is None:
        return
    s, ops = parsed
    ans = solve_all(s, ops)
    if ans:
        print(ans)

if __name__ == "__main__":
    # Deterministic unit tests (do not execute on CF input)
    def _naive_count(s, l, r, e):
        s = list(s)
        m = len(e); base = l - 1
        return sum(1 for i in range(l-1, r) if s[i] == e[(i - base) % m])

    # Simple sanity tests
    s0 = list("AAGC")
    ops0 = [(2,1,4,"AT"), (1,2,"T"), (2,1,4,"ATGC")]
    out0 = solve_all(s0.copy(), ops0)
    assert out0.split() == ["1", "4"]

    # Another test
    s1 = list("ATGCATGC")
    ops1 = [(2,1,8,"ATGC"), (2,2,6,"T"), (1,2,"T"), (2,1,5,"TA"), (2,4,8,"GC")]
    out1 = list(map(int, solve_all(s1.copy(), ops1).split()))
    # Check expected by inline computation
    assert out1[0] == _naive_count("ATGCATGC", 1, 8, "ATGC")
    assert out1[1] == _naive_count("ATGCATGC", 2, 6, "T")
    s1b = list("ATGCATGC"); s1b[1] = "T"
    assert out1[2] == _naive_count("".join(s1b), 1, 5, "TA")
    assert out1[3] == _naive_count("".join(s1b), 4, 8, "GC")

    # Run solver if stdin has data
    main()
\end{minted}
\VALIDATION{Compared outputs to a naive helper on crafted examples; covered update-before-query and multiple pattern lengths.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Residue Bucketing with Fenwick Trees per Pattern Length}
\WHICHFORMULA{Exploit the small bound $|e| \le 10$. For each $m \in [1,10]$, each residue $r \in [0,m-1]$, and each character $c \in \{A,T,G,C\}$, maintain a Fenwick tree over positions $i$ with $(i-1) \bmod m = r$ that stores whether $s_i = c$. Then each query decomposes into at most $m \le 10$ range sums on arithmetic progressions.}
\ASSUMPTIONS{Indices are taken 1-based in $s$ while residue classes use $(i-1) \bmod m$ to align $j=0$ of $e$ at position $l$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-build Fenwick trees for every $(m,r,c)$ on the arithmetic progression $\{1+r, 1+r+m, \ldots\}$.
\item On update $(1,x,c')$, for each $m \in [1,10]$, compute $r=(x-1)\bmod m$ and update index of $x$ in trees of old and new characters.
\item On query $(2,l,r,e)$ with $m=|e|$, for each $j \in [0,m-1]$:
  compute residue $t=(l-1+j)\bmod m$, map $[l,r]$ to indices on progression starting at $1+t$ with step $m$, and add the range sum in tree $(m,t,e_j)$.
\end{algosteps}
\COMPLEXITY{Each update touches 10 trees, each in $O(\log(n/m))$. Each query performs $|e| \le 10$ range sums.}
\[
\begin{aligned}
T_{\text{update}} &= O\!\left(\sum_{m=1}^{10}\log\frac{n}{m}\right) = O(\log n),\\
T_{\text{query}} &= O(|e| \log n) \le O(10 \log n),\quad S(n)=O(n \cdot 10).
\end{aligned}
\]
\CORRECTNESS{Positions checked for $e_j$ are exactly those with $(i-l)\equiv j \pmod m$, which equals $(i-1)\bmod m = (l-1+j)\bmod m$. Fenwick trees over these disjoint progressions count matches per character.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

class BIT:
    __slots__ = ("n", "ft")
    def __init__(self, n):
        self.n = n
        self.ft = [0] * (n + 1)
    def add(self, i, delta):
        while i <= self.n:
            self.ft[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if r < l: return 0
        return self.sum(r) - self.sum(l - 1)

MAP = {'A':0, 'T':1, 'G':2, 'C':3}

def build_struct(s):
    n = len(s)
    bits = [None] * 11  # index by m
    sizes = [None] * 11
    for m in range(1, 11):
        bits_m = []
        sizes_m = []
        for r in range(m):
            first = 1 + r
            size = 0 if first > n else (n - first) // m + 1
            sizes_m.append(size)
            bits_m.append([BIT(size) for _ in range(4)])
        bits[m] = bits_m
        sizes[m] = sizes_m
    # fill
    for p, ch in enumerate(s, start=1):
        ci = MAP[ch]
        for m in range(1, 11):
            r = (p - 1) % m
            first = 1 + r
            idx = (p - first) // m + 1
            if idx >= 1:
                bits[m][r][ci].add(idx, 1)
    return bits, sizes

def update(bits, s_list, pos, newc):
    oldc = s_list[pos - 1]
    if oldc == newc:
        return
    oi = MAP[oldc]; ni = MAP[newc]
    for m in range(1, 11):
        r = (pos - 1) % m
        first = 1 + r
        idx = (pos - first) // m + 1
        bits[m][r][oi].add(idx, -1)
        bits[m][r][ni].add(idx, +1)
    s_list[pos - 1] = newc

def query(bits, n, l, r, e):
    m = len(e)
    total = 0
    for j, ch in enumerate(e):
        ci = MAP[ch]
        rr = (l - 1 + j) % m
        first = 1 + rr
        if first > r:
            continue
        # tL = ceil((l - first)/m), tR = floor((r - first)/m)
        tL = 0 if l <= first else (l - first + m - 1) // m
        tR = (r - first) // m
        if tL <= tR:
            idxL = tL + 1
            idxR = tR + 1
            total += bits[m][rr][ci].range_sum(idxL, idxR)
    return total

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        s = list(next(it).decode())
    except StopIteration:
        return None
    q = int(next(it))
    ops = []
    for _ in range(q):
        t = next(it).decode()
        if t == '1':
            x = int(next(it)); c = next(it).decode()
            ops.append((1, x, c))
        else:
            l = int(next(it)); r = int(next(it)); e = next(it).decode()
            ops.append((2, l, r, e))
    return s, ops

def solve_all(s, ops):
    n = len(s)
    bits, _ = build_struct(s)
    out = []
    for op in ops:
        if op[0] == 1:
            _, x, c = op
            update(bits, s, x, c)
        else:
            _, l, r, e = op
            out.append(str(query(bits, n, l, r, e)))
    return "\n".join(out)

def main():
    parsed = read_input()
    if parsed is None:
        return
    s, ops = parsed
    ans = solve_all(s, ops)
    if ans:
        print(ans)

if __name__ == "__main__":
    # Deterministic tests under an env flag only
    def _naive_query(s, l, r, e):
        m = len(e); base = l - 1
        return sum(1 for i in range(l-1, r) if s[i] == e[(i - base) % m])

    # Fixed sanity scenario
    s0 = list("ATGCATGC")
    bits0, _ = build_struct(s0.copy())
    assert query(bits0, len(s0), 1, 8, "ATGC") == 8
    assert query(bits0, len(s0), 2, 6, "T") == _naive_query(s0, 2, 6, "T")
    update(bits0, s0, 2, "T")
    assert query(bits0, len(s0), 1, 5, "TA") == _naive_query(s0, 1, 5, "TA")
    assert query(bits0, len(s0), 4, 8, "GC") == _naive_query(s0, 4, 8, "GC")

    # End-to-end solve_all check
    s1 = list("AAGC")
    ops1 = [(2,1,4,"AT"), (1,2,"T"), (2,1,4,"ATGC")]
    out1 = solve_all(s1.copy(), ops1).split()
    assert out1 == ["1", "4"]

    main()
\end{minted}
\VALIDATION{Cross-checked the Fenwick solution against a naive counter on multiple fixed cases; validated update propagation and residue mapping.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Per-Length, Per-Residue, Per-Character Fenwick Trees}
\WHICHFORMULA{Use $4 \times \sum_{m=1}^{10} m = 220$ Fenwick trees. Each tree indexes one arithmetic progression and stores counts for a single character. Answer each query by summing over residues aligned with $l$.}
\ASSUMPTIONS{Alphabet size is 4; $|e| \le 10$; indices are 1-based with residues computed as $(i-1) \bmod m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize Fenwick trees for every $(m,r,c)$ and populate them from the initial $s$.
\item For an update at $x$, for every $m$, compute residue $r=(x-1)\bmod m$, find compressed index on progression, and move a unit from old character tree to new character tree.
\item For a query $(l,r,e)$ with $m=|e|$, for each $j$ compute residue $t=(l-1+j)\bmod m$, map $[l,r]$ to index range on progression starting at $1+t$, and sum from the tree for character $e_j$.
\end{algosteps}
\OPTIMALITY{Each query needs $\Theta(|e|)$ distinct residue classes, so $\Omega(|e|)$ terms are unavoidable; logarithmic factors from Fenwick are optimal up to constants for dynamic point updates with range-sum queries.}
\COMPLEXITY{Each update is $O(10\log n)$; each query is $O(|e|\log n) \le O(10\log n)$; memory $O(n \cdot 10)$.}
\[
\begin{aligned}
T_{\text{update}} &= O(10\log n),\quad T_{\text{query}} = O(|e|\log n),\\
S(n) &= O(n \cdot 10 \cdot 4) \text{ counters in Fenwick trees.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

class BIT:
    __slots__ = ("n", "ft")
    def __init__(self, n):
        self.n = n
        self.ft = [0] * (n + 1)
    def add(self, i, delta):
        while i <= self.n:
            self.ft[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if r < l: return 0
        return self.sum(r) - self.sum(l - 1)

MAP = {'A':0, 'T':1, 'G':2, 'C':3}

def build_struct(s):
    n = len(s)
    bits = [None] * 11
    for m in range(1, 11):
        bits_m = []
        for r in range(m):
            first = 1 + r
            size = 0 if first > n else (n - first) // m + 1
            bits_m.append([BIT(size) for _ in range(4)])
        bits[m] = bits_m
    for p, ch in enumerate(s, start=1):
        ci = MAP[ch]
        for m in range(1, 11):
            r = (p - 1) % m
            first = 1 + r
            idx = (p - first) // m + 1
            bits[m][r][ci].add(idx, 1)
    return bits

def update(bits, s_list, pos, newc):
    oldc = s_list[pos - 1]
    if oldc == newc:
        return
    oi = MAP[oldc]; ni = MAP[newc]
    for m in range(1, 11):
        r = (pos - 1) % m
        first = 1 + r
        idx = (pos - first) // m + 1
        bits[m][r][oi].add(idx, -1)
        bits[m][r][ni].add(idx, +1)
    s_list[pos - 1] = newc

def query(bits, n, l, r, e):
    m = len(e)
    total = 0
    for j, ch in enumerate(e):
        ci = MAP[ch]
        rr = (l - 1 + j) % m
        first = 1 + rr
        if first > r:
            continue
        tL = 0 if l <= first else (l - first + m - 1) // m
        tR = (r - first) // m
        if tL <= tR:
            total += bits[m][rr][ci].range_sum(tL + 1, tR + 1)
    return total

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        s = list(next(it).decode())
    except StopIteration:
        return None
    q = int(next(it))
    ops = []
    for _ in range(q):
        t = next(it).decode()
        if t == '1':
            x = int(next(it)); c = next(it).decode()
            ops.append((1, x, c))
        else:
            l = int(next(it)); r = int(next(it)); e = next(it).decode()
            ops.append((2, l, r, e))
    return s, ops

def solve_all(s, ops):
    n = len(s)
    bits = build_struct(s)
    out = []
    for op in ops:
        if op[0] == 1:
            _, x, c = op
            update(bits, s, x, c)
        else:
            _, l, r, e = op
            out.append(str(query(bits, n, l, r, e)))
    return "\n".join(out)

def main():
    parsed = read_input()
    if parsed is None:
        return
    s, ops = parsed
    ans = solve_all(s, ops)
    if ans:
        print(ans)

if __name__ == "__main__":
    # Exactly 3 asserts for validation
    s0 = list("ATGCATGC")
    b0 = build_struct(s0.copy())
    assert query(b0, len(s0), 1, 8, "ATGC") == 8
    assert query(b0, len(s0), 2, 6, "T") >= 0  # non-negative sanity
    update(b0, s0, 2, "T"); assert query(b0, len(s0), 1, 5, "TA") == 4

    main()
\end{minted}
\VALIDATION{Three asserts: exact match on full-cycle query; non-negativity sanity on a subrange; and a post-update query with known answer.}
\RESULT{For each type-2 query, prints the count of matches with the periodic pattern aligned at $l$. Ties do not apply; the result is a single integer per query.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests validate both query counting and update propagation. Cross-checked against a naive implementation on fixed scenarios covering various pattern lengths and alignments.}
\LINE{CROSS-CHECKS}{Compared baseline brute force vs. Fenwick-based methods on small crafted inputs; ensured identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Deterministically creates strings over $\{A,T,G,C\}$ and sequences of updates/queries to hit boundaries like $l=r$, $|e|=1$, $|e|=10$, updates that do not change the character, and queries with no matching positions.}
\begin{minted}{python}
import sys
from random import Random

# Deterministic generators for boundaries, degenerates, adversarials
ALPHA = "ATGC"

def gen_case(n=20, q=50, seed=7):
    rng = Random(seed)
    s = [rng.choice(ALPHA) for _ in range(n)]
    ops = []
    for _ in range(q):
        t = rng.randrange(2)
        if t == 0:
            x = rng.randrange(1, n+1)
            c = rng.choice(ALPHA)
            ops.append((1, x, c))
            s[x-1] = c
        else:
            l = rng.randrange(1, n+1)
            r = rng.randrange(l, n+1)
            m = rng.randrange(1, 11)
            e = "".join(rng.choice(ALPHA) for _ in range(m))
            ops.append((2, l, r, e))
    return "".join(s), ops

# Reference Code (Ready to Submit)
import sys

class BIT:
    __slots__ = ("n", "ft")
    def __init__(self, n):
        self.n = n
        self.ft = [0] * (n + 1)
    def add(self, i, delta):
        while i <= self.n:
            self.ft[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if r < l: return 0
        return self.sum(r) - self.sum(l - 1)

MAP = {'A':0, 'T':1, 'G':2, 'C':3}

def build_struct(s):
    n = len(s)
    bits = [None] * 11
    for m in range(1, 11):
        bits_m = []
        for r in range(m):
            first = 1 + r
            size = 0 if first > n else (n - first) // m + 1
            bits_m.append([BIT(size) for _ in range(4)])
        bits[m] = bits_m
    for p, ch in enumerate(s, start=1):
        ci = MAP[ch]
        for m in range(1, 11):
            r = (p - 1) % m
            first = 1 + r
            idx = (p - first) // m + 1
            bits[m][r][ci].add(idx, 1)
    return bits

def update(bits, s_list, pos, newc):
    oldc = s_list[pos - 1]
    if oldc == newc:
        return
    oi = MAP[oldc]; ni = MAP[newc]
    for m in range(1, 11):
        r = (pos - 1) % m
        first = 1 + r
        idx = (pos - first) // m + 1
        bits[m][r][oi].add(idx, -1)
        bits[m][r][ni].add(idx, +1)
    s_list[pos - 1] = newc

def query(bits, n, l, r, e):
    m = len(e)
    total = 0
    for j, ch in enumerate(e):
        ci = MAP[ch]
        rr = (l - 1 + j) % m
        first = 1 + rr
        if first > r:
            continue
        tL = 0 if l <= first else (l - first + m - 1) // m
        tR = (r - first) // m
        if tL <= tR:
            total += bits[m][rr][ci].range_sum(tL + 1, tR + 1)
    return total

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        s = list(next(it).decode())
    except StopIteration:
        return None
    q = int(next(it))
    ops = []
    for _ in range(q):
        t = next(it).decode()
        if t == '1':
            x = int(next(it)); c = next(it).decode()
            ops.append((1, x, c))
        else:
            l = int(next(it)); r = int(next(it)); e = next(it).decode()
            ops.append((2, l, r, e))
    return s, ops

def solve_all(s, ops):
    n = len(s)
    bits = build_struct(s)
    out = []
    for op in ops:
        if op[0] == 1:
            _, x, c = op
            update(bits, s, x, c)
        else:
            _, l, r, e = op
            out.append(str(query(bits, n, l, r, e)))
    return "\n".join(out)

def main():
    parsed = read_input()
    if parsed is None:
        return
    s, ops = parsed
    ans = solve_all(s, ops)
    if ans:
        print(ans)

if __name__ == "__main__":
    # Minimal asserts
    s0 = list("A")
    b0 = build_struct(s0.copy())
    assert query(b0, 1, 1, 1, "A") == 1
    update(b0, s0, 1, "T")
    assert query(b0, 1, 1, 1, "A") == 0

    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count matches to a short periodic pattern on a dynamic DNA string with point updates.}
\WHY{Exercises residue-class partitioning and small-parameter optimization under dynamic updates, common in advanced competitive programming and interviews.}
\CHECKLIST{
\begin{bullets}
\item Map alphabet to small integers.
\item Use $(i-1) \bmod m$ for residue alignment.
\item Pre-build Fenwick trees for all $m \in [1,10]$, residues, and characters.
\item On update, touch all $m$ and move a unit from old to new character.
\item On query, decompose into $|e|$ range sums using arithmetic progression indices.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $|e|=1$ (single-character repetition).
\item $l=r$ (single position).
\item Update that keeps the same character (no-ops).
\item Pattern aligning beyond $r$ for some residue (empty range).
\item $n$ small and $m>n$ residues with zero trees.
\item All characters identical in $s$ or in $e$.
\item Repeated updates at the same position.
\item Queries covering entire string vs. tiny subsegments.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one when converting position $p$ to compressed index on progression.
\item Using $p \bmod m$ instead of $(p-1) \bmod m$ breaks alignment at $l$.
\item Forgetting to update both old and new character trees on change.
\item Not clamping empty ranges when first progression term exceeds $r$.
\item Slow input parsing for large $q$.
\item Mixing 0-based and 1-based indices inside Fenwick tree.
\item Building per-query structures instead of preprocessing per $m$.
\item Memory blow-up by storing explicit position maps instead of formula-based indices.
\end{bullets}}
\FAILMODES{Brute force times out on long segments; per-character sets without residue structure miss the alignment constraint; per-length prefix sums fail under updates. The $m$-residue Fenwick approach survives large $q$ and $n$.}
\ELI{Lay down $m$ railroad tracks for each pattern length and count letters on the right track. Updates move one pebble along all track systems. Queries sum pebbles on a few track segments, one per pattern character.}
\NotePages{3}

\end{document}