% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lena and Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1689/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Lena is a beautiful girl who likes logical puzzles.

As a gift for her birthday, Lena got a matrix puzzle!

The matrix consists of $n$ rows and $m$ columns, and each cell is either black or white. The coordinates $(i,j)$ denote the cell which belongs to the $i$-th row and $j$-th column for every $1\le i \le n$ and $1\le j \le m$. To solve the puzzle, Lena has to choose a cell that minimizes the Manhattan distance to the farthest black cell from the chosen cell.

More formally, let there be $k \ge 1$ black cells in the matrix with coordinates $(x_i,y_i)$ for every $1\le i \le k$. Lena should choose a cell $(a,b)$ that minimizes
\begin{BreakableEquation*}
\max_{i=1}^{k}\bigl(\lvert a-x_i\rvert+\lvert b-y_i\rvert\bigr).
\end{BreakableEquation*}

As Lena has no skill, she asked you for help. Will you tell her the optimal cell to choose?

Input:
There are several test cases in the input data. The first line contains a single integer $t$ ($1\le t\le 10{,}000$) — the number of test cases. This is followed by the test cases description.

The first line of each test case contains two integers $n$ and $m$ ($2\le n,m \le 1000$) — the dimensions of the matrix.

The following $n$ lines contain $m$ characters each, each character is either \texttt{W} or \texttt{B}. The $j$-th character in the $i$-th of these lines is \texttt{W} if the cell $(i,j)$ is white, and \texttt{B} if the cell $(i,j)$ is black.

It is guaranteed that at least one black cell exists.

It is guaranteed that the sum of $n\cdot m$ does not exceed $10^6$.

Output:
For each test case, output the optimal cell $(a,b)$ to choose. If multiple answers exist, output any.

Note:
In the first test case the two black cells have coordinates $(1,1)$ and $(3,2)$. The four optimal cells are $(1,2)$, $(2,1)$, $(2,2)$ and $(3,1)$. It can be shown that no other cell minimizes the maximum Manhattan distance to every black cell.

In the second test case it is optimal to choose the black cell $(2,2)$ with maximum Manhattan distance being $2$.}
\BREAKDOWN{We must find, for each test, a cell minimizing the maximum Manhattan distance to all black cells. The key is that the farthest distance from a point $(a,b)$ to a set of points under Manhattan metric can be expressed using extrema of $x+y$ and $x-y$ over black cells, enabling an $O(nm)$ scan.}
\ELI{Rotate the grid by $45^\circ$: then you only need the min and max of $x{+}y$ and $x{-}y$ of black cells to evaluate any candidate, so scan all cells and pick the best.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.

- $t$: integer, number of tests, $1\le t\le 10{,}000$.

For each test:

- $n,m$: integers, $2\le n,m\le 1000$; total $\sum nm \le 10^6$.

- A grid of $n$ lines, each of length $m$, characters in $\{\texttt{W},\texttt{B}\}$. At least one \texttt{B} exists.}
\OUTPUTS{For each test case, print two integers $a~b$ ($1\le a\le n$, $1\le b\le m$): any cell minimizing $\max_i \bigl(\lvert a-x_i\rvert+\lvert b-y_i\rvert\bigr)$.}
\SAMPLES{Example 1:

Input
\begin{verbatim}
1
3 3
BWW
WWW
WBW
\end{verbatim}
One valid output
\begin{verbatim}
2 2
\end{verbatim}

Example 2:

Input
\begin{verbatim}
1
2 3
BWW
WWW
\end{verbatim}
Output
\begin{verbatim}
1 1
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given black cell set $P=\{(x_i,y_i)\}_{i=1}^k \subset \{1,\ldots,n\}\times\{1,\ldots,m\}$, find
\begin{BreakableEquation*}
(a^*,b^*) \in \arg\min_{(a,b)\in [n]\times[m]}~ \max_{1\le i\le k} \bigl(\lvert a-x_i\rvert+\lvert b-y_i\rvert\bigr).
\end{BreakableEquation*}
Let $S_i=x_i+y_i$, $D_i=x_i-y_i$, and define $S_{\min}=\min_i S_i$, $S_{\max}=\max_i S_i$, $D_{\min}=\min_i D_i$, $D_{\max}=\max_i D_i$.}
\varmapStart
\var{n,m}{grid dimensions}
\var{(x_i,y_i)}{$i$-th black cell coordinates (1-indexed)}
\var{(a,b)}{candidate cell}
\var{S_i, D_i}{rotated coordinates: $S_i=x_i+y_i$, $D_i=x_i-y_i$}
\var{S_{\min},S_{\max},D_{\min},D_{\max}}{extrema of $S_i$ and $D_i$ over black cells}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{cost}(a,b)=\max\bigl\{(a{+}b)-S_{\min},~S_{\max}-(a{+}b),~(a{-}b)-D_{\min},~D_{\max}-(a{-}b)\bigr\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{At least one black cell exists. Grid indices are 1-indexed. Any minimizing $(a,b)$ is acceptable.}
\INVARIANTS{For any fixed set $P$, the function $\text{cost}(a,b)$ is convex in the $L_\infty$ sense over the rotated coordinates $(a{+}b,a{-}b)$. The extrema $S_{\min},S_{\max},D_{\min},D_{\max}$ suffice to evaluate $\text{cost}(a,b)$ for any $(a,b)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute, for each cell $(a,b)$, the maximum Manhattan distance to all black cells by scanning the full black list. Choose the cell with minimal maximum.}
\ASSUMPTIONS{Suitable only for very small grids; serves as a correctness baseline and unit-test oracle.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse grid; collect coordinates of all black cells into a list $P$.
\item For every $(a,b)$ in the $n\times m$ grid, compute $\max_{(x,y)\in P} \lvert a-x\rvert+\lvert b-y\rvert$.
\item Keep the $(a,b)$ that yields the smallest value; break ties arbitrarily.
\end{algosteps}
\COMPLEXITY{Time $T(n,m,k)=\Theta(nmk)$, where $k$ is the number of black cells; space $S(n,m,k)=\Theta(k)$.}
\[
\begin{aligned}
T(n,m,k) &= \sum_{a=1}^{n}\sum_{b=1}^{m}\sum_{i=1}^{k} 1 \\
         &= n\cdot m\cdot k~.
\end{aligned}
\]
\CORRECTNESS{By definition, evaluating the exact maximum distance for every candidate cell and choosing the minimum yields an optimal answer.}
\EDGECASES{Single black cell; all cells black; thin rectangles; multiple optimal cells.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, int, List[str]]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = []
        for _ in range(n):
            row = list(next(it).strip())
            assert len(row) == m
            grid.append(''.join(row))
        tests.append((n, m, grid))
    return t, tests

def solve_case_baseline(n: int, m: int, grid: List[str]) -> Tuple[int, int]:
    blacks: List[Tuple[int, int]] = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                blacks.append((i + 1, j + 1))
    assert blacks, "At least one black cell must exist"
    best = (10**18, 1, 1)
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            worst = 0
            for (x, y) in blacks:
                d = abs(a - x) + abs(b - y)
                if d > worst:
                    worst = d
                    # small pruning: if already worse than best, we can break
                    if worst >= best[0]:
                        break
            if worst < best[0]:
                best = (worst, a, b)
    return best[1], best[2]

def solve_all_baseline() -> None:
    t, tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        a, b = solve_case_baseline(n, m, grid)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _test_baseline_small():
    # single black
    n, m = 2, 3
    grid = ["BWW", "WWW"]
    a, b = solve_case_baseline(n, m, grid)
    assert (a, b) == (1, 1)
    # two blacks; acceptable set
    n, m = 3, 3
    grid = ["BWW", "WWW", "WBW"]
    a, b = solve_case_baseline(n, m, grid)
    assert (a, b) in {(1, 2), (2, 1), (2, 2), (3, 1)}
    # all black: any is fine, cost 0 at all cells
    n, m = 2, 2
    grid = ["BB", "BB"]
    a, b = solve_case_baseline(n, m, grid)
    assert 1 <= a <= 2 and 1 <= b <= 2

def main():
    # Prefer optimized in final submission; this baseline main is for completeness.
    solve_all_baseline()

if __name__ == "__main__":
    # Run lightweight unit tests only when in interactive TTY to avoid interfering with judges.
    if sys.stdin.isatty():
        _test_baseline_small()
        print("OK")
    else:
        main()
\end{minted}
\VALIDATION{Compared against hand-computed tiny cases. For larger instances, use this as an oracle to cross-check the optimized method on random small grids.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the identity that for any $(a,b)$, the farthest Manhattan distance to the set of black cells equals the maximum of four linear forms derived from the extrema of $x{+}y$ and $x{-}y$ over black cells:
\begin{BreakableEquation*}
\text{cost}(a,b)=\max\bigl\{(a{+}b)-S_{\min},~S_{\max}-(a{+}b),~(a{-}b)-D_{\min},~D_{\max}-(a{-}b)\bigr\}.
\end{BreakableEquation*}
Thus, after one pass to compute these extrema, we can evaluate each cell in $O(1)$ and scan all cells.}
\ASSUMPTIONS{Grid indices are 1-indexed; at least one black cell exists.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan the grid; for each black cell $(i,j)$ compute $S=i{+}j$ and $D=i{-}j$. Track $S_{\min},S_{\max},D_{\min},D_{\max}$.
\item For each cell $(a,b)$, compute $s=a{+}b$, $d=a{-}b$, and evaluate $\text{cost}(a,b)$ via the four-term max above.
\item Return the $(a,b)$ with minimal cost; break ties arbitrarily (first encountered).
\end{algosteps}
\COMPLEXITY{One pass to get extrema $O(nm)$; one scan to evaluate all candidates $O(nm)$. Total $T(n,m)=\Theta(nm)$; space $O(1)$ beyond input.}
\[
\begin{aligned}
T(n,m) &= \underbrace{nm}_{\text{extrema}} + \underbrace{nm}_{\text{scan}} = 2nm = \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{For any fixed set $P$, the farthest distance from $(a,b)$ equals the maximum of distances to the four extreme supporting lines in the rotated coordinates. This equivalence follows from the convexity of the $L_1$ ball and the fact that the support in directions $(\pm 1,\pm 1)$ is realized by extrema of $x{+}y$ and $x{-}y$. Minimizing over $(a,b)$ on the grid via exhaustive scan thus finds an optimal cell.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, int, List[str]]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = []
        for _ in range(n):
            row = list(next(it).strip())
            assert len(row) == m
            grid.append(''.join(row))
        tests.append((n, m, grid))
    return t, tests

def solve_case_optimized(n: int, m: int, grid: List[str]) -> Tuple[int, int]:
    INF = 10**18
    smin, smax = INF, -INF
    dmin, dmax = INF, -INF
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                S = (i + 1) + (j + 1)
                D = (i + 1) - (j + 1)
                if S < smin: smin = S
                if S > smax: smax = S
                if D < dmin: dmin = D
                if D > dmax: dmax = D
    # At least one black cell guaranteed
    best_cost, best_a, best_b = INF, 1, 1
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            s = a + b
            d = a - b
            cost = max(s - smin, smax - s, d - dmin, dmax - d)
            if cost < best_cost:
                best_cost, best_a, best_b = cost, a, b
    return best_a, best_b

def solve_all_optimized() -> None:
    t, tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        a, b = solve_case_optimized(n, m, grid)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _test_optimized_matches_baseline():
    # small random-like deterministic grids
    cases = []
    cases.append((2, 3, ["BWW", "WWW"]))
    cases.append((3, 3, ["BWW", "WWW", "WBW"]))
    cases.append((2, 2, ["BB", "BB"]))
    for (n, m, g) in cases:
        a1, b1 = solve_case_optimized(n, m, g)
        # Brute force to verify optimality
        def brute(n, m, grid):
            blacks = []
            for i in range(n):
                for j in range(m):
                    if grid[i][j] == 'B':
                        blacks.append((i + 1, j + 1))
            best = (10**18, 1, 1)
            for a in range(1, n + 1):
                for b in range(1, m + 1):
                    worst = 0
                    for (x, y) in blacks:
                        worst = max(worst, abs(a - x) + abs(b - y))
                    if worst < best[0]:
                        best = (worst, a, b)
            return best[1], best[2], best[0]
        a2, b2, c2 = brute(n, m, g)
        # Ensure optimized is at least as good as brute optimum
        def cost_at(a, b, grid):
            blacks = []
            for i in range(n):
                for j in range(m):
                    if grid[i][j] == 'B':
                        blacks.append((i + 1, j + 1))
            return max(abs(a - x) + abs(b - y) for (x, y) in blacks)
        assert cost_at(a1, b1, g) == c2

def main():
    solve_all_optimized()

if __name__ == "__main__":
    if sys.stdin.isatty():
        _test_optimized_matches_baseline()
        print("OK")
    else:
        main()
\end{minted}
\VALIDATION{Cross-check the optimized answer versus brute force on small crafted cases; assert that the achieved cost equals the brute-force optimal cost.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use rotated-coordinate extrema. The optimal minimax radius equals
\begin{BreakableEquation*}
R^*=\min_{(a,b)} \max\{(a{+}b){-}S_{\min},~S_{\max}{-}(a{+}b),~(a{-}b){-}D_{\min},~D_{\max}{-}(a{-}b)\}.
\end{BreakableEquation*}
Scanning $(a,b)$ over the grid in $O(nm)$ attains the minimum.}
\ASSUMPTIONS{At least one black cell exists. Ties among optimal cells can be broken arbitrarily.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S_{\min},S_{\max},D_{\min},D_{\max}$ over black cells.
\item For each $(a,b)$, compute $s=a{+}b$, $d=a{-}b$, and evaluate the four-term max as the candidate radius.
\item Pick $(a,b)$ with smallest radius; output it.
\end{algosteps}
\OPTIMALITY{The unit balls in $L_1$ are diamonds whose support functions are realized in directions $(\pm 1,\pm 1)$. The farthest distance to a set is the maximum over supports, hence determined by the extrema of $x{+}y$ and $x{-}y$. Minimizing that convex piecewise-linear function over the discrete grid by exhaustive scan yields a global minimizer.}
\COMPLEXITY{$T(n,m)=\Theta(nm)$ time and $O(1)$ extra space beyond input.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, int, List[str]]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = []
        for _ in range(n):
            row = list(next(it).strip())
            assert len(row) == m
            grid.append(''.join(row))
        tests.append((n, m, grid))
    return t, tests

def solve_case(n: int, m: int, grid: List[str]) -> Tuple[int, int]:
    INF = 10**18
    smin, smax = INF, -INF
    dmin, dmax = INF, -INF
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                S = (i + 1) + (j + 1)
                D = (i + 1) - (j + 1)
                if S < smin: smin = S
                if S > smax: smax = S
                if D < dmin: dmin = D
                if D > dmax: dmax = D
    best_cost, best_a, best_b = INF, 1, 1
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            s = a + b
            d = a - b
            cost = max(s - smin, smax - s, d - dmin, dmax - d)
            if cost < best_cost:
                best_cost, best_a, best_b = cost, a, b
    return best_a, best_b

def solve_all() -> None:
    t, tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        a, b = solve_case(n, m, grid)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _tests():
    # Test 1: single black
    a, b = solve_case(2, 3, ["BWW", "WWW"])
    assert (a, b) == (1, 1)
    # Test 2: two blacks at (1,1) and (3,2)
    a, b = solve_case(3, 3, ["BWW", "WWW", "WBW"])
    assert (a, b) in {(1, 2), (2, 1), (2, 2), (3, 1)}
    # Test 3: all black (any is fine, ensure radius 0)
    def radius(n, m, grid, a, b):
        blacks = []
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 'B':
                    blacks.append((i + 1, j + 1))
        return max(abs(a - x) + abs(b - y) for (x, y) in blacks)
    a, b = solve_case(2, 2, ["BB", "BB"])
    assert radius(2, 2, ["BB", "BB"], a, b) == 0

def main():
    solve_all()

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
        print("OK")
    else:
        main()
\end{minted}
\VALIDATION{Exactly three asserts: single black; two black cells example (accepts any of the four); all black grid yields radius $0$.}
\RESULT{Outputs any optimal cell $(a,b)$. If multiple cells are optimal, the earliest encountered in row-major order is printed by the provided implementation.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on crafted grids; property check by comparing optimized versus brute force on small random-like cases; edge cases such as all black, single black, thin rectangles.}
\LINE{CROSS-CHECKS}{For small $n,m\le 4$, generate random grids with at least one \texttt{B}; compare results and costs from baseline and optimized solvers; assert equal minimal cost.}
\LINE{EDGE-CASE GENERATOR}{Generate minimal $2\times 2$ and $2\times 3$ grids; force blacks at corners, center, and edges to exercise extrema in $S$ and $D$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import sys

def gen_all_2x2_cases() -> List[List[str]]:
    grids = []
    base = ["WW", "WW"]
    # place blacks in all non-empty subsets deterministically
    cells = [(0,0),(0,1),(1,0),(1,1)]
    for mask in range(1, 1 << 4):
        g = [list(r) for r in base]
        for b in range(4):
            if (mask >> b) & 1:
                i, j = cells[b]
                g[i][j] = 'B'
        grids.append([''.join(r) for r in g])
    return grids

def solve_case(n: int, m: int, grid: List[str]) -> Tuple[int, int]:
    INF = 10**18
    smin, smax = INF, -INF
    dmin, dmax = INF, -INF
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                S = (i + 1) + (j + 1)
                D = (i + 1) - (j + 1)
                if S < smin: smin = S
                if S > smax: smax = S
                if D < dmin: dmin = D
                if D > dmax: dmax = D
    best_cost, best_a, best_b = INF, 1, 1
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            s = a + b
            d = a - b
            cost = max(s - smin, smax - s, d - dmin, dmax - d)
            if cost < best_cost:
                best_cost, best_a, best_b = cost, a, b
    return best_a, best_b

def brute_cost(n: int, m: int, grid: List[str], a: int, b: int) -> int:
    blacks = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                blacks.append((i + 1, j + 1))
    return max(abs(a - x) + abs(b - y) for (x, y) in blacks)

def brute_best(n: int, m: int, grid: List[str]) -> Tuple[int, int, int]:
    blacks = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                blacks.append((i + 1, j + 1))
    best = (10**9, 1, 1)
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            worst = 0
            for (x, y) in blacks:
                worst = max(worst, abs(a - x) + abs(b - y))
            if worst < best[0]:
                best = (worst, a, b)
    return best

def cross_check():
    for grid in gen_all_2x2_cases():
        a, b = solve_case(2, 2, grid)
        w, aa, bb = brute_best(2, 2, grid)
        # Ensure optimal cost is achieved
        assert brute_cost(2, 2, grid, a, b) == w
    # Additional crafted case
    a, b = solve_case(3, 3, ["BWW", "WWW", "WBW"])
    assert (a, b) in {(1, 2), (2, 1), (2, 2), (3, 1)}

if __name__ == "__main__":
    if sys.stdin.isatty():
        cross_check()
        print("TESTS OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, int, List[str]]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = []
        for _ in range(n):
            row = list(next(it).strip())
            assert len(row) == m
            grid.append(''.join(row))
        tests.append((n, m, grid))
    return t, tests

def solve_case(n: int, m: int, grid: List[str]) -> Tuple[int, int]:
    INF = 10**18
    smin, smax = INF, -INF
    dmin, dmax = INF, -INF
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                S = (i + 1) + (j + 1)
                D = (i + 1) - (j + 1)
                if S < smin: smin = S
                if S > smax: smax = S
                if D < dmin: dmin = D
                if D > dmax: dmax = D
    best_cost, best_a, best_b = INF, 1, 1
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            s = a + b
            d = a - b
            cost = max(s - smin, smax - s, d - dmin, dmax - d)
            if cost < best_cost:
                best_cost, best_a, best_b = cost, a, b
    return best_a, best_b

def solve_all() -> None:
    t, tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        a, b = solve_case(n, m, grid)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _tests():
    # Simple self-checks
    a, b = solve_case(2, 3, ["BWW", "WWW"])
    assert (a, b) == (1, 1)
    a, b = solve_case(3, 3, ["BWW", "WWW", "WBW"])
    assert (a, b) in {(1, 2), (2, 1), (2, 2), (3, 1)}
    # All black -> radius 0 at any cell, check returned cell is in range
    a, b = solve_case(2, 2, ["BB", "BB"])
    assert 1 <= a <= 2 and 1 <= b <= 2

def main():
    solve_all()

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
        print("OK")
    else:
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the farthest Manhattan distance to black cells by scanning all cells with a constant-time cost function derived from extrema of $x{+}y$ and $x{-}y$.}
\WHY{Classic $L_1$ minimax center on a grid; appears in interviews to test geometric transforms and reducing from naive $O(nmk)$ to $O(nm)$.}
\CHECKLIST{Compute $S_{\min},S_{\max},D_{\min},D_{\max}$; iterate cells; evaluate four-term max; track argmin; output 1-indexed coordinates.}
\EDGECASES{Single black cell; all cells black; narrow grids (e.g., $2\times 1000$); multiple optimal answers; black cells only on one row or one column; extremes near corners; large $n\cdot m$ close to $10^6$.}
\PITFALLS{Off-by-one indexing; forgetting to 1-index coordinates; not initializing extrema with $\pm\infty$; using slow brute force for large inputs; mishandling ties; reading input lines with spaces; miscomputing $D=i{-}j$ sign; integer overflow not an issue in Python but is in fixed-width languages.}
\FAILMODES{Brute force times out when $k$ and $nm$ are large; nearest-black BFS solves a different problem; choosing midpoints of $S$ and $D$ without grid bounds or parity handling can pick out-of-range or invalid cells. The scan-based extrema method avoids these.}
\ELI{Turn the grid $45^\circ$ by using $x{+}y$ and $x{-}y$. The farthest black from any cell is controlled by the farthest extremes along these two axes. Compute those four numbers once, then pick the cell that balances them best.}
\NotePages{3}

\end{document}