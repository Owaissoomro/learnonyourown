% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Two Heaps}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/353/B}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Valera has $2\cdot n$ cubes, each cube contains an integer from $10$ to $99$. He arbitrarily chooses $n$ cubes and puts them in the first heap. The remaining cubes form the second heap.

Valera decided to play with cubes. During the game he takes a cube from the first heap and writes down the number it has. Then he takes a cube from the second heap and write out its two digits near two digits he had written (to the right of them). In the end he obtained a single four-digit integer — the first two digits of it is written on the cube from the first heap, and the second two digits of it is written on the second cube from the second heap.

Valera knows arithmetic very well. So, he can easily count the number of distinct four-digit numbers he can get in the game. The other question is: how to split cubes into two heaps so that this number (the number of distinct four-digit integers Valera can get) will be as large as possible?

Input:
The first line contains integer $n$ ($1 \le n \le 100$). The second line contains $2\cdot n$ space-separated integers $a_i$ ($10 \le a_i \le 99$), denoting the numbers on the cubes.

Output:
In the first line print a single number — the maximum possible number of distinct four-digit numbers Valera can obtain. In the second line print $2\cdot n$ numbers $b_i$ ($1 \le b_i \le 2$). The numbers mean: the $i$-th cube belongs to the $b_i$-th heap in your division.

If there are multiple optimal ways to split the cubes into the heaps, print any of them.

Note:
In the first test case Valera can put the first cube in the first heap, and second cube — in second heap. In this case he obtain number $1099$. If he put the second cube in the first heap, and the first cube in the second heap, then he can obtain number $9910$. In both cases the maximum number of distinct integers is equal to one.

In the second test case Valera can obtain numbers $1313$, $1345$, $2413$, $2445$. Note, that if he put the first and the third cubes in the first heap, he can obtain only two numbers $1324$ and $1345$.}
\BREAKDOWN{We must partition the $2n$ cubes into two heaps of size $n$ to maximize the number of distinct concatenations $100\cdot x+y$ where $x$ comes from heap 1 and $y$ from heap 2. This equals the product of the counts of distinct values appearing in each heap. Distribute duplicates across heaps and balance singletons.}
\ELI{Maximize distinct prefixes times distinct suffixes: put one copy of each duplicate value in both heaps, and alternate singletons to balance.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ — integer, $1 \le n \le 100$.
\item Sequence $a_1,\ldots,a_{2n}$ — integers, $10 \le a_i \le 99$.
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item First line: integer $M$ — the maximum possible number of distinct four-digit numbers.
\item Second line: $2n$ integers $b_1,\ldots,b_{2n}$ where $b_i \in \{1,2\}$ indicating the heap of the $i$-th cube. Any optimal assignment is acceptable.
\end{bullets}}
\SAMPLES{Example 1
\[
\begin{aligned}
n&=1,\\
a&=[10,\,99]
\end{aligned}
\]
A valid optimal output (one of many):
\begin{BreakableEquation*}
M=1,\quad b=[1,\,2].
\end{BreakableEquation*}
Example 2
\[
\begin{aligned}
n&=2,\\
a&=[13,\,24,\,13,\,45]
\end{aligned}
\]
A valid optimal output:
\begin{BreakableEquation*}
M=4,\quad b=[1,\,2,\,2,\,1].
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_{2n}\}$ be the multiset of two-digit numbers. Partition indices into $H_1,H_2$ with $|H_1|=|H_2|=n$. Define $P=\{a_i:i\in H_1\}$ and $S=\{a_i:i\in H_2\}$ as sets of distinct values in each heap. The number of distinct four-digit results equals $|P|\cdot|S|$. Maximize $|P|\cdot|S|$.}
\varmapStart
\var{n}{half the number of cubes}
\var{a_i}{number on the $i$-th cube}
\var{H_1,H_2}{index sets forming the two heaps}
\var{P,S}{sets of distinct values in $H_1$ and $H_2$}
\var{D_v}{multiplicity of value $v$ in the input}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\max_{H_1\sqcup H_2=[2n],\,|H_1|=|H_2|=n}\; f(H_1,H_2),\quad f(H_1,H_2)=|P|\cdot|S|,\quad P=\{a_i:i\in H_1\},\; S=\{a_i:i\in H_2\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Concatenation $100x+y$ is injective in pair $(x,y)$ for two-digit $x,y$, hence no collisions. Distinct count per heap is at most its size: $|P|\le n$, $|S|\le n$.}
\INVARIANTS{
\begin{bullets}
\item Splitting a value $v$ with $D_v\ge 2$ across both heaps increases both $|P|$ and $|S|$ by $1$.
\item Assigning a singleton value affects exactly one of $|P|,|S|$ by $+1$.
\item For fixed $|P|+|S|=T$, the product $|P|\cdot|S|$ is maximized when $|P|,|S|$ are as balanced as possible (by AM-GM or convexity).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all ways to select $n$ indices into heap 1 (the rest go to heap 2), compute $|P|\cdot|S|$, and take the maximum.}
\ASSUMPTIONS{Feasible only for tiny $n$ due to $\binom{2n}{n}$ growth. Useful for validation on small cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate all $\binom{2n}{n}$ subsets (or backtrack) to assign heaps.
\item For each assignment, compute $|P|,|S|$ and product.
\item Track the best product and an associated assignment.
\end{algosteps}
\COMPLEXITY{Exponential time; polynomial space.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(\binom{2n}{n}\cdot n\big)\,,\quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{Exhaustive search guarantees the maximum by definition.}
\EDGECASES{All equal values; all distinct values; extreme $n=1$ and $n=100$ (not runnable by brute force for large $n$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys
import io
from itertools import combinations

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(2*n)]
    return n, a

def distinct_product(a: List[int], assign: List[int]) -> Tuple[int, int, int]:
    # assign[i] in {1,2}
    p = set()
    s = set()
    for i, side in enumerate(assign):
        if side == 1:
            p.add(a[i])
        else:
            s.add(a[i])
    return len(p)*len(s), len(p), len(s)

def brute_solve(n: int, a: List[int]) -> Tuple[int, List[int]]:
    m = 2*n
    best_prod = -1
    best_assign = None
    idx = list(range(m))
    for comb in combinations(idx, n):
        assign = [2]*m
        for i in comb:
            assign[i] = 1
        prod, _, _ = distinct_product(a, assign)
        if prod > best_prod:
            best_prod = prod
            best_assign = assign[:]
    return best_prod, best_assign

def solve_all():
    n, a = read_input()
    # For safety on large n, fall back to greedy if n > 12.
    if n <= 12:
        prod, assign = brute_solve(n, a)
    else:
        prod, assign = greedy_solve(n, a)
        # Recompute product to ensure consistency.
        prod2, _, _ = distinct_product(a, assign)
        assert prod == prod2
    out = []
    out.append(str(prod))
    out.append(" ".join(str(x) for x in assign))
    sys.stdout.write("\n".join(out))

def greedy_solve(n: int, a: List[int]) -> Tuple[int, List[int]]:
    from collections import defaultdict
    m = 2*n
    pos: Dict[int, List[int]] = defaultdict(list)
    for i, v in enumerate(a):
        pos[v].append(i)
    assign = [0]*m
    # Track counts and current distincts
    c1 = c2 = 0
    d1 = d2 = 0
    extras: List[int] = []
    singles: List[int] = []
    # First, split duplicates
    for v, lst in pos.items():
        if len(lst) >= 2:
            i1, i2 = lst[0], lst[1]
            assign[i1] = 1; c1 += 1; d1 += 1
            assign[i2] = 2; c2 += 1; d2 += 1
            for k in lst[2:]:
                extras.append(k)
        else:
            singles.append(lst[0])
    # Assign singles, balancing distincts and respecting capacity
    toggle = 0
    for i in singles:
        if c1 == n:
            assign[i] = 2; c2 += 1; d2 += 1
        elif c2 == n:
            assign[i] = 1; c1 += 1; d1 += 1
        else:
            if d1 < d2:
                assign[i] = 1; c1 += 1; d1 += 1
            elif d2 < d1:
                assign[i] = 2; c2 += 1; d2 += 1
            else:
                if toggle == 0:
                    assign[i] = 1; c1 += 1; d1 += 1
                else:
                    assign[i] = 2; c2 += 1; d2 += 1
                toggle ^= 1
    # Fill remaining with extras
    for i in extras:
        if c1 < n:
            assign[i] = 1; c1 += 1
        else:
            assign[i] = 2; c2 += 1
    assert c1 == n and c2 == n
    prod, _, _ = distinct_product(a, assign)
    return prod, assign

def main():
    if sys.stdin.isatty():
        # Self-tests
        def run_io(inp: str) -> str:
            backup_stdin, backup_stdout = sys.stdin, sys.stdout
            sys.stdin = io.StringIO(inp)
            sys.stdout = io.StringIO()
            try:
                solve_all()
                return sys.stdout.getvalue()
            finally:
                sys.stdin, sys.stdout = backup_stdin, backup_stdout

        # Tiny tests for brute and greedy agreement
        out = run_io("1\n10 99\n").strip().splitlines()
        assert int(out[0]) == 1
        b = list(map(int, out[1].split()))
        assert sorted(b) == [1,2]
        out = run_io("2\n13 24 13 45\n").strip().splitlines()
        assert int(out[0]) == 4
        b = list(map(int, out[1].split()))
        assert b.count(1) == b.count(2) == 2
        out = run_io("2\n55 55 55 55\n").strip().splitlines()
        assert int(out[0]) == 1
        b = list(map(int, out[1].split()))
        assert b.count(1) == b.count(2) == 2
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts verify product correctness and heap sizes on small crafted cases, including all distinct, all equal, and mixed duplicates.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Distribute Duplicates, Balance Singletons}
\WHICHFORMULA{Since the number of distinct four-digit outcomes is $|P|\cdot|S|$, we want both $|P|$ and $|S|$ as large and balanced as possible. Splitting duplicates across heaps increases both; assign singletons to the side with fewer distincts.}
\ASSUMPTIONS{No collisions in concatenations; capacities $|H_1|=|H_2|=n$ must be respected while assigning.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group indices by value $v$.
\item For each $v$ with multiplicity $\ge 2$, put one occurrence in heap 1 and one in heap 2; add remaining occurrences to an extras list.
\item Collect singleton indices and assign them one by one to the heap with currently fewer distinct values (break ties by alternating), while not exceeding capacity.
\item Fill remaining capacity with extras arbitrarily (they do not change distinct counts).
\item Output the product $|P|\cdot|S|$ and the assignment.
\end{algosteps}
\COMPLEXITY{Linear in input size.}
\[
\begin{aligned}
T(n) &= \Theta(n)\quad\text{over }2n\text{ items},\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Every duplicate value contributes to both $|P|$ and $|S|$ when split, which is always optimal. Singletons can increase only one side; by convexity, distributing them to balance $|P|$ and $|S|$ maximizes the product. Capacity constraints are maintained by capping assignments per heap at $n$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys, io

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(2*n)]
    return n, a

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    from collections import defaultdict
    m = 2*n
    pos: Dict[int, List[int]] = defaultdict(list)
    for i, v in enumerate(a):
        pos[v].append(i)
    assign = [0]*m
    c1 = c2 = 0
    d1 = d2 = 0
    extras: List[int] = []
    singles: List[int] = []
    for v, lst in pos.items():
        if len(lst) >= 2:
            i1, i2 = lst[0], lst[1]
            assign[i1] = 1; c1 += 1; d1 += 1
            assign[i2] = 2; c2 += 1; d2 += 1
            for k in lst[2:]:
                extras.append(k)
        else:
            singles.append(lst[0])
    toggle = 0
    for i in singles:
        if c1 == n:
            assign[i] = 2; c2 += 1; d2 += 1
        elif c2 == n:
            assign[i] = 1; c1 += 1; d1 += 1
        else:
            if d1 < d2:
                assign[i] = 1; c1 += 1; d1 += 1
            elif d2 < d1:
                assign[i] = 2; c2 += 1; d2 += 1
            else:
                if toggle == 0:
                    assign[i] = 1; c1 += 1; d1 += 1
                else:
                    assign[i] = 2; c2 += 1; d2 += 1
                toggle ^= 1
    for i in extras:
        if c1 < n:
            assign[i] = 1; c1 += 1
        else:
            assign[i] = 2; c2 += 1
    assert c1 == n and c2 == n
    # Compute product
    pset = set(a[i] for i in range(m) if assign[i] == 1)
    sset = set(a[i] for i in range(m) if assign[i] == 2)
    prod = len(pset) * len(sset)
    return prod, assign

def solve_all():
    n, a = read_input()
    prod, assign = solve_case(n, a)
    print(prod)
    print(" ".join(map(str, assign)))

def main():
    if sys.stdin.isatty():
        # Tests
        def run_io(inp: str) -> str:
            backup_stdin, backup_stdout = sys.stdin, sys.stdout
            sys.stdin = io.StringIO(inp)
            sys.stdout = io.StringIO()
            try:
                solve_all()
                return sys.stdout.getvalue()
            finally:
                sys.stdin, sys.stdout = backup_stdin, backup_stdout

        out = run_io("1\n10 99\n").strip().splitlines()
        assert int(out[0]) == 1
        b = list(map(int, out[1].split()))
        assert b.count(1) == 1 and b.count(2) == 1

        out = run_io("2\n13 24 13 45\n").strip().splitlines()
        assert int(out[0]) == 4

        out = run_io("2\n55 55 55 55\n").strip().splitlines()
        assert int(out[0]) == 1
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks cover distinct vs duplicate-dominated cases and enforce heap sizes and product values.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Split Duplicates, Balance Singletons with Capacity}
\WHICHFORMULA{Final method: assign one copy of each multi-occurring value to each heap; alternate singletons to balance distinct counts; fill remaining capacity with extras.}
\ASSUMPTIONS{Each value in both heaps contributes independently to the product; number of duplicate values is at most $n$, so splitting never violates capacity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build value-to-indices map.
\item For each value with at least two occurrences, put one in each heap; push surplus indices to an extras list.
\item Assign singletons to the heap with fewer distincts (tie-break by alternating), without exceeding $n$ per heap.
\item Fill remaining slots using extras; compute $|P|$, $|S|$, and print $|P|\cdot|S|$ plus the assignment vector.
\end{algosteps}
\OPTIMALITY{Let $D_2$ be the set of values with multiplicity $\ge 2$, and $D_1$ the set of singleton values. Splitting each $v\in D_2$ adds $1$ to both $|P|$ and $|S|$, strictly improving any solution that fails to split. Singletons can only increase one side; for fixed total $|P|+|S|=2|D_2|+|D_1|$, the product is maximized when $|P|$ and $|S|$ are as equal as possible, achieved by balancing assignments.}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple, Dict
import sys, io

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(2*n)]
    return n, a

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    from collections import defaultdict
    m = 2*n
    pos: Dict[int, List[int]] = defaultdict(list)
    for i, v in enumerate(a):
        pos[v].append(i)
    assign = [0]*m
    c1 = c2 = 0
    d1 = d2 = 0
    extras: List[int] = []
    singles: List[int] = []
    # Split duplicates
    for v, lst in pos.items():
        if len(lst) >= 2:
            i1, i2 = lst[0], lst[1]
            assign[i1] = 1; c1 += 1; d1 += 1
            assign[i2] = 2; c2 += 1; d2 += 1
            for k in lst[2:]:
                extras.append(k)
        else:
            singles.append(lst[0])
    # Assign singles with balancing and capacity checks
    toggle = 0
    for i in singles:
        if c1 == n:
            assign[i] = 2; c2 += 1; d2 += 1
        elif c2 == n:
            assign[i] = 1; c1 += 1; d1 += 1
        else:
            if d1 < d2:
                assign[i] = 1; c1 += 1; d1 += 1
            elif d2 < d1:
                assign[i] = 2; c2 += 1; d2 += 1
            else:
                if toggle == 0:
                    assign[i] = 1; c1 += 1; d1 += 1
                else:
                    assign[i] = 2; c2 += 1; d2 += 1
                toggle ^= 1
    # Fill remaining capacity with extras
    for i in extras:
        if c1 < n:
            assign[i] = 1; c1 += 1
        else:
            assign[i] = 2; c2 += 1
    assert c1 == n and c2 == n
    # Compute product
    pset = set(a[i] for i in range(m) if assign[i] == 1)
    sset = set(a[i] for i in range(m) if assign[i] == 2)
    prod = len(pset) * len(sset)
    return prod, assign

def solve_all():
    n, a = read_input()
    prod, assign = solve_case(n, a)
    print(prod)
    print(" ".join(map(str, assign)))

def main():
    if sys.stdin.isatty():
        # Exactly 3 asserts via I/O mini-tests
        def run_io(inp: str) -> str:
            backup_stdin, backup_stdout = sys.stdin, sys.stdout
            sys.stdin = io.StringIO(inp)
            sys.stdout = io.StringIO()
            try:
                solve_all()
                return sys.stdout.getvalue()
            finally:
                sys.stdin, sys.stdout = backup_stdin, backup_stdout

        out = run_io("1\n10 99\n").strip().splitlines()
        assert int(out[0]) == 1

        out = run_io("2\n13 24 13 45\n").strip().splitlines()
        assert int(out[0]) == 4

        out = run_io("3\n10 10 10 20 30 40\n").strip().splitlines()
        # Product should be at least 5 (e.g., |P|=3, |S|=2)
        assert int(out[0]) >= 5
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three I\!/O tests validate distinct cases: all distinct values, a mix with one duplicate, and a triple duplicate with singletons ensuring capacity and balancing.}
\RESULT{Print the maximum $|P|\cdot|S|$ and any assignment achieving it. Ties are arbitrary.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests via I\!/O for: all-equal, all-distinct, mixed duplicates; capacity edge when many duplicates; random small cases compared to brute force.}
\LINE{CROSS-CHECKS}{For $n\le 8$, compare greedy against brute force on random inputs to ensure matching optimum. For larger $n$, sanity-check heap sizes and recomputed product.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with: (a) single value repeated $2n$ times; (b) $n$ values each repeated twice; (c) alternating many singletons and one high-multiplicity value; (d) strictly increasing sequence.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_all_equal(n: int, v: int = 55):
    return [v]*(2*n)

def gen_all_distinct(n: int):
    vals = list(range(10, 10+2*n))
    return vals

def gen_pairs(n: int):
    vals = []
    cur = 10
    for _ in range(n):
        vals.extend([cur, cur])
        cur += 1
    return vals

def gen_spiky(n: int):
    vals = []
    vals.extend([10]*min(2*n, max(3, n+1)))
    need = 2*n - len(vals)
    cur = 11
    while need > 0:
        vals.append(cur)
        cur += 1
        need -= 1
    return vals[:2*n]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import List, Tuple, Dict
import sys

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(2*n)]
    return n, a

def solve_case(n: int, a: List[int]) -> Tuple[int, List[int]]:
    from collections import defaultdict
    m = 2*n
    pos: Dict[int, List[int]] = defaultdict(list)
    for i, v in enumerate(a):
        pos[v].append(i)
    assign = [0]*m
    c1 = c2 = 0
    d1 = d2 = 0
    extras: List[int] = []
    singles: List[int] = []
    for v, lst in pos.items():
        if len(lst) >= 2:
            i1, i2 = lst[0], lst[1]
            assign[i1] = 1; c1 += 1; d1 += 1
            assign[i2] = 2; c2 += 1; d2 += 1
            for k in lst[2:]:
                extras.append(k)
        else:
            singles.append(lst[0])
    toggle = 0
    for i in singles:
        if c1 == n:
            assign[i] = 2; c2 += 1; d2 += 1
        elif c2 == n:
            assign[i] = 1; c1 += 1; d1 += 1
        else:
            if d1 < d2:
                assign[i] = 1; c1 += 1; d1 += 1
            elif d2 < d1:
                assign[i] = 2; c2 += 1; d2 += 1
            else:
                if toggle == 0:
                    assign[i] = 1; c1 += 1; d1 += 1
                else:
                    assign[i] = 2; c2 += 1; d2 += 1
                toggle ^= 1
    for i in extras:
        if c1 < n:
            assign[i] = 1; c1 += 1
        else:
            assign[i] = 2; c2 += 1
    assert c1 == n and c2 == n
    pset = set(a[i] for i in range(m) if assign[i] == 1)
    sset = set(a[i] for i in range(m) if assign[i] == 2)
    prod = len(pset) * len(sset)
    return prod, assign

def solve_all():
    n, a = read_input()
    prod, assign = solve_case(n, a)
    print(prod)
    print(" ".join(map(str, assign)))

def main():
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $|P|\cdot|S|$ by splitting duplicates and balancing singletons across heaps.}
\WHY{Greedy distribution leveraging multiplicities and balancing is common in partition and combinatorial optimization interview problems.}
\CHECKLIST{
\begin{bullets}
\item Build value-to-indices map.
\item Split one copy of each duplicate to both heaps.
\item Assign singletons to the side with fewer distincts; tie-break alternately.
\item Respect capacities when assigning.
\item Fill remaining slots with extras.
\item Recompute and print product and assignment.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All values equal: product $=1$.
\item All values distinct: $|P|=|S|=n$, product $=n^2$.
\item Many values with multiplicity $\ge 3$: extras must not change distinct counts.
\item $n=1$ minimal case.
\item One heap reaches capacity early: force remaining items to the other heap.
\item Number of duplicate values exactly $n$: assignment is fully determined by splits.
\item Highly imbalanced singletons count.
\item Values at bounds $10$ and $99$.
\item Duplicate values interleaved in input order.
\item Verify no heap ends with size $\ne n$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting capacity checks when assigning singletons.
\item Counting distincts by items instead of by values.
\item Not recomputing the product from the final assignment.
\item Mishandling values with multiplicity $\ge 3$ (extras).
\item Off-by-one in indexing when printing assignment.
\item Assuming collisions can happen in concatenation (they cannot).
\item Using unstable tie-breaking causing test flakiness (use deterministic alternation).
\item Not initializing assignment for all indices (ensure every index is set).
\item Accidentally exceeding heap sizes during duplicate splitting (cannot happen; reason why).
\item Printing $0$ or other invalid heap labels.
\end{bullets}}
\FAILMODES{Brute force fails on large $n$ due to combinatorial explosion. Naive greedy that does not balance singletons can yield suboptimal product. The presented method avoids both by structural reasoning.}
\ELI{Think of the first heap giving the first two digits and the second heap giving the last two digits. More unique options on each side means more total combinations, and the best is to keep both sides as diverse and balanced as possible.}
\NotePages{3}

\end{document}