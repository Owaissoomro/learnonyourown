% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — k-Factorization}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/797/A}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Given a positive integer $n$, find $k$ integers (not necessarily distinct) such that all these integers are strictly greater than $1$, and their product is equal to $n$.

Input: The first line contains two integers $n$ and $k$ ($2 \le n \le 100000$, $1 \le k \le 20$).

Output: If it is impossible to represent $n$ as a product of $k$ numbers, print $-1$.

Otherwise, print $k$ integers in any order. Their product must be equal to $n$. If there are multiple answers, print any of them.}
\BREAKDOWN{Factorize $n$ into prime factors; if the number of prime factors with multiplicity is at least $k$, output $k-1$ factors then the remaining product. Otherwise, output $-1$.}
\ELI{Split $n$ into $k$ pieces bigger than $1$ by peeling off small prime factors until only one piece remains.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ and $k$ with $2 \le n \le 100000$ and $1 \le k \le 20$.}
\OUTPUTS{Either $-1$ if impossible, or $k$ integers $a_1,\ldots,a_k$ with each $a_i \ge 2$ and $a_1 \times \cdots \times a_k = n$. Any valid order is accepted.}
\SAMPLES{Example 1

Input:
100 3

Output:
2 2 25

Example 2

Input:
17 2

Output:
-1}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{Z}_{\ge 2}$ and $k \in \mathbb{Z}_{\ge 1}$, find $(a_1,\ldots,a_k) \in \mathbb{Z}_{\ge 2}^k$ such that $\prod_{i=1}^k a_i = n$, or decide that no such $k$-tuple exists.}
\varmapStart
\var{n}{target product}
\var{k}{required number of factors}
\var{a_i}{the $i$-th factor, constrained by $a_i \ge 2$}
\var{p_i}{prime factors of $n$ with multiplicity}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Find } a_1,\ldots,a_k \in \mathbb{Z},~ a_i \ge 2 \text{ and } \prod_{i=1}^k a_i = n.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All arithmetic is over nonnegative integers. Prime factorization of $n$ exists and is unique up to order.}
\INVARIANTS{ 
- Multiplicative invariant: The product of chosen factors times the remaining $n$ stays equal to the original $n$.
- Count invariant: We output exactly $k$ factors if and only if we can peel off $k-1$ factors $\ge 2$ leaving a final remainder $\ge 2$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Repeatedly extract the smallest divisor $d \ge 2$ of the current $n$ until we have $k-1$ factors, then output the remaining $n$ as the $k$-th factor.}
\ASSUMPTIONS{Trial division up to $\lfloor \sqrt{n} \rfloor$ is feasible since $n \le 100000$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty list of factors.
\item For $d$ from $2$ upward, while $d \times d \le n$ and we still need more than one factor, repeatedly divide $n$ by $d$ and append $d$.
\item If we have exactly $k-1$ factors and the remaining $n \ge 2$, append $n$; else, output $-1$.
\end{algosteps}
\COMPLEXITY{Worst case $O(\sqrt{n})$ trial divisions; space $O(k)$.}
\[
\begin{aligned}
T(n) &\le \sum_{d=2}^{\lfloor \sqrt{n} \rfloor} 1 \\
     &= O(\sqrt{n}), \quad S(n) = O(k).
\end{aligned}
\]
\CORRECTNESS{Prime factorization is unique. If the multiset of prime factors has size $m$, then $m < k$ makes it impossible to produce $k$ integers $\ge 2$; otherwise, taking any $k-1$ prime factors and grouping the rest preserves the product and constraints.}
\EDGECASES{ 
- $k=1$: always output $n$.
- $n$ is prime and $k>1$: impossible.
- $n$ is a power of a prime: possible iff the exponent $\ge k-1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)  # sentinel for tests/no input
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> Optional[List[int]]:
    if k == 1:
        return [n] if n >= 2 else None
    res: List[int] = []
    d = 2
    # Peel off at most k-1 factors using trial division
    while d * d <= n and len(res) < k - 1:
        while n % d == 0 and len(res) < k - 1:
            res.append(d)
            n //= d
        d += 1
    if len(res) == k - 1 and n > 1:
        res.append(n)
        return res
    return None

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return  # no input; tests-only run
    ans = solve_case(n, k)
    if ans is None:
        print(-1)
    else:
        print(" ".join(map(str, ans)))

def _is_valid(n: int, k: int, factors: Optional[List[int]]) -> bool:
    if factors is None:
        # Valid only if impossible to decompose
        # Check by counting prime multiplicity
        m = 0
        x = n
        d = 2
        while d * d <= x:
            while x % d == 0:
                m += 1
                x //= d
            d += 1
        if x > 1:
            m += 1
        return m < k
    if len(factors) != k:
        return False
    prod = 1
    for v in factors:
        if v < 2:
            return False
        prod *= v
    return prod == n

def _run_tests() -> None:
    # Basic correctness tests
    assert solve_case(2, 1) == [2]
    assert solve_case(17, 2) is None  # prime cannot be split into 2 factors > 1
    f = solve_case(100, 3); assert _is_valid(100, 3, f)
    f = solve_case(36, 4); assert f == [2, 2, 3, 3] or _is_valid(36, 4, f)
    # Edge: many small factors
    f = solve_case(64, 6); assert _is_valid(64, 6, f)
    # Impossible: not enough prime multiplicity
    assert solve_case(6, 3) is None
    # Random-like checks (deterministic set)
    for n in [12, 18, 60, 99991]:
        for k in range(1, 6):
            f = solve_case(n, k)
            assert _is_valid(n, k, f)

if __name__ == "__main__":
    _run_tests()
    data = sys.stdin.read()
    if data.strip():
        import io
        sys.stdin = io.StringIO(data)
        solve_all()
\end{minted}
\VALIDATION{Checked $k=1$; prime $n$ with $k>1$; composite with enough multiplicity; and a set of fixed cases including impossible instances.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Pre-sieve primes up to $10^5$ and factorize $n$ by dividing only by primes, reducing iterations and modulus checks.}
\ASSUMPTIONS{Sieve of Eratosthenes up to $10^5$ fits easily in time and space; $n \le 100000$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a list of primes by a sieve up to $\lfloor \sqrt{100000} \rfloor$ or up to $100000$.
\item Iterate primes in ascending order, peeling off factors until we have $k-1$ factors or the prime exceeds $\sqrt{n}$ dynamically.
\item Append the remaining $n$ if we have exactly $k-1$ factors and $n>1$; otherwise, report impossible.
\end{algosteps}
\COMPLEXITY{Sieve in $O(N \log\log N)$ for $N=100000$ once; factorization visits only primes, so $O(\pi(\sqrt{n}) + \text{number of prime factors})$.}
\[
\begin{aligned}
T(n) &= O(N \log\log N) + O(\pi(\sqrt{n})) \text{ (one-time sieve + per query)}, \\
S(n) &= O(N) \text{ for the sieve} + O(k).
\end{aligned}
\]
\CORRECTNESS{Same invariant and reasoning as baseline; restricting to primes does not miss any factor.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

_MAXN = 100000

def _sieve(n: int) -> List[int]:
    n = max(2, n)
    is_comp = bytearray(b"\x00") * (n + 1)
    primes: List[int] = []
    for i in range(2, n + 1):
        if not is_comp[i]:
            primes.append(i)
            step = i
            start = i * i
            if start > n:
                continue
            for j in range(start, n + 1, step):
                is_comp[j] = 1
    return primes

_PRIMES = _sieve(_MAXN)

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> Optional[List[int]]:
    if k == 1:
        return [n] if n >= 2 else None
    res: List[int] = []
    for p in _PRIMES:
        if p * p > n or len(res) >= k - 1:
            break
        while n % p == 0 and len(res) < k - 1:
            res.append(p)
            n //= p
    if len(res) == k - 1 and n > 1:
        res.append(n)
        return res
    return None

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    ans = solve_case(n, k)
    if ans is None:
        print(-1)
    else:
        print(" ".join(map(str, ans)))

def _is_valid(n: int, k: int, factors: Optional[List[int]]) -> bool:
    if factors is None:
        # Verify impossibility by counting prime multiplicity via simple trial
        m = 0
        x = n
        d = 2
        while d * d <= x:
            while x % d == 0:
                m += 1
                x //= d
            d += 1
        if x > 1:
            m += 1
        return m < k
    if len(factors) != k:
        return False
    prod = 1
    for v in factors:
        if v < 2:
            return False
        prod *= v
    return prod == n

def _run_tests() -> None:
    # Deterministic tests
    assert solve_case(2, 1) == [2]
    assert solve_case(17, 2) is None
    f = solve_case(100, 3); assert _is_valid(100, 3, f)
    f = solve_case(36, 4); assert f == [2, 2, 3, 3] or _is_valid(36, 4, f)
    assert solve_case(6, 3) is None
    # Additional checks
    for n in [12, 18, 60, 99991]:
        for k in range(1, 6):
            f = solve_case(n, k)
            assert _is_valid(n, k, f)

if __name__ == "__main__":
    _run_tests()
    data = sys.stdin.read()
    if data.strip():
        import io
        sys.stdin = io.StringIO(data)
        solve_all()
\end{minted}
\VALIDATION{Cross-checked outputs on representative inputs and verified impossibility detection via prime multiplicity count.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two-phase factorization: strip factor $2$ first, then iterate odd $d$ and update the loop bound with the shrinking $n$. Stop as soon as we have $k-1$ factors.}
\ASSUMPTIONS{Dynamic $\sqrt{n}$ bound tightening minimizes iterations; $n \le 100000$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item While $n$ is even and we still need factors, divide by $2$ and record $2$.
\item For odd $d=3,5,7,\ldots$ while $d \times d \le n$ and we need factors, divide repeatedly by $d$ and record $d$.
\item If we have $k-1$ factors and $n \ge 2$, append $n$; else report impossible.
\end{algosteps}
\OPTIMALITY{Any solution must find at least $k-1$ nontrivial divisors. The method reduces trial checks by halving search space and tightening the bound as $n$ shrinks, which is asymptotically optimal for deterministic trial division under these constraints.}
\COMPLEXITY{$O(\sqrt{n})$ worst case; typically faster due to early termination and bound tightening.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}),\quad S(n) = O(k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> Optional[List[int]]:
    if k == 1:
        return [n] if n >= 2 else None
    res: List[int] = []
    # Strip factor 2
    while n % 2 == 0 and len(res) < k - 1:
        res.append(2)
        n //= 2
    # Strip odd factors
    d = 3
    while d * d <= n and len(res) < k - 1:
        while n % d == 0 and len(res) < k - 1:
            res.append(d)
            n //= d
        d += 2
    if len(res) == k - 1 and n > 1:
        res.append(n)
        return res
    return None

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    ans = solve_case(n, k)
    if ans is None:
        print(-1)
    else:
        print(" ".join(map(str, ans)))

def _is_valid(n: int, k: int, factors: Optional[List[int]]) -> bool:
    if factors is None:
        # Independent check: count prime multiplicity by naive means
        cnt = 0
        x = n
        d = 2
        while d * d <= x:
            while x % d == 0:
                cnt += 1
                x //= d
            d += 1
        if x > 1:
            cnt += 1
        return cnt < k
    if len(factors) != k:
        return False
    prod = 1
    for v in factors:
        if v < 2:
            return False
        prod *= v
    return prod == n

def _run_tests() -> None:
    # Exactly 3 asserts or mini-tests
    assert solve_case(100, 3) in ([2, 2, 25], [2, 5, 10], [4, 5, 5]) or _is_valid(100, 3, solve_case(100, 3))
    assert solve_case(17, 2) is None
    facs = solve_case(36, 4); assert facs == [2, 2, 3, 3] or _is_valid(36, 4, facs)

if __name__ == "__main__":
    _run_tests()
    data = sys.stdin.read()
    if data.strip():
        import io
        sys.stdin = io.StringIO(data)
        solve_all()
\end{minted}
\VALIDATION{Three asserts covering composite with multiple decompositions, prime-impossible case, and a balanced composite.}
\RESULT{Print $k$ integers $\ge 2$ whose product is $n$ if possible; otherwise print $-1$. Any valid order is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify validity via product and lower bound on the number of prime factors. Include edge cases: $k=1$, prime $n$ with $k>1$, powers, and composites with many small factors.}
\LINE{CROSS-CHECKS}{Compare outputs across Approaches A, B, and C on the same inputs to ensure consistent feasibility and valid factor sets.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n$ up to $200$ and all $k \in [1,8]$ to validate correctness and impossibility detection.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import sys
from typing import List, Optional, Tuple

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    return tuple(map(int, data[:2]))  # type: ignore

def solve_case(n: int, k: int) -> Optional[List[int]]:
    if k == 1:
        return [n] if n >= 2 else None
    res: List[int] = []
    # Fast stripping of 2s
    while n % 2 == 0 and len(res) < k - 1:
        res.append(2)
        n //= 2
    d = 3
    while d * d <= n and len(res) < k - 1:
        while n % d == 0 and len(res) < k - 1:
            res.append(d)
            n //= d
        d += 2
    if len(res) == k - 1 and n > 1:
        res.append(n)
        return res
    return None

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    ans = solve_case(n, k)
    if ans is None:
        print(-1)
    else:
        print(" ".join(map(str, ans)))

def _is_valid(n: int, k: int, factors: Optional[List[int]]) -> bool:
    if factors is None:
        # Check impossibility by counting prime multiplicity
        m = 0
        x = n
        d = 2
        while d * d <= x:
            while x % d == 0:
                m += 1
                x //= d
            d += 1
        if x > 1:
            m += 1
        return m < k
    if len(factors) != k:
        return False
    prod = 1
    for v in factors:
        if v < 2:
            return False
        prod *= v
    return prod == n

def _run_tests() -> None:
    # Property-based small grid
    for n in range(2, 201):
        for k in range(1, 9):
            f = solve_case(n, k)
            assert _is_valid(n, k, f)
    # Hand-picked boundary checks
    assert solve_case(2, 1) == [2]
    assert solve_case(99991, 1) == [99991]  # a prime (<= 100000)
    assert solve_case(99991, 2) is None
    assert _is_valid(100000, 6, solve_case(100000, 6))

if __name__ == "__main__":
    _run_tests()
    data = sys.stdin.read()
    if data.strip():
        import io
        sys.stdin = io.StringIO(data)
        solve_all()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> Optional[List[int]]:
    if k == 1:
        return [n] if n >= 2 else None
    res: List[int] = []
    # Extract factor 2s
    while n % 2 == 0 and len(res) < k - 1:
        res.append(2)
        n //= 2
    # Extract odd factors
    d = 3
    while d * d <= n and len(res) < k - 1:
        while n % d == 0 and len(res) < k - 1:
            res.append(d)
            n //= d
        d += 2
    if len(res) == k - 1 and n > 1:
        res.append(n)
        return res
    return None

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    ans = solve_case(n, k)
    if ans is None:
        print(-1)
    else:
        print(" ".join(map(str, ans)))

def _is_valid(n: int, k: int, factors: Optional[List[int]]) -> bool:
    if factors is None:
        # Verify impossibility by prime multiplicity
        cnt = 0
        x = n
        d = 2
        while d * d <= x:
            while x % d == 0:
                cnt += 1
                x //= d
            d += 1
        if x > 1:
            cnt += 1
        return cnt < k
    if len(factors) != k:
        return False
    prod = 1
    for v in factors:
        if v < 2:
            return False
        prod *= v
    return prod == n

def _run_tests() -> None:
    # Smoke tests
    assert solve_case(100, 3) in ([2, 2, 25], [2, 5, 10], [4, 5, 5]) or _is_valid(100, 3, solve_case(100, 3))
    assert solve_case(17, 2) is None
    assert _is_valid(36, 4, solve_case(36, 4))

if __name__ == "__main__":
    _run_tests()
    data = sys.stdin.read()
    if data.strip():
        import io
        sys.stdin = io.StringIO(data)
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count prime multiplicities; if fewer than $k$, print $-1$, else output $k-1$ prime factors and the remaining product.}
\WHY{Common factorization-based construction; tests ability to reason with prime multiplicity and implement clean factor extraction.}
\CHECKLIST{
- Count of extracted factors before the last is exactly $k-1$.
- Remaining $n$ for the last factor is $\ge 2$.
- Handle $k=1$ directly.
- Early exit when enough factors are collected.}
\EDGECASES{
- $k=1$.
- $n$ prime with $k>1$.
- $n$ a prime power with small exponent.
- $n$ with many small factors (e.g., $2^a 3^b$).
- Maximum $n=100000$.
- $k$ large but feasible only if multiplicity $\ge k$.}
\PITFALLS{
- Appending $1$ as the last factor if $n$ fully divides before collecting $k-1$ factors.
- Forgetting to update the loop bound as $n$ shrinks.
- Not separating factor $2$ to skip even checks.
- Off-by-one in the count of factors to collect.
- Printing extra whitespace or wrong format.}
\FAILMODES{Brute force that tries to split into arbitrary composites without leveraging primes may TLE or fail on primes. The presented method avoids both by stopping as soon as infeasibility is detected via multiplicity.}
\ELI{Keep dividing $n$ by small numbers until you have $k-1$ pieces, then the leftover is the last piece. If you run out of pieces before reaching $k$, it is impossible.}
\NotePages{3}

\end{document}