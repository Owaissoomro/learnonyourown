% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Reconstruct a 2-Row Binary Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given the following details of a matrix with $n$ columns and $2$ rows:
\begin{bullets}
\item The matrix is a binary matrix, which means each element in the matrix can be $0$ or $1$.
\item The sum of elements of the $0$-th (upper) row is given as \texttt{upper}.
\item The sum of elements of the $1$-st (lower) row is given as \texttt{lower}.
\item The sum of elements in the $i$-th column ($0$-indexed) is \texttt{colsum[i]}, where \texttt{colsum} is given as an integer array with length $n$.
\end{bullets}
Your task is to reconstruct the matrix with \texttt{upper}, \texttt{lower} and \texttt{colsum}. Return it as a $2$-D integer array. If there is more than one valid solution, any of them will be accepted. If no valid solution exists, return an empty $2$-D array.

Examples:
\begin{bullets}
\item Input: \texttt{upper = 2}, \texttt{lower = 1}, \texttt{colsum = [1,1,1]} \quad Output: \texttt{[[1,1,0],[0,0,1]}. Explanation: \texttt{[[1,0,1],[0,1,0]]} and \texttt{[[0,1,1],[1,0,0]]} are also correct answers.
\item Input: \texttt{upper = 2}, \texttt{lower = 3}, \texttt{colsum = [2,2,1,1]} \quad Output: \texttt{[]}.
\item Input: \texttt{upper = 5}, \texttt{lower = 5}, \texttt{colsum = [2,1,2,0,1,0,1,2,0,1]} \quad Output: \texttt{[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]}.
\end{bullets}
Constraints:
\begin{bullets}
\item $1 \le \texttt{colsum.length} \le 10^5$.
\item $0 \le \texttt{upper}, \texttt{lower} \le \texttt{colsum.length}$.
\item $0 \le \texttt{colsum[i]} \le 2$.
\end{bullets}}
\BREAKDOWN{We must assign $0/1$ to each of the two entries in every column such that: per-column sums match \texttt{colsum[i]}, total of the top row equals \texttt{upper}, and total of the bottom row equals \texttt{lower}. Columns with \texttt{colsum[i]} equal to $2$ or $0$ are forced; columns with sum $1$ must be split between rows according to remaining capacities.}
\ELI{First fill columns that must be $[1,1]$ or $[0,0]$, then distribute the $1$s to the top as long as \texttt{upper} allows, otherwise to the bottom; fail if capacities do not fit.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function call: \texttt{reconstructMatrix(upper: int, lower: int, colsum: List[int])}.
\begin{bullets}
\item \texttt{upper}: integer, $0 \le \texttt{upper} \le n$.
\item \texttt{lower}: integer, $0 \le \texttt{lower} \le n$.
\item \texttt{colsum}: list of $n$ integers, each in $\{0,1,2\}$, with $1 \le n \le 10^5$.
\end{bullets}}
\OUTPUTS{A list of two lists (a $2 \times n$ binary matrix) that satisfies the constraints, or an empty list \texttt{[]} if impossible.}
\SAMPLES{
\begin{bullets}
\item \texttt{upper=1}, \texttt{lower=1}, \texttt{colsum=[2]} $\Rightarrow$ \texttt{[[1],[1]]}.
\item \texttt{upper=1}, \texttt{lower=0}, \texttt{colsum=[1,0,1]} $\Rightarrow$ \texttt{[[1,0,0],[0,0,1]]} or \texttt{[[0,0,1],[0,0,0]]} is invalid since bottom sum must be $0$; a valid output is \texttt{[[1,0,0],[0,0,1]]} only if \texttt{lower} were $1$. For the given inputs, the only valid is \texttt{[[1,0,0],[0,0,0]]}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $u_i, \ell_i \in \{0,1\}$ be the entries at column $i$ in the upper and lower rows, respectively, for $i=1,\ldots,n$. Given $c_i=\texttt{colsum}[i]$, find $\{(u_i,\ell_i)\}_{i=1}^n$ such that
\begin{BreakableEquation*}
\sum_{i=1}^n u_i=\texttt{upper},\quad \sum_{i=1}^n \ell_i=\texttt{lower},\quad u_i+\ell_i=c_i\ \text{for all }i.
\end{BreakableEquation*}%
The objective is feasibility; any feasible solution is acceptable.}
\varmapStart
\var{n}{number of columns, $n=\lvert \texttt{colsum}\rvert$}
\var{c_i}{given column sum at column $i$, equals \texttt{colsum[i]}}
\var{u_i}{binary decision for top row at column $i$}
\var{\ell_i}{binary decision for bottom row at column $i$}
\var{\texttt{upper}}{required sum of the top row}
\var{\texttt{lower}}{required sum of the bottom row}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&u_i,\ \ell_i \in \{0,1\}\quad (i=1,\ldots,n),\\
&u_i+\ell_i=c_i\quad (i=1,\ldots,n),\\
&\sum_{i=1}^n u_i=\texttt{upper},\qquad \sum_{i=1}^n \ell_i=\texttt{lower}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based in the API; the model uses $1$-based for algebraic clarity. Feasibility requires $\sum_i c_i=\texttt{upper}+\texttt{lower}$ and $\#\{i:c_i=2\} \le \min(\texttt{upper},\texttt{lower})$.}
\INVARIANTS{
\begin{bullets}
\item After fixing all $c_i=2$, remaining capacities are $\texttt{upper}'=\texttt{upper}-\#\{i:c_i=2\}$ and $\texttt{lower}'=\texttt{lower}-\#\{i:c_i=2\}$.
\item Columns with $c_i=0$ are fixed to $(0,0)$.
\item Each $c_i=1$ must be assigned to exactly one of the two rows while capacities stay nonnegative.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate assignments for the ambiguous columns with $c_i=1$; columns with $c_i\in\{0,2\}$ are forced. This is a straightforward feasibility search.}
\ASSUMPTIONS{Let $K=\#\{i:c_i=1\}$. Explore all $2^K$ ways to distribute these ones between the two rows, pruning whenever a capacity would go negative.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count forced placements: set $(u_i,\ell_i)=(1,1)$ for $c_i=2$, and $(0,0)$ for $c_i=0$, updating remaining \texttt{upper}, \texttt{lower}. If remaining capacities become negative, return empty.
\item Collect indices $I$ where $c_i=1$.
\item Backtrack over $I$: try setting $u_i=1$ if \texttt{upper} remains $>0$; otherwise try $\ell_i=1$ if \texttt{lower} remains $>0$. Prune when either capacity is negative or exceeds remaining positions.
\item If a full assignment reaches exact capacities, construct the two rows and return.
\end{algosteps}
\COMPLEXITY{Worst-case exponential in $K$; linear space for the partial assignment.}
\[
\begin{aligned}
T(n) &= O\big(n + 2^K\big),\quad S(n)=O(n+K).\\
K &\le n.
\end{aligned}
\]
\CORRECTNESS{Forced columns satisfy their constraints. The backtracking explores all distributions of the $K$ unit columns while pruning infeasible partial sums, so any feasible solution will be found.}
\EDGECASES{Sum check $\sum c_i=\texttt{upper}+\texttt{lower}$; too many $2$'s; all zeros; single column; capacities running out before finishing $1$-columns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Optional, Tuple

class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        n = len(colsum)
        top = [0] * n
        bot = [0] * n

        total = sum(colsum)
        if total != upper + lower:
            return []

        # Forced placements
        up_rem = upper
        lo_rem = lower
        ones_idx: List[int] = []
        for i, c in enumerate(colsum):
            if c == 2:
                top[i] = 1
                bot[i] = 1
                up_rem -= 1
                lo_rem -= 1
                if up_rem < 0 or lo_rem < 0:
                    return []
            elif c == 1:
                ones_idx.append(i)
            elif c == 0:
                pass
            else:
                return []

        K = len(ones_idx)

        # Upper bound pruning: cannot place more than available capacity
        if up_rem > K or lo_rem > K:
            # A tighter necessary condition is up_rem + lo_rem == K, which is implied by total check.
            # But keep a quick reject if any individual capacity exceeds K.
            return []

        assign_top = [0] * K  # 1 if assign to top, else to bottom
        res: Optional[Tuple[List[int], List[int]]] = None

        def backtrack(ti: int, up_left: int, lo_left: int) -> bool:
            nonlocal res
            # Prune impossible remaining capacity vs remaining items
            rem = K - ti
            if up_left < 0 or lo_left < 0 or up_left > rem or lo_left > rem:
                return False
            if ti == K:
                if up_left == 0 and lo_left == 0:
                    # Build full rows
                    for j, idx in enumerate(ones_idx):
                        if assign_top[j]:
                            top[idx] = 1
                            bot[idx] = 0
                        else:
                            top[idx] = 0
                            bot[idx] = 1
                    res = (top[:], bot[:])
                    return True
                return False
            idx = ones_idx[ti]
            # Try assign to top
            assign_top[ti] = 1
            if backtrack(ti + 1, up_left - 1, lo_left):
                return True
            # Try assign to bottom
            assign_top[ti] = 0
            if backtrack(ti + 1, up_left, lo_left - 1):
                return True
            return False

        ok = backtrack(0, up_rem, lo_rem)
        if not ok or res is None:
            return []
        return [res[0], res[1]]


# Basic asserts (examples and small cases)
if __name__ == "__main__":
    s = Solution()
    assert s.reconstructMatrix(2, 1, [1, 1, 1]) in (
        [[1, 1, 0], [0, 0, 1]],
        [[1, 0, 1], [0, 1, 0]],
        [[0, 1, 1], [1, 0, 0]],
    )
    assert s.reconstructMatrix(2, 3, [2, 2, 1, 1]) == []
    out = s.reconstructMatrix(5, 5, [2, 1, 2, 0, 1, 0, 1, 2, 0, 1])
    assert sum(out[0]) == 5 and sum(out[1]) == 5 and all(out[0][i] + out[1][i] == [2,1,2,0,1,0,1,2,0,1][i] for i in range(10))
\end{minted}
\VALIDATION{Tiny checks: all entries are binary; per-column sum equals \texttt{colsum[i]}; row sums match capacities; infeasible instances return empty.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Two-Pass Greedy with Capacity Tracking}
\WHICHFORMULA{First allocate all $c_i=2$ to both rows; then for $c_i=1$, greedily assign to the row with greater remaining capacity (or to the upper row deterministically when tied). This avoids backtracking.}
\ASSUMPTIONS{Feasibility necessary condition $\sum c_i=\texttt{upper}+\texttt{lower}$ and $\#\{i:c_i=2\} \le \min(\texttt{upper},\texttt{lower})$. Deterministic tie-breaking to ensure stable output.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Verify $\sum c_i=\texttt{upper}+\texttt{lower}$; otherwise return empty.
\item Place $(1,1)$ for all $c_i=2$, decrementing capacities; if any capacity becomes negative, return empty.
\item For each $c_i=1$ in order: if \texttt{upper} $>$ \texttt{lower}, place $(1,0)$ and decrement \texttt{upper}; else place $(0,1)$ and decrement \texttt{lower}. If the chosen capacity is zero, switch to the other; if both are zero, return empty.
\item If both capacities reach zero exactly, return the built matrix; else empty.
\end{algosteps}
\COMPLEXITY{Single pass after counting; linear time and space.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Forced columns fix minimum contributions. Remaining $1$-columns must exactly fill the remaining capacities of the two rows. Greedy assignment never overshoots because we only place a $1$ in a row with positive remaining capacity; the total number of $1$-columns equals the sum of remaining capacities by the initial sum check.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        n = len(colsum)
        if sum(colsum) != upper + lower:
            return []
        top = [0] * n
        bot = [0] * n

        # Handle columns with sum 2
        for i, c in enumerate(colsum):
            if c == 2:
                top[i] = 1
                bot[i] = 1
                upper -= 1
                lower -= 1
                if upper < 0 or lower < 0:
                    return []
            elif c not in (0, 1):
                return []

        # Handle columns with sum 1
        for i, c in enumerate(colsum):
            if c == 1:
                if upper > lower:
                    if upper <= 0:
                        return []
                    top[i] = 1
                    upper -= 1
                else:
                    if lower <= 0:
                        return []
                    bot[i] = 1
                    lower -= 1

        if upper != 0 or lower != 0:
            return []
        return [top, bot]


# Quick checks
if __name__ == "__main__":
    s = Solution()
    assert s.reconstructMatrix(1, 1, [2]) == [[1], [1]]
    assert s.reconstructMatrix(1, 0, [1, 0, 0]) == [[1, 0, 0], [0, 0, 0]]
    assert s.reconstructMatrix(0, 0, [0, 0]) == [[0, 0], [0, 0]]
\end{minted}
\VALIDATION{Edge checks: all zeros; all twos equal to capacities; cases where one capacity is zero and all $1$-columns must go to the other row.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Canonical Greedy with Early Necessary-Condition Pruning}
\WHICHFORMULA{Same two-pass greedy but with explicit necessary-condition checks: $\sum c_i=\texttt{upper}+\texttt{lower}$ and $\#\{i:c_i=2\} \le \min(\texttt{upper},\texttt{lower})$. Assign all $2$'s, then assign $1$'s to the upper row while \texttt{upper} $>0$, else to the lower row.}
\ASSUMPTIONS{Applies to any $n$ with $c_i\in\{0,1,2\}$. Deterministic iteration preserves input order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $s=\sum_i c_i$ and $t=\#\{i:c_i=2\}$. If $s\ne \texttt{upper}+\texttt{lower}$ or $t>\min(\texttt{upper},\texttt{lower})$, return empty.
\item Initialize two arrays with zeros. For each $c_i=2$, set top and bottom to $1$ and decrement capacities.
\item For each $c_i=1$, if \texttt{upper} $>0$, set top to $1$ and decrement; else if \texttt{lower} $>0$, set bottom to $1$ and decrement; else return empty.
\item If both capacities are zero, return the matrix; otherwise return empty.
\end{algosteps}
\OPTIMALITY{This is optimal in time $O(n)$ and space $O(n)$ for constructing the matrix. Any algorithm must inspect all $n$ columns in the worst case, so $O(n)$ is tight.}
\COMPLEXITY{Linear passes with constant work per column.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        n = len(colsum)
        if sum(colsum) != upper + lower:
            return []
        two_cnt = sum(1 for c in colsum if c == 2)
        if two_cnt > min(upper, lower):
            return []

        top = [0] * n
        bot = [0] * n

        # Place all 2's
        for i, c in enumerate(colsum):
            if c == 2:
                top[i] = 1
                bot[i] = 1
                upper -= 1
                lower -= 1
                if upper < 0 or lower < 0:
                    return []
            elif c not in (0, 1):
                return []

        # Distribute 1's
        for i, c in enumerate(colsum):
            if c == 1:
                if upper > 0:
                    top[i] = 1
                    upper -= 1
                elif lower > 0:
                    bot[i] = 1
                    lower -= 1
                else:
                    return []

        if upper != 0 or lower != 0:
            return []
        return [top, bot]


if __name__ == "__main__":
    s = Solution()
    # Exactly 3 asserts
    assert s.reconstructMatrix(2, 1, [1, 1, 1]) in (
        [[1, 1, 0], [0, 0, 1]],
        [[1, 0, 1], [0, 1, 0]],
        [[0, 1, 1], [1, 0, 0]],
    )
    assert s.reconstructMatrix(2, 3, [2, 2, 1, 1]) == []
    ans = s.reconstructMatrix(5, 5, [2, 1, 2, 0, 1, 0, 1, 2, 0, 1])
    assert len(ans) == 2 and len(ans[0]) == 10 and all(ans[0][i] + ans[1][i] == [2,1,2,0,1,0,1,2,0,1][i] for i in range(10))
\end{minted}
\VALIDATION{Three asserts cover the provided examples, ensuring feasibility detection and correct distribution of $1$-columns.}
\RESULT{Return any one valid $2 \times n$ binary matrix; if none exists, return \texttt{[]}. No tie-breaking beyond deterministic iteration order is required by the platform.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on: trivial $n=1$; all zeros; all twos; random feasible instances matching $\sum c_i=\texttt{upper}+\texttt{lower}$; infeasible instances where $\#\{2\}$ exceeds a capacity; stress linear scans for large $n$.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final on small random cases ($n\le 12$) to ensure agreement on feasibility and sums; when multiple outputs exist, check constraints rather than exact equality.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with extreme capacities, alternating patterns $[2,1,0,2,1,0,\ldots]$, and prefixes that saturate one row early to catch assignment bugs.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_case(n: int, seed: int = 0) -> Tuple[int, int, List[int]]:
    random.seed(seed)
    col = [random.choice([0, 1, 2]) for _ in range(n)]
    total = sum(col)
    # Choose a feasible split of total into (upper, lower) with constraint that count(2) <= min(upper, lower)
    two_cnt = sum(1 for c in col if c == 2)
    # Ensure feasibility by construction
    upper = random.randint(two_cnt, total - two_cnt)
    lower = total - upper
    return upper, lower, col

def check_solution(upper: int, lower: int, colsum: List[int], mat: List[List[int]]) -> bool:
    if not mat:
        # Accept only if infeasible; quick check (not complete proof)
        return sum(colsum) != upper + lower or sum(1 for c in colsum if c == 2) > min(upper, lower)
    if len(mat) != 2 or len(mat[0]) != len(colsum) or len(mat[1]) != len(colsum):
        return False
    top, bot = mat
    if sum(top) != upper or sum(bot) != lower:
        return False
    return all(top[i] + bot[i] == colsum[i] and top[i] in (0, 1) and bot[i] in (0, 1) for i in range(len(colsum)))

class ReferenceSolution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        n = len(colsum)
        if sum(colsum) != upper + lower:
            return []
        two_cnt = sum(1 for c in colsum if c == 2)
        if two_cnt > min(upper, lower):
            return []
        top = [0] * n
        bot = [0] * n
        for i, c in enumerate(colsum):
            if c == 2:
                top[i] = 1
                bot[i] = 1
                upper -= 1
                lower -= 1
                if upper < 0 or lower < 0:
                    return []
            elif c not in (0, 1):
                return []
        for i, c in enumerate(colsum):
            if c == 1:
                if upper > 0:
                    top[i] = 1
                    upper -= 1
                elif lower > 0:
                    bot[i] = 1
                    lower -= 1
                else:
                    return []
        if upper != 0 or lower != 0:
            return []
        return [top, bot]

if __name__ == "__main__":
    # Cross-check small randoms
    ref = ReferenceSolution()
    for n in range(1, 8):
        for seed in range(5):
            up, lo, col = gen_case(n, seed)
            mat = ref.reconstructMatrix(up, lo, col)
            assert check_solution(up, lo, col, mat)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        # Necessary condition: sums must match
        if sum(colsum) != upper + lower:
            return []
        n = len(colsum)
        # Necessary condition: cannot have more "2" columns than either capacity
        two_cnt = sum(1 for c in colsum if c == 2)
        if two_cnt > min(upper, lower):
            return []

        top = [0] * n
        bot = [0] * n

        # Assign all "2" columns first
        for i, c in enumerate(colsum):
            if c == 2:
                top[i] = 1
                bot[i] = 1
                upper -= 1
                lower -= 1
                if upper < 0 or lower < 0:
                    return []
            elif c not in (0, 1):
                # Out-of-domain value; LC will not provide this, but be safe.
                return []

        # Distribute "1" columns according to remaining capacity
        for i, c in enumerate(colsum):
            if c == 1:
                if upper > 0:
                    top[i] = 1
                    upper -= 1
                elif lower > 0:
                    bot[i] = 1
                    lower -= 1
                else:
                    return []

        # All capacities must be exactly used
        if upper != 0 or lower != 0:
            return []
        return [top, bot]


# Inline sanity tests
if __name__ == "__main__":
    s = Solution()
    assert s.reconstructMatrix(2, 1, [1, 1, 1]) in (
        [[1, 1, 0], [0, 0, 1]],
        [[1, 0, 1], [0, 1, 0]],
        [[0, 1, 1], [1, 0, 0]],
    )
    assert s.reconstructMatrix(2, 3, [2, 2, 1, 1]) == []
    out = s.reconstructMatrix(1, 0, [1, 0, 0])
    assert out == [[1, 0, 0], [0, 0, 0]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reconstruct a $2 \times n$ binary matrix matching given row sums and per-column sums; force $2$'s, skip $0$'s, and greedily place $1$'s respecting remaining capacities.}
\WHY{Common greedy-feasibility pattern; tests understanding of necessary conditions, capacity tracking, and constructing one valid witness solution.}
\CHECKLIST{
\begin{bullets}
\item Check $\sum c_i=\texttt{upper}+\texttt{lower}$.
\item Count $2$'s and ensure $\le \min(\texttt{upper},\texttt{lower})$.
\item Place all $2$'s and update capacities.
\item Place $1$'s to the row with remaining capacity (prefer upper to be deterministic).
\item Verify capacities are exactly zero at the end.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No $1$'s: only $0$ and $2$ columns.
\item All $1$'s: pure split between rows.
\item One capacity is zero.
\item Too many $2$'s for the smaller capacity.
\item $\sum c_i \ne \texttt{upper}+\texttt{lower}$.
\item Single column $n=1$ with $c\in\{0,1,2\}$.
\item Large $n$ with alternating pattern.
\item Capacities exhausted before finishing $1$-columns.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to subtract capacities when placing $2$'s.
\item Assigning a $1$ to a row with zero remaining capacity.
\item Not verifying capacities are zero at the end.
\item Mixing $0$-based and $1$-based indexing in descriptions.
\item Returning \texttt{None} or malformed shapes instead of \texttt{[]} when impossible.
\item Not handling tie-breaking deterministically, causing flaky tests.
\item Modifying input list inadvertently (not an issue here but avoid side effects).
\item Assuming uniqueness of the answer.
\end{bullets}}
\FAILMODES{Brute force times out for large $n$ due to $2^K$ explosion; greedy that ignores placing all $2$'s first can violate row sums; skipping sum checks can lead to late failures or wrong acceptances. The final method survives by enforcing necessary conditions and placing forced columns before distributing $1$'s.}
\ELI{Some columns are fixed: both $1$ or both $0$. The rest each contribute one $1$ that must go to either the top or the bottom. Just give them to the top until its quota is met, then to the bottom. If you ever run out of room, no solution exists.}
\NotePages{3}

\end{document}