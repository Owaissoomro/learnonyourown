% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Factorial Divisibility}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1753/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{You are given an integer $x$ and an array of integers $a_1, a_2, \ldots, a_n$. You have to determine if the number $a_1! + a_2! + \ldots + a_n!$ is divisible by $x!$.

Here $k!$ is a factorial of $k$~— the product of all positive integers less than or equal to $k$. For example, $3! = 1 \cdot 2 \cdot 3 = 6$, and $5! = 1 \cdot 2 \cdot 3 \cdot 4 \cdot 5 = 120$.

Input:
The first line contains two integers $n$ and $x$ ($1 \le n \le 500{,}000$, $1 \le x \le 500{,}000$).

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le x$)~— elements of given array.

Output:
In the only line print ``Yes'' (without quotes) if $a_1! + a_2! + \ldots + a_n!$ is divisible by $x!$, and ``No'' (without quotes) otherwise.

Note:
In the first example $3! + 2! + 2! + 2! + 3! + 3! = 6 + 2 + 2 + 2 + 6 + 6 = 24$. Number $24$ is divisible by $4! = 24$.

In the second example $3! + 2! + 2! + 2! + 2! + 2! + 1! + 1! = 18$, is divisible by $3! = 6$.

In the third example $7! + 7! + 7! + 7! + 7! + 7! + 7! = 7 \cdot 7!$. It is easy to prove that this number is not divisible by $8!$.}
\BREAKDOWN{Reduce to checking whether the sum has no ``digits'' in factorial number system below $x!$. Maintain counts of each $k$ and repeatedly carry $k+1$ copies of $k!$ into one copy of $(k+1)!$. If all residual counts for $k<x$ are zero, the sum is divisible by $x!$.}
\ELI{Think of each $a_i!$ as adding 1 to the $a_i$-th ``factorial digit''; after doing carries from $k!$ to $(k+1)!$, divisibility by $x!$ means no leftover digits for positions $1$ through $x-1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case. First line: integers $n$, $x$ with $1 \le n,x \le 500{,}000$. Second line: $n$ integers $a_i$ with $1 \le a_i \le x$.}
\OUTPUTS{Print exactly one word: ``Yes'' if $\sum_i a_i!$ is divisible by $x!$, otherwise ``No''.}
\SAMPLES{
Example 1
Input
6 4
3 2 2 2 3 3
Output
Yes

Example 2
Input
4 5
1 1 1 1
Output
No
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $c_k$ be the count of indices $i$ with $a_i=k$ for $1 \le k \le x$. Consider the integer
\begin{BreakableEquation*}
S=\sum_{k=1}^{x} c_k \cdot k!.
\end{BreakableEquation*}
We ask whether $x! \mid S$.
Equivalently, write $S$ in the factorial number system $S=\sum_{k\ge 1} d_k \cdot k!$ with $0 \le d_k \le k$. Then $x! \mid S$ iff $d_k=0$ for all $1 \le k \le x-1$.}
\varmapStart
\var{n}{number of terms}
\var{x}{target factorial modulus level}
\var{a_i}{input values, each in $[1,x]$}
\var{c_k}{frequency of value $k$ in the multiset $\{a_i\}$}
\var{d_k}{normalized factorial digits after carrying}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
d_1 &\equiv c_1 \pmod{2}, & d_2 &\equiv \left(c_2 + \left\lfloor \tfrac{c_1}{2}\right\rfloor\right) \pmod{3}, \\
d_3 &\equiv \left(c_3 + \left\lfloor \tfrac{c_2 + \left\lfloor c_1/2 \right\rfloor}{3}\right\rfloor\right) \pmod{4}, \\
&\vdots \\
\text{for }1 \le k < x:\quad
c_{k+1} &\leftarrow c_{k+1} + \left\lfloor \tfrac{c_k}{k+1}\right\rfloor,\qquad
d_k \leftarrow c_k \bmod (k+1).
\end{aligned}
\]
Divisibility criterion: $x!\mid S \iff d_k=0 \text{ for all } 1 \le k < x$.
}
\ASSUMPTIONS{All $a_i$ satisfy $1 \le a_i \le x$. Arithmetic is on unbounded integers. Frequencies $c_k$ are finite.}
\INVARIANTS{
\begin{bullets}
\item After processing level $k$, the partial sum modulo $(k+1)!$ is encoded by $d_1,\ldots,d_k$ with $0 \le d_j \le j$, and the carry has been added into $c_{k+1}$.
\item The transformation preserves $S$ exactly: replacing $(k+1)$ copies of $k!$ with one $(k+1)!$ keeps the sum unchanged.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Normalize counts $c_k$ by repeatedly carrying $\left\lfloor c_k/(k+1)\right\rfloor$ to $c_{k+1}$ and reducing $c_k \bmod (k+1)$ for $k=1,\ldots,x-1$. Check that all reduced $c_k$ are $0$.}
\ASSUMPTIONS{We store frequency array of size $x+1$. The sum $S$ itself is never formed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies $c_k$ for $k=1$ to $x$.
\item For $k$ from $1$ to $x-1$: add $\left\lfloor c_k/(k+1)\right\rfloor$ to $c_{k+1}$, then set $c_k \leftarrow c_k \bmod (k+1)$. If $c_k \ne 0$, conclude ``No''.
\item If the loop finishes without a nonzero remainder, answer ``Yes''.
\end{algosteps}
\COMPLEXITY{Linear in input size and $x$.}
\[
\begin{aligned}
T(n,x) &= \Theta(n+x),\\
S(n,x) &= \Theta(x).
\end{aligned}
\]
\CORRECTNESS{Each step implements the identity $(k+1)\cdot k! = (k+1)!$, so the multiset sum is unchanged while reducing digits into the valid range $[0,k]$. Divisibility by $x!$ holds iff all digits below $x$ vanish after normalization.}
\EDGECASES{All $a_i=x$ trivially yield ``Yes''. For $x=1$ answer is always ``Yes''. Any leftover at some $k<x$ immediately implies ``No''.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    data = data.strip().split()
    if not data:
        return None
    it = list(map(int, data))
    n, x = it[0], it[1]
    a = it[2:2 + n]
    return n, x, a

def solve_case(n, x, a):
    # Frequency of k in a (1..x)
    c = [0] * (x + 1)
    for v in a:
        if 1 <= v <= x:
            c[v] += 1
    # Carry from k to k+1
    for k in range(1, x):
        carry = c[k] // (k + 1)
        c[k + 1] += carry
        c[k] %= (k + 1)
        if c[k] != 0:
            return "No"
    return "Yes"

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, x, a = parsed
    return solve_case(n, x, a) + "\n"

def _self_test():
    # Sample-like checks
    assert solve_case(6, 4, [3, 2, 2, 2, 3, 3]) == "Yes"  # 24 divisible by 4!
    assert solve_case(4, 5, [1, 1, 1, 1]) == "No"
    assert solve_case(8, 3, [3, 2, 2, 2, 2, 2, 1, 1]) == "Yes"
    assert solve_case(7, 8, [7, 7, 7, 7, 7, 7, 7]) == "No"
    assert solve_case(3, 1, [1, 1, 1]) == "Yes"

def main():
    if sys.stdin.isatty():
        _self_test()
    sys.stdout.write(solve_all())

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on multiple tiny cases, including trivial $x=1$, all $a_i=x$, and the illustrative examples.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Early Exit and Sparse Counting}
\WHICHFORMULA{Same carry-based normalization, with two micro-optimizations: early exit on the first nonzero remainder and sparse frequency build via dict for potentially smaller memory, expanded to array only up to the maximum present value.}
\ASSUMPTIONS{We only iterate up to $\max a_i$ or $x$, whichever is smaller; if $x$ is larger than all $a_i$, trailing zeros remain trivial.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a dictionary of counts; compute $m=\min(x,\max a_i)$.
\item Allocate array $c$ of length $x+1$ but fill only up to $m$.
\item For $k$ in $1..x-1$, perform carry; immediately return ``No'' on first nonzero remainder.
\end{algosteps}
\COMPLEXITY{Same asymptotics; constant factors may improve when $\max a_i \ll x$.}
\[
\begin{aligned}
T(n,x) &= \Theta(n+x) \text{ with early exit},\\
S(n,x) &= \Theta(x).
\end{aligned}
\]
\CORRECTNESS{Identical invariant and termination condition as Approach A; only iteration bounds and early exit differ.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import Counter

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    tok = list(map(int, data.strip().split()))
    if not tok:
        return None
    n, x = tok[0], tok[1]
    a = tok[2:2 + n]
    return n, x, a

def solve_case(n, x, a):
    cnt = Counter(v for v in a if 1 <= v <= x)
    c = [0] * (x + 1)
    m = 0
    for k, v in cnt.items():
        c[k] = v
        if k > m:
            m = k
    # Carry through to x-1 regardless of m due to cascading carries
    for k in range(1, x):
        if c[k] >= (k + 1):
            c[k + 1] += c[k] // (k + 1)
            c[k] %= (k + 1)
        if c[k] != 0:
            return "No"
    return "Yes"

def solve_all(data=None):
    parsed = read_input(data)
    if not parsed:
        return ""
    n, x, a = parsed
    return solve_case(n, x, a) + "\n"

def _self_test():
    assert solve_case(6, 4, [3, 2, 2, 2, 3, 3]) == "Yes"
    assert solve_case(4, 5, [1, 1, 1, 1]) == "No"
    assert solve_case(8, 3, [3, 2, 2, 2, 2, 2, 1, 1]) == "Yes"
    assert solve_case(7, 8, [7] * 7) == "No"
    assert solve_case(5, 5, [5, 5, 5, 5, 5]) == "Yes"

def main():
    if sys.stdin.isatty():
        _self_test()
    sys.stdout.write(solve_all())

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers examples and edge cases; early return confirmed whenever a remainder appears at some $k<x$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Factorial Number System Carry Test}
\WHICHFORMULA{Use the factorial-digit carry from $k!$ to $(k+1)!$ and check that no residual digit remains for $k<x$. This is optimal: $O(n+x)$ time and $O(x)$ memory.}
\ASSUMPTIONS{Valid when all $a_i \in [1,x]$. Works in integer arithmetic without forming $x!$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies $c_k$ for $k=1..x$.
\item For each $k=1..x-1$: $c_{k+1}\mathrel{+}= \left\lfloor c_k/(k+1)\right\rfloor$; set $c_k \leftarrow c_k \bmod (k+1)$. If $c_k \ne 0$, return ``No''.
\item Otherwise return ``Yes''.
\end{algosteps}
\OPTIMALITY{Any correct method must inspect input and, in the worst case, propagate through levels up to $x-1$; thus $\Theta(n+x)$ is tight.}
\COMPLEXITY{
\[
\begin{aligned}
T(n,x) &= \Theta(n+x),\quad S(n,x)=\Theta(x).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    s = data.strip().split()
    if not s:
        return None
    it = list(map(int, s))
    n, x = it[0], it[1]
    a = it[2:2 + n]
    return n, x, a

def solve_case(n, x, a):
    c = [0] * (x + 1)
    for v in a:
        if 1 <= v <= x:
            c[v] += 1
    for k in range(1, x):
        c[k + 1] += c[k] // (k + 1)
        c[k] %= (k + 1)
        if c[k] != 0:
            return "No"
    return "Yes"

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, x, a = parsed
    return solve_case(n, x, a) + "\n"

def _self_test():
    assert solve_case(6, 4, [3, 2, 2, 2, 3, 3]) == "Yes"
    assert solve_case(8, 3, [3, 2, 2, 2, 2, 2, 1, 1]) == "Yes"
    assert solve_case(7, 8, [7] * 7) == "No"

def main():
    if sys.stdin.isatty():
        _self_test()
    sys.stdout.write(solve_all())

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover positive and negative cases and a trivial always-``Yes'' case when $a_i=x$.}
\RESULT{Print ``Yes'' if and only if, after carrying, every residue $c_k \bmod (k+1)$ for $1 \le k < x$ equals $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over handcrafted cases: all $a_i=x$; strictly less than $x$ with insufficient carries; mixes that exactly carry to eliminate residues; random small $x$ cross-checked by a slow oracle.}
\LINE{CROSS-CHECKS}{Compare Approach A, B, and C outputs on small random instances to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Produce adversarial instances such as many copies at a single level $k$ just below $(k+1)$ to force borderline carries.}
\begin{minted}{python}
import random

def gen_case(n, x, seed=0):
    random.seed(seed)
    return [random.randint(1, x) for _ in range(n)]

def slow_oracle(n, x, a):
    # Only for tiny x: form digits directly by repeated carry; same as solution.
    c = [0] * (x + 1)
    for v in a:
        c[v] += 1
    for k in range(1, x):
        c[k + 1] += c[k] // (k + 1)
        c[k] %= (k + 1)
        if c[k] != 0:
            return "No"
    return "Yes"

def cross_check():
    for x in range(1, 12):
        for n in range(1, 20):
            a = gen_case(n, x, seed=x * 100 + n)
            got = slow_oracle(n, x, a)
            # Reuse final solver
            from sys import setrecursionlimit
            setrecursionlimit(1 << 25)
            c = [0] * (x + 1)
            for v in a:
                c[v] += 1
            ok = True
            for k in range(1, x):
                c[k + 1] += c[k] // (k + 1)
                c[k] %= (k + 1)
                if c[k] != 0:
                    ok = False
                    break
            got2 = "Yes" if ok else "No"
            assert got == got2

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    s = data.strip().split()
    if not s:
        return None
    it = list(map(int, s))
    n, x = it[0], it[1]
    a = it[2:2 + n]
    return n, x, a

def solve_case(n, x, a):
    c = [0] * (x + 1)
    for v in a:
        if 1 <= v <= x:
            c[v] += 1
    for k in range(1, x):
        c[k + 1] += c[k] // (k + 1)
        c[k] %= (k + 1)
        if c[k] != 0:
            return "No"
    return "Yes"

def solve_all(data=None):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, x, a = parsed
    return solve_case(n, x, a) + "\n"

def _self_test():
    assert solve_case(6, 4, [3, 2, 2, 2, 3, 3]) == "Yes"
    assert solve_case(4, 5, [1, 1, 1, 1]) == "No"
    assert solve_case(7, 8, [7] * 7) == "No"
    assert solve_case(5, 5, [5, 5, 5, 5, 5]) == "Yes"
    assert solve_case(1, 1, [1]) == "Yes"

def main():
    if sys.stdin.isatty():
        _self_test()
    sys.stdout.write(solve_all())

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Divisibility of $\sum a_i!$ by $x!$ reduces to a factorial-digit carry process; ensure no residues remain below $x$.}
\WHY{Tests understanding of factorial number system and carrying, plus ability to avoid constructing astronomically large factorials.}
\CHECKLIST{
\begin{bullets}
\item Count frequencies for $1..x$.
\item For $k=1..x-1$: add carries, reduce modulo $(k+1)$.
\item Early exit on first nonzero remainder.
\item Print the result.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $x=1$ always ``Yes''.
\item All $a_i=x$ always ``Yes''.
\item Single value repeated just below a carry threshold, e.g., $k$ repeated $k$ times $\Rightarrow$ ``No''.
\item Exactly $(k+1)$ copies of $k$ should carry cleanly.
\item Mixed small values like many $1$'s causing multi-level cascades.
\item Empty after parsing or malformed input: handle gracefully.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Trying to compute $x!$ explicitly will overflow time/memory.
\item Forgetting to iterate carries all the way to $x-1$.
\item Not reducing $c_k$ before checking residual nonzero.
\item Off-by-one between $(k+1)$ and the modulus base.
\item Ignoring $a_i$ outside $[1,x]$ if inputs are dirty.
\item Using modulo with negative or zero indices.
\end{bullets}
}
\FAILMODES{Naive modulus by $x!$ fails due to huge numbers. Prime-factor valuation per prime is overkill; the carry method is simpler and linear.}
\ELI{Treat the sum as a number written in a special base where the $k$-th place is $k!$. If, after carrying, every place below $x!$ is zero, then the whole number is a multiple of $x!$.}
\NotePages{3}

\end{document}