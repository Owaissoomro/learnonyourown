% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kill Demodogs}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1731/B}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Demodogs from the Upside-down have attacked Hawkins again. El wants to reach Mike and also kill as many Demodogs in the way as possible.

Hawkins can be represented as an $n \times n$ grid. The number of Demodogs in a cell at the $i$-th row and the $j$-th column is $i \cdot j$. El is at position $(1, 1)$ of the grid, and she has to reach $(n, n)$ where she can find Mike.

The only directions she can move are the right (from $(i, j)$ to $(i, j + 1)$) and the down (from $(i, j)$ to $(i + 1, j)$). She cannot go out of the grid, as there are doors to the Upside-down at the boundaries.

Calculate the maximum possible number of Demodogs $\mathrm{ans}$ she can kill on the way, considering that she kills all Demodogs in cells she visits (including starting and finishing cells).

Print $2022 \cdot \mathrm{ans}$ modulo $10^9 + 7$. Modulo $10^9 + 7$ because the result can be too large and multiplied by $2022$ because we are never gonna see it again!

(Note, you firstly multiply by $2022$ and only after that take the remainder.)

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). Description of the test cases follows.

The first line of each test case contains one integer $n$ ($2 \le n \le 10^9$) — the size of the grid.

Output:
For each test case, print a single integer — the maximum number of Demodogs that can be killed multiplied by $2022$, modulo $10^9 + 7$.

Note:
In the first test case, for any path chosen by her the number of Demodogs to be killed would be $7$, so the answer would be $2022 \cdot 7 = 14154$.}
\BREAKDOWN{Maximize the sum $\sum i \cdot j$ along a monotone path from $(1,1)$ to $(n,n)$. Identify the structure of an optimal path and derive a closed-form expression for the maximum sum, then output it times $2022$ modulo $10^9+7$.}
\ELI{Keep $i$ and $j$ as balanced as possible along the path so products $i \cdot j$ are large; this yields a tidy formula.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.\\
- $t$: integer, number of test cases, $1 \le t \le 10^4$.\\
- For each test case: $n$: integer, grid size, $2 \le n \le 10^9$.}
\OUTPUTS{For each test case, print one integer: $\bigl(2022 \cdot \mathrm{ans}(n)\bigr) \bmod (10^9+7)$, where $\mathrm{ans}(n)$ is the maximum path sum along a right/down path from $(1,1)$ to $(n,n)$ on the grid with weight $i \cdot j$ at $(i,j)$.}
\SAMPLES{Example 1: Input
\[
\begin{aligned}
2\\
2\\
3
\end{aligned}
\]
Output
\[
\begin{aligned}
14154\\
44484
\end{aligned}
\]
Explanation: For $n=2$, $\mathrm{ans}=7$, so $2022 \cdot 7 = 14154$. For $n=3$, $\mathrm{ans}=22$, so $2022 \cdot 22 = 44484$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G$ be an $n \times n$ grid with cell weights $w(i,j)=i \cdot j$. Let $\mathcal{P}$ be the set of monotone paths from $(1,1)$ to $(n,n)$ with unit steps right or down. Define
\begin{BreakableEquation*}
\mathrm{ans}(n)=\max_{P \in \mathcal{P}} \sum_{(i,j)\in P} i \cdot j.
\end{BreakableEquation*}
We seek $2022 \cdot \mathrm{ans}(n) \bmod (10^9+7)$ for each input $n$.}
\varmapStart
\var{n}{grid size}
\var{\mathcal{P}}{set of all monotone right/down paths from $(1,1)$ to $(n,n)$}
\var{\mathrm{ans}(n)}{maximum achievable sum of products along a path}
\var{w(i,j)}{cell weight at $(i,j)$ equals $i \cdot j$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\mathrm{ans}(n) \;=\; \sum_{k=1}^{n} k^2 \;+\; \sum_{k=1}^{n-1} k(k+1) \;=\; \frac{n(n+1)(4n-1)}{6}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $1$-based; paths include both endpoints; additions and multiplications are in standard integer arithmetic before applying the final modulus.}
\INVARIANTS{
\begin{bullets}
\item Optimal paths can be chosen to alternate increasing the smaller of $(i,j)$ until both reach $n$.
\item The path length is fixed at $2n-1$ visited cells for any monotone path.
\item Exchange argument: swapping a step that increases the larger coordinate with one that increases the smaller does not decrease the total sum, hence balancing is optimal.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the greedy path that always increases the smaller of $(i,j)$ (ties arbitrary), summing $i \cdot j$ along the way. This realizes the optimal path but runs in $O(n)$ time.}
\ASSUMPTIONS{We can iterate $O(n)$ steps for small $n$; use only integer arithmetic; apply modulus at the end.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $(i,j) \gets (1,1)$, sum $S \gets i \cdot j$.
\item While $(i,j) \ne (n,n)$:
  \begin{bullets}
  \item If $i=n$, increment $j$; else if $j=n$, increment $i$; else increment the smaller of $i$ and $j$.
  \end{bullets}
\item Add $i \cdot j$ to $S$ each step; finally output $(2022 \cdot S) \bmod (10^9+7)$.
\end{algosteps}
\COMPLEXITY{$T(n)=O(n)$ steps, $S(n)=O(1)$ space.}
\[
\begin{aligned}
T(n) &= 2n-2 \text{ state updates} \\
     &= O(n).
\end{aligned}
\]
\CORRECTNESS{By the exchange argument for supermodular weights $i \cdot j$, increasing the smaller coordinate maintains or improves the total sum, hence the greedy path achieves the optimum. Summing along this path yields $\mathrm{ans}(n)$.}
\EDGECASES{Smallest $n=2$; large $n$ cannot be simulated under constraints but this baseline is for reasoning and small validation only.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
import sys

MOD = 1_000_000_007

def read_input(data: str | None = None):
    if data is None:
        data = sys.stdin.read().strip()
    if not data:
        return 0, []
    it = iter(data.split())
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def solve_case_baseline(n: int) -> int:
    # Greedy: increase the smaller coordinate; sum i*j along the path
    i = j = 1
    s = i * j
    while i < n or j < n:
        if i == n:
            j += 1
        elif j == n:
            i += 1
        elif i < j:
            i += 1
        else:
            j += 1
        s += i * j
    return (2022 * s) % MOD

def solve_all_baseline(ns: list[int]) -> list[int]:
    return [solve_case_baseline(n) for n in ns]

def main():
    # Internal asserts (do not print)
    assert solve_case_baseline(2) == (2022 * 7) % MOD
    assert solve_case_baseline(3) == (2022 * 22) % MOD
    assert solve_case_baseline(4) == (2022 * 50) % MOD
    # Run if input provided
    t, ns = read_input()
    if t and ns:
        out = solve_all_baseline(ns)
        sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked $n=2 \mapsto 7$, $n=3 \mapsto 22$, $n=4 \mapsto 50$ before multiplying by $2022$ and taking the modulus.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the derived structure of the optimal path to sum two arithmetic families without simulating the path: the diagonal squares and the $n-1$ adjacent off-diagonal products.}
\ASSUMPTIONS{Use closed-form sums: $\sum_{k=1}^m k = \tfrac{m(m+1)}{2}$ and $\sum_{k=1}^m k^2 = \tfrac{m(m+1)(2m+1)}{6}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $A=\sum_{k=1}^{n} k^2$.
\item Compute $B=\sum_{k=1}^{n-1} k(k+1)=\sum_{k=1}^{n-1} (k^2+k)$ using the two standard formulas.
\item Return $(2022 \cdot (A+B)) \bmod (10^9+7)$ using modular arithmetic.
\end{algosteps}
\COMPLEXITY{$O(1)$ time and $O(1)$ space using constant-time modular arithmetic.}
\[
\begin{aligned}
T(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{This adds exactly the weights of the optimal greedy-balanced path: the sequence of visited cells is $(1,1),(1,2),(2,2),(2,3),\ldots,(n,n)$, contributing $1^2 + 1\cdot 2 + 2^2 + 2\cdot 3 + \cdots + n^2$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys

MOD = 1_000_000_007

def read_input(data: str | None = None):
    if data is None:
        data = sys.stdin.read().strip()
    if not data:
        return 0, []
    it = iter(data.split())
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def solve_case_improved(n: int) -> int:
    n_mod = n % MOD
    n1_mod = (n + 1) % MOD
    nm1_mod = (n - 1) % MOD
    inv2 = pow(2, MOD - 2, MOD)
    inv6 = pow(6, MOD - 2, MOD)
    # Sum of squares up to n
    sumsq_n = (n_mod * n1_mod) % MOD
    sumsq_n = (sumsq_n * ((2 * n_mod + 1) % MOD)) % MOD
    sumsq_n = (sumsq_n * inv6) % MOD
    # Sum of squares up to n-1
    sumsq_nm1 = (nm1_mod * n_mod) % MOD
    sumsq_nm1 = (sumsq_nm1 * ((2 * nm1_mod + 1) % MOD)) % MOD
    sumsq_nm1 = (sumsq_nm1 * inv6) % MOD
    # Sum of first (n-1) integers
    sum_nm1 = (nm1_mod * n_mod) % MOD
    sum_nm1 = (sum_nm1 * inv2) % MOD
    total = (sumsq_n + sumsq_nm1 + sum_nm1) % MOD
    return (2022 * total) % MOD

def solve_all_improved(ns: list[int]) -> list[int]:
    return [solve_case_improved(n) for n in ns]

def main():
    # Internal asserts
    assert solve_case_improved(2) == (2022 * 7) % MOD
    assert solve_case_improved(3) == (2022 * 22) % MOD
    assert solve_case_improved(4) == (2022 * 50) % MOD
    # Run if input provided
    t, ns = read_input()
    if t and ns:
        out = solve_all_improved(ns)
        sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Matches the baseline for small $n \in \{2,3,4\}$ by asserts; uses only $O(1)$ arithmetic per test.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Algebraically simplify to a single closed form: $\mathrm{ans}(n)=\dfrac{n(n+1)(4n-1)}{6}$, so the final value is $2022 \cdot \mathrm{ans}(n) \bmod (10^9+7)$.}
\ASSUMPTIONS{All operations are done modulo $10^9+7$; use modular inverses of $2$ and $6$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $a = n \bmod M$, $b = (n+1) \bmod M$, $c = (4n-1) \bmod M$ where $M=10^9+7$.
\item Compute $x = a \cdot b \cdot c \bmod M$.
\item Multiply by $\mathrm{inv6} = 6^{M-2} \bmod M$ and by $2022$, then reduce modulo $M$.
\end{algosteps}
\OPTIMALITY{This is information-theoretically optimal: constant work per test case, using a closed-form expression for the maximum.}
\COMPLEXITY{$O(1)$ time, $O(1)$ space per test.}
\[
\begin{aligned}
T(n) &= \Theta(1), \quad S(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys

MOD = 1_000_000_007
INV6 = pow(6, MOD - 2, MOD)

def read_input(data: str | None = None):
    if data is None:
        data = sys.stdin.read().strip()
    if not data:
        return 0, []
    it = iter(data.split())
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def solve_case(n: int) -> int:
    a = n % MOD
    b = (n + 1) % MOD
    c = (4 * a - 1) % MOD
    val = (a * b) % MOD
    val = (val * c) % MOD
    val = (val * INV6) % MOD
    return (2022 * val) % MOD

def solve_all(ns: list[int]) -> list[int]:
    return [solve_case(n) for n in ns]

def main():
    # Internal sanity asserts (do not print)
    assert solve_case(2) == (2022 * 7) % MOD
    assert solve_case(3) == (2022 * 22) % MOD
    assert solve_case(4) == (2022 * 50) % MOD
    # Execute solver
    t, ns = read_input()
    if t and ns:
        out = solve_all(ns)
        sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts: $n=2 \Rightarrow 14154$, $n=3 \Rightarrow 44484$, $n=4 \Rightarrow 101100$.}
\RESULT{For each $n$, print $\bigl(2022 \cdot \tfrac{n(n+1)(4n-1)}{6}\bigr) \bmod (10^9+7)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test small $n$ against the baseline greedy and the improved sum-decomposition. Spot-check random small $n$ and boundary $n=10^9$.}
\LINE{CROSS-CHECKS}{Compare Approach A vs C for $n \le 100$; they must match.}
\LINE{EDGE-CASE GENERATOR}{Iterate $n$ over the small range $[2,50]$ and verify equality across implementations; test $n=10^9$ only with the $O(1)$ formula.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import sys

MOD = 1_000_000_007
INV6 = pow(6, MOD - 2, MOD)

def solve_case_baseline(n: int) -> int:
    i = j = 1
    s = i * j
    while i < n or j < n:
        if i == n:
            j += 1
        elif j == n:
            i += 1
        elif i < j:
            i += 1
        else:
            j += 1
        s += i * j
    return (2022 * s) % MOD

def solve_case_formula(n: int) -> int:
    a = n % MOD
    b = (n + 1) % MOD
    c = (4 * a - 1) % MOD
    val = (a * b) % MOD
    val = (val * c) % MOD
    val = (val * INV6) % MOD
    return (2022 * val) % MOD

# Cross-check small n
for n in range(2, 51):
    assert solve_case_baseline(n) == solve_case_formula(n)

# Boundary sanity for large n (no baseline here)
assert solve_case_formula(10**9) >= 0
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys

MOD = 1_000_000_007
INV6 = pow(6, MOD - 2, MOD)

def read_input(data: str | None = None):
    if data is None:
        data = sys.stdin.read().strip()
    if not data:
        return 0, []
    it = iter(data.split())
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def solve_case(n: int) -> int:
    a = n % MOD
    b = (n + 1) % MOD
    c = (4 * a - 1) % MOD
    val = (a * b) % MOD
    val = (val * c) % MOD
    val = (val * INV6) % MOD
    return (2022 * val) % MOD

def solve_all(ns: list[int]) -> list[int]:
    return [solve_case(n) for n in ns]

def main():
    # Internal tests
    assert solve_case(2) == (2022 * 7) % MOD
    assert solve_case(3) == (2022 * 22) % MOD
    assert solve_case(4) == (2022 * 50) % MOD
    t, ns = read_input()
    if t and ns:
        ans = solve_all(ns)
        sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Max sum over right/down paths on $w(i,j)=i\cdot j$ equals $\dfrac{n(n+1)(4n-1)}{6}$, then multiply by $2022$ and reduce modulo $10^9+7$.}
\WHY{Common CF pattern: identify greedy structure and collapse to a closed form to handle very large $n$.}
\CHECKLIST{
\begin{bullets}
\item Recognize supermodularity: balance $i$ and $j$.
\item Write the path contribution as $1^2 + 1\cdot 2 + 2^2 + \cdots + n^2$.
\item Sum via standard formulas, simplify to $\tfrac{n(n+1)(4n-1)}{6}$.
\item Compute with modular arithmetic and inverses.
\item Multiply by $2022$ before the modulus (equivalently under mod).
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$ minimal path length.
\item Large $n=10^9$ — must avoid loops or overflow, use $64$-bit and modulo.
\item Ensure $(4n-1) \bmod M$ is non-negative.
\item Multiple test cases $t$ up to $10^4$ — $O(1)$ per test is required.
\item Input with trailing spaces/newlines.
\item Verify path includes both endpoints.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to use modular inverses of $2$ and $6$.
\item Doing integer division before modulus (incorrect).
\item Overflow in intermediate products without taking modulo progressively.
\item Miscounting the off-diagonal terms: there are $n-1$ of $k(k+1)$.
\item Treating $4n-1$ as $4(n-1)$ by mistake.
\item Accidental negative modulo when computing $4n-1$.
\end{bullets}
}
\FAILMODES{Any $O(n)$ loop will time out or be infeasible for $n=10^9$; naive DP over the grid is impossible. The constant-time formula avoids these failure modes entirely.}
\ELI{Walk so that $i$ and $j$ stay neck-and-neck; that maximizes each product visited. The resulting sum follows a simple pattern that collapses to a neat closed form, which we evaluate modulo $10^9+7$.}
\NotePages{3}

\end{document}