% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cheap Robot}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1253/F}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{You are given a simple, undirected, connected, weighted graph with $n$ nodes and $m$ edges.

Nodes are numbered from $1$ to $n$. There are exactly $k$ centrals (recharge points), which are nodes $1, 2, \ldots, k$.

We consider a robot moving in this graph, with a battery of capacity $c$, not fixed yet. At any time, the battery contains an integer amount $x$ of energy between $0$ and $c$ inclusive.

Traversing an edge of weight $w_i$ is possible only if $x \ge w_i$, and costs $w_i$ energy points (so $x := x - w_i$).

Moreover, when the robot reaches a central, its battery is entirely recharged (so $x := c$).

You are given $q$ independent missions; the $i$-th mission requires moving the robot from central $a_i$ to central $b_i$.

For each mission, tell the minimum capacity required to achieve it.

Input:
The first line contains four integers $n$, $m$, $k$ and $q$ ($2 \le k \le n \le 10^5$ and $1 \le m, q \le 3 \cdot 10^5$).

The $i$-th of the next $m$ lines contains three integers $u_i$, $v_i$ and $w_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$, $1 \le w_i \le 10^9$), meaning there is an edge between nodes $u_i$ and $v_i$ with weight $w_i$.

It is guaranteed that the graph is simple (no self-loop, at most one edge per unordered pair) and connected.

The $i$-th of the next $q$ lines contains two integers $a_i$ and $b_i$ ($1 \le a_i, b_i \le k$, $a_i \ne b_i$).

Output:
Print $q$ lines; the $i$-th line contains a single integer: the minimum capacity required to achieve the $i$-th mission.

Note:
In the first example, the graph is the chain $10 - 9 - 2^{\text{C}} - 4 - 1^{\text{C}} - 5 - 7 - 3^{\text{C}} - 8 - 6$, where centrals are nodes $1$, $2$ and $3$.

For the mission $(2, 3)$, there is only one simple path possible. Here is a simulation of this mission when the capacity is $12$.

- The robot begins on node $2$, with $c = 12$ energy points.
- It uses an edge of weight $4$.
- It reaches node $4$, with $12 - 4 = 8$ energy points.
- It uses an edge of weight $8$.
- It reaches node $1$ with $8 - 8 = 0$ energy points.
- It is on a central, so its battery is recharged to $c = 12$.
- It uses an edge of weight $2$ to node $5$ ($12 - 2 = 10$).
- It uses an edge of weight $3$ to node $7$ ($10 - 3 = 7$).
- It uses an edge of weight $2$ to node $3$ ($7 - 2 = 5$).
- It is on a central, so its battery is recharged to $c = 12$.
- End of the simulation.

If $c$ was lower than $12$, we would have less than $8$ energy points on node $4$, thus unable to use the edge $4 \leftrightarrow 1$ of weight $8$. Hence $12$ is the minimum capacity required to achieve the mission.

In the second example (centrals are red), the robot can achieve the mission $(3, 1)$ with capacity $c = 38$ using the path $3 \rightarrow 9 \rightarrow 8 \rightarrow 7 \rightarrow 2 \rightarrow 7 \rightarrow 6 \rightarrow 5 \rightarrow 4 \rightarrow 1$. It can achieve the mission $(2, 3)$ with $c = 15$ using $2 \rightarrow 7 \rightarrow 8 \rightarrow 9 \rightarrow 3$.}
\BREAKDOWN{We must compute, for each pair of centrals $(a, b)$, the minimal battery capacity $c$ such that there exists a route from $a$ to $b$ respecting edge-consumption and full recharge at centrals. The classic reduction builds an MST between centrals using special edge costs and answers queries as max edge on the path.}
\ELI{Collapse the graph so that every non-central knows its nearest central; connect centrals through original edges with a cost that accounts for reaching that edge; then the best battery is the biggest edge on the MST path between the two centrals.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n, m, k, q$.
- $m$ lines: $u_i, v_i, w_i$ describing undirected weighted edges.
- $q$ lines: $a_i, b_i$ with $1 \le a_i, b_i \le k$, $a_i \ne b_i$.}
\OUTPUTS{Print $q$ lines; the $i$-th is the minimum required capacity $c$ for mission $(a_i, b_i)$.}
\SAMPLES{Example (tiny, not from platform):
- Input:
3 3 3 3
1 2 10
2 3 7
1 3 12
1 2
2 3
1 3

Output:
10
7
10

- Input:
5 4 2 1
1 3 5
2 3 2
3 4 4
4 5 3
1 2

Output:
5}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a connected undirected graph with positive edge weights $w:E\to\mathbb{Z}_{>0}$. Let $C=\{1,\ldots,k\}$ be the set of centrals. A feasible walk starting at $a\in C$ with capacity $c$ is a sequence of adjacent vertices whose per-edge traversal requires current battery $x \ge w(e)$ and consumes $w(e)$; whenever the walk enters a central, $x$ is reset to $c$. For each query $(a,b)\in C\times C$, find the minimal $c$ such that there exists a feasible walk from $a$ to $b$.}
\varmapStart
\var{n,m}{number of nodes and edges}
\var{k}{number of centrals (nodes $1..k$)}
\var{q}{number of queries}
\var{d(v)}{distance from $v$ to its nearest central}
\var{\text{own}(v)}{an arbitrary nearest central to $v$}
\var{\tilde{w}(u,v)}{induced inter-central edge weight via original edge $(u,v)$: $d(u)+w(u,v)+d(v)$}
\var{T}{MST on vertex set $C$ with weights from $\tilde{w}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
d(v) &= \min_{c\in C} \operatorname{dist}_G(v,c), \\
\tilde{w}(c_i,c_j) &= \min_{\substack{(u,v)\in E\\ \text{own}(u)=c_i,\,\text{own}(v)=c_j}} \left(d(u) + w(u,v) + d(v)\right), \\
\forall a,b\in C:\quad \text{Ans}(a,b) &= \max_{e\in P_T(a,b)} \tilde{w}(e),
\end{aligned}
\]
where $P_T(a,b)$ is the unique path in MST $T$ between $a$ and $b$.
}
\ASSUMPTIONS{Graph is connected and simple; edge weights are positive integers; if multiple centrals give equal nearest distance to a node, break ties arbitrarily (any fixed nearest is valid).}
\INVARIANTS{%
- Multi-source Dijkstra from all $c\in C$ yields $d(\cdot)$ and a nearest-owner map $\text{own}(\cdot)$.
- For any two centrals $a,b$, the optimal capacity equals the minimax cost over all $a$-$b$ connecting schemes, which equals the maximum edge along the MST path under $\tilde{w}$ (cut property).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Binary search the capacity $c$ and test feasibility by graph search that tracks remaining energy and recharges at centrals.}
\ASSUMPTIONS{Feasibility test tracks, for each node, the maximum remaining energy reachable; if we can reach $b$ with any nonnegative energy, capacity is sufficient.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query $(a,b)$, binary search $c$ in $[0, \sum w_i]$.
\item Feasibility check for a given $c$: push $a$ with energy $c$; propagate to neighbor $v$ via edge weight $w$ only if current energy $\ge w$; arriving at a central resets energy to $c$; keep per-node best energy seen to prune.
\item If $b$ is reached, capacity works; shrink high; else increase low.
\end{algosteps}
\COMPLEXITY{Let $W=\sum w_i$. For one query, binary search costs $O(\log W)$ checks; each check is $O(m)$ with pruning in practice.
\[
\begin{aligned}
T(q) &\approx O\!\left(q \cdot m \cdot \log W\right), \\
S & = O(n).
\end{aligned}
\]
}
\CORRECTNESS{Monotonicity: if capacity $c$ works, any larger $c'$ also works. The best-energy-per-node pruning is safe since a lower remaining energy can never help extend feasibility beyond what a higher energy state already enables.}
\EDGECASES{Disconnected under capacity threshold; edges heavier than $c$; multiple centrals on path; revisiting centrals repeatedly.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (Baseline feasibility via binary search per query)
from typing import List, Tuple
import sys
from collections import deque

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def parse(data: str):
    it = iter(map(int, data.strip().split()))
    n = next(it); m = next(it); k = next(it); q = next(it)
    edges = []
    adj = [[] for _ in range(n+1)]
    sum_w = 0
    for _ in range(m):
        u = next(it); v = next(it); w = next(it)
        edges.append((u, v, w))
        adj[u].append((v, w))
        adj[v].append((u, w))
        sum_w += w
    queries = []
    for _ in range(q):
        a = next(it); b = next(it)
        queries.append((a, b))
    return n, m, k, q, adj, edges, queries, sum_w

def feasible(c: int, a: int, b: int, k: int, adj: List[List[Tuple[int,int]]], n: int) -> bool:
    best = [-1]*(n+1)
    dq = deque()
    best[a] = c
    dq.append(a)
    while dq:
        u = dq.popleft()
        cur = best[u]
        # Recharge if central
        if u <= k and cur < c:
            cur = c
            if cur > best[u]:
                best[u] = cur
        if u == b:
            return True
        for v, w in adj[u]:
            if cur >= w:
                rem = cur - w
                if v <= k:
                    rem = c
                if rem > best[v]:
                    best[v] = rem
                    dq.append(v)
    return False

def solve_case(data: str) -> str:
    n, m, k, q, adj, edges, queries, sum_w = parse(data)
    out_lines = []
    for a, b in queries:
        lo, hi = 0, sum_w
        while lo < hi:
            mid = (lo + hi) // 2
            if feasible(mid, a, b, k, adj, n):
                hi = mid
            else:
                lo = mid + 1
        out_lines.append(str(lo))
    return "\n".join(out_lines)

def solve_all():
    data = read_input()
    sys.stdout.write(solve_case(data))

if __name__ == "__main__":
    # Tiny self-checks (baseline is slow; use small graphs)
    data1 = """\
5 4 2 1
1 3 5
2 3 2
3 4 4
4 5 3
1 2
"""
    assert solve_case(data1).strip() == "5"
    data2 = """\
3 3 3 3
1 2 10
2 3 7
1 3 12
1 2
2 3
1 3
"""
    # Minimal capacities: 10, 7, 10 (via central 2)
    assert solve_case(data2).strip() == "10\n7\n10"
    # Run main if input provided
    if sys.stdin.isatty():
        pass
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked on two tiny crafted cases; the binary search feasibility aligns with intuition and known MST answers on these cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Reweight + MST + LCA}
\WHICHFORMULA{Compute $d(v)$ and $\text{own}(v)$ by multi-source Dijkstra. For each original edge $(u,v)$, induce an inter-central edge $(\text{own}(u),\text{own}(v))$ with weight $d(u)+w(u,v)+d(v)$. Kruskal builds an MST on $k$ centrals. Each query answer is the maximum edge weight on the unique path in the MST, obtainable via binary-lifting LCA with max-edge tracking.}
\ASSUMPTIONS{Positive weights; connectivity ensures the induced inter-central graph is connected; ties for nearest central can be broken arbitrarily.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Multi-source Dijkstra from all centrals (distance $0$) to get $d(\cdot)$ and nearest owner $\text{own}(\cdot)$.
\item For each original edge $(u,v,w)$ with $\text{own}(u) \ne \text{own}(v)$, form edge $(\text{own}(u), \text{own}(v))$ of weight $d(u)+w+d(v)$.
\item Run Kruskal on these edges to obtain an MST over $k$ centrals.
\item Preprocess LCA with binary lifting on the MST, storing for each jump the maximum edge on the path to the ancestor.
\item For each query $(a,b)$, lift to equal depth and then converge, tracking maximum edge; output that maximum.
\end{algosteps}
\COMPLEXITY{Dijkstra is $O(m \log n)$. Building induced edges is $O(m)$. Kruskal is $O(m \alpha(k) + m \log m)$ for sorting. LCA preprocessing is $O(k \log k)$ and queries are $O(\log k)$ each.
\[
\begin{aligned}
T &= O\!\left(m \log n + m \log m + k \log k + q \log k\right), \\
S &= O(n + m + k \log k).
\end{aligned}
\]
}
\CORRECTNESS{Cut property: any $s$-$t$ minimax capacity equals the maximum weight along the MST path under $\tilde{w}$. The reweight $\tilde{w}$ captures the cheapest way to ``meet'' two nearest-central regions at any original edge, respecting the cost to reach that meeting edge from the centrals.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF TEMPLATE (MST of centrals via multi-source Dijkstra, Kruskal, LCA)
from typing import List, Tuple
import sys, heapq
from collections import deque

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def parse(data: str):
    it = iter(map(int, data.strip().split()))
    n = next(it); m = next(it); k = next(it); q = next(it)
    edges = []
    adj = [[] for _ in range(n+1)]
    for _ in range(m):
        u = next(it); v = next(it); w = next(it)
        edges.append((u, v, w))
        adj[u].append((v, w))
        adj[v].append((u, w))
    queries = []
    for _ in range(q):
        a = next(it); b = next(it)
        queries.append((a, b))
    return n, m, k, q, adj, edges, queries

def multi_source_dijkstra(n: int, k: int, adj: List[List[Tuple[int,int]]]):
    INF = 10**30
    dist = [INF]*(n+1)
    owner = [-1]*(n+1)
    pq = []
    for c in range(1, k+1):
        dist[c] = 0
        owner[c] = c
        heapq.heappush(pq, (0, c))
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                owner[v] = owner[u]
                heapq.heappush(pq, (nd, v))
    return dist, owner

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n+1))
        self.r = [0]*(n+1)
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst_centrals(n: int, k: int, adj: List[List[Tuple[int,int]]], edges: List[Tuple[int,int,int]]):
    dist, owner = multi_source_dijkstra(n, k, adj)
    inter = []
    for u, v, w in edges:
        ou, ov = owner[u], owner[v]
        if ou != ov:
            inter.append((dist[u] + w + dist[v], ou, ov))
    inter.sort()
    dsu = DSU(k)
    mst_adj = [[] for _ in range(k+1)]
    cnt = 0
    for w, a, b in inter:
        if dsu.union(a, b):
            mst_adj[a].append((b, w))
            mst_adj[b].append((a, w))
            cnt += 1
            if cnt == k-1:
                break
    return mst_adj

def lca_prep_and_query_structure(k: int, mst_adj: List[List[Tuple[int,int]]]):
    LOG = (k).bit_length()
    up = [[0]*(k+1) for _ in range(LOG)]
    mx = [[0]*(k+1) for _ in range(LOG)]
    depth = [0]*(k+1)
    # BFS to set depth and up[0], mx[0]
    from collections import deque
    vis = [False]*(k+1)
    root = 1
    dq = deque([root])
    vis[root] = True
    up[0][root] = 0
    mx[0][root] = 0
    while dq:
        u = dq.popleft()
        for v, w in mst_adj[u]:
            if not vis[v]:
                vis[v] = True
                depth[v] = depth[u] + 1
                up[0][v] = u
                mx[0][v] = w
                dq.append(v)
    for j in range(1, LOG):
        for v in range(1, k+1):
            up[j][v] = up[j-1][up[j-1][v]]
            mx[j][v] = max(mx[j-1][v], mx[j-1][up[j-1][v]])
    def query(a: int, b: int) -> int:
        if a == b:
            return 0
        ans = 0
        if depth[a] < depth[b]:
            a, b = b, a
        # Lift a
        diff = depth[a] - depth[b]
        for j in range(LOG):
            if diff & (1 << j):
                ans = max(ans, mx[j][a])
                a = up[j][a]
        if a == b:
            return ans
        for j in range(LOG-1, -1, -1):
            if up[j][a] != up[j][b]:
                ans = max(ans, mx[j][a], mx[j][b])
                a = up[j][a]
                b = up[j][b]
        # Now they are children of LCA
        ans = max(ans, mx[0][a], mx[0][b])
        return ans
    return query

def solve_case(data: str) -> str:
    n, m, k, q, adj, edges, queries = parse(data)
    mst_adj = build_mst_centrals(n, k, adj, edges)
    query = lca_prep_and_query_structure(k, mst_adj)
    out = []
    for a, b in queries:
        out.append(str(query(a, b)))
    return "\n".join(out)

def solve_all():
    data = read_input()
    sys.stdout.write(solve_case(data))

if __name__ == "__main__":
    # Tiny tests consistent with approach
    data1 = """\
5 4 2 1
1 3 5
2 3 2
3 4 4
4 5 3
1 2
"""
    assert solve_case(data1).strip() == "5"
    data2 = """\
3 3 3 3
1 2 10
2 3 7
1 3 12
1 2
2 3
1 3
"""
    assert solve_case(data2).strip() == "10\n7\n10"
    if sys.stdin.isatty():
        pass
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked identical tiny cases as in the baseline; MST answers match baseline and intuition.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Multi-source Dijkstra + Inter-central MST + Binary-Lift LCA}
\WHICHFORMULA{Use multi-source Dijkstra to partition by nearest central with distances $d(\cdot)$. Build candidate inter-central edges with weight $d(u)+w(u,v)+d(v)$ for each original edge $(u,v,w)$. Run Kruskal to form MST over $k$ centrals. Answer each query as the maximum edge on the MST path via LCA with max-edge lifting.}
\ASSUMPTIONS{Graph connectivity and positive weights. Ties for nearest central do not affect correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $(d,\text{own})$ via multi-source Dijkstra.
\item Form inter-central edges; Kruskal builds MST on $k$ nodes.
\item Precompute binary lifting tables $(\text{up}, \text{mx})$ and depths by BFS/DFS on the MST.
\item For each $(a,b)$, lift to equal depth and converge while tracking maximum edge weight seen.
\end{algosteps}
\OPTIMALITY{By the cut property of MSTs, for any two terminals, the minimax bottleneck value equals the maximum edge on the MST path. The induced metric $\tilde{w}$ respects triangle inequality over centrals, and Kruskal gives a minimum bottleneck spanning tree.}
\COMPLEXITY{Dominated by Dijkstra and sorting $m$ edges; queries are logarithmic:
\[
\begin{aligned}
T(n,m,k,q) &= O\!\left(m \log n + m \log m + q \log k\right),\\
S &= O(n + m + k \log k).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import sys, heapq

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def parse(data: str):
    it = iter(map(int, data.strip().split()))
    n = next(it); m = next(it); k = next(it); q = next(it)
    edges = []
    adj = [[] for _ in range(n+1)]
    for _ in range(m):
        u = next(it); v = next(it); w = next(it)
        edges.append((u, v, w))
        adj[u].append((v, w))
        adj[v].append((u, w))
    queries = []
    for _ in range(q):
        a = next(it); b = next(it)
        queries.append((a, b))
    return n, m, k, q, adj, edges, queries

def multi_source_dijkstra(n: int, k: int, adj: List[List[Tuple[int,int]]]):
    INF = 10**30
    dist = [INF]*(n+1)
    owner = [-1]*(n+1)
    pq = []
    for c in range(1, k+1):
        dist[c] = 0
        owner[c] = c
        heapq.heappush(pq, (0, c))
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                owner[v] = owner[u]
                heapq.heappush(pq, (nd, v))
    return dist, owner

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n+1))
        self.r = [0]*(n+1)
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst_centrals(n: int, k: int, adj: List[List[Tuple[int,int]]], edges: List[Tuple[int,int,int]]):
    dist, owner = multi_source_dijkstra(n, k, adj)
    inter = []
    for u, v, w in edges:
        ou, ov = owner[u], owner[v]
        if ou != ov:
            inter.append((dist[u] + w + dist[v], ou, ov))
    inter.sort()
    dsu = DSU(k)
    mst_adj = [[] for _ in range(k+1)]
    cnt = 0
    for w, a, b in inter:
        if dsu.union(a, b):
            mst_adj[a].append((b, w))
            mst_adj[b].append((a, w))
            cnt += 1
            if cnt == k-1:
                break
    return mst_adj

def prep_lca(k: int, mst_adj: List[List[Tuple[int,int]]]):
    LOG = (k).bit_length()
    up = [[0]*(k+1) for _ in range(LOG)]
    mx = [[0]*(k+1) for _ in range(LOG)]
    depth = [0]*(k+1)
    from collections import deque
    vis = [False]*(k+1)
    root = 1
    dq = deque([root])
    vis[root] = True
    up[0][root] = 0
    mx[0][root] = 0
    while dq:
        u = dq.popleft()
        for v, w in mst_adj[u]:
            if not vis[v]:
                vis[v] = True
                depth[v] = depth[u] + 1
                up[0][v] = u
                mx[0][v] = w
                dq.append(v)
    for j in range(1, LOG):
        for v in range(1, k+1):
            up[j][v] = up[j-1][up[j-1][v]]
            mx[j][v] = max(mx[j-1][v], mx[j-1][up[j-1][v]])
    return up, mx, depth

def query_max_on_path(a: int, b: int, up, mx, depth) -> int:
    LOG = len(up)
    if a == b:
        return 0
    ans = 0
    if depth[a] < depth[b]:
        a, b = b, a
    # Lift a
    diff = depth[a] - depth[b]
    for j in range(LOG):
        if diff & (1 << j):
            ans = max(ans, mx[j][a])
            a = up[j][a]
    if a == b:
        return ans
    for j in range(LOG-1, -1, -1):
        if up[j][a] != up[j][b]:
            ans = max(ans, mx[j][a], mx[j][b])
            a = up[j][a]
            b = up[j][b]
    ans = max(ans, mx[0][a], mx[0][b])
    return ans

def solve_case(data: str) -> str:
    n, m, k, q, adj, edges, queries = parse(data)
    mst_adj = build_mst_centrals(n, k, adj, edges)
    up, mx, depth = prep_lca(k, mst_adj)
    out = []
    for a, b in queries:
        out.append(str(query_max_on_path(a, b, up, mx, depth)))
    return "\n".join(out)

def solve_all():
    data = read_input()
    sys.stdout.write(solve_case(data))

if __name__ == "__main__":
    # Exactly 3 asserts
    data1 = """\
5 4 2 1
1 3 5
2 3 2
3 4 4
4 5 3
1 2
"""
    assert solve_case(data1).strip() == "5"
    data2 = """\
3 3 3 3
1 2 10
2 3 7
1 3 12
1 2
2 3
1 3
"""
    assert solve_case(data2).strip() == "10\n7\n10"
    data3 = """\
6 6 2 2
1 3 4
3 4 4
4 2 4
2 5 100
5 6 100
6 1 100
1 2
2 1
"""
    # Best is via path 1-3-4-2 with segment sums 8 and 4; capacity 8 both ways.
    assert solve_case(data3).strip() == "8\n8"
    if sys.stdin.isatty():
        pass
    else:
        solve_all()
\end{minted}
\VALIDATION{Three asserts on small graphs including a case where direct heavy edges exist but are avoided by using an intermediate central.}
\RESULT{For each query $(a,b)$, output $\max$-edge weight along the path between $a$ and $b$ in the MST on centrals constructed with edge weights $d(u)+w(u,v)+d(v)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use unit tests on small graphs: chains, triangles with all-centrals, and graphs where indirect paths via centrals beat direct heavy edges. Verify baseline vs. improved vs. final produce identical outputs.}
\LINE{CROSS-CHECKS}{On tiny inputs, compare Approach A's binary-search feasibility with Approaches B/C.}
\LINE{EDGE-CASE GENERATOR}{Generate small graphs with random weights and a few centrals; compare outputs across methods to catch tie-handling and lifting issues.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from typing import List, Tuple

def gen_chain(n: int, k: int, w: int = 5):
    # Centrals are first k nodes on a chain
    edges = []
    for i in range(1, n):
        edges.append((i, i+1, w))
    queries = []
    for a in range(1, k+1):
        for b in range(1, k+1):
            if a < b:
                queries.append((a, b))
    return n, len(edges), k, len(queries), edges, queries

def to_input(n:int,m:int,k:int,q:int,edges:List[Tuple[int,int,int]],queries:List[Tuple[int,int]]):
    parts = [f"{n} {m} {k} {q}"]
    for u,v,w in edges:
        parts.append(f"{u} {v} {w}")
    for a,b in queries:
        parts.append(f"{a} {b}")
    return "\n".join(parts) + "\n"

if __name__ == "__main__":
    # Example generator usage:
    n,m,k,q,edges,queries = gen_chain(6, 3)
    s = to_input(n,m,k,q,edges,queries)
    print(s)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution (same as Approach C)
from typing import List, Tuple
import sys, heapq

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def parse(data: str):
    it = iter(map(int, data.strip().split()))
    n = next(it); m = next(it); k = next(it); q = next(it)
    edges = []
    adj = [[] for _ in range(n+1)]
    for _ in range(m):
        u = next(it); v = next(it); w = next(it)
        edges.append((u, v, w))
        adj[u].append((v, w))
        adj[v].append((u, w))
    queries = []
    for _ in range(q):
        a = next(it); b = next(it)
        queries.append((a, b))
    return n, m, k, q, adj, edges, queries

def multi_source_dijkstra(n: int, k: int, adj: List[List[Tuple[int,int]]]):
    INF = 10**30
    dist = [INF]*(n+1)
    owner = [-1]*(n+1)
    pq = []
    for c in range(1, k+1):
        dist[c] = 0
        owner[c] = c
        heapq.heappush(pq, (0, c))
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                owner[v] = owner[u]
                heapq.heappush(pq, (nd, v))
    return dist, owner

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n+1))
        self.r = [0]*(n+1)
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst_centrals(n: int, k: int, adj: List[List[Tuple[int,int]]], edges: List[Tuple[int,int,int]]):
    dist, owner = multi_source_dijkstra(n, k, adj)
    inter = []
    for u, v, w in edges:
        ou, ov = owner[u], owner[v]
        if ou != ov:
            inter.append((dist[u] + w + dist[v], ou, ov))
    inter.sort()
    dsu = DSU(k)
    mst_adj = [[] for _ in range(k+1)]
    cnt = 0
    for w, a, b in inter:
        if dsu.union(a, b):
            mst_adj[a].append((b, w))
            mst_adj[b].append((a, w))
            cnt += 1
            if cnt == k-1:
                break
    return mst_adj

def prep_lca(k: int, mst_adj: List[List[Tuple[int,int]]]):
    LOG = (k).bit_length()
    up = [[0]*(k+1) for _ in range(LOG)]
    mx = [[0]*(k+1) for _ in range(LOG)]
    depth = [0]*(k+1)
    from collections import deque
    vis = [False]*(k+1)
    root = 1
    dq = deque([root])
    vis[root] = True
    up[0][root] = 0
    mx[0][root] = 0
    while dq:
        u = dq.popleft()
        for v, w in mst_adj[u]:
            if not vis[v]:
                vis[v] = True
                depth[v] = depth[u] + 1
                up[0][v] = u
                mx[0][v] = w
                dq.append(v)
    for j in range(1, LOG):
        for v in range(1, k+1):
            up[j][v] = up[j-1][up[j-1][v]]
            mx[j][v] = max(mx[j-1][v], mx[j-1][up[j-1][v]])
    return up, mx, depth

def query_max_on_path(a: int, b: int, up, mx, depth) -> int:
    LOG = len(up)
    if a == b:
        return 0
    ans = 0
    if depth[a] < depth[b]:
        a, b = b, a
    diff = depth[a] - depth[b]
    for j in range(LOG):
        if diff & (1 << j):
            ans = max(ans, mx[j][a])
            a = up[j][a]
    if a == b:
        return ans
    for j in range(LOG-1, -1, -1):
        if up[j][a] != up[j][b]:
            ans = max(ans, mx[j][a], mx[j][b])
            a = up[j][a]
            b = up[j][b]
    ans = max(ans, mx[0][a], mx[0][b])
    return ans

def solve_case(data: str) -> str:
    n, m, k, q, adj, edges, queries = parse(data)
    mst_adj = build_mst_centrals(n, k, adj, edges)
    up, mx, depth = prep_lca(k, mst_adj)
    out = []
    for a, b in queries:
        out.append(str(query_max_on_path(a, b, up, mx, depth)))
    return "\n".join(out)

def solve_all():
    data = read_input()
    sys.stdout.write(solve_case(data))

if __name__ == "__main__":
    # Simple asserts
    d1 = """\
5 4 2 1
1 3 5
2 3 2
3 4 4
4 5 3
1 2
"""
    assert solve_case(d1).strip() == "5"
    d2 = """\
3 3 3 3
1 2 10
2 3 7
1 3 12
1 2
2 3
1 3
"""
    assert solve_case(d2).strip() == "10\n7\n10"
    d3 = """\
6 6 2 2
1 3 4
3 4 4
4 2 4
2 5 100
5 6 100
6 1 100
1 2
2 1
"""
    assert solve_case(d3).strip() == "8\n8"
    if sys.stdin.isatty():
        pass
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build an MST between centrals using edge costs that include distances from centrals to the edge endpoints; answer queries as the maximum edge on the MST path.}
\WHY{This is a classic reduction: multi-source Dijkstra to partition by nearest source, Kruskal to build a minimum bottleneck structure, and LCA for fast per-query answers.}
\CHECKLIST{%
- Run multi-source Dijkstra from all $k$ centrals; record $d$ and owner.
- For each original edge, if owners differ, create inter-central edge with $d(u)+w+d(v)$.
- Kruskal to get MST on centrals.
- Binary-lift LCA with max-edge to answer queries.}
\EDGECASES{%
- Multiple nearest centrals at equal distance (tie-breaking arbitrary but consistent).
- Heavy edges that are never used due to cheaper detours via centrals.
- $k=2$ (MST is a single edge).
- Graph where optimal route visits many centrals (still captured by MST).
- Non-central nodes far from centrals (distance handled by $d(\cdot)$).
- Large weights up to $10^9$ (use 64-bit in Python).}
\PITFALLS{%
- Forgetting to include edges where owners differ in either direction.
- Incorrect owner propagation in Dijkstra (must carry the source id).
- Insufficient LOG size for LCA (use $(k)$.bit\_length()).
- Not initializing LCA root and parent properly.
- Using recursion for DFS may hit recursion limits; BFS is safer.
- Integer overflow in languages with fixed-width types (use 64-bit).}
\FAILMODES{%
- Per-query binary search without recharge logic will be wrong; must consider recharges.
- Building an MST on original weights (not reweighted) is incorrect.}
\ELI{Let each place pick its closest charging station. Every road between places becomes a connection between two charging stations, priced by how much battery you need to get from the stations to that road and cross it. Build the cheapest spanning network of stations, then the hardest hop on the unique path between two stations tells you the needed battery.}
\NotePages{3}

\end{document}