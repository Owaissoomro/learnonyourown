% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nikita and Order Statistics}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/993/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Nikita likes tasks on order statistics, for example, he can easily find the $k$-th number in increasing order on a segment of an array. But now Nikita wonders how many segments of an array there are such that a given number $x$ is the $k$-th number in increasing order on this segment. In other words, you should find the number of segments of a given array such that there are exactly $k$ numbers of this segment which are less than $x$.

Nikita wants to get the answer for this question for each $k$ from $0$ to $n$, where $n$ is the size of the array.

Input:
The first line contains two integers $n$ and $x$ $(1 \le n \le 2 \cdot 10^5,\,-10^9 \le x \le 10^9)$.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ $(-10^9 \le a_i \le 10^9)$ — the given array.

Output:
Print $n+1$ integers, where the $i$-th number is the answer for Nikita's question for $k=i-1$.}
\BREAKDOWN{Transform the array into indicators $b_i = [a_i < x]$ so each subarray's count of elements less than $x$ is its sum. Count, for all $k$, the number of subarrays with sum exactly $k$. Use prefix sums and frequency convolution to compute all $k \ge 1$ at once; handle $k=0$ separately.}
\ELI{Turn the problem into counting subarrays with a given number of ones and compute all answers using a single fast convolution.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test with:
- $n$ (int), $x$ (int).
- Array $a$ of length $n$ with integers in range $[-10^9, 10^9]$.}
\OUTPUTS{Print $n+1$ space separated integers: for each $k=0,1,\ldots,n$, the number of subarrays that contain exactly $k$ elements strictly less than $x$.}
\SAMPLES{Example 1:
- Input: $n=3$, $x=5$, $a=[1,2,3]$.
- Output: $0\ 3\ 2\ 1$.

Example 2:
- Input: $n=3$, $x=2$, $a=[3,2,1]$.
- Output: $3\ 3\ 0\ 0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $b_i = \mathbf{1}[a_i < x] \in \{0,1\}$ and prefix sums $p_0=0$, $p_i = \sum_{j=1}^i b_j$. For a subarray $[L,R]$, its number of elements $< x$ equals $p_R - p_{L-1}$. For each $k \in \{0,\ldots,n\}$, we want the number of pairs $(i,j)$ with $0 \le i < j \le n$ and $p_j - p_i = k$.}
\varmapStart
\var{a_i}{original array values}
\var{x}{threshold}
\var{b_i}{indicator that $a_i < x$}
\var{p_i}{prefix sum of $b$ up to $i$}
\var{c_s}{count of indices $i$ with $p_i = s$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For } k \ge 1:\quad \mathrm{ans}[k] = \sum_{s \ge 0} c_s \cdot c_{s+k}
\end{BreakableEquation*}
\begin{BreakableEquation*}
\mathrm{ans}[0] = \sum_{s \ge 0} \binom{c_s}{2} = \sum_{\text{zero-runs } \ell} \frac{\ell(\ell+1)}{2}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $1$-based for $a$ and $b$, with $p_0=0$. $p_i$ is nondecreasing and takes integer values in $[0,m]$, where $m=\sum b_i$.}
\INVARIANTS{
- $p_i$ is nondecreasing with steps of size $0$ or $1$.
- For $k \ge 1$, every occurrence of value $s+k$ in $p$ appears after every occurrence of $s$, hence $\sum_s c_s c_{s+k}$ precisely counts pairs $i<j$.
- $k$ cannot exceed $m$; for $k>m$ the answer is $0$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all subarrays and count $b$-ones per subarray using prefix sums: $p_R-p_{L-1}$.}
\ASSUMPTIONS{Works for small $n$; serves as a correctness oracle for testing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $b_i = \mathbf{1}[a_i < x]$ and prefix sums $p$.
\item For all $1 \le L \le R \le n$, compute $t = p_R - p_{L-1}$.
\item Increment $\mathrm{ans}[t]$.
\end{algosteps}
\COMPLEXITY{Brute force over all $O(n^2)$ subarrays.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Directly counts each subarray's number of elements less than $x$ and buckets by $k$.}
\EDGECASES{All elements $\ge x$ (then only $k=0$ nonzero); all elements $<x$ (answers are descending counts by length).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); x = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, x, a

def solve_case_bruteforce(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = p[i-1] + b[i-1]
    ans = [0]*(n+1)
    for L in range(1, n+1):
        for R in range(L, n+1):
            t = p[R] - p[L-1]
            ans[t] += 1
    return ans

def solve_all():
    n, x, a = read_input()
    if n == 0:
        return
    ans = solve_case_bruteforce(n, x, a)
    print(" ".join(map(str, ans)))

def _self_test():
    # tiny fixed tests
    n, x, a = 3, 5, [1, 2, 3]
    assert solve_case_bruteforce(n, x, a) == [0, 3, 2, 1]
    n, x, a = 3, 2, [3, 2, 1]
    assert solve_case_bruteforce(n, x, a) == [3, 3, 0, 0]
    n, x, a = 1, 0, [0]
    # b = [0], only k=0 subarray
    assert solve_case_bruteforce(n, x, a) == [1, 0]

if __name__ == "__main__":
    # run asserts but do not print on success
    _self_test()
    if sys.stdin.isatty():
        # demo
        demo = "3 5\n1 2 3\n"
        sys.stdin = sys.__stdin__
        n, x, a = 3, 5, [1, 2, 3]
        print(" ".join(map(str, solve_case_bruteforce(n, x, a))))
    else:
        solve_all()
\end{minted}
\VALIDATION{Compared against hand calculations for small arrays. Two tiny asserts and a demo are included.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Positions-of-ones Decomposition}
\WHICHFORMULA{Let $b_i=\mathbf{1}[a_i<x]$ and let positions of ones be $1\le p_1<\cdots<p_m\le n$. Let $p_0=0$, $p_{m+1}=n+1$. The number of subarrays with exactly $k\ge 1$ ones equals
\begin{BreakableEquation*}
\sum_{i=1}^{m-k+1} (p_i-p_{i-1})\cdot(p_{i+k}-p_{i+k-1}),
\end{BreakableEquation*}
and $k=0$ equals $\sum$ over zero-runs $\ell$ of $\ell(\ell+1)/2$.}
\ASSUMPTIONS{Efficient when $m$ (number of elements $<x$) is small; avoids global convolution.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $b$ and extract indices $p$ of ones; compute gaps $L_i=p_i-p_{i-1}$ and $R_i=p_{i+1}-p_i$.
\item For $k=0$, sum zero-only subarrays via run lengths or via $\sum \ell(\ell+1)/2$.
\item For each $k=1$ to $m$, accumulate $\sum_i L_i \cdot R_{i+k-1}$ in $O(m)$ per $k$; stop at $k=n$ since beyond $m$ answers are $0$.
\end{algosteps}
\COMPLEXITY{If $m\ll n$, then $O(m^2 + n)$; worst case $O(n^2)$, but often much better.}
\[
\begin{aligned}
T(n,m) &= O(n + m^2), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Each subarray with exactly $k$ ones is uniquely determined by choosing a block of $k$ consecutive ones (indexed by $i$ to $i+k-1$), then extending left into the zeros before $p_i$ and right into the zeros after $p_{i+k-1}$. Choices multiply as $(p_i-p_{i-1})\cdot(p_{i+k}-p_{i+k-1})$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); x = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, x, a

def solve_case_positions(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    # k = 0 via zero-runs
    ans = [0]*(n+1)
    run = 0
    for v in b + [1]:  # sentinel to flush last run
        if v == 0:
            run += 1
        else:
            ans[0] += run * (run + 1) // 2
            run = 0
    # positions of ones
    pos = [i+1 for i, v in enumerate(b) if v == 1]
    m = len(pos)
    if m == 0:
        # only k=0 subarrays exist; others zero
        return ans
    # add sentinels
    p = [0] + pos + [n+1]
    L = [p[i] - p[i-1] for i in range(1, m+1)]
    R = [p[i+1] - p[i] for i in range(1, m+1)]
    # For k >= 1
    for k in range(1, m+1):
        s = 0
        for i in range(1, m - k + 2):
            s += (p[i] - p[i-1]) * (p[i+k] - p[i+k-1])
        ans[k] = s
    # remaining k>m are zeros
    return ans

def solve_all():
    n, x, a = read_input()
    if n == 0:
        return
    ans = solve_case_positions(n, x, a)
    print(" ".join(map(str, ans)))

def _self_test():
    # cross-check with brute force for small random cases
    import random
    random.seed(0)
    for n in range(1, 8):
        for _ in range(50):
            a = [random.randint(-3, 3) for _ in range(n)]
            x = random.randint(-3, 3)
            bf = _bruteforce(n, x, a)
            sp = solve_case_positions(n, x, a)
            assert bf == sp, (n, x, a, bf, sp)
    # fixed tests
    assert solve_case_positions(3, 5, [1, 2, 3]) == [0, 3, 2, 1]
    assert solve_case_positions(3, 2, [3, 2, 1]) == [3, 3, 0, 0]

def _bruteforce(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = p[i-1] + b[i-1]
    ans = [0]*(n+1)
    for L in range(1, n+1):
        for R in range(L, n+1):
            t = p[R] - p[L-1]
            ans[t] += 1
    return ans

if __name__ == "__main__":
    _self_test()
    if sys.stdin.isatty():
        print(" ".join(map(str, solve_case_positions(3, 5, [1, 2, 3]))))
    else:
        solve_all()
\end{minted}
\VALIDATION{Cross-checked against brute force on many small random cases; fixed tiny examples verified.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prefix-Sum Frequencies + FFT Convolution}
\WHICHFORMULA{Let $c_s$ be the number of prefix indices with $p_i = s$. Then for $k \ge 1$, $\mathrm{ans}[k] = \sum_s c_s c_{s+k}$, which equals the $(m+k)$-th coefficient of the convolution $f * \mathrm{rev}(f)$ where $f[s]=c_s$ and $\mathrm{rev}(f)[i]=f[m-i]$, with $m=\sum b_i$. Compute this via FFT in $O(n \log n)$. For $k=0$, use $\sum_s \binom{c_s}{2}$.}
\ASSUMPTIONS{FFT with floating point is acceptable with rounding to nearest integer; array sizes up to $n+1 \le 2\cdot 10^5+1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $b$ and prefix sums $p$, count frequencies $c_s$ for $s\in[0,m]$, where $m=p_n$.
\item Form $f = [c_0, c_1, \ldots, c_m]$ and $g$ as the reverse of $f$.
\item Convolve $h = f * g$ by FFT; then for $k=1,\ldots,m$, set $\mathrm{ans}[k] = h[m+k]$.
\item Compute $\mathrm{ans}[0] = \sum_{s=0}^m c_s(c_s-1)/2$; for $k>m$ set $0$.
\end{algosteps}
\OPTIMALITY{Any method that computes all $\mathrm{ans}[k]$ simultaneously from $c$ requires at least the cost of one convolution in general. FFT achieves $O(n\log n)$ and is tight up to logarithmic factors.}
\COMPLEXITY{Let $m \le n$.
\begin{BreakableEquation*}
T(n) = O(n \log n),\quad S(n) = O(n).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math, cmath
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); x = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, x, a

def _fft(a: List[complex], invert: bool) -> None:
    n = len(a)
    j = 0
    for i in range(1, n):
        bit = n >> 1
        while j & bit:
            j ^= bit
            bit >>= 1
        j ^= bit
        if i < j:
            a[i], a[j] = a[j], a[i]
    length = 2
    while length <= n:
        ang = 2 * math.pi / length * (-1 if invert else 1)
        wlen = complex(math.cos(ang), math.sin(ang))
        for i in range(0, n, length):
            w = 1+0j
            half = length >> 1
            for j in range(i, i + half):
                u = a[j]
                v = a[j + half] * w
                a[j] = u + v
                a[j + half] = u - v
                w *= wlen
        length <<= 1
    if invert:
        inv_n = 1.0 / n
        for i in range(n):
            a[i] *= inv_n

def _convolve_int(a: List[int], b: List[int]) -> List[int]:
    # Convolution via complex FFT with rounding
    if not a or not b:
        return []
    n = 1
    need = len(a) + len(b) - 1
    while n < need:
        n <<= 1
    fa = [0j]*n
    fb = [0j]*n
    for i, v in enumerate(a):
        fa[i] = complex(v, 0.0)
    for i, v in enumerate(b):
        fb[i] = complex(v, 0.0)
    _fft(fa, False)
    _fft(fb, False)
    for i in range(n):
        fa[i] *= fb[i]
    _fft(fa, True)
    res = [0]*need
    for i in range(need):
        val = fa[i].real
        # round to nearest integer
        res[i] = int(round(val))
    return res

def solve_case_fft(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    # prefix sums and frequency counts
    m = sum(b)
    cnt = [0] * (m + 1)
    pref = 0
    cnt[pref] += 1
    for v in b:
        pref += v
        cnt[pref] += 1
    # k = 0
    ans0 = 0
    for c in cnt:
        ans0 += c * (c - 1) // 2
    # convolution for k >= 1
    f = cnt[:]  # length m+1
    g = f[::-1]
    h = _convolve_int(f, g) if m >= 1 else [cnt[0] * cnt[0]]
    ans = [0] * (n + 1)
    ans[0] = ans0
    for k in range(1, m + 1):
        ans[k] = h[m + k]
    # k > m are zero already
    return ans

def solve_all():
    n, x, a = read_input()
    if n == 0:
        return
    ans = solve_case_fft(n, x, a)
    print(" ".join(map(str, ans)))

def _bruteforce(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = p[i-1] + b[i-1]
    ans = [0]*(n+1)
    for L in range(1, n+1):
        for R in range(L, n+1):
            t = p[R] - p[L-1]
            ans[t] += 1
    return ans

def _self_test():
    # Fixed tests
    assert solve_case_fft(3, 5, [1, 2, 3]) == [0, 3, 2, 1]
    assert solve_case_fft(3, 2, [3, 2, 1]) == [3, 3, 0, 0]
    # Random cross-checks
    import random
    random.seed(123)
    for n in range(1, 40):
        for _ in range(10):
            a = [random.randint(-5, 5) for _ in range(n)]
            x = random.randint(-5, 5)
            bf = _bruteforce(n, x, a)
            ff = solve_case_fft(n, x, a)
            assert bf == ff, (n, x, a, bf, ff)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts are included for fixed cases; additional randomized cross-checks against brute force confirm correctness for many small inputs.}
\RESULT{Print $n+1$ integers: for each $k=0$ to $n$, the count of subarrays having exactly $k$ elements $<x$. For $k>m$ with $m=\#\{i: a_i<x\}$, the answer is $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use brute force for small $n$ as oracle; cover edge cases (all $<x$, all $\ge x$, mixed), random arrays, and thresholds outside the range of $a$.}
\LINE{CROSS-CHECKS}{Compare Approach A vs C on dozens of small random arrays; ensure exact equality.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with:
- no elements $<x$,
- all elements $<x$,
- alternating $<x$ and $\ge x$,
- long runs of zeros in $b$,
- single one in $b$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_all_ge(n: int, x: int) -> Tuple[int, int, List[int]]:
    a = [x] * n
    return n, x, a

def gen_all_lt(n: int, x: int) -> Tuple[int, int, List[int]]:
    a = [x - 1] * n
    return n, x, a

def gen_alternating(n: int, x: int) -> Tuple[int, int, List[int]]:
    a = []
    for i in range(n):
        a.append(x - 1 if i % 2 == 0 else x)
    return n, x, a

def gen_single_one(n: int, x: int) -> Tuple[int, int, List[int]]:
    a = [x] * n
    if n > 0:
        a[n // 2] = x - 1
    return n, x, a

def reference_solution(n: int, x: int, a: List[int]) -> List[int]:
    # Use the FFT solution from Approach C
    from math import pi, cos, sin
    import cmath
    def _fft(a, invert):
        n = len(a); j = 0
        for i in range(1, n):
            bit = n >> 1
            while j & bit:
                j ^= bit; bit >>= 1
            j ^= bit
            if i < j:
                a[i], a[j] = a[j], a[i]
        length = 2
        while length <= n:
            ang = 2 * pi / length * (-1 if invert else 1)
            wlen = complex(cos(ang), sin(ang))
            for i in range(0, n, length):
                w = 1+0j
                half = length >> 1
                for j in range(i, i+half):
                    u = a[j]; v = a[j+half] * w
                    a[j] = u + v
                    a[j+half] = u - v
                    w *= wlen
            length <<= 1
        if invert:
            inv_n = 1.0 / n
            for i in range(n):
                a[i] *= inv_n
    def conv(A, B):
        if not A or not B: return []
        need = len(A) + len(B) - 1
        n = 1
        while n < need: n <<= 1
        fa = [0j]*n; fb = [0j]*n
        for i,v in enumerate(A): fa[i] = complex(v, 0.0)
        for i,v in enumerate(B): fb[i] = complex(v, 0.0)
        _fft(fa, False); _fft(fb, False)
        for i in range(n): fa[i] *= fb[i]
        _fft(fa, True)
        return [int(round(fa[i].real)) for i in range(need)]
    b = [1 if v < x else 0 for v in a]
    m = sum(b)
    cnt = [0]*(m+1)
    s = 0; cnt[s] += 1
    for v in b:
        s += v; cnt[s] += 1
    ans0 = sum(c*(c-1)//2 for c in cnt)
    f = cnt[:]; g = f[::-1]
    h = conv(f, g) if m >= 1 else [cnt[0]*cnt[0]]
    ans = [0]*(n+1); ans[0] = ans0
    for k in range(1, m+1):
        ans[k] = h[m + k]
    return ans

def test_suite():
    # Fixed suites
    cases = [
        gen_all_ge(5, 10),
        gen_all_lt(5, 10),
        gen_alternating(6, 0),
        gen_single_one(7, 3),
        (3, 5, [1, 2, 3]),
        (3, 2, [3, 2, 1]),
    ]
    for n, x, a in cases:
        ans = reference_solution(n, x, a)
        # quick brute for small n to cross-check
        if n <= 12:
            bf = brute(n, x, a)
            assert ans == bf
    # Random
    random.seed(7)
    for _ in range(50):
        n = random.randint(1, 30)
        x = random.randint(-5, 5)
        a = [random.randint(-5, 5) for _ in range(n)]
        ans = reference_solution(n, x, a)
        bf = brute(n, x, a)
        assert ans == bf

def brute(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = p[i-1] + b[i-1]
    ans = [0]*(n+1)
    for L in range(1, n+1):
        for R in range(L, n+1):
            ans[p[R]-p[L-1]] += 1
    return ans

if __name__ == "__main__":
    test_suite()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys, math
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); x = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, x, a

def _fft(a, invert):
    n = len(a); j = 0
    for i in range(1, n):
        bit = n >> 1
        while j & bit:
            j ^= bit; bit >>= 1
        j ^= bit
        if i < j:
            a[i], a[j] = a[j], a[i]
    length = 2
    while length <= n:
        ang = 2 * math.pi / length * (-1 if invert else 1)
        wlen = complex(math.cos(ang), math.sin(ang))
        for i in range(0, n, length):
            w = 1+0j
            half = length >> 1
            for j in range(i, i+half):
                u = a[j]; v = a[j+half] * w
                a[j] = u + v
                a[j+half] = u - v
                w *= wlen
        length <<= 1
    if invert:
        inv_n = 1.0 / n
        for i in range(n):
            a[i] *= inv_n

def _convolve_int(a: List[int], b: List[int]) -> List[int]:
    if not a or not b:
        return []
    need = len(a) + len(b) - 1
    n = 1
    while n < need:
        n <<= 1
    fa = [0j]*n; fb = [0j]*n
    for i, v in enumerate(a): fa[i] = complex(v, 0.0)
    for i, v in enumerate(b): fb[i] = complex(v, 0.0)
    _fft(fa, False); _fft(fb, False)
    for i in range(n): fa[i] *= fb[i]
    _fft(fa, True)
    return [int(round(fa[i].real)) for i in range(need)]

def solve_case(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    m = sum(b)
    cnt = [0]*(m+1)
    s = 0; cnt[s] += 1
    for v in b:
        s += v; cnt[s] += 1
    ans = [0]*(n+1)
    # k = 0
    ans[0] = sum(c*(c-1)//2 for c in cnt)
    if m >= 1:
        f = cnt[:]; g = f[::-1]
        h = _convolve_int(f, g)
        for k in range(1, m+1):
            ans[k] = h[m + k]
    return ans

def solve_all():
    n, x, a = read_input()
    if n == 0:
        return
    ans = solve_case(n, x, a)
    print(" ".join(map(str, ans)))

def _bruteforce(n: int, x: int, a: List[int]) -> List[int]:
    b = [1 if v < x else 0 for v in a]
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = p[i-1] + b[i-1]
    ans = [0]*(n+1)
    for L in range(1, n+1):
        for R in range(L, n+1):
            ans[p[R]-p[L-1]] += 1
    return ans

def _self_test():
    assert solve_case(3, 5, [1, 2, 3]) == [0, 3, 2, 1]
    assert solve_case(3, 2, [3, 2, 1]) == [3, 3, 0, 0]
    # random small
    import random
    random.seed(42)
    for n in range(1, 35):
        for _ in range(6):
            a = [random.randint(-4, 4) for _ in range(n)]
            x = random.randint(-4, 4)
            assert solve_case(n, x, a) == _bruteforce(n, x, a)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count subarrays with exactly $k$ elements less than a threshold $x$ for all $k$.}
\WHY{Transforms order-statistic queries into frequency convolution, a common trick in competitive programming and interviews.}
\CHECKLIST{
- Build $b_i=\mathbf{1}[a_i<x]$ and prefix sums $p$.
- Count frequencies $c_s$ of $p$.
- Compute $k=0$ via $\sum \binom{c_s}{2}$ or zero-run sum.
- Compute $k\ge 1$ via convolution of $c$ with its reverse and read off $h[m+k]$.
- Print $n+1$ answers.}
\EDGECASES{
- No $a_i<x$ (all answers zero except $k=0$ which equals $n(n+1)/2$).
- All $a_i<x$ (answers are $[0, n, n-1, \ldots, 1]$).
- $x$ outside the range of $a$.
- Large $n$ with sparse ones vs dense ones.
- Single element arrays.}
\PITFALLS{
- Double counting for $k=0$ if using convolution directly; must use $\sum \binom{c_s}{2}$.
- Off-by-one in prefix indexing ($p_0=0$).
- FFT rounding; always round to nearest integer.
- Allocating convolution arrays of correct length.
- Printing exactly $n+1$ values and handling $k>m$ as zeros.}
\FAILMODES{Naive $O(n^2)$ enumeration times out on large $n$; position-based $O(m^2)$ fails when many $a_i<x$. The FFT approach handles all cases in $O(n\log n)$.}
\ELI{Mark each element that is smaller than $x$ as $1$ and others as $0$. Then each subarray’s count of smaller elements is just the sum of its ones. Counting how many subarrays have each possible sum can be done all at once using a fast convolution, and the special case $k=0$ is just counting stretches of zeros.}
\NotePages{3}

\end{document}