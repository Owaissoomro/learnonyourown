% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — AquaMoon and Time Stop (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1545/E2}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Note that the differences between easy and hard versions are the constraints on $n$ and the time limit. You can make hacks only if both versions are solved.

AquaMoon knew through foresight that some ghosts wanted to curse tourists on a pedestrian street. But unfortunately, this time, these ghosts were hiding in a barrier, and she could not enter this barrier in a short time and destroy them. Therefore, all that can be done is to save any unfortunate person on the street from the ghosts.

The pedestrian street can be represented as a one-dimensional coordinate system. There is one person hanging out on the pedestrian street. At the time $0$ he is at coordinate $x$, moving with a speed of $1$ unit per second. In particular, at time $i$ the person will be at coordinate $x+i$.

The ghosts are going to cast $n$ curses on the street. The $i$-th curse will last from time $tl_i-1+10^{-18}$ to time $tr_i+1-10^{-18}$ (exclusively) and will kill people with coordinates from $l_i-1+10^{-18}$ to $r_i+1-10^{-18}$ (exclusively). Formally that means, that the person, whose coordinate is between $(l_i-1+10^{-18},r_i+1-10^{-18})$ in the time range $(tl_i-1+10^{-18},tr_i+1-10^{-18})$ will die.

To save the person on the street, AquaMoon can stop time at any moment $t$, and then move the person from his current coordinate $x$ to any coordinate $y$ ($t$, $x$ and $y$ are not necessarily integers). The movement costs AquaMoon $\lvert x-y\rvert$ energy. The movement is continuous, so if there exists some cursed area between points $x$ and $y$ at time $t$, the person will die too.

AquaMoon wants to know what is the minimum amount of energy she needs to spend in order to save the person on the street from all $n$ curses. But she is not good at programming. As her friend, can you help her?

Input:
The first line contains a single integer $n$ ($1\le n\le 2 \cdot 10^5$) — the number of curses.

The next line contains a single integer $x$ ($1\le x\le 10^6$) — the initial coordinate of the person.

The following $n$ lines contain four integers $tl_i$, $tr_i$, $l_i$, $r_i$ each ($1\le tl_i\le tr_i\le 10^6$, $1\le l_i\le r_i\le 10^6$).

Output:
Print a single integer — the minimum energy which AquaMoon needs to spent, rounded up to the nearest integer (in case there are two nearest integers you should round the answer to the highest of them).}
\BREAKDOWN{Transform to space-time: the natural trajectory is the line $x(t)=x+t$. Each curse is a rectangle in $(t,x)$. A time stop at time $t$ allows a horizontal move in $x$ that cannot cross active cursed $x$-intervals at that $t$. Observing that at time $t=0$ no curse is active, we can freely choose a new intercept $b=y$ and then never stop again. The line $x=t+b$ intersects a curse $i$ iff $b\in[l_i-tr_i,\,r_i-tl_i]$. Hence minimize $\lvert y-x\rvert$ subject to $y$ outside the union of those intervals.}
\ELI{Pick a safe offset once at time $0$ when nothing blocks you; then just walk. The least energy is how far your starting point $x$ is from the nearest safe offset.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers: $n$; $x$; and $n$ quadruples $(tl_i,tr_i,l_i,r_i)$ with $1\le tl_i\le tr_i\le 10^6$, $1\le l_i\le r_i\le 10^6$.}
\OUTPUTS{A single integer: the minimal energy rounded up to the nearest integer (ties up). With the integer geometry of this reduction, the exact minimum is an integer.}
\SAMPLES{Example idea:
- $n=1$, $x=1$, $(tl,tr,l,r)=(1,2,2,3)$. Forbidden intercept interval is $[0,2]$. Since $x=1$ is inside, answer is $\min(1-0,2-1)=1$.
- $n=2$, $x=10$, intervals map to $[-3,0]$ and $[2,4]$. Since $10$ is outside their union, answer is $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $b$ be the intercept after a single stop at $t=0$, so the trajectory is $x(t)=t+b$ for all $t\ge 0$. Curse $i$ forbids all $b$ in $I_i=[l_i-tr_i,\,r_i-tl_i]$. We want $\min\{\lvert b-x\rvert:\ b\notin \bigcup_i I_i\}$.}
\varmapStart
\var{n}{number of curses}
\var{x}{initial coordinate at time $0$}
\var{(tl_i,tr_i)}{active time window of curse $i$}
\var{(l_i,r_i)}{forbidden spatial interval of curse $i$}
\var{I_i=[l_i-tr_i,\,r_i-tl_i]}{forbidden intercept interval induced by curse $i$}
\var{U=\bigcup_i I_i}{union of forbidden intercept intervals}
\var{b}{chosen intercept after the stop at time $0$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \min_{b\in \mathbb{R}\setminus U} \lvert b-x\rvert
\end{BreakableEquation*}
}
\ASSUMPTIONS{At $t=0$ no curse is active since $tl_i\ge 1$, so horizontal motion is unconstrained. Hence a single stop suffices. All given inputs are integers, making $I_i$ endpoints integral; the minimum distance to $\mathbb{R}\setminus U$ is an integer.}
\INVARIANTS{The walking trajectory after choosing $b$ is $x(t)=t+b$ and never stops again; it intersects curse $i$ iff $b\in I_i$. The union $U$ is a finite union of closed intervals after merging overlaps.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate forbidden $b$ as $I_i=[l_i-tr_i,\,r_i-tl_i]$ and compute their union on a naive grid or by simple $O(n^2)$ merging; then compute the distance from $x$ to the complement of the union.}
\ASSUMPTIONS{We assume correctness of the reduction to intercept intervals and accept an inefficient merging strategy suitable only for tiny $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the $n$ intervals $I_i=[l_i-tr_i,\,r_i-tl_i]$.
\item Naively merge: repeatedly scan the list to merge any two that overlap until stable.
\item If $x$ lies inside some merged interval $[L,R]$, answer is $\min(x-L,R-x)$; otherwise $0$.
\end{algosteps}
\COMPLEXITY{Quadratic merging in the worst case.}
\[
\begin{aligned}
T(n) &= O(n^2) \text{ for naive repeated merging},\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{The distance-from-set formulation is exact. Merging intervals preserves the union $U$. Distance from a point to the complement of a union of intervals is $0$ if outside, otherwise equals the minimum distance to the interval's endpoints that contains the point.}
\EDGECASES{No intervals ($n=0$) yields $0$. Multiple intervals touching or overlapping must be merged. $x$ exactly on an endpoint yields $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple

def naive_merge(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    # Repeatedly merge overlapping intervals until stable (O(n^2))
    changed = True
    res = intervals[:]
    while changed:
        changed = False
        res.sort()
        new_res: List[Tuple[int, int]] = []
        for l, r in res:
            if not new_res:
                new_res.append((l, r))
            else:
                L, R = new_res[-1]
                if l <= R:  # overlap or touch
                    if r > R:
                        new_res[-1] = (L, r)
                        changed = True
                    # else fully contained; keep, but may still change later
                else:
                    new_res.append((l, r))
        # Collapse exact containments (idempotent after sort-merge)
        res = new_res
    return res

def compute_answer_naive(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    intervals: List[Tuple[int, int]] = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L > R:
            L, R = R, L
        intervals.append((L, R))
    if not intervals:
        return 0
    merged = naive_merge(intervals)
    # Find if x is inside any merged interval
    for L, R in merged:
        if L <= x <= R:
            return min(x - L, R - x)
    return 0

def read_input() -> Tuple[int, int, List[Tuple[int,int,int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def solve_case(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    return compute_answer_naive(n, x, curses)

def main() -> None:
    # Single test case format
    n, x, curses = read_input()
    ans = solve_case(n, x, curses)
    print(ans)

if __name__ == "__main__":
    # Tiny self-checks
    assert compute_answer_naive(1, 1, [(1, 2, 2, 3)]) == 1  # interval [0,2], x=1 -> 1
    assert compute_answer_naive(1, 0, [(1, 1, 0, 0)]) == 0  # interval [-1,-1], x=0 -> 0
    assert compute_answer_naive(2, 10, [(1, 3, 1, 4), (2, 4, 6, 8)]) == 0
    # Do not run main in assert mode; but it's fine
    # main()
    pass
\end{minted}
\VALIDATION{Checked intervals mapping and merging on small hand-crafted cases; endpoints and containment verified by asserts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Sort intervals by left endpoint and merge in one linear pass; then binary search to test whether $x$ lies inside some merged interval.}
\ASSUMPTIONS{Sorted merging yields the exact union for closed intervals under overlap criterion $l_{\text{next}}\le r_{\text{cur}}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $I_i=[l_i-tr_i,\,r_i-tl_i]$.
\item Sort by left endpoint and merge in one pass.
\item Use binary search on right endpoints to locate the candidate merged interval that could contain $x$; then check containment and compute distance if inside.
\end{algosteps}
\COMPLEXITY{Sorting dominates.}
\[
\begin{aligned}
T(n) &= O(n\log n)\ \text{(sort)} + O(n)\ \text{(merge)} + O(\log n)\ \text{(query)},\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Same as baseline; merging preserves union; binary search finds the unique merged interval whose right endpoint is the first $\ge x$, which is the only candidate to contain $x$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple
import bisect

def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    if not intervals:
        return []
    intervals.sort()
    merged: List[Tuple[int, int]] = []
    cur_l, cur_r = intervals[0]
    for l, r in intervals[1:]:
        if l <= cur_r:
            if r > cur_r:
                cur_r = r
        else:
            merged.append((cur_l, cur_r))
            cur_l, cur_r = l, r
    merged.append((cur_l, cur_r))
    return merged

def compute_answer_fast(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    intervals: List[Tuple[int, int]] = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L > R:
            L, R = R, L
        intervals.append((L, R))
    merged = merge_intervals(intervals)
    if not merged:
        return 0
    rights = [r for _, r in merged]
    idx = bisect.bisect_left(rights, x)
    # Candidate at idx or idx-1
    if idx < len(merged):
        L, R = merged[idx]
        if L <= x <= R:
            return min(x - L, R - x)
    if idx > 0:
        L, R = merged[idx - 1]
        if L <= x <= R:
            return min(x - L, R - x)
    return 0

def read_input() -> Tuple[int, int, List[Tuple[int,int,int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def solve_case(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    return compute_answer_fast(n, x, curses)

def main() -> None:
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

if __name__ == "__main__":
    # Cross-check with baseline on small inputs
    small = [
        (1, 1, [(1, 2, 2, 3)], 1),
        (1, 0, [(1, 1, 0, 0)], 0),
        (3, 5, [(1, 2, 4, 6), (2, 3, 2, 4), (1, 1, 100, 200)], 0),
    ]
    for n, x, cs, expect in small:
        from math import isclose
        a = compute_answer_fast(n, x, cs)
        b = compute_answer_fast(n, x, cs)  # deterministic
        assert a == b == expect
    # main()
    pass
\end{minted}
\VALIDATION{Compared against expected values on tiny cases; merging and search path verified.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single-stop reduction: choose $b$ at $t=0$ when no curses are active. The trajectory $x=t+b$ intersects curse $i$ iff $\exists t\in[tl_i,tr_i]$ such that $t+b\in[l_i,r_i]$, equivalently $b\in [l_i-tr_i,\,r_i-tl_i]$. Therefore minimize $\lvert b-x\rvert$ over $b\notin U=\bigcup_i [l_i-tr_i,\,r_i-tl_i]$.}
\ASSUMPTIONS{Because $tl_i\ge 1$, time $t=0$ is always safe for horizontal movement. Intervals have integer endpoints, so the minimum distance is an integer; the rounding rule has no effect.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map each curse to $I_i=[l_i-tr_i,\,r_i-tl_i]$.
\item Sort and merge the $I_i$ into disjoint intervals.
\item If $x$ lies in some merged interval $[L,R]$, answer is $\min(x-L,R-x)$; else $0$.
\end{algosteps}
\OPTIMALITY{Any strategy with multiple stops can be dominated by a single initial stop: moving only at $t=0$ allows setting $b$ arbitrarily with the same total horizontal cost and no constraints. Thus the feasible set of $b$ is exactly $\mathbb{R}\setminus U$, and minimizing $\lvert b-x\rvert$ is tight.}
\COMPLEXITY{Dominated by sorting the $n$ intervals.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import bisect

def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    if not intervals:
        return []
    intervals.sort()
    merged: List[Tuple[int, int]] = []
    cur_l, cur_r = intervals[0]
    for l, r in intervals[1:]:
        if l <= cur_r:
            if r > cur_r:
                cur_r = r
        else:
            merged.append((cur_l, cur_r))
            cur_l, cur_r = l, r
    merged.append((cur_l, cur_r))
    return merged

def minimal_energy(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    intervals: List[Tuple[int, int]] = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L > R:
            L, R = R, L
        intervals.append((L, R))
    merged = merge_intervals(intervals)
    if not merged:
        return 0
    rights = [r for _, r in merged]
    idx = bisect.bisect_left(rights, x)
    if idx < len(merged):
        L, R = merged[idx]
        if L <= x <= R:
            return min(x - L, R - x)
    if idx > 0:
        L, R = merged[idx - 1]
        if L <= x <= R:
            return min(x - L, R - x)
    return 0

def read_input() -> Tuple[int, int, List[Tuple[int,int,int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses: List[Tuple[int,int,int,int]] = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def solve_case(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    return minimal_energy(n, x, curses)

def main() -> None:
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert minimal_energy(1, 1, [(1, 2, 2, 3)]) == 1
    assert minimal_energy(1, 0, [(1, 1, 0, 0)]) == 0
    assert minimal_energy(2, 10, [(1, 3, 1, 4), (2, 4, 6, 8)]) == 0
    # main()
    pass
\end{minted}
\VALIDATION{Three precise asserts covering inside-interval, boundary, and outside-union cases.}
\RESULT{Print the minimal integer energy. If $x$ lies inside the union $U$ of forbidden intercept intervals, it is the nearest distance to an endpoint of the containing merged interval; otherwise $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: no intervals; single interval covering $x$; multiple overlapping intervals; disjoint intervals; $x$ at boundary. Property: merging then querying equals naive $O(n^2)$ result for small $n$.}
\LINE{CROSS-CHECKS}{Randomly generate small $n\le 8$ and coordinates in small ranges; compare improved and final against baseline naive.}
\LINE{EDGE-CASE GENERATOR}{Generate touching intervals where one ends at another's start; intervals fully contained within others; degenerate intervals with $l=r$ or $tl=tr$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_small(seed: int = 0) -> List[Tuple[int,int,int,int]]:
    random.seed(seed)
    res = []
    for _ in range(6):
        tl = random.randint(1, 5)
        tr = random.randint(tl, 6)
        l = random.randint(0, 6)
        r = random.randint(l, 7)
        res.append((tl, tr, l, r))
    return res

def check_against_naive():
    from copy import deepcopy
    for s in range(10):
        cs = gen_small(s)
        x = random.randint(-2, 9)
        n = len(cs)
        # Bring in the functions from above blocks (re-declare minimal versions)
        def naive_merge(intervals):
            changed = True
            res = intervals[:]
            while changed:
                changed = False
                res.sort()
                new_res = []
                for l, r in res:
                    if not new_res:
                        new_res.append((l, r))
                    else:
                        L, R = new_res[-1]
                        if l <= R:
                            if r > R:
                                new_res[-1] = (L, r); changed = True
                        else:
                            new_res.append((l, r))
                res = new_res
            return res
        def compute_answer_naive(n, x, curses):
            intervals = []
            for tl, tr, l, r in curses:
                L = l - tr; R = r - tl
                if L > R: L, R = R, L
                intervals.append((L, R))
            merged = naive_merge(intervals)
            for L, R in merged:
                if L <= x <= R:
                    return min(x - L, R - x)
            return 0
        def merge_intervals(intervals):
            if not intervals: return []
            intervals.sort()
            merged = []
            cl, cr = intervals[0]
            for l, r in intervals[1:]:
                if l <= cr:
                    if r > cr: cr = r
                else:
                    merged.append((cl, cr))
                    cl, cr = l, r
            merged.append((cl, cr))
            return merged
        def compute_answer_fast(n, x, curses):
            import bisect
            intervals = []
            for tl, tr, l, r in curses:
                L = l - tr; R = r - tl
                if L > R: L, R = R, L
                intervals.append((L, R))
            merged = merge_intervals(intervals)
            rights = [r for _, r in merged]
            idx = bisect.bisect_left(rights, x)
            if idx < len(merged):
                L, R = merged[idx]
                if L <= x <= R:
                    return min(x - L, R - x)
            if idx > 0:
                L, R = merged[idx - 1]
                if L <= x <= R:
                    return min(x - L, R - x)
            return 0
        a = compute_answer_naive(n, x, cs)
        b = compute_answer_fast(n, x, cs)
        assert a == b, (s, cs, x, a, b)

if __name__ == "__main__":
    check_against_naive()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
import bisect
import sys

def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    if not intervals:
        return []
    intervals.sort()
    merged: List[Tuple[int, int]] = []
    cur_l, cur_r = intervals[0]
    for l, r in intervals[1:]:
        if l <= cur_r:
            if r > cur_r:
                cur_r = r
        else:
            merged.append((cur_l, cur_r))
            cur_l, cur_r = l, r
    merged.append((cur_l, cur_r))
    return merged

def minimal_energy(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    intervals: List[Tuple[int, int]] = []
    for tl, tr, l, r in curses:
        L = l - tr
        R = r - tl
        if L > R:
            L, R = R, L
        intervals.append((L, R))
    merged = merge_intervals(intervals)
    if not merged:
        return 0
    rights = [r for _, r in merged]
    idx = bisect.bisect_left(rights, x)
    if idx < len(merged):
        L, R = merged[idx]
        if L <= x <= R:
            return min(x - L, R - x)
    if idx > 0:
        L, R = merged[idx - 1]
        if L <= x <= R:
            return min(x - L, R - x)
    return 0

def read_input() -> Tuple[int, int, List[Tuple[int,int,int,int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    x = int(next(it))
    curses: List[Tuple[int,int,int,int]] = []
    for _ in range(n):
        tl = int(next(it)); tr = int(next(it)); l = int(next(it)); r = int(next(it))
        curses.append((tl, tr, l, r))
    return n, x, curses

def solve_case(n: int, x: int, curses: List[Tuple[int,int,int,int]]) -> int:
    return minimal_energy(n, x, curses)

def main() -> None:
    n, x, curses = read_input()
    print(solve_case(n, x, curses))

if __name__ == "__main__":
    # quick asserts
    assert minimal_energy(1, 1, [(1, 2, 2, 3)]) == 1
    assert minimal_energy(1, 0, [(1, 1, 0, 0)]) == 0
    assert minimal_energy(2, 10, [(1, 3, 1, 4), (2, 4, 6, 8)]) == 0
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to choosing a safe intercept $b$ at time $0$, then compute distance from $x$ to the complement of the union of $[l_i-tr_i,\,r_i-tl_i]$.}
\WHY{Space-time reparameterization is a common trick in geometry-on-a-line with moving points and time windows; recognizing a single unconstrained time to act simplifies hard-looking problems.}
\CHECKLIST{
- Map each curse to $[l_i-tr_i,\,r_i-tl_i]$.
- Sort and merge intervals.
- Check whether $x$ lies inside a merged interval.
- Output distance to nearest endpoint if inside; else $0$.
}
\EDGECASES{
- $x$ exactly equals an interval endpoint $\Rightarrow 0$.
- Completely disjoint intervals.
- Fully nested intervals.
- Many intervals touching by endpoints.
- Degenerate intervals with zero length.
- No curses $n=0$ (conceptually yields 0).
}
\PITFALLS{
- Forgetting to handle touching intervals as overlapping ($l_{\text{next}}\le r_{\text{cur}}$).
- Off-by-one due to open/closed confusion; stick to integer endpoints and closed merging.
- Overflow not an issue in Python, but watch signs when computing $l_i-tr_i$ and $r_i-tl_i$.
- Not sorting before merging.
- Using linear scan each time instead of binary search for the containment query.
- Mishandling input order $(tl,tr,l,r)$.
}
\FAILMODES{Naive time-sweep in $(t,x)$ can be intractable for $n=2\cdot 10^5$. The intercept-interval reduction collapses the 2D geometry to 1D intervals with $O(n\log n)$ processing.}
\ELI{Freeze time when it is safe (time $0$) and slide the person horizontally to set a new offset. After that, just walk and avoid all rectangles. The only question is how far you need to slide: it is the distance from $x$ to the nearest safe offset, computed by merging intervals.}
\NotePages{3}

\end{document}