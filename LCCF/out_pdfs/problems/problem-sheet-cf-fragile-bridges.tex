% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Fragile Bridges}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/201/C}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{You are playing a video game and you have just reached the bonus level, where the only possible goal is to score as many points as possible. Being a perfectionist, you have decided that you will not leave this level until you have gained the maximum possible number of points there.

The bonus level consists of $n$ small platforms placed in a line and numbered from $1$ to $n$ from left to right and $(n - 1)$ bridges connecting adjacent platforms. The bridges between the platforms are very fragile, and for each bridge the number of times one can pass this bridge from one of its ends to the other before it collapses forever is known in advance.

The player's actions are as follows. First, he selects one of the platforms to be the starting position for his hero. After that the player can freely move the hero across the platforms moving by the undestroyed bridges. As soon as the hero finds himself on a platform with no undestroyed bridge attached to it, the level is automatically ended. The number of points scored by the player at the end of the level is calculated as the number of transitions made by the hero between the platforms. Note that if the hero started moving by a certain bridge, he has to continue moving in the same direction until he is on a platform.

Find how many points you need to score to be sure that nobody will beat your record, and move to the next level with a quiet heart.

Input: The first line contains a single integer $n$ ($2 \le n \le 10^5$) — the number of platforms on the bonus level. The second line contains $(n - 1)$ integers $a_i$ ($1 \le a_i \le 10^9$, $1 \le i < n$) — the number of transitions from one end to the other that the bridge between platforms $i$ and $i + 1$ can bear.

Output: Print a single integer — the maximum number of points a player can get on the bonus level.

Please, do not use the \%lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the \%I64d specifier.

Note: One possibility of getting $5$ points in the sample is starting from platform $3$ and consequently moving to platforms $4$, $3$, $2$, $1$ and $2$. After that the only undestroyed bridge is the bridge between platforms $4$ and $5$, but this bridge is too far from platform $2$ where the hero is located now.}
\BREAKDOWN{Model the level as a path multigraph with edge multiplicities $a_i$. The walk ends when stuck at a vertex with no remaining incident edges. Maximize the number of edge traversals before this forced termination. Characterize when all edges can be used and how many must necessarily be left unused otherwise.}
\ELI{Count all crossings you could ever make, then subtract how many you are inevitably forced to miss because of parity ``mismatches'' of the bridges.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ ($2 \le n \le 10^5$).
\item Integers $a_1,\ldots,a_{n-1}$ ($1 \le a_i \le 10^9$).
\end{bullets}
}
\OUTPUTS{One integer: the maximum possible number of transitions (bridge crossings) before the hero is forced to stop.}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input:
\begin{minted}{python}
5
1 2 1 2
\end{minted}
\item Output:
\begin{minted}{python}
5
\end{minted}
\item Explanation: Sum is 6; odd $a_i$ appear in two separated runs, so subtract $2-1=1$.
\end{bullets}

Example 2:
\begin{bullets}
\item Input:
\begin{minted}{python}
4
2 2 2
\end{minted}
\item Output:
\begin{minted}{python}
6
\end{minted}
\item Explanation: All bridges even; an Euler trail exists using all $6$ crossings.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Path multigraph $P_n$ on vertices $\{1,\ldots,n\}$ with an edge of multiplicity $a_i$ between $i$ and $i+1$. A \emph{walk} consumes an edge copy on each traversal; it terminates when the current vertex has degree $0$ in the residual multigraph. Objective: maximize total traversals.}
\varmapStart
\var{n}{number of platforms}
\var{a_i}{capacity (number of traversable copies) of bridge $(i,i+1)$}
\var{E}{total capacity $E=\sum_{i=1}^{n-1} a_i$}
\var{b_i}{parity $b_i=a_i \bmod 2 \in \{0,1\}$}
\var{s}{number of maximal contiguous runs of indices with $b_i=1$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Let } o = \#\{v:\deg(v)\text{ is odd}\} = 2s.
\end{BreakableEquation*}
\[
\text{Maximum walk length } L_{\max} =
\begin{cases}
E, & o \le 2,\\
E - \left(\dfrac{o}{2}-1\right) = E - (s-1), & o \ge 4.
\end{cases}
\]
}
\ASSUMPTIONS{Initial graph is connected since $a_i \ge 1$. Each traversal consumes exactly one unit of capacity on that bridge; direction does not matter.}
\INVARIANTS{
\begin{bullets}
\item The parity of $\deg(v)$ equals the parity of incident odd-capacity edges; odd-degree vertices are exactly endpoints of odd-capacity runs.
\item Any maximal walk must end at a vertex with residual degree $0$; otherwise it can be extended.
\item In a connected multigraph, an Euler trail uses all edges iff there are $0$ or $2$ odd-degree vertices.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use Euler-trail parity characterization. Count total capacity $E$ and the number $s$ of contiguous runs of odd $a_i$. Then answer is $E$ if $s \le 1$, else $E - (s-1)$.}
\ASSUMPTIONS{The path structure ensures the odd-degree count is $o=2s$. Maximal walk length equals the length of the longest trail.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$ and array $a$.
\item Compute $E = \sum a_i$.
\item Scan $a$ to count $s$, the number of maximal contiguous segments where $a_i$ is odd.
\item Output $E$ if $s \le 1$, else output $E - (s-1)$.
\end{algosteps}
\COMPLEXITY{Linear in $n$.
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(1).
\end{aligned}
\]
}
\CORRECTNESS{For a connected multigraph, a trail covering all edges exists iff there are at most two odd-degree vertices. In a path, internal vertex $v$ has $\deg(v)=a_{v-1}+a_v$ and endpoints have degree $a_1$ and $a_{n-1}$. Thus odd-degree vertices occur exactly at boundaries of runs of odd $a_i$, giving $o=2s$. If $o \le 2$ we can take an Euler trail and achieve $E$. Otherwise, any single trail must leave unused at least $\tfrac{o}{2}-1=s-1$ edges; this bound is tight on a path, so the maximum is $E-(s-1)$.}
\EDGECASES{
\begin{bullets}
\item All $a_i$ even $\Rightarrow s=0 \Rightarrow$ answer $E$.
\item Exactly one contiguous odd-run $\Rightarrow s=1 \Rightarrow$ answer $E$.
\item Many alternating parities $\Rightarrow$ larger $s$, subtract $s-1$ accordingly.
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n - 1)]
    return n, a

def count_odd_runs(a):
    s = 0
    prev_odd = 0
    for x in a:
        cur_odd = x & 1
        if cur_odd and not prev_odd:
            s += 1
        prev_odd = cur_odd
    return s

def solve_case(n, a):
    total = sum(a)
    s = count_odd_runs(a)
    if s <= 1:
        return total
    return total - (s - 1)

def main():
    # Unit tests (do not print on success)
    def _tests():
        assert solve_case(3, [1, 1]) == 2
        assert solve_case(4, [1, 2, 1]) == 3  # E=4, s=2 -> 4-1
        assert solve_case(5, [2, 2, 2, 2]) == 8
        assert solve_case(5, [1, 2, 1, 2]) == 5  # E=6, s=2 -> 5
        assert solve_case(6, [1, 2, 3, 4, 5]) == (1+2+3+4+5) - (3 - 1)
        # All even -> s=0 -> E
        assert solve_case(4, [2, 4, 6]) == 12
        # Alternating odd runs at positions [0],[2],[4] -> s=3 -> subtract 2
        assert solve_case(6, [1, 2, 1, 2, 1]) == (1+2+1+2+1) - 2
    _tests()

    n, a = read_input()
    if n == 0:
        return
    ans = solve_case(n, a)
    print(ans)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{
\begin{bullets}
\item Hand-check small arrays with alternating parity.
\item Check all-even arrays return the sum.
\item Check a single odd-run returns the sum.
\end{bullets}
}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Parity Compression}
\WHICHFORMULA{Compress the parity sequence $b_i=a_i \bmod 2$ and count runs of $1$ directly in one pass without storing the entire sequence.}
\ASSUMPTIONS{Only parity changes matter beyond the total sum.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain running sum $E$.
\item Maintain a boolean flag for whether we are currently inside an odd run.
\item Increment $s$ upon entering an odd run.
\item Output $E$ if $s \le 1$, otherwise $E - (s-1)$.
\end{algosteps}
\COMPLEXITY{Same asymptotic as baseline but with minimal state: $T(n)=\Theta(n)$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n) &= \Theta(n) \\
S(n) &= \Theta(1)
\end{aligned}
\]
\CORRECTNESS{Same as Approach A; counting runs via streaming parity is equivalent to counting maximal contiguous 1-blocks.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n - 1)]
    return n, a

def solve_case(n, a):
    total = 0
    s = 0
    in_run = False
    for x in a:
        total += x
        odd = (x & 1) == 1
        if odd and not in_run:
            s += 1
        in_run = odd
    if s <= 1:
        return total
    return total - (s - 1)

def main():
    # Unit tests
    def _tests():
        assert solve_case(3, [2, 2]) == 4
        assert solve_case(4, [1, 2, 1]) == 3
        assert solve_case(5, [1, 2, 1, 2]) == 5
        assert solve_case(6, [1, 2, 1, 2, 1]) == 7 - 2
    _tests()

    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{
\begin{bullets}
\item Alternating parity arrays: predictable $s$ count.
\item Degenerate all-even and single odd-run arrays.
\end{bullets}
}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Euler Trail Parity Criterion on a Path}
\WHICHFORMULA{Compute $E=\sum a_i$ and $s=$ number of odd-capacity runs. Answer is $E - \max(0, s-1)$.}
\ASSUMPTIONS{Path graph is connected; traversals consume capacity; a maximal walk has no extension.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Single pass: accumulate $E$ and count $s$ upon entering an odd run.
\item Compute $E$ if $s \le 1$ else $E - (s-1)$.
\item Print the result.
\end{algosteps}
\OPTIMALITY{Tight by classical Euler trail bounds: in a connected multigraph with $o$ odd vertices, a single trail can cover at most $E - \left(\tfrac{o}{2}-1\right)$ edges, and this bound is achieved on a path. Here $o=2s$.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n - 1)]
    return n, a

def solve_case(n, a):
    total = 0
    s = 0
    in_run = False
    for x in a:
        total += x
        odd = (x & 1) == 1
        if odd and not in_run:
            s += 1
        in_run = odd
    if s <= 1:
        return total
    return total - (s - 1)

def main():
    # Minimal unit tests
    def _tests():
        assert solve_case(4, [2, 2, 2]) == 6
        assert solve_case(4, [1, 2, 1]) == 3
        assert solve_case(6, [1, 2, 1, 2, 1]) == (1+2+1+2+1) - 2
    _tests()

    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts included in main.}
\RESULT{Maximum number of transitions equals $\sum a_i - \max(0, s-1)$, where $s$ is the number of contiguous runs of odd $a_i$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on:
\begin{bullets}
\item All-even capacities (Euler trail exists).
\item Single odd-run.
\item Multiple odd-runs (alternating parity cases).
\item Random small $n$ cross-checked by brute enumeration of parity formula.
\end{bullets}
}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, C on the same inputs; they are identical by construction.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with patterns of parity (all even, one odd block, many short odd blocks) to exercise $s=0,1,2,3,\ldots$.}
\begin{minted}{python}
import random

def gen_parity_pattern(n, runs):
    # Create an array of length n-1 with exactly 'runs' odd runs
    m = n - 1
    if runs == 0:
        return [2] * m
    # Place 'runs' segments of length >=1 within m positions, separated by >=1 zero segment
    # Start with all even
    b = [0] * m
    # Choose run lengths that sum to at most m with separators
    # Simple strategy: pick start indices greedily
    positions = list(range(m))
    # Split m into runs*2-1 blocks: odd blocks = ones, even blocks = zeros (at least 1 for interior zeros)
    # We will first set all interior zeros to length 1, then distribute remaining to ones
    blocks = [1] * (runs * 2 - 1)
    # Sum of ones blocks initially = runs, zeros blocks initially = runs-1
    used = sum(blocks) + (runs - 1)  # include mandatory interior zeros
    extra = m - used
    # Distribute extra to ones blocks
    for i in range(0, len(blocks), 2):
        add = 0
        if extra > 0:
            add = random.randint(0, extra)
        blocks[i] += add
        extra -= add
    # Distribute any leftover to the last ones block
    if extra > 0:
        blocks[-1] += extra
    # Build parity array
    idx = 0
    for i, length in enumerate(blocks):
        if i % 2 == 0:
            for _ in range(length):
                if idx < m: b[idx] = 1; idx += 1
        else:
            # interior zero block: length at least 1
            for _ in range(length + 1):
                if idx < m: b[idx] = 0; idx += 1
    # Map to capacities (odd -> 1, even -> 2)
    a = [1 if x == 1 else 2 for x in b]
    return a[:m]

def brute_formula(a):
    total = sum(a)
    s = 0
    in_run = False
    for x in a:
        odd = (x & 1) == 1
        if odd and not in_run:
            s += 1
        in_run = odd
    return total if s <= 1 else total - (s - 1)

def reference_solve(n, a):
    return brute_formula(a)

def quick_check():
    for n in range(2, 25):
        for runs in range(0, min(6, n)):
            a = gen_parity_pattern(n, runs)
            ans = reference_solve(n, a)
            # Cross-check with the same solver used above
            assert ans == brute_formula(a)
    print("All generated tests passed.")

if __name__ == "__main__":
    quick_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n - 1)]
    return n, a

def solve_case(n, a):
    total = 0
    s = 0
    in_run = False
    for x in a:
        total += x
        odd = (x & 1) == 1
        if odd and not in_run:
            s += 1
        in_run = odd
    if s <= 1:
        return total
    return total - (s - 1)

def main():
    # Sanity asserts
    def _tests():
        assert solve_case(3, [1, 1]) == 2
        assert solve_case(4, [2, 2, 2]) == 6
        assert solve_case(5, [1, 2, 1, 2]) == 5
    _tests()

    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer equals total capacity minus the number of odd-capacity runs beyond the first: $\sum a_i - \max(0, s-1)$.}
\WHY{This is a direct application of Euler trail existence and tight bounds in connected multigraphs, specialized to a path.}
\CHECKLIST{
\begin{bullets}
\item Sum all $a_i$.
\item Scan once to count odd-run entries.
\item Subtract $s-1$ if $s \ge 2$.
\item Print as 64-bit integer.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$ (single bridge).
\item All $a_i$ even $\Rightarrow$ no subtraction.
\item Single odd bridge or single odd run.
\item Long alternating parity creating many short odd runs.
\item Very large $a_i$ values (ensure no overflow in languages with fixed-width ints).
\item Leading/trailing odd runs (properly counted as one each).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Miscounting runs when two odd bridges are adjacent (should be one run, not two).
\item Forgetting that only parity matters for the subtraction term.
\item Off-by-one when scanning from the first element.
\item Using 32-bit integers in languages where overflow is possible.
\item Printing with the wrong format specifier in C++; in Python this is not an issue.
\item Reading input with trailing spaces/newlines.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Greedy local walking simulations can get trapped early and are not robust.
\item Attempting to simulate the whole process is too slow and error-prone.
\item Ignoring parity and trying to subtract the count of odd bridges (instead of runs) yields wrong answers.
\end{bullets}
}
\ELI{Treat each bridge as many copies of an edge. You can traverse all copies unless the pattern of odd bridges forces too many places where a trail must start or end. Each separated block of odd bridges beyond the first costs you exactly one missed crossing.}
\NotePages{3}

\end{document}