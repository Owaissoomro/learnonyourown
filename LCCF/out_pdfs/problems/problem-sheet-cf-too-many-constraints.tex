% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Too Many Constraints}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1697/F}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{You are asked to build an array $a$, consisting of $n$ integers, each element should be from $1$ to $k$.

The array should be non-decreasing ($a_i \le a_{i+1}$ for all $i$ from $1$ to $n-1$).

You are also given additional constraints on it. Each constraint is of one of three following types:
\begin{bullets}
\item $1~i~x$: $a_i$ should not be equal to $x$;
\item $2~i~j~x$: $a_i + a_j \le x$;
\item $3~i~j~x$: $a_i + a_j \ge x$.
\end{bullets}
Build any non-decreasing array that satisfies all constraints or report that no such array exists.

Input: The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of testcases.

The first line of each testcase contains three integers $n, m$ and $k$ ($2 \le n \le 2\cdot 10^4$; $0 \le m \le 2\cdot 10^4$; $2 \le k \le 10$).

The $i$-th of the next $m$ lines contains a description of a constraint. Each constraint is of one of three following types:
\begin{bullets}
\item $1~i~x$ ($1 \le i \le n$; $1 \le x \le k$): $a_i$ should not be equal to $x$;
\item $2~i~j~x$ ($1 \le i < j \le n$; $2 \le x \le 2\cdot k$): $a_i + a_j \le x$;
\item $3~i~j~x$ ($1 \le i < j \le n$; $2 \le x \le 2\cdot k$): $a_i + a_j \ge x$.
\end{bullets}
The sum of $n$ over all testcases does not exceed $2\cdot 10^4$. The sum of $m$ over all testcases does not exceed $2\cdot 10^4$.

Output: For each testcase, determine if there exists a non-decreasing array that satisfies all conditions. If there is no such array, then print $-1$. Otherwise, print any valid array — $n$ integers from $1$ to $k$.}
\BREAKDOWN{Model values with tiny domain $\{1,\ldots,k\}$ and capture non-decreasingness and pairwise sum bounds. Reduce to boolean thresholds per position and solve via implications (2-SAT), then reconstruct any valid non-decreasing array.}
\ELI{Turn each integer into a stack of at most $k-1$ yes/no switches; all constraints become if-then rules between switches, which we solve with a standard 2-SAT implication graph.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple testcases. For each testcase: integers $n, m, k$; then $m$ constraint lines of types:
\begin{bullets}
\item Type 1: $1~i~x$ with $1 \le i \le n$, $1 \le x \le k$.
\item Type 2: $2~i~j~x$ with $1 \le i < j \le n$, $2 \le x \le 2k$.
\item Type 3: $3~i~j~x$ with $1 \le i < j \le n$, $2 \le x \le 2k$.
\end{bullets}
Global sums: $\sum n \le 2\cdot 10^4$, $\sum m \le 2\cdot 10^4$.}
\OUTPUTS{For each testcase, either $-1$ if infeasible, or any non-decreasing array $a_1,\ldots,a_n$ with each $a_i \in [1,k]$ that satisfies all constraints. One line per testcase.}
\SAMPLES{Example 1 (possible): $n=3,k=3,m=1$ with constraint $3~1~3~4$ (i.e., $a_1+a_3 \ge 4$). Output: $1~2~2$.

Example 2 (impossible): $n=2,k=2,m=2$ with $1~1~1$ and $2~1~2~2$; non-decreasing plus $a_1 \ne 1$ and $a_1+a_2 \le 2$ contradict. Output: $-1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a_i \in \{1,\ldots,k\}$ and define $y_i = a_i - 1 \in \{0,\ldots,k-1\}$. Introduce boolean thresholds
\begin{BreakableEquation*}
X_{i,v} = [\,y_i \ge v\,], \quad \text{for } i \in \{1,\ldots,n\},~ v \in \{1,\ldots,k-1\}.
\end{BreakableEquation*}
Monotonicity implies $X_{i,v+1} \Rightarrow X_{i,v}$ for each $i$, and non-decreasing array implies $X_{i+1,v} \Rightarrow X_{i,v}$ for each $v$. Then:
\begin{bullets}
\item $a_i \ne x$ forbids the pattern $X_{i,x-1}=1$ and $X_{i,x}=0$ (with $x=1$ means force $X_{i,1}=1$; $x=k$ means force $X_{i,k-1}=0$).
\item $a_i + a_j \le x$ with $T=x-2$ gives, for all $s \in \{1,\ldots,k-1\}$:
\begin{BreakableEquation*}
X_{i,s} \Rightarrow \neg X_{j,\,T - s + 1}\quad\text{(when the index is in }[1,k-1]\text{; clamp to unit clauses otherwise)}.
\end{BreakableEquation*}
\item $a_i + a_j \ge x$ with $T=x-2$ gives, for all $s \in \{0,\ldots,k-1\}$:
\begin{BreakableEquation*}
(y_i \le s) \Rightarrow (y_j \ge T-s)\quad\Longleftrightarrow\quad X_{i,s+1} \lor X_{j,\,T-s}
\end{BreakableEquation*}
(with boundary handling for indices $\le 0$ or $\ge k$).
\end{bullets}
All constraints are clauses of size at most 2 over literals $\{X_{i,v}, \neg X_{i,v}\}$, thus solvable by 2-SAT.}
\varmapStart
\var{a_i}{value at position $i$}
\var{y_i}{shifted value $a_i-1 \in [0,k-1]$}
\var{X_{i,v}}{boolean literal $[y_i \ge v]$, for $v=1,\ldots,k-1$}
\var{T}{abbreviation $x-2$ for sum constraints on $y$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&X_{i,v+1} \Rightarrow X_{i,v}\quad(1 \le v \le k-2),\qquad X_{i+1,v} \Rightarrow X_{i,v}\quad(1 \le v \le k-1),\\
&\text{Type 1: } \begin{cases}
x=1:~ X_{i,1}=\text{true},\\
1<x<k:~ X_{i,x-1} \Rightarrow X_{i,x},\\
x=k:~ X_{i,k-1}=\text{false},
\end{cases}\\
&\text{Type 2: } \forall s\in[1,k-1],~ X_{i,s} \Rightarrow \neg X_{j,\,T-s+1}\quad(\text{index range checked}),\\
&\text{Type 3: } \forall s\in[0,k-1],~ X_{i,s+1} \lor X_{j,\,T-s}\quad(\text{index range checked}).
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based; constraints have $i<j$ for sum types. Domains are small: $k \le 10$. We may add both directional clauses for symmetry; they are redundant but safe.}
\INVARIANTS{If 2-SAT is satisfiable, the reconstructed $a$ is non-decreasing by construction; each $a_i$ equals $1+\max\{v: X_{i,v}=\text{true}\}$, defaulting to $1$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Backtracking over non-decreasing arrays $a_1 \le \cdots \le a_n$ with pruning by constraints.}
\ASSUMPTIONS{Small $n$ only; used to validate ideas and tiny cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate non-decreasing arrays by increasing positions, trying values from previous $a_{i-1}$ up to $k$.
\item After setting each $a_i$, check all constraints whose endpoints are decided; prune on violation.
\item Stop on first full assignment satisfying all constraints; otherwise report $-1$.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in worst case; only suitable for toy inputs.}
\[
\begin{aligned}
T(n) &\le O(k^n) \text{ in the worst case, with pruning},\\
S(n) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{Exhaustive search over all non-decreasing arrays; pruning preserves correctness.}
\EDGECASES{Handle type 1 with $x=1$ or $x=k$; sum bounds at extremes $2$ and $2k$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple, TextIO
def read_input(inp: TextIO):
    data = inp.read().strip().split()
    it = iter(data)
    t = int(next(it, '0'))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        cons = []
        for _ in range(m):
            typ = int(next(it))
            if typ == 1:
                i = int(next(it)); x = int(next(it))
                cons.append((1, i-1, None, x))
            else:
                i = int(next(it)); j = int(next(it)); x = int(next(it))
                cons.append((typ, i-1, j-1, x))
        tests.append((n, m, k, cons))
    return tests
def check_constraints(a: List[int], cons: List[Tuple[int,int,int,int]]) -> bool:
    for typ, i, j, x in cons:
        if typ == 1:
            if a[i] == x: return False
        elif typ == 2:
            if a[i] + a[j] > x: return False
        else:
            if a[i] + a[j] < x: return False
    return True
def solve_case_bruteforce(n: int, m: int, k: int, cons: List[Tuple[int,int,int,int]]) -> List[int] or None:
    a = [1]*n
    def ok_prefix(u: int) -> bool:
        # Check constraints fully within [0..u]
        for typ, i, j, x in cons:
            if typ == 1:
                if i <= u and a[i] == x: return False
            else:
                if i <= u and j <= u:
                    s = a[i] + a[j]
                    if typ == 2 and s > x: return False
                    if typ == 3 and s < x: return False
        return True
    def dfs(i: int, prev: int) -> bool:
        if i == n:
            return check_constraints(a, cons)
        for val in range(prev, k+1):
            a[i] = val
            if not ok_prefix(i): continue
            if dfs(i+1, val):
                return True
        return False
    if dfs(0, 1):
        return a[:]
    return None
def solve_all(inp: TextIO, out: TextIO):
    tests = read_input(inp)
    for n, m, k, cons in tests:
        ans = solve_case_bruteforce(n, m, k, cons)
        if ans is None:
            print(-1, file=out)
        else:
            print(" ".join(map(str, ans)), file=out)
def main():
    solve_all(sys.stdin, sys.stdout)
if __name__ == "__main__":
    # Tiny self-checks (baseline intended for small instances)
    from io import StringIO
    def run_io(data: str) -> str:
        inp = StringIO(data)
        out = StringIO()
        solve_all(inp, out)
        return out.getvalue()
    # 1) No constraints, non-decreasing length 3 with k=2 -> 1 1 1
    out = run_io("1\n3 0 2\n")
    assert out.strip() in {"1 1 1", "1 1 2", "1 2 2", "2 2 2"}
    # 2) Forbid 1 at i=1, n=1,k=3 -> minimal is 2
    out = run_io("1\n1 1 3\n1 1 1\n")
    assert out.strip() == "2"
    # 3) Impossible: n=2,k=2; a1!=1 and a1+a2<=2 and non-decreasing -> -1
    out = run_io("1\n2 2 2\n1 1 1\n2 1 2 2\n")
    assert out.strip() == "-1"
    main()
\end{minted}
\VALIDATION{Validated on three handcrafted small cases within asserts; baseline is only for toy sizes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Arc-Consistency on Tiny Domains}
\WHICHFORMULA{View each $a_i$ as a domain subset of $\{1,\ldots,k\}$ and iteratively prune infeasible values using constraint supports (AC-3).}
\ASSUMPTIONS{Domains are tiny ($k \le 10$); many constraints are binary. Non-decreasing adds $a_i \le a_{i+1}$. This still may fail to decide all global interactions, but works well on many cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $D_i = \{1,\ldots,k\}$, remove $x$ from $D_i$ for type 1 constraints.
\item Add binary relations for non-decreasing and sum constraints; run AC-3 to delete unsupported values.
\item If any $D_i=\varnothing$, infeasible. Else greedily assign non-decreasing values consistent with remaining constraints (left to right).
\end{algosteps}
\COMPLEXITY{Each delete event is $O(1)$ and each pair is revisited boundedly; overall roughly $O(m\cdot k^2)$ but may backtrack in assignment.}
\[
\begin{aligned}
T(n) &\approx O((n+m)\cdot k^2) \text{ for pruning} \\
\end{aligned}
\]
\CORRECTNESS{Arc-consistency is necessary but not sufficient; the method may be inconclusive or backtrack.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple, TextIO, Deque, Set
from collections import deque
def read_input(inp: TextIO):
    data = inp.read().strip().split()
    it = iter(data)
    t = int(next(it, '0'))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        cons = []
        for _ in range(m):
            typ = int(next(it))
            if typ == 1:
                i = int(next(it)); x = int(next(it))
                cons.append((1, i-1, None, x))
            else:
                i = int(next(it)); j = int(next(it)); x = int(next(it))
                cons.append((typ, i-1, j-1, x))
        tests.append((n, m, k, cons))
    return tests
def solve_case_ac3(n: int, m: int, k: int, cons: List[Tuple[int,int,int,int]]) -> List[int] or None:
    # Domains
    D: List[Set[int]] = [set(range(1, k+1)) for _ in range(n)]
    # Apply unary constraints
    for typ, i, j, x in cons:
        if typ == 1:
            if x in D[i]:
                D[i].remove(x)
                if not D[i]: return None
    # Build adjacency of binary constraints including monotonicity
    arcs: List[Tuple[int,int]] = []
    # non-decreasing: a_i <= a_{i+1}
    for i in range(n-1):
        arcs.append((i, i+1))
        arcs.append((i+1, i))
    # sum constraints
    pair_cons = {}  # (i,j) -> list of (type,x)
    for typ, i, j, x in cons:
        if typ != 1:
            if i > j: i, j = j, i
            pair_cons.setdefault((i,j), []).append((typ, x))
            arcs.append((i, j))
            arcs.append((j, i))
    # AC-3
    Q: Deque[Tuple[int,int]] = deque(arcs)
    def supported(i: int, j: int, vi: int, vj: int) -> bool:
        if abs(i-j) == 1:
            # non-decreasing relates neighbors only
            if i < j and not (vi <= vj): return False
            if i > j and not (vj <= vi): return False
        if (min(i,j), max(i,j)) in pair_cons:
            for typ, x in pair_cons[(min(i,j), max(i,j))]:
                if typ == 2 and not (vi + vj <= x): return False
                if typ == 3 and not (vi + vj >= x): return False
        return True
    while Q:
        i, j = Q.popleft()
        removed = False
        Dj = D[j]
        newDi = set()
        for vi in D[i]:
            ok = any(supported(i, j, vi, vj) for vj in Dj)
            if ok:
                newDi.add(vi)
        if newDi != D[i]:
            if not newDi: return None
            D[i] = newDi
            # add neighbors back
            if i-1 >= 0: Q.append((i-1, i))
            if i+1 < n: Q.append((i+1, i))
            for (u,v) in pair_cons.keys():
                if u == i and v != j: Q.append((v, u))
                if v == i and u != j: Q.append((u, v))
    # Greedy assign left-to-right smallest feasible respecting non-decreasing
    a = [1]*n
    prev = 1
    for i in range(n):
        cand = sorted(x for x in D[i] if x >= prev)
        ok_pick = None
        for val in cand:
            # check already determined constraints
            good = True
            for typ, u, v, x in cons:
                if typ == 1:
                    if u == i and val == x: good = False; break
                else:
                    if u == i and v < i:
                        if typ == 2 and not (val + a[v] <= x): good = False; break
                        if typ == 3 and not (val + a[v] >= x): good = False; break
                    if v == i and u < i:
                        if typ == 2 and not (val + a[u] <= x): good = False; break
                        if typ == 3 and not (val + a[u] >= x): good = False; break
            if good:
                ok_pick = val
                break
        if ok_pick is None:
            return None
        a[i] = ok_pick
        prev = ok_pick
    return a
def solve_all(inp: TextIO, out: TextIO):
    tests = read_input(inp)
    for n, m, k, cons in tests:
        ans = solve_case_ac3(n, m, k, cons)
        if ans is None:
            print(-1, file=out)
        else:
            print(" ".join(map(str, ans)), file=out)
def main():
    solve_all(sys.stdin, sys.stdout)
if __name__ == "__main__":
    from io import StringIO
    def run_io(data: str) -> str:
        inp = StringIO(data)
        out = StringIO()
        solve_all(inp, out)
        return out.getvalue()
    # Basic checks mirroring baseline
    out = run_io("1\n3 0 2\n")
    assert out.strip() in {"1 1 1", "1 1 2", "1 2 2", "2 2 2"}
    out = run_io("1\n1 1 3\n1 1 1\n")
    assert out.strip() == "2"
    out = run_io("1\n2 2 2\n1 1 1\n2 1 2 2\n")
    assert out.strip() == "-1"
    main()
\end{minted}
\VALIDATION{Checked on small cases; AC-3 prunes many inconsistencies but is not guaranteed complete.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{2-SAT over Threshold Booleans}
\WHICHFORMULA{Encode each $a_i$ by booleans $X_{i,v}=[a_i \ge v+1]$ for $v=1,\ldots,k-1$. Non-decreasing and all constraints translate to 2-CNF clauses. Solve by SCC on the implication graph and reconstruct $a$.}
\ASSUMPTIONS{$k \le 10$ so variables are $n\cdot(k-1) \le 1.8\cdot 10^5$ over all tests; edges are linear in $(m+n)\cdot k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Create variable for each $(i,v)$: $X_{i,v}=[a_i \ge v+1]$.
\item Add implications for value monotonicity ($X_{i,v+1}\Rightarrow X_{i,v}$) and index monotonicity ($X_{i+1,v}\Rightarrow X_{i,v}$).
\item Translate each constraint into 2-CNF clauses as detailed in the model; add symmetric clauses for robustness.
\item Solve 2-SAT via SCC. If unsatisfiable, print $-1$; else reconstruct $a_i=1+\max\{v:X_{i,v}=\text{true}\}$.
\end{algosteps}
\OPTIMALITY{This exactly captures feasibility; 2-SAT runs in linear time in the implication graph size, which is $O((n+m)\cdot k)$.}
\COMPLEXITY{With $V=n(k-1)$ variables and $E=O((n+m)k)$ clauses:
\[
\begin{aligned}
T(n) &= O(V+E) \quad \text{per testcase},\\
S(n) &= O(V+E).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, TextIO

class TwoSAT:
    def __init__(self, nvars: int):
        self.n = nvars
        self.N = nvars * 2
        self.g = [[] for _ in range(self.N)]
        self.gr = [[] for _ in range(self.N)]
    @staticmethod
    def _neg(lit: int) -> int:
        return lit ^ 1
    def _add_edge(self, u: int, v: int):
        self.g[u].append(v)
        self.gr[v].append(u)
    def add_clause(self, u: int, v: int):
        # (u OR v): u and v are literals encoded as 2*x or 2*x^1
        self._add_edge(self._neg(u), v)
        self._add_edge(self._neg(v), u)
    def add_imp(self, u: int, v: int):
        # u => v  is (not u) OR v
        self.add_clause(self._neg(u), v)
    def force_true(self, u: int):
        # (u) as (u OR u)
        self.add_clause(u, u)
    def force_false(self, u: int):
        # (not u)
        self.force_true(self._neg(u))
    def satisfiable(self) -> Tuple[bool, List[bool]]:
        order = []
        vis = [False]*self.N
        sys.setrecursionlimit(1 << 20)
        def dfs(v: int):
            vis[v] = True
            for to in self.g[v]:
                if not vis[to]:
                    dfs(to)
            order.append(v)
        for v in range(self.N):
            if not vis[v]:
                dfs(v)
        comp = [-1]*self.N
        def rdfs(v: int, c: int):
            comp[v] = c
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, c)
        j = 0
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j)
                j += 1
        assign = [False]*self.n
        for i in range(self.n):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assign[i] = comp[2*i] > comp[2*i+1]
        return True, assign

def read_input(inp: TextIO):
    data = inp.read().strip().split()
    it = iter(data)
    t = int(next(it, '0'))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        cons = []
        for _ in range(m):
            typ = int(next(it))
            if typ == 1:
                i = int(next(it)); x = int(next(it))
                cons.append((1, i-1, None, x))
            else:
                i = int(next(it)); j = int(next(it)); x = int(next(it))
                cons.append((typ, i-1, j-1, x))
        tests.append((n, m, k, cons))
    return tests

def var_id(i: int, v: int, k: int) -> int:
    # X_{i,v} with v in [1..k-1] maps to variable index
    return i*(k-1) + (v-1)

def lit(var_index: int, is_true: bool) -> int:
    return (var_index << 1) | (0 if is_true else 1)

def solve_case_2sat(n: int, m: int, k: int, cons: List[Tuple[int,int,int,int]]) -> List[int] or None:
    if k == 1:
        # Only value is 1; check feasibility quickly
        # Must be non-decreasing (trivial) and all constraints satisfied
        a = [1]*n
        for typ, i, j, x in cons:
            if typ == 1 and x == 1: return None
            if typ == 2 and 1+1 > x: return None
            if typ == 3 and 1+1 < x: return None
        return a
    V = n*(k-1)
    sat = TwoSAT(V)
    # Value monotonicity: X_{i,v+1} => X_{i,v}
    for i in range(n):
        for v in range(1, k-1):
            u = var_id(i, v+1, k)
            w = var_id(i, v, k)
            sat.add_imp(lit(u, True), lit(w, True))
    # Index monotonicity: X_{i+1,v} => X_{i,v}
    for i in range(n-1):
        for v in range(1, k):
            u = var_id(i+1, v, k)
            w = var_id(i, v, k)
            sat.add_imp(lit(u, True), lit(w, True))
    # Constraints
    unsat_flag = False
    for typ, i, j, x in cons:
        if typ == 1:
            xi = x
            if xi == 1:
                if k-1 >= 1:
                    sat.force_true(lit(var_id(i, 1, k), True))
                else:
                    # k==1 handled earlier
                    pass
            elif xi == k:
                sat.force_false(lit(var_id(i, k-1, k), True))
            else:
                # X_{i,xi-1} => X_{i,xi}
                sat.add_imp(lit(var_id(i, xi-1, k), True), lit(var_id(i, xi, k), True))
        elif typ == 2:
            # a_i + a_j <= x  =>  y_i + y_j <= T
            T = x - 2
            # For all s in [1..k-1]: (not X_{i,s}) OR (not X_{j,u}), where u = T - s + 1
            for s in range(1, k):
                uidx = T - s + 1
                if uidx <= 0:
                    # Force not X_{i,s}
                    sat.force_false(lit(var_id(i, s, k), True))
                elif uidx >= k:
                    # Clause is tautology
                    pass
                else:
                    sat.add_clause(lit(var_id(i, s, k), False), lit(var_id(j, uidx, k), False))
            # Symmetric (optional)
            for s in range(1, k):
                uidx = T - s + 1
                if uidx <= 0:
                    sat.force_false(lit(var_id(j, s, k), True))
                elif uidx >= k:
                    pass
                else:
                    sat.add_clause(lit(var_id(j, s, k), False), lit(var_id(i, uidx, k), False))
        else:
            # a_i + a_j >= x  =>  y_i + y_j >= T
            T = x - 2
            # For s in [0..k-2]: X_{i,s+1} OR X_{j, v}, where v = T - s
            for s in range(0, k-1):
                vneed = T - s
                if vneed <= 0:
                    continue
                elif vneed >= k:
                    # Clause reduces to X_{i,s+1}
                    sat.force_true(lit(var_id(i, s+1, k), True))
                else:
                    sat.add_clause(lit(var_id(i, s+1, k), True), lit(var_id(j, vneed, k), True))
            # Handle s = k-1 separately: antecedent is True
            vneed = T - (k-1)
            if vneed > 0:
                if vneed >= k:
                    unsat_flag = True
                else:
                    sat.force_true(lit(var_id(j, vneed, k), True))
            # Symmetric (optional)
            for s in range(0, k-1):
                vneed = T - s
                if vneed <= 0:
                    continue
                elif vneed >= k:
                    sat.force_true(lit(var_id(j, s+1, k), True))
                else:
                    sat.add_clause(lit(var_id(j, s+1, k), True), lit(var_id(i, vneed, k), True))
            vneed = T - (k-1)
            if vneed > 0:
                if vneed >= k:
                    unsat_flag = True
                else:
                    sat.force_true(lit(var_id(i, vneed, k), True))
    if unsat_flag:
        return None
    ok, assign = sat.satisfiable()
    if not ok:
        return None
    # Reconstruct a: for each i, pick 1 + max v with X_{i,v}=True
    a = [1]*n
    for i in range(n):
        val = 1
        for v in range(1, k):
            if assign[var_id(i, v, k)]:
                val = v + 1
        a[i] = val
    return a

def solve_all(inp: TextIO, out: TextIO):
    tests = read_input(inp)
    for n, m, k, cons in tests:
        ans = solve_case_2sat(n, m, k, cons)
        if ans is None:
            print(-1, file=out)
        else:
            print(" ".join(map(str, ans)), file=out)

def main():
    solve_all(sys.stdin, sys.stdout)

if __name__ == "__main__":
    # Deterministic unit tests
    from io import StringIO
    def run_io(data: str) -> str:
        inp = StringIO(data)
        out = StringIO()
        solve_all(inp, out)
        return out.getvalue()
    # 1) No constraints; n=3,k=3 -> a non-decreasing array exists
    out = run_io("1\n3 0 3\n")
    arr = list(map(int, out.strip().split()))
    assert len(arr) == 3 and all(1 <= x <= 3 for x in arr) and all(arr[i] <= arr[i+1] for i in range(2))
    # 2) Forbid 1 at i=1; n=1,k=3 -> expect >=2, 2-SAT often picks minimal 2
    out = run_io("1\n1 1 3\n1 1 1\n")
    assert out.strip() in {"2", "3"}
    # 3) Force maximum sum: n=2,k=3, a1+a2>=6 -> 3 3
    out = run_io("1\n2 1 3\n3 1 2 6\n")
    assert out.strip() == "3 3"
    main()
\end{minted}
\VALIDATION{Three asserts cover basic feasibility, a unary constraint, and a tight sum lower bound that forces the top values.}
\RESULT{Outputs any non-decreasing array in $[1,k]^n$ satisfying all constraints; prints $-1$ when infeasible.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Combine unit asserts on corner constraints: unary forbiddance at ends ($x=1,k$), tight sum bounds ($2$ and $2k$), and mixed constraints. Also test random small instances against the brute-force baseline.}
\LINE{CROSS-CHECKS}{For small $n,k$, compare Approach A's brute force against Approach C's 2-SAT to ensure identical feasibility outcomes and reconstruct a witness when possible.}
\LINE{EDGE-CASE GENERATOR}{Generate constraints with extremes ($x=2, 2k$), disallowing boundary values, and consistency checks for monotonicity across indices.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from typing import List, Tuple

def gen_case(n: int, k: int, seed: int = 0) -> Tuple[int,int,int,List[Tuple[int,int,int,int]]]:
    random.seed(seed)
    m = 0
    cons: List[Tuple[int,int,int,int]] = []
    # Randomly forbid some boundary values
    for i in range(n):
        if random.random() < 0.2:
            cons.append((1, i, None, 1)); m += 1
        if random.random() < 0.2:
            cons.append((1, i, None, k)); m += 1
    # Add some sum constraints
    for _ in range(n):
        i = random.randrange(n-1)
        j = random.randrange(i+1, n)
        typ = 2 if random.random() < 0.5 else 3
        x = random.randint(2, 2*k)
        cons.append((typ, i, j, x)); m += 1
    return n, m, k, cons

# Reference solve via 2-SAT (Approach C) callable for fuzzing
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple, TextIO

class TwoSAT:
    def __init__(self, nvars: int):
        self.n = nvars
        self.N = nvars * 2
        self.g = [[] for _ in range(self.N)]
        self.gr = [[] for _ in range(self.N)]
    @staticmethod
    def _neg(lit: int) -> int:
        return lit ^ 1
    def _add_edge(self, u: int, v: int):
        self.g[u].append(v)
        self.gr[v].append(u)
    def add_clause(self, u: int, v: int):
        self._add_edge(self._neg(u), v)
        self._add_edge(self._neg(v), u)
    def add_imp(self, u: int, v: int):
        self.add_clause(self._neg(u), v)
    def force_true(self, u: int):
        self.add_clause(u, u)
    def force_false(self, u: int):
        self.force_true(self._neg(u))
    def satisfiable(self) -> Tuple[bool, List[bool]]:
        order = []
        vis = [False]*self.N
        sys.setrecursionlimit(1 << 20)
        def dfs(v: int):
            vis[v] = True
            for to in self.g[v]:
                if not vis[to]:
                    dfs(to)
            order.append(v)
        for v in range(self.N):
            if not vis[v]:
                dfs(v)
        comp = [-1]*self.N
        def rdfs(v: int, c: int):
            comp[v] = c
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, c)
        j = 0
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j); j += 1
        assign = [False]*self.n
        for i in range(self.n):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assign[i] = comp[2*i] > comp[2*i+1]
        return True, assign

def read_input(inp: TextIO):
    data = inp.read().strip().split()
    it = iter(data)
    t = int(next(it, '0'))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        cons = []
        for _ in range(m):
            typ = int(next(it))
            if typ == 1:
                i = int(next(it)); x = int(next(it))
                cons.append((1, i-1, None, x))
            else:
                i = int(next(it)); j = int(next(it)); x = int(next(it))
                cons.append((typ, i-1, j-1, x))
        tests.append((n, m, k, cons))
    return tests

def var_id(i: int, v: int, k: int) -> int:
    return i*(k-1) + (v-1)

def lit(var_index: int, is_true: bool) -> int:
    return (var_index << 1) | (0 if is_true else 1)

def solve_case(n: int, m: int, k: int, cons: List[Tuple[int,int,int,int]]) -> List[int] or None:
    if k == 1:
        a = [1]*n
        for typ, i, j, x in cons:
            if typ == 1 and x == 1: return None
            if typ == 2 and 2 > x: return None
            if typ == 3 and 2 < x: return None
        return a
    V = n*(k-1)
    sat = TwoSAT(V)
    for i in range(n):
        for v in range(1, k-1):
            sat.add_imp(lit(var_id(i, v+1, k), True), lit(var_id(i, v, k), True))
    for i in range(n-1):
        for v in range(1, k):
            sat.add_imp(lit(var_id(i+1, v, k), True), lit(var_id(i, v, k), True))
    unsat_flag = False
    for typ, i, j, x in cons:
        if typ == 1:
            if x == 1:
                if k-1 >= 1: sat.force_true(lit(var_id(i, 1, k), True))
            elif x == k:
                sat.force_false(lit(var_id(i, k-1, k), True))
            else:
                sat.add_imp(lit(var_id(i, x-1, k), True), lit(var_id(i, x, k), True))
        elif typ == 2:
            T = x - 2
            for s in range(1, k):
                uidx = T - s + 1
                if uidx <= 0:
                    sat.force_false(lit(var_id(i, s, k), True))
                elif uidx >= k:
                    pass
                else:
                    sat.add_clause(lit(var_id(i, s, k), False), lit(var_id(j, uidx, k), False))
            for s in range(1, k):
                uidx = T - s + 1
                if uidx <= 0:
                    sat.force_false(lit(var_id(j, s, k), True))
                elif uidx >= k:
                    pass
                else:
                    sat.add_clause(lit(var_id(j, s, k), False), lit(var_id(i, uidx, k), False))
        else:
            T = x - 2
            for s in range(0, k-1):
                vneed = T - s
                if vneed <= 0:
                    continue
                elif vneed >= k:
                    sat.force_true(lit(var_id(i, s+1, k), True))
                else:
                    sat.add_clause(lit(var_id(i, s+1, k), True), lit(var_id(j, vneed, k), True))
            vneed = T - (k-1)
            if vneed > 0:
                if vneed >= k:
                    unsat_flag = True
                else:
                    sat.force_true(lit(var_id(j, vneed, k), True))
            for s in range(0, k-1):
                vneed = T - s
                if vneed <= 0:
                    continue
                elif vneed >= k:
                    sat.force_true(lit(var_id(j, s+1, k), True))
                else:
                    sat.add_clause(lit(var_id(j, s+1, k), True), lit(var_id(i, vneed, k), True))
            vneed = T - (k-1)
            if vneed > 0:
                if vneed >= k:
                    unsat_flag = True
                else:
                    sat.force_true(lit(var_id(i, vneed, k), True))
    if unsat_flag:
        return None
    ok, assign = sat.satisfiable()
    if not ok:
        return None
    a = [1]*n
    for i in range(n):
        val = 1
        for v in range(1, k):
            if assign[var_id(i, v, k)]:
                val = v + 1
        a[i] = val
    return a

def solve_all(inp: TextIO, out: TextIO):
    tests = read_input(inp)
    for n, m, k, cons in tests:
        ans = solve_case(n, m, k, cons)
        if ans is None:
            print(-1, file=out)
        else:
            print(" ".join(map(str, ans)), file=out)

def main():
    solve_all(sys.stdin, sys.stdout)

if __name__ == "__main__":
    from io import StringIO
    def run_io(data: str) -> str:
        inp = StringIO(data)
        out = StringIO()
        solve_all(inp, out)
        return out.getvalue()
    # Reuse three core checks
    out = run_io("1\n3 0 3\n")
    arr = list(map(int, out.strip().split()))
    assert len(arr) == 3 and all(1 <= x <= 3 for x in arr) and all(arr[i] <= arr[i+1] for i in range(2))
    out = run_io("1\n1 1 3\n1 1 1\n")
    assert out.strip() in {"2", "3"}
    out = run_io("1\n2 1 3\n3 1 2 6\n")
    assert out.strip() == "3 3"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Encode integers with threshold booleans and solve the resulting 2-CNF via 2-SAT.}
\WHY{This pattern reappears whenever variables have small integer domains and constraints are monotone or separable into threshold implications.}
\CHECKLIST{
\begin{bullets}
\item Define $X_{i,v}=[a_i \ge v+1]$ for $v=1,\ldots,k-1$.
\item Add value-chain $X_{i,v+1}\Rightarrow X_{i,v}$ and index-chain $X_{i+1,v}\Rightarrow X_{i,v}$.
\item Translate type 1, 2, 3 constraints into clauses carefully handling boundaries.
\item Build implication graph; run SCC; detect conflicts.
\item Reconstruct $a_i$ from assigned thresholds.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $x=1$ or $x=k$ in type 1.
\item $x=2$ or $x=2k$ in sum constraints.
\item $k=2$ (only one boolean per position).
\item Long-range constraints between distant indices.
\item Empty clause due to impossible lower bound in type 3.
\item Non-decreasing chain across all indices.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in mapping $a_i$ to $y_i$ and thresholds.
\item Forgetting to add both monotonicity chains (value and index).
\item Mishandling indices when $T-s+1 \le 0$ or $\ge k$.
\item Omitting unit clauses for boundary cases in type 3.
\item Reconstructing $a_i$ incorrectly (use max true threshold).
\item Not guarding recursion depth in SCC on large graphs.
\end{bullets}
}
\FAILMODES{Arc-consistency alone can miss global contradictions; brute force does not scale. The 2-SAT formulation avoids both by providing a complete and efficient decision method.}
\ELI{Treat each number as a staircase of yes/no switches that must be non-decreasing both within a number and along the array. Every rule becomes an if-then statement between switches. Solving all these if-then statements at once gives you a consistent set of switches, hence a valid array.}
\NotePages{3}

\end{document}