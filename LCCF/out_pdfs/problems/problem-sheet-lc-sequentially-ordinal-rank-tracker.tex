% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sequentially Ordinal Rank Tracker}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/sequentially-ordinal-rank-tracker/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{A scenic location is represented by its \texttt{name} and attractiveness \texttt{score}, where \texttt{name} is a unique string among all locations and \texttt{score} is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.

You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:
\begin{itemize}
\item Adding scenic locations, one at a time.
\item Querying the $i$th best location of all locations already added, where $i$ is the number of times the system has been queried (including the current query).
\end{itemize}
For example, when the system is queried for the $4$th time, it returns the $4$th best location of all locations already added.

Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.

Implement the \texttt{SORTracker} class:
\begin{itemize}
\item \texttt{SORTracker()} Initializes the tracker system.
\item \texttt{void add(string name, int score)} Adds a scenic location with \texttt{name} and \texttt{score} to the system.
\item \texttt{string get()} Queries and returns the $i$th best location, where $i$ is the number of times this method has been invoked (including this invocation).
\end{itemize}

Example 1:

\begin{tcolorbox}
\textbf{Input}\\
\texttt{["SORTracker", "add", "add", "get", "add", "get", "add", "get", "add", "get", "add", "get", "get"]}\\
\texttt{[[], ["bradford", 2], ["branford", 3], [], ["alps", 2], [], ["orland", 2], [], ["orlando", 3], [], ["alpine", 2], [], []]}\\[4pt]
\textbf{Output}\\
\texttt{[null, null, null, "branford", null, "alps", null, "bradford", null, "bradford", null, "bradford", "orland"]}
\end{tcolorbox}

Explanation

\begin{itemize}
\item \texttt{SORTracker tracker = new SORTracker();} Initialize the tracker system.
\item \texttt{tracker.add("bradford", 2);} Add location with \texttt{name="bradford"} and \texttt{score=2}.
\item \texttt{tracker.add("branford", 3);} Add location with \texttt{name="branford"} and \texttt{score=3}.
\item \texttt{tracker.get();} The sorted locations, from best to worst, are: branford, bradford. Note that branford precedes bradford due to its higher score (3 > 2). This is the 1st time \texttt{get()} is called, so return the best location: \texttt{"branford"}.
\item \texttt{tracker.add("alps", 2);} Add location with \texttt{name="alps"} and \texttt{score=2}.
\item \texttt{tracker.get();} Sorted locations: branford, alps, bradford. Note that alps precedes bradford even though they have the same score (2). This is because \texttt{"alps"} is lexicographically smaller than \texttt{"bradford"}. Return the 2nd best location \texttt{"alps"}, as it is the 2nd time \texttt{get()} is called.
\item \texttt{tracker.add("orland", 2);} Add location with \texttt{name="orland"} and \texttt{score=2}.
\item \texttt{tracker.get();} Sorted locations: branford, alps, bradford, orland. Return \texttt{"bradford"}, as it is the 3rd time \texttt{get()} is called.
\item \texttt{tracker.add("orlando", 3);} Add location with \texttt{name="orlando"} and \texttt{score=3}.
\item \texttt{tracker.get();} Sorted locations: branford, orlando, alps, bradford, orland. Return \texttt{"bradford"}.
\item \texttt{tracker.add("alpine", 2);} Add location with \texttt{name="alpine"} and \texttt{score=2}.
\item \texttt{tracker.get();} Sorted locations: branford, orlando, alpine, alps, bradford, orland. Return \texttt{"bradford"}.
\item \texttt{tracker.get();} Sorted locations: branford, orlando, alpine, alps, bradford, orland. Return \texttt{"orland"}.
\end{itemize}

Constraints:
\begin{itemize}
\item \texttt{name} consists of lowercase English letters, and is unique among all locations.
\item $1 \le \lvert\texttt{name}\rvert \le 10$.
\item $1 \le \texttt{score} \le 10^{5}$.
\item At any time, the number of calls to \texttt{get} does not exceed the number of calls to \texttt{add}.
\item At most $4 \times 10^{4}$ calls in total will be made to \texttt{add} and \texttt{get}.
\end{itemize}}
\BREAKDOWN{We must support two operations online: add a new item and return the $i$th best item where $i$ increases each time we call \texttt{get()}. Correct ranking uses score descending with name ascending as a tie-breaker. We need an efficient dynamic-order statistic tracker.}
\ELI{Keep a live leaderboard; each time you call \texttt{get()}, you reveal the next best unseen location.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A sequence of operations on a class:
\begin{itemize}
\item \texttt{SORTracker()}.
\item \texttt{add(name: str, score: int)} with $1 \le \lvert\texttt{name}\rvert \le 10$, lowercase letters, unique names, and $1 \le \texttt{score} \le 10^{5}$.
\item \texttt{get()} returning a \texttt{str}.
\end{itemize}
The number of \texttt{get()} calls never exceeds the number of \texttt{add()} calls at any time.}
\OUTPUTS{Each \texttt{get()} returns the current $i$th best location name where $i$ equals the number of \texttt{get()} calls so far (including the current one), using score descending and name ascending for tie-breaking.}
\SAMPLES{
\begin{itemize}
\item After \texttt{add("a", 5)}, \texttt{add("b", 5)}, first \texttt{get()} returns \texttt{"a"}.
\item After the above and \texttt{add("c", 6)}, second \texttt{get()} returns \texttt{"b"}; third \texttt{get()} returns \texttt{"c"} if added before the third call.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S$ be the set of all added locations, each as a pair $(n,s)$ of name $n$ and score $s \in \mathbb{Z}$. Define a total order $\prec$ on $S$ by
\[
(a \prec b) \iff \big( s(a) > s(b) \big) \ \text{or}\ \big( s(a)=s(b)\ \text{and}\ n(a) < n(b) \big).
\]
After $k$ calls to \texttt{get()}, the returned names are the first $k$ elements of $S$ in order $\prec$.}
\varmapStart
\var{k}{number of \texttt{get()} calls so far}
\var{S}{multiset of items added so far (names are unique)}
\var{L}{the set of top-$k$ items under $\prec$}
\var{R}{the set $S \setminus L$ of remaining items}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } S_k = \text{the first } k \text{ elements of } S \text{ in order } \prec.\\
&\text{Invariant after } k \text{ gets: } L = S_k,\quad R = S \setminus S_k.\\
&\text{Next answer } = \min\nolimits_{\prec}\, R \quad (\text{the } (k{+}1)\text{th best}).
\end{aligned}
}
\ASSUMPTIONS{Names are unique; scores are integers; comparisons are total via score descending then name ascending; queries never exceed additions.}
\INVARIANTS{
\begin{itemize}
\item $|L| = k$ after $k$ gets.
\item For all $\ell \in L$ and $r \in R$, $\ell \prec r$.
\item The $k$th answer equals $\max_{\prec} L$, i.e., the worst among the top-$k$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain all items in an unsorted list. On each \texttt{get()}, sort all items by the required order, and pick index $k{-}1$.}
\ASSUMPTIONS{Sorting at every \texttt{get()} is acceptable for small input; unique names avoid duplicates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Store each added pair $(\texttt{name}, \texttt{score})$ in a vector.
\item On \texttt{get()}, increment $k$, sort by key $(-\texttt{score}, \texttt{name})$.
\item Return the $(k{-}1)$th element's name.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of items so far and $q$ the number of gets so far. Each \texttt{get()} costs $O(n \log n)$ due to sorting; \texttt{add()} is $O(1)$.}
\[
\begin{aligned}
T_{\texttt{add}}(n) &= O(1),\\
T_{\texttt{get}}(n) &= O(n \log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Sorting with key $(-\texttt{score}, \texttt{name})$ yields score descending and name ascending. The $(k{-}1)$ index corresponds to the $k$th best.}
\EDGECASES{Equal scores; first query when only one element; many adds before any get; names are unique so no tie on names with same score.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class SORTracker:
    def __init__(self) -> None:
        self.items: List[Tuple[str, int]] = []
        self.k = 0  # number of get() calls so far

    def add(self, name: str, score: int) -> None:
        self.items.append((name, score))

    def get(self) -> str:
        self.k += 1
        # Sort by score desc, name asc
        arr = sorted(self.items, key=lambda x: (-x[1], x[0]))
        return arr[self.k - 1][0]

# Optional presence to satisfy LC template variants; unused here.
class Solution:
    pass

def _run_example_baseline():
    tracker = SORTracker()
    ops = ["add","add","get","add","get","add","get","add","get","add","get","get"]
    args = [["bradford",2],["branford",3],[],["alps",2],[],["orland",2],[],["orlando",3],[],["alpine",2],[],[]]
    out = []
    for op, a in zip(ops, args):
        if op == "add":
            tracker.add(a[0], a[1])
            out.append(None)
        elif op == "get":
            out.append(tracker.get())
    expect = [None, None, "branford", None, "alps", None, "bradford", None, "bradford", None, "bradford", "orland"]
    # We intentionally skip the constructor slot in outputs for brevity
    assert out == expect

def _tiny_checks_baseline():
    tr = SORTracker()
    tr.add("a", 5); tr.add("b", 5)
    assert tr.get() == "a"
    tr.add("c", 6)
    assert tr.get() == "b"

if __name__ == "__main__":
    _run_example_baseline()
    _tiny_checks_baseline()
\end{minted}
\VALIDATION{Checked example sequence; validated equal-score lex ordering; validated progressive $i$th selection with interleaved adds.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sorted List + Pointer (Bisect)}
\WHICHFORMULA{Maintain an always-sorted list by key $(-\texttt{score}, \texttt{name})$. Insert via binary search, and maintain a pointer $k$ to return the $k$th element on \texttt{get()}.}
\ASSUMPTIONS{Python list insertion is $O(n)$; good tradeoff when many \texttt{get()} calls occur compared to \texttt{add()}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep an array of tuples $(-\texttt{score}, \texttt{name})$ sorted ascending.
\item On \texttt{add}, use \texttt{bisect.insort} to insert in $O(n)$.
\item On \texttt{get}, return element at index $k$, then increment $k$.
\end{algosteps}
\COMPLEXITY{Insertion $O(n)$; \texttt{get()} is $O(1)$. Beats baseline when many queries relative to $n$ since sorting whole array each time is avoided.}
\[
\begin{aligned}
T_{\texttt{add}}(n) &= O(n),\\
T_{\texttt{get}}(n) &= O(1),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Order is maintained globally; the $k$ pointer ensures each \texttt{get()} returns the next best.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import bisect

class SORTracker:
    def __init__(self) -> None:
        # Store tuples (-score, name) so that best is smallest tuple
        self.arr: List[Tuple[int, str]] = []
        self.k = 0  # number of get() calls

    def add(self, name: str, score: int) -> None:
        bisect.insort(self.arr, (-score, name))

    def get(self) -> str:
        ans = self.arr[self.k][1]
        self.k += 1
        return ans

# Optional presence to satisfy LC template variants; unused here.
class Solution:
    pass

def _run_example_improved():
    tracker = SORTracker()
    ops = ["add","add","get","add","get","add","get","add","get","add","get","get"]
    args = [["bradford",2],["branford",3],[],["alps",2],[],["orland",2],[],["orlando",3],[],["alpine",2],[],[]]
    out = []
    for op, a in zip(ops, args):
        if op == "add":
            tracker.add(a[0], a[1]); out.append(None)
        else:
            out.append(tracker.get())
    expect = [None, None, "branford", None, "alps", None, "bradford", None, "bradford", None, "bradford", "orland"]
    assert out == expect

def _edge_improved():
    tr = SORTracker()
    tr.add("b", 1); tr.add("a", 1); tr.add("c", 2)
    assert tr.get() == "c"
    assert tr.get() == "a"
    assert tr.get() == "b"

if __name__ == "__main__":
    _run_example_improved()
    _edge_improved()
\end{minted}
\VALIDATION{Validated the provided example and an equal-score tie case; pointer correctness verified by sequential gets.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two Heaps (Top-$k$ frontier)}
\WHICHFORMULA{Maintain two heaps:
\begin{itemize}
\item Left heap $L$ holds the current top $k$ items (where $k$ is the number of \texttt{get()} calls), keyed so that its root is the worst among the top $k$ (the $k$th best).
\item Right heap $R$ holds the remaining items, keyed so that its root is the next best (the $(k{+}1)$th).
\end{itemize}
Use $O(\log n)$ rebalancing on each operation.}
\ASSUMPTIONS{Unique names; $k$ never exceeds current $|S|$, so $R$ is nonempty before required moves.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define order: better if higher score, tie by lexicographically smaller name.
\item Heaps:
  \begin{itemize}
  \item $R$: min-heap on $(-\texttt{score}, \texttt{name})$; its root is the best among remaining.
  \item $L$: min-heap on $(\texttt{score}, \texttt{name}^{\text{inv}}, \texttt{name})$ where $\texttt{name}^{\text{inv}}$ reverses lex order; its root is the worst among the top $k$.
  \end{itemize}
\item On \texttt{add(name,score)}:
  \begin{itemize}
  \item Push $(-\texttt{score}, \texttt{name})$ into $R$.
  \item Move the best from $R$ to $L$.
  \item If $|L| > k$, move $L$'s root (worst of top-$k$+1) back to $R$.
  \end{itemize}
\item On \texttt{get()}:
  \begin{itemize}
  \item Increment $k$.
  \item Ensure $|L|=k$ by moving one best from $R$ to $L$ if needed.
  \item Return $L$'s root name (the $k$th best).
  \end{itemize}
\end{algosteps}
\OPTIMALITY{Each operation does $O(1)$ heap pushes/pops; comparison keys are $O(1)$; thus both \texttt{add} and \texttt{get} are $O(\log n)$ and optimal for comparison-based ordered maintenance under arbitrary interleaving.}
\COMPLEXITY{
\[
\begin{aligned}
T_{\texttt{add}}(n) &= O(\log n),\quad T_{\texttt{get}}(n)=O(\log n),\\
S(n) &= O(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

def _inv_name(name: str) -> str:
    # Map 'a'..'z' into descending-ordered bytes so that lex larger original names compare smaller here.
    return ''.join(chr(255 - ord(c)) for c in name)

class SORTracker:
    def __init__(self) -> None:
        # Left: min-heap on (score, inv_name, name) => root is worst among current top-k
        self.left: List[Tuple[int, str, str]] = []
        # Right: min-heap on (-score, name) => root is the next best not yet returned
        self.right: List[Tuple[int, str]] = []
        self.k = 0  # number of get() calls so far

    def add(self, name: str, score: int) -> None:
        # Add to right as a candidate
        heapq.heappush(self.right, (-score, name))
        # Promote the best candidate into left
        sneg, nm = heapq.heappop(self.right)
        heapq.heappush(self.left, (-sneg, _inv_name(nm), nm))
        # Maintain |left| == k (push the (k+1)th back to right)
        if len(self.left) > self.k:
            sc, invnm, nm2 = heapq.heappop(self.left)
            heapq.heappush(self.right, (-sc, nm2))

    def get(self) -> str:
        self.k += 1
        # Ensure left holds top-k
        if len(self.left) < self.k:
            sneg, nm = heapq.heappop(self.right)
            heapq.heappush(self.left, (-sneg, _inv_name(nm), nm))
        # Root of left is the kth best
        return self.left[0][2]

# Optional presence to satisfy LC template variants; unused here.
class Solution:
    pass

def _run_example_optimal():
    tracker = SORTracker()
    ops = ["add","add","get","add","get","add","get","add","get","add","get","get"]
    args = [["bradford",2],["branford",3],[],["alps",2],[],["orland",2],[],["orlando",3],[],["alpine",2],[],[]]
    out = []
    for op, a in zip(ops, args):
        if op == "add":
            tracker.add(a[0], a[1]); out.append(None)
        else:
            out.append(tracker.get())
    expect = [None, None, "branford", None, "alps", None, "bradford", None, "bradford", None, "bradford", "orland"]
    assert out == expect

def _more_tests_optimal():
    # Equal scores lex order
    tr = SORTracker()
    tr.add("b", 1); tr.add("a", 1); tr.add("c", 2)
    assert tr.get() == "c"
    assert tr.get() == "a"
    assert tr.get() == "b"
    # Interleave many adds before gets
    tr2 = SORTracker()
    for n, s in [("x",10), ("m",7), ("z",7), ("a",10)]:
        tr2.add(n, s)
    assert tr2.get() == "a"
    assert tr2.get() == "x"
    assert tr2.get() == "m"
    assert tr2.get() == "z"

if __name__ == "__main__":
    _run_example_optimal()
    _more_tests_optimal()
\end{minted}
\VALIDATION{Three assert suites:
\begin{itemize}
\item Full example sequence matches expected outputs.
\item Lexicographic tie-breaking with equal scores.
\item Batch adds before gets with multiple equal scores.
\end{itemize}}
\RESULT{The tracker returns the next best unseen location on each \texttt{get()}, respecting descending score and ascending name; ties and order are handled deterministically.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty-initialization then single add/get; equal-score tie ordering; interleaved adds/gets; many adds before any gets; progression across multiple gets beyond first $k$.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline (A), Improved (B), and Optimal (C) on small randomized sets to ensure identical sequences of answers for the same operation stream.}
\LINE{EDGE-CASE GENERATOR}{Generate random lowercase names and integer scores; ensure name uniqueness; enforce that the number of gets never exceeds adds.}
\begin{minted}{python}
import random
import string
from typing import List, Tuple

def rand_name(k: int) -> str:
    return "".join(random.choice(string.ascii_lowercase) for _ in range(k))

def gen_ops(n_add: int, n_get: int) -> Tuple[List[str], List[list]]:
    # Ensure n_get <= n_add
    n_get = min(n_get, n_add)
    ops, args = [], []
    names = set()
    adds_done = 0
    gets_done = 0
    for _ in range(n_add + n_get):
        if adds_done < n_add and (gets_done >= adds_done or random.random() < 0.7):
            # Do add
            name = rand_name(random.randint(1, 5))
            while name in names:
                name = rand_name(random.randint(1, 5))
            names.add(name)
            score = random.randint(1, 100)
            ops.append("add"); args.append([name, score]); adds_done += 1
        else:
            ops.append("get"); args.append([]); gets_done += 1
    # Trim to exact totals
    while ops.count("get") > n_get:
        i = ops.index("get"); del ops[i]; del args[i]
    while ops.count("add") > n_add:
        i = ops.index("add"); del ops[i]; del args[i]
    # Fix prefix so gets never exceed adds at any point
    adds = 0; gets = 0
    for i, op in enumerate(ops):
        if op == "add": adds += 1
        else:
            gets += 1
            if gets > adds:
                # Convert this get to add
                name = rand_name(random.randint(1, 5))
                while name in names:
                    name = rand_name(random.randint(1, 5))
                names.add(name)
                ops[i] = "add"; args[i] = [name, random.randint(1, 100)]
                adds += 1; gets -= 1
    return ops, args

# Reference Implementation (Optimal)
import heapq

def _inv_name(name: str) -> str:
    return ''.join(chr(255 - ord(c)) for c in name)

class SORTracker:
    def __init__(self) -> None:
        self.left = []   # (score, inv_name, name)
        self.right = []  # (-score, name)
        self.k = 0

    def add(self, name: str, score: int) -> None:
        heapq.heappush(self.right, (-score, name))
        sneg, nm = heapq.heappop(self.right)
        heapq.heappush(self.left, (-sneg, _inv_name(nm), nm))
        if len(self.left) > self.k:
            sc, invnm, nm2 = heapq.heappop(self.left)
            heapq.heappush(self.right, (-sc, nm2))

    def get(self) -> str:
        self.k += 1
        if len(self.left) < self.k:
            sneg, nm = heapq.heappop(self.right)
            heapq.heappush(self.left, (-sneg, _inv_name(nm), nm))
        return self.left[0][2]

def run_cross_check(trials: int = 50) -> None:
    # Compare Improved (B) vs Optimal (C) on random small cases
    import bisect

    class TrackerB:
        def __init__(self):
            self.arr = []
            self.k = 0
        def add(self, name: str, score: int):
            bisect.insort(self.arr, (-score, name))
        def get(self) -> str:
            ans = self.arr[self.k][1]; self.k += 1; return ans

    for _ in range(trials):
        ops, args = gen_ops(20, 20)
        b = TrackerB(); c = SORTracker()
        out_b, out_c = [], []
        for op, a in zip(ops, args):
            if op == "add":
                b.add(a[0], a[1]); c.add(a[0], a[1])
            else:
                out_b.append(b.get()); out_c.append(c.get())
        assert out_b == out_c

if __name__ == "__main__":
    random.seed(0)
    run_cross_check(20)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

def _inv_name(name: str) -> str:
    return ''.join(chr(255 - ord(c)) for c in name)

class SORTracker:
    def __init__(self) -> None:
        # Left holds top-k, root is kth best
        self.left: List[Tuple[int, str, str]] = []
        # Right holds remaining, root is (k+1)th best
        self.right: List[Tuple[int, str]] = []
        self.k = 0

    def add(self, name: str, score: int) -> None:
        heapq.heappush(self.right, (-score, name))
        sneg, nm = heapq.heappop(self.right)
        heapq.heappush(self.left, (-sneg, _inv_name(nm), nm))
        if len(self.left) > self.k:
            sc, invnm, nm2 = heapq.heappop(self.left)
            heapq.heappush(self.right, (-sc, nm2))

    def get(self) -> str:
        self.k += 1
        if len(self.left) < self.k:
            sneg, nm = heapq.heappop(self.right)
            heapq.heappush(self.left, (-sneg, _inv_name(nm), nm))
        return self.left[0][2]

# Optional presence to satisfy LC template variants; unused here.
class Solution:
    pass

def _sanity():
    tr = SORTracker()
    tr.add("bradford", 2); tr.add("branford", 3)
    assert tr.get() == "branford"
    tr.add("alps", 2)
    assert tr.get() == "alps"
    tr.add("orland", 2)
    assert tr.get() == "bradford"
    tr.add("orlando", 3)
    assert tr.get() == "bradford"
    tr.add("alpine", 2)
    assert tr.get() == "bradford"
    assert tr.get() == "orland"

if __name__ == "__main__":
    _sanity()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Track the next $i$th best item online with score-descending and name-ascending order.}
\WHY{Classic interview test of order-statistic maintenance with custom tie-breaking, showcasing two-heap partitioning and invariant design.}
\CHECKLIST{
\begin{itemize}
\item Define total order correctly: score desc, then name asc.
\item Maintain $k=\#$\texttt{get()} calls.
\item Ensure left holds top-$k$ and right the rest.
\item Root of left is $k$th best; root of right is $(k{+}1)$th.
\item Rebalance heaps on each operation.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Equal scores: verify lexicographic ascending by name.
\item Many adds before any get (large right heap).
\item All same score with different names.
\item Alternate add/get tightly interleaved.
\item Single element sequences.
\item Max constraints near $4 \times 10^{4}$ operations.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Implementing wrong comparator (e.g., name descending on ties).
\item Returning best from left instead of worst among top-$k$.
\item Forgetting to increment $k$ on \texttt{get()}.
\item Not rebalancing after \texttt{add()}, causing $|L| \ne k$.
\item Python heapq comparator limits: cannot supply custom comparator.
\item Attempting to invert string order incorrectly; consistent transform required.
\end{itemize}}
\FAILMODES{Brute-force sort per \texttt{get()} times out at scale; single-heap approaches cannot provide $k$th best efficiently without re-sorting; incorrect tie-break keys break determinism. Two-heap invariant guarantees next element in $O(\log n)$.}
\ELI{Keep two piles: the left pile holds the top $k$ winners so far, and the right pile holds everyone else. The top of the left pile is the current $k$th best, and the top of the right pile is the next winner to promote when you call \texttt{get()}.}
\NotePages{3}

\end{document}