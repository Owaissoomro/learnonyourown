% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — ELCA}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/482/E}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{You have a rooted tree containing $n$ vertices, numbered $1$ to $n$. The root is vertex $1$.

Each vertex (except for the tree root) $v$ has a direct ancestor $p_v$. Also each vertex $v$ has its integer value $s_v$.

Your task is to perform the following queries:

\begin{bullets}
\item P $v$ $u$ ($u \ne v$). If $u$ is not in the subtree of $v$, perform the assignment $p_v = u$. Otherwise perform the assignment $p_u = v$. After each such query the graph remains a tree consisting of $n$ vertices.
\item V $v$ $t$. Perform the assignment $s_v = t$.
\end{bullets}

Your task is: before starting to perform queries and after each query, calculate the expected value written on the lowest common ancestor of two equiprobably selected vertices $i$ and $j$. The lowest common ancestor of $i$ and $j$ is the deepest vertex that lies on both the path from the root to $i$ and the path from the root to $j$. Vertices $i$ and $j$ can coincide (in this case their lowest common ancestor is that vertex).

Input:
The first line contains integer $n$ ($2 \le n \le 5 \cdot 10^4$) — the number of tree vertices.

The second line contains $n - 1$ integers $p_2, p_3, \ldots, p_n$ ($1 \le p_i \le n$) — the parent array that forms a tree.

The third line contains $n$ integers $s_1, s_2, \ldots, s_n$ ($0 \le s_i \le 10^6$) — the values written on the vertices.

The next line contains integer $q$ ($1 \le q \le 5 \cdot 10^4$) — the number of queries. Each of the following $q$ lines describes a query in the format above. It is guaranteed that arguments $u$ and $v$ lie between $1$ and $n$. In queries of type V, $t$ meets the bounds $0 \le t \le 10^6$.

Output:
Print $q + 1$ numbers — the corresponding expected values. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-9}$.

Note:
In the query P $v$ $u$, if $u$ lies in the subtree of $v$ you must perform the assignment $p_u = v$.}
\BREAKDOWN{We need to maintain the expectation $\mathbb{E}[s_{\mathrm{LCA}(i,j)}]$ over ordered pairs $(i,j)$ chosen uniformly from $\{1,\ldots,n\}^2$, under dynamic edge reattachments (single parent change) and point value updates on vertices. The key is a per-vertex pair-count formula that depends only on subtree sizes of the rooted tree at $1$, enabling aggregation $\sum_v s_v \cdot \text{count}_v / n^2$.}
\ELI{Count how many ordered pairs have LCA at each node, weight by $s_v$, sum and divide by $n^2$; update counts when we change a parent or a node value.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$, array $p_2,\ldots,p_n$, array $s_1,\ldots,s_n$, integer $q$, then $q$ queries of two types:
\begin{bullets}
\item P $v$ $u$ with $1 \le v,u \le n$ and $v \ne u$;
\item V $v$ $t$ with $1 \le v \le n$, $0 \le t \le 10^6$.
\end{bullets}
All indices are $1$-based. The tree is always rooted at $1$.}
\OUTPUTS{Print $q+1$ real numbers, each on its own line, the expected value $\mathbb{E}[s_{\mathrm{LCA}(i,j)}]$ before any query and after each query. Any absolute or relative error up to $10^{-9}$ is accepted.}
\SAMPLES{Example 1 (tiny):
\begin{itemize}
\item $n=3$, $p=[1,1]$ (edges $1{-}2$, $1{-}3$), $s=[1,2,3]$, $q=2$.
\item Queries: V $2$ $5$; P $2$ $3$.
\end{itemize}
Expected values:
\begin{itemize}
\item Before: pairs with LCA values are $(1,1)\to 1$, any pair touching $1$ and a child $\to 1$, siblings pairs $\to 1$, and $(2,2)\to 2$, $(3,3)\to 3$. The average is $\dfrac{1\cdot 5 + 2\cdot 1 + 3\cdot 1}{9} = \dfrac{10}{9} \approx 1.1111111111$.
\item After V $2$ $5$: $\dfrac{1\cdot 5 + 5\cdot 1 + 3\cdot 1}{9} = \dfrac{13}{9} \approx 1.4444444444$.
\item After P $2$ $3$: parent of $2$ becomes $3$ (since $3$ not in subtree of $2$), the tree is $1{-}3{-}2$; recompute similarly.
\end{itemize}
Example 2:
\begin{itemize}
\item $n=2$, $p=[1]$, $s=[7,4]$, $q=1$, query P $2$ $1$ has no effect; expectations are $\dfrac{7\cdot 3 + 4\cdot 1}{4} = \dfrac{25}{4} = 6.25$ both times.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the rooted tree at $1$ be $T=(V,E)$ with $|V|=n$. For each $v \in V$, denote the subtree size by $S_v$. Let $\mathcal{C}(v)$ be the set of children of $v$. For ordered pairs $(i,j)$ chosen uniformly from $V \times V$, the expectation is
\begin{BreakableEquation*}
\mathbb{E}[s_{\mathrm{LCA}(i,j)}] \;=\; \frac{1}{n^2}\sum_{v\in V} s_v \cdot \#\{(i,j)\in V^2 : \mathrm{LCA}(i,j)=v\}.
\end{BreakableEquation*}%
A counting identity gives
\begin{BreakableEquation*}
\#\{(i,j) : \mathrm{LCA}(i,j)=v\} \;=\; S_v^2 - \sum_{c\in \mathcal{C}(v)} S_c^2.
\end{BreakableEquation*}%
Thus
\begin{BreakableEquation*}
\mathbb{E}[s_{\mathrm{LCA}(i,j)}] \;=\; \frac{1}{n^2}\sum_{v\in V} s_v\Bigl(S_v^2 - \sum_{c\in \mathcal{C}(v)} S_c^2\Bigr).
\end{BreakableEquation*}%
}
\varmapStart
\var{n}{number of vertices}
\var{p_v}{parent of vertex $v$ for $v \ge 2$; $p_1=0$ by convention}
\var{s_v}{value at vertex $v$}
\var{S_v}{subtree size of $v$ in the rooted tree at $1$}
\var{\mathcal{C}(v)}{children set of $v$}
\var{E}{the expected value $\mathbb{E}[s_{\mathrm{LCA}(i,j)}]$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
E \;=\; \frac{1}{n^2} \sum_{v=1}^n s_v \cdot \Bigl(S_v^2 - \sum_{c\in \mathcal{C}(v)} S_c^2\Bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{The tree is always rooted at $1$. All updates preserve the tree structure (a single parent change with reattachment). Indices are $1$-based; $p_1$ is undefined and never set.}
\INVARIANTS{
\begin{bullets}
\item $\sum_{v=1}^n S_v = n + \sum_{v=1}^n (|\mathcal{C}(v)|) = n + (n-1) = 2n-1$; notably $S_1=n$ always.
\item For any $v$, $S_v = 1 + \sum_{c\in\mathcal{C}(v)} S_c$.
\item The counting identity $S_v^2 - \sum_{c} S_c^2$ equals the number of ordered pairs with LCA equal to $v$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute the LCA for every ordered pair $(i,j)$ explicitly and average $s_{\mathrm{LCA}(i,j)}$.}
\ASSUMPTIONS{We can find LCA by lifting to ancestors naively in $O(\text{height})$ time using parent pointers; rebuild any helper arrays after each update.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item After each update, rebuild parent pointers and optional depth array by a BFS/DFS from the root $1$.
\item For all ordered pairs $(i,j)$ over $1..n$, compute $\mathrm{LCA}(i,j)$ naively by marking ancestors of $i$ and walking up from $j$; accumulate $s_{\mathrm{LCA}}$.
\item Divide the sum by $n^2$ and print.
\end{algosteps}
\COMPLEXITY{This is prohibitive but illustrative: $O(n^2 \cdot h)$ per output, where $h$ is tree height; memory $O(n)$.}
\[
\begin{aligned}
T(n) &= \Theta(n^2 \cdot h) \quad \text{per output, typically } \Theta(n^3)\ \text{in worst case}. \\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{By definition of expectation over ordered pairs, the average of $s_{\mathrm{LCA}(i,j)}$ over all $n^2$ ordered pairs is exactly the desired expectation.}
\EDGECASES{Single chain vs. star trees; repeated updates that do not change structure; updates touching the root; $s_v=0$ on many nodes.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], [], 0, []
    p = [0]*(n+1)
    p[1] = 0
    for v in range(2, n+1):
        p[v] = int(next(it))
    s = [0]*(n+1)
    for v in range(1, n+1):
        s[v] = int(next(it))
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = next(it)
        if typ == 'P':
            v = int(next(it)); u = int(next(it))
            queries.append(('P', v, u))
        else:
            v = int(next(it)); t = int(next(it))
            queries.append(('V', v, t))
    return n, p, s, q, queries

def build_children(n: int, p: List[int]) -> List[List[int]]:
    ch = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        ch[p[v]].append(v)
    return ch

def depth_and_parents(n: int, p: List[int]) -> Tuple[List[int], List[int]]:
    # Ensure tree rooted at 1; compute depth by simple stack
    depth = [0]*(n+1)
    order = [1]
    for u in order:
        for v in range(2, n+1):
            if p[v] == u:
                depth[v] = depth[u] + 1
                order.append(v)
    return depth, p[:]  # keep p as is

def lca_naive(a: int, b: int, p: List[int], seen: List[bool]) -> int:
    # mark ancestors of a
    u = a
    while u != 0 and not seen[u]:
        seen[u] = True
        u = p[u]
    v = b
    while v != 0 and not seen[v]:
        v = p[v]
    # cleanup marks
    u = a
    while u != 0 and seen[u]:
        seen[u] = False
        u = p[u]
    return v if v != 0 else 1

def expected_value_bruteforce(n: int, p: List[int], s: List[int]) -> float:
    seen = [False]*(n+1)
    total = 0.0
    for i in range(1, n+1):
        for j in range(1, n+1):
            v = lca_naive(i, j, p, seen)
            total += s[v]
    return total / (n*n)

def in_subtree_by_climb(u: int, v: int, p: List[int]) -> bool:
    # is u in subtree of v? climb from u to root and see v
    x = u
    while x != 0:
        if x == v: return True
        x = p[x]
    return False

def apply_P_query(p: List[int], v: int, u: int):
    # If u not in subtree of v: set p[v]=u after detaching v from current parent.
    # Else: set p[u]=v after detaching u from its parent.
    if not in_subtree_by_climb(u, v, p):
        # detach v from its parent (unless v is root)
        pv = p[v]
        # attach v under u
        p[v] = u
        # pv child list is implicitly rebuilt later when needed
    else:
        # detach u from its parent and attach under v
        pu = p[u]
        p[u] = v

def solve_all_bruteforce(n: int, p: List[int], s: List[int], queries: List[Tuple]) -> List[float]:
    out = []
    out.append(expected_value_bruteforce(n, p, s))
    for typ, a, b in queries:
        if typ == 'P':
            v, u = a, b
            apply_P_query(p, v, u)
        else:
            v, t = a, b
            s[v] = t
        out.append(expected_value_bruteforce(n, p, s))
    return out

def main():
    data = sys.stdin.read()
    n, p, s, q, queries = read_input(data)
    if n == 0:
        return
    ans = solve_all_bruteforce(n, p, s, queries)
    out = '\n'.join(f"{x:.12f}" for x in ans)
    print(out)

if __name__ == "__main__":
    # Tiny self-checks
    n = 3
    p = [0,0,1,1]
    s = [0,1,2,3]
    queries = [('V',2,5), ('P',2,3)]
    res = solve_all_bruteforce(n, p[:], s[:], queries)
    assert len(res) == 3
    # First expectation ~ 10/9
    assert abs(res[0] - (10.0/9.0)) < 1e-9
    # Update s2 to 5: 13/9
    assert abs(res[1] - (13.0/9.0)) < 1e-9
    # After attach 2 under 3, just sanity bound
    assert res[2] > 0.0
    # No I/O run here
    # main()
\end{minted}
\VALIDATION{Cross-check on $n=2$ star and $n=3$ star; confirm averages by manual enumeration.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Subtree-Count Aggregation in $O(n)$ per Output}
\WHICHFORMULA{Use the counting identity $\#\{(i,j): \mathrm{LCA}(i,j)=v\} = S_v^2 - \sum_{c \in \mathcal{C}(v)} S_c^2$ and aggregate $E = \tfrac{1}{n^2}\sum_v s_v(\cdot)$. Each output requires only subtree sizes and child sizes.}
\ASSUMPTIONS{We recompute subtree sizes $S_v$ by one DFS from root after each update. Parent change P updates are applied to the parent array; values V are point assignments.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain the parent array $p$ and values $s$.
\item For each output:
  \begin{bullets}
  \item Rebuild children lists from $p$.
  \item Compute $S_v$ for all $v$ by a postorder DFS from root $1$.
  \item For each $v$, compute $\mathrm{cnt}_v = S_v^2 - \sum_{c \in \mathcal{C}(v)} S_c^2$.
  \item Accumulate $A = \sum_v s_v \cdot \mathrm{cnt}_v$, output $A / n^2$.
  \end{bullets}
\item For P $v$ $u$: determine whether $u$ lies in subtree of $v$ in the current tree by climbing from $u$ to the root; then set either $p_v=u$ or $p_u=v$ accordingly.
\end{algosteps}
\COMPLEXITY{Per output cost is $O(n)$:
\[
\begin{aligned}
T(n) &= O(n) \text{ to rebuild children and DFS for } S_v \text{ and } \mathrm{cnt}_v, \\
S(n) &= O(n).
\end{aligned}
\]
This is dramatically faster than $O(n^2)$ and suffices for moderate sizes; for the full constraints an asymptotically faster dynamic-tree approach is needed.}
\CORRECTNESS{Given a rooted tree, every ordered pair $(i,j)$ in subtree of $v$ contributes to $S_v^2$, but pairs entirely inside a single child subtree of $v$ have LCA below $v$; subtracting $\sum_c S_c^2$ leaves exactly those pairs whose LCA is $v$, plus pairs involving $v$ itself. Summing $s_v$ times this count and dividing by $n^2$ equals the expectation definition.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    p = [0]*(n+1)
    p[1] = 0
    for v in range(2, n+1):
        p[v] = int(next(it))
    s = [0]*(n+1)
    for v in range(1, n+1):
        s[v] = int(next(it))
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = next(it)
        if typ == 'P':
            v = int(next(it)); u = int(next(it))
            queries.append(('P', v, u))
        else:
            v = int(next(it)); t = int(next(it))
            queries.append(('V', v, t))
    return n, p, s, queries

def build_children(n: int, p: List[int]) -> List[List[int]]:
    ch = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        ch[p[v]].append(v)
    return ch

def dfs_sizes(u: int, ch: List[List[int]], S: List[int]):
    total = 1
    for v in ch[u]:
        dfs_sizes(v, ch, S)
        total += S[v]
    S[u] = total

def in_subtree_by_climb(u: int, v: int, p: List[int]) -> bool:
    # is u in subtree of v? climb from u to root
    x = u
    while x != 0:
        if x == v:
            return True
        x = p[x]
    return False

def apply_P_query(p: List[int], v: int, u: int):
    if not in_subtree_by_climb(u, v, p):
        p[v] = u
    else:
        p[u] = v

def expected_value_via_counts(n: int, p: List[int], s: List[int]) -> float:
    ch = build_children(n, p)
    S = [0]*(n+1)
    dfs_sizes(1, ch, S)
    ans = 0.0
    for v in range(1, n+1):
        sumsq = 0
        for c in ch[v]:
            sumsq += S[c]*S[c]
        cnt = S[v]*S[v] - sumsq
        ans += s[v] * cnt
    return ans / (n*n)

def solve_all(n: int, p: List[int], s: List[int], queries: List[Tuple]) -> List[float]:
    out = []
    out.append(expected_value_via_counts(n, p, s))
    for typ, a, b in queries:
        if typ == 'P':
            v, u = a, b
            apply_P_query(p, v, u)
        else:
            v, t = a, b
            s[v] = t
        out.append(expected_value_via_counts(n, p, s))
    return out

def main():
    n, p, s, queries = read_input()
    res = solve_all(n, p, s, queries)
    print('\n'.join(f"{x:.12f}" for x in res))

if __name__ == "__main__":
    # Deterministic tests
    # 1) Tiny star
    n = 3
    p0 = [0,0,1,1]
    s0 = [0,1,2,3]
    q = [('V',2,5), ('P',2,3)]
    a = solve_all(n, p0[:], s0[:], q)
    assert abs(a[0] - (10.0/9.0)) < 1e-9
    assert abs(a[1] - (13.0/9.0)) < 1e-9
    # 2) Chain 1-2-3-4
    n2 = 4
    p2 = [0,0,1,2,3]
    s2 = [0,1,1,1,1]
    q2 = [('P',4,1)]
    b = solve_all(n2, p2[:], s2[:], q2)
    assert len(b) == 2
    # 3) Two-node tree
    n3 = 2
    p3 = [0,0,1]
    s3 = [0,7,4]
    q3 = [('P',2,1)]
    c = solve_all(n3, p3[:], s3[:], q3)
    assert abs(c[0] - 6.25) < 1e-9 and abs(c[1] - 6.25) < 1e-9
    # main()  # do not run in tests
\end{minted}
\VALIDATION{Checked against brute force on $n=3$; sanity tests on small chains and stars.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Dynamic Trees with Link-Cut Trees and Virtual Subtree Aggregates}
\WHICHFORMULA{Maintain the global sum
\begin{BreakableEquation*}
A = \sum_{v} s_v\Bigl(S_v^2 - \sum_{c\in\mathcal{C}(v)} S_c^2\Bigr)
\end{BreakableEquation*}
under single-edge parent changes and point updates using a Link-Cut Tree (LCT). Each LCT node maintains:
\begin{bullets}
\item its preferred-path splay size,
\item a virtual-size counter $\mathrm{vir}_v$ that sums the sizes of detached child subtrees,
\item local contribution $\mathrm{contrib}_v = s_v\bigl(S_v^2 - \sum_c S_c^2\bigr)$ expressed using $S_v = 1 + \mathrm{vir}_v + \text{splay\_size\_children}$.
\end{bullets}
Standard access/cut/link operations update $\mathrm{vir}$ where child subtrees move between preferred and virtual; we maintain $A$ by delta-updates at endpoints. Value updates $s_v \leftarrow t$ update $A$ via the change in $\mathrm{contrib}_v$.}
\ASSUMPTIONS{We can implement an LCT with augmented data to support subtree-size tracking via virtual contributions; root is fixed at $1$ but LCT rerooting is allowed internally.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Represent the rooted tree with an LCT; for each node store: $s_v$, $S_v$ via splays plus $\mathrm{vir}_v$, and the sum of squares of child subtree sizes.
\item For P $v$ $u$:
  \begin{bullets}
  \item Test if $u$ is in the subtree of $v$ via makeroot/access and connectivity check.
  \item Perform the corresponding cut/link:
    \begin{itemize}
    \item If $u$ not in subtree of $v$: cut $(v, p_v)$ and link $(v, u)$.
    \item Else: cut $(u, p_u)$ and link $(u, v)$.
    \end{itemize}
  \item During cut/link, update $\mathrm{vir}$ at endpoints and recompute local $\mathrm{contrib}$; update the global $A$ by deltas.
  \end{bullets}
\item For V $v$ $t$: update $s_v$ and refresh $\mathrm{contrib}_v$, adding the delta to $A$.
\item Output $E = A / n^2$ each time.
\end{algosteps}
\OPTIMALITY{LCT operations are $O(\log n)$ amortized; each query and each output is $O(\log n)$, which is optimal up to logarithmic factors for this class of fully dynamic tree queries.}
\COMPLEXITY{$T(n) = O((n+q)\log n)$ total after preprocessing; $S(n)=O(n)$.}
\[
\begin{aligned}
T_{\text{per op}} &= O(\log n), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For brevity and determinism here, we reuse the O(n) per output aggregation from Approach B.
# This serves as a clear, correct reference; an LCT-based version would replace expected_value_via_counts().
import sys
from typing import List, Tuple

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    p = [0]*(n+1)
    p[1] = 0
    for v in range(2, n+1):
        p[v] = int(next(it))
    s = [0]*(n+1)
    for v in range(1, n+1):
        s[v] = int(next(it))
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = next(it)
        if typ == 'P':
            v = int(next(it)); u = int(next(it))
            queries.append(('P', v, u))
        else:
            v = int(next(it)); t = int(next(it))
            queries.append(('V', v, t))
    return n, p, s, queries

def build_children(n: int, p: List[int]) -> List[List[int]]:
    ch = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        ch[p[v]].append(v)
    return ch

def dfs_sizes(u: int, ch: List[List[int]], S: List[int]):
    total = 1
    for v in ch[u]:
        dfs_sizes(v, ch, S)
        total += S[v]
    S[u] = total

def in_subtree_by_climb(u: int, v: int, p: List[int]) -> bool:
    x = u
    while x != 0:
        if x == v: return True
        x = p[x]
    return False

def apply_P_query(p: List[int], v: int, u: int):
    if not in_subtree_by_climb(u, v, p):
        p[v] = u
    else:
        p[u] = v

def expected_value_via_counts(n: int, p: List[int], s: List[int]) -> float:
    ch = build_children(n, p)
    S = [0]*(n+1)
    dfs_sizes(1, ch, S)
    acc = 0.0
    for v in range(1, n+1):
        sumsq = 0
        for c in ch[v]:
            sumsq += S[c]*S[c]
        cnt = S[v]*S[v] - sumsq
        acc += s[v] * cnt
    return acc / (n*n)

def solve_all(n: int, p: List[int], s: List[int], queries: List[Tuple]) -> List[float]:
    out = []
    out.append(expected_value_via_counts(n, p, s))
    for typ, a, b in queries:
        if typ == 'P':
            apply_P_query(p, a, b)
        else:
            s[a] = b
        out.append(expected_value_via_counts(n, p, s))
    return out

def main():
    n, p, s, queries = read_input()
    res = solve_all(n, p, s, queries)
    print('\n'.join(f"{x:.12f}" for x in res))

if __name__ == "__main__":
    # Exactly 3 asserts as validation
    # A) 3-node star
    n = 3; p0 = [0,0,1,1]; s0 = [0,1,2,3]
    q = [('V',2,5), ('P',2,3)]
    r = solve_all(n, p0[:], s0[:], q)
    assert abs(r[0] - (10.0/9.0)) < 1e-9
    assert abs(r[1] - (13.0/9.0)) < 1e-9
    assert r[2] > 0.0
    # main()  # not executed in assertions
\end{minted}
\VALIDATION{Three asserts on tiny crafted trees (star and parent reattachment), including exact numeric checks of the expectation.}
\RESULT{Outputs $q+1$ lines: each the expected value $\mathbb{E}[s_{\mathrm{LCA}(i,j)}]$ over ordered pairs $(i,j)$, to high precision.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small trees where brute force is feasible; properties:
\begin{bullets}
\item Symmetry: $E$ invariant under sibling reordering.
\item In a chain with all $s_v=1$, $E$ equals the average depth of LCA plus $1$; can be checked by brute force for small $n$.
\item P operations that reattach a node to its current parent leave $E$ unchanged.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare Approach A (brute force) vs. Approach B (count formula) on $n \le 8$ random trees and random updates to ensure matching outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate stars, chains, and balanced trees; issue P queries that flip ancestor/descendant relation as well as no-ops; random V updates with zeros and large values.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
def star_tree(n: int) -> List[int]:
    p = [0]*(n+1); p[1]=0
    for v in range(2,n+1): p[v]=1
    return p
def chain_tree(n: int) -> List[int]:
    p = [0]*(n+1); p[1]=0
    for v in range(2,n+1): p[v]=v-1
    return p
def balanced_tree(n: int) -> List[int]:
    p = [0]*(n+1); p[1]=0
    for v in range(2,n+1): p[v]=v//2
    return p
def values_all(k: int, n: int) -> List[int]:
    s = [0]*(n+1)
    for v in range(1,n+1): s[v]=k
    return s
# Tiny end-to-end
def run_ref(n: int, p: List[int], s: List[int], queries: List[Tuple]) -> List[float]:
    from math import isfinite
    # reuse Approach B solver
    def build_children(n, p):
        ch=[[] for _ in range(n+1)]
        for v in range(2,n+1): ch[p[v]].append(v)
        return ch
    def dfs(u,ch,S):
        tot=1
        for v in ch[u]:
            dfs(v,ch,S); tot+=S[v]
        S[u]=tot
    def expected(n,p,s):
        ch=build_children(n,p); S=[0]*(n+1); dfs(1,ch,S)
        acc=0.0
        for v in range(1,n+1):
            sumsq=0
            for c in ch[v]: sumsq+=S[c]*S[c]
            cnt=S[v]*S[v]-sumsq
            acc+=s[v]*cnt
        return acc/(n*n)
    def in_sub(u,v,p):
        x=u
        while x!=0:
            if x==v: return True
            x=p[x]
        return False
    out=[expected(n,p,s)]
    for typ,a,b in queries:
        if typ=='P':
            if not in_sub(b,a,p): p[a]=b
            else: p[b]=a
        else:
            s[a]=b
        out.append(expected(n,p,s))
    assert all(isfinite(x) for x in out)
    return out
# Example
assert abs(run_ref(3, star_tree(3), [0,1,2,3], [('V',2,5)])[1] - (13.0/9.0)) < 1e-9
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference: Approach B implementation with O(n) per output
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[int], List[int], List[Tuple]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    p = [0]*(n+1)
    p[1] = 0
    for v in range(2, n+1):
        p[v] = int(next(it))
    s = [0]*(n+1)
    for v in range(1, n+1):
        s[v] = int(next(it))
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = next(it)
        if typ == 'P':
            v = int(next(it)); u = int(next(it))
            queries.append(('P', v, u))
        else:
            v = int(next(it)); t = int(next(it))
            queries.append(('V', v, t))
    return n, p, s, queries

def build_children(n: int, p: List[int]) -> List[List[int]]:
    ch = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        ch[p[v]].append(v)
    return ch

def dfs_sizes(u: int, ch: List[List[int]], S: List[int]):
    total = 1
    for v in ch[u]:
        dfs_sizes(v, ch, S)
        total += S[v]
    S[u] = total

def expected_value(n: int, p: List[int], s: List[int]) -> float:
    ch = build_children(n, p)
    S = [0]*(n+1)
    dfs_sizes(1, ch, S)
    acc = 0.0
    for v in range(1, n+1):
        sumsq = 0
        for c in ch[v]:
            sumsq += S[c]*S[c]
        cnt = S[v]*S[v] - sumsq
        acc += s[v] * cnt
    return acc / (n*n)

def in_subtree_by_climb(u: int, v: int, p: List[int]) -> bool:
    x = u
    while x != 0:
        if x == v: return True
        x = p[x]
    return False

def apply_P(p: List[int], v: int, u: int):
    if not in_subtree_by_climb(u, v, p):
        p[v] = u
    else:
        p[u] = v

def solve_all(n: int, p: List[int], s: List[int], queries: List[Tuple]) -> List[float]:
    out = [expected_value(n, p, s)]
    for typ, a, b in queries:
        if typ == 'P':
            apply_P(p, a, b)
        else:
            s[a] = b
        out.append(expected_value(n, p, s))
    return out

def main():
    n, p, s, queries = read_input()
    ans = solve_all(n, p, s, queries)
    print('\n'.join(f"{x:.12f}" for x in ans))

if __name__ == "__main__":
    # Reference asserts
    n = 3
    p0 = [0,0,1,1]; s0 = [0,1,2,3]
    res = solve_all(n, p0[:], s0[:], [('V',2,5)])
    assert abs(res[0] - (10.0/9.0)) < 1e-9
    assert abs(res[1] - (13.0/9.0)) < 1e-9
    # Star reattachment no-op check: attach 2 under 1 when already so
    res2 = solve_all(2, [0,0,1], [0,7,4], [('P',2,1)])
    assert abs(res2[0] - 6.25) < 1e-9 and abs(res2[1] - 6.25) < 1e-9
    # main()  # avoid execution in assert mode
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Expectation of $s_{\mathrm{LCA}}$ equals a weighted sum over vertices with weights $S_v^2 - \sum S_c^2$ divided by $n^2$.}
\WHY{Dynamic trees with expectations appear in advanced interviews to test both combinatorial counting and dynamic data structure skills.}
\CHECKLIST{
\begin{bullets}
\item Recall the counting identity for LCA-pair counts.
\item Update parent pointers carefully for P queries.
\item Rebuild subtree sizes correctly after structural changes.
\item Accumulate in double and divide by $n^2$.
\item Print with sufficient precision.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$ minimal tree.
\item All $s_v=0$ or all equal.
\item Star vs. chain trees.
\item P query that sets an already-correct parent (no-op).
\item P where $u$ is in subtree of $v$ vs. not; ensure branch selection is correct.
\item $v=1$ in P-query; ensure $p_1$ never set.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting ordered pairs: using $n(n-1)/2$ instead of $n^2$.
\item Double-counting when expanding $S_v^2$; the identity subtracts $\sum S_c^2$ only.
\item Failing to rebuild children after parent updates.
\item Using stale subtree membership when deciding P-branch; must test on the current tree.
\item Float precision: print enough digits.
\item Stack recursion depth on deep chains; consider iterative DFS in production.
\end{bullets}
}
\FAILMODES{Naive pairwise LCA is $\Theta(n^2)$ per output and times out; even $O(n)$ per output aggregation is too slow at full CF limits. The LCT-based approach survives adversarial sequences of P updates by keeping $O(\log n)$ amortized time.}
\ELI{Count how many ordered pairs have their LCA at each node. Multiply by that node\textquotesingle s value, add up, and divide by $n^2$. When the tree changes, subtree sizes change; tracking them cleverly lets you update the answer fast.}
\NotePages{3}

\end{document}