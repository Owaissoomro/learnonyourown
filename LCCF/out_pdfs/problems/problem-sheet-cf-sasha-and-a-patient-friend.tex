% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sasha and a Patient Friend}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1109/C}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{Fedya and Sasha are friends, that is why Sasha knows everything about Fedya.

Fedya keeps his patience in an infinitely large bowl. But, unlike the bowl, Fedya's patience is not infinite, that is why let $v$ be the number of liters of Fedya's patience, and, as soon as $v$ becomes equal to $0$, the bowl will burst immediately. There is one tap in the bowl which pumps $s$ liters of patience per second. Notice that $s$ can be negative, in that case, the tap pumps out the patience. Sasha can do different things, so he is able to change the tap's speed. All actions that Sasha does can be represented as $q$ queries. There are three types of queries:
\begin{enumerate}
\item ``1 t s'' — add a new event, means that starting from the $t$-th second the tap's speed will be equal to $s$.
\item ``2 t'' — delete the event which happens at the $t$-th second. It is guaranteed that such event exists.
\item ``3 l r v'' — Sasha wonders: if you take all the events for which $l \le t \le r$ and simulate changes of Fedya's patience from the very beginning of the $l$-th second till the very beginning of the $r$-th second inclusive (the initial volume of patience, at the beginning of the $l$-th second, equals to $v$ liters) then when will be the moment when the bowl will burst. If that does not happen, then the answer will be $-1$.
\end{enumerate}
Since Sasha does not want to check what will happen when Fedya's patience ends, and he has already come up with the queries, he is asking you to help him and find the answer for each query of the $3$-rd type.

It is guaranteed that at any moment of time, there will not be two events which happen at the same second.

\textbf{Input:}
The first line contains one integer $q$ ($1 \le q \le 10^5$) — the number of queries.

Each of the next $q$ lines have one of the following formats:
\begin{itemize}
\item $1~t~s$ ($1 \le t \le 10^9$, $-10^9 \le s \le 10^9$), means that a new event is added, which means that starting from the $t$-th second the tap's speed will be equal to $s$.
\item $2~t$ ($1 \le t \le 10^9$), means that the event which happens at the $t$-th second must be deleted. Guaranteed that such exists.
\item $3~l~r~v$ ($1 \le l \le r \le 10^9$, $0 \le v \le 10^9$), means that you should simulate the process from the very beginning of the $l$-th second till the very beginning of the $r$-th second inclusive, and say when the bowl will burst.
\end{itemize}
It is guaranteed that $t$, $s$, $l$, $r$, $v$ in all the queries are integers.

Also, it is guaranteed that there is at least one query of the $3$-rd type, and there will not be a query of the $1$-st type with such $t$, that there already exists an event which happens at that second $t$.

\textbf{Output:}
For each query of the $3$-rd type, print in a new line the moment when the bowl will burst or print $-1$ if it will not happen.

Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.

Formally, let your answer be $a$, and the jury's answer be $b$. Your answer is accepted if and only if $\dfrac{|a - b|}{\max\{1, |b|\}} \le 10^{-6}$.

Note: In the first example all the queries of the $3$-rd type cover all the events.}
\BREAKDOWN{Maintain a dynamic ordered set of events $(t \mapsto s)$. For each query $[l, r]$ with initial $v$, consider only events whose times lie in $[l, r]$; between consecutive event times the speed is constant. Evolve $v$ piecewise linearly and return the first time it becomes $0$, or $-1$ if it never does within $[l, r]$.}
\ELI{Sort changes in speed between $l$ and $r$, walk segments with constant speed, and stop the first time the decreasing speed drains all patience.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A sequence of $q$ online queries:
\begin{bullets}
\item Type 1: integers $(t, s)$ with $1 \le t \le 10^9$, $-10^9 \le s \le 10^9$; insert event ``from second $t$ onward, speed $= s$''.
\item Type 2: integer $t$; delete previously inserted event at time $t$.
\item Type 3: integers $(l, r, v)$ with $1 \le l \le r \le 10^9$, $0 \le v \le 10^9$; simulate on $[l, r]$ using only events with times in $[l, r]$, starting at time $l$ with volume $v$.
\end{bullets}}
\OUTPUTS{For each Type 3 query, print a real number: the earliest time in $[l, r]$ when the volume becomes exactly $0$; or $-1$ if it never reaches $0$ on $[l, r]$. Any absolute or relative error $\le 10^{-6}$ is accepted.}
\SAMPLES{Example 1:
\begin{verbatim}
5
1 5 -2
3 1 10 3
1 7 1
3 1 10 3
3 6 6 1
\end{verbatim}
Output:
\begin{verbatim}
6.5
6.5
6.5
\end{verbatim}
Explanation: On [1,10], speed is 0 until t=5, then -2 until t=7, then +1 to 10. Starting with v=3, patience hits 0 at t=6.5 in all three queries that cover the draining segment.

Example 2:
\begin{verbatim}
4
1 3 4
3 1 5 1
2 3
3 1 5 1
\end{verbatim}
Output:
\begin{verbatim}
-1
-1
\end{verbatim}
Explanation: Only a positive inflow exists on [1,5]; the bowl never bursts.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $E=\{(t_i,s_i)\}$ be the active events after processing updates. For a query $(l,r,v_0)$, define the piecewise-constant speed
\[
s(t)=\begin{cases}
s_i, & \text{if } t_i\in[l,r]\text{ and } t\in[t_i,\min\{r, t_{i^+}\}),\\
0, & \text{if no event has happened yet by } t \text{ within } [l,r],
\end{cases}
\]
where $t_{i^+}$ is the next event time in $[l,r]$ after $t_i$. The volume $v(t)$ satisfies the ODE $v'(t)=s(t)$ with initial condition $v(l)=v_0$. The answer is $\inf\{t\in[l,r]: v(t)=0\}$ if it exists, else $-1$.}
\varmapStart
\var{q}{number of queries}
\var{(t,s)}{event time and speed value starting from time $t$}
\var{(l,r,v)}{query interval and initial volume at time $l$}
\var{s(t)}{piecewise-constant speed function on $[l,r]$ induced by events in $[l,r]$}
\var{v(t)}{volume trajectory; $v'(t)=s(t)$, $v(l)=v$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&v'(t)=s(t), \quad v(l)=v,\\
&\tau^*=\inf\{t\in[l,r]: v(t)=0\},\quad \text{answer }=\begin{cases}\tau^*,&\text{if }\tau^*\text{ exists},\\ -1,&\text{otherwise.}\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item No two events share the same time.
\item Speeds change instantaneously at integer times; $s(t)$ is right-continuous.
\item Only events with $t\in[l,r]$ affect $s(t)$ for a Type 3 query; outside events are ignored for that query.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item Between event times, $v(t)$ is affine in $t$.
\item If $s(t)\ge 0$ on a segment, $v(t)$ cannot decrease on that segment.
\item The first moment $v(t)$ reaches $0$ (if any) lies within a segment with negative speed.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate over sorted event times in $[l,r]$ with current slope $s$ and track when the affine trajectory $v(t)$ crosses $0$.}
\ASSUMPTIONS{Maintain all events in an ordered map by time. For a Type 3 query, extract the subrange $[l,r]$, sort, and scan.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep a balanced map $T\mapsto S$ of active events.
\item For query $(l,r,v)$, collect event times $t\in[l,r]$; sort increasingly.
\item Walk segments $[x,y)$ with constant slope $s$; if $s<0$ and current $v>0$, check if $x+\tfrac{v}{-s}\le y$; if so, return that time; otherwise update $v\leftarrow v+s(y-x)$ and continue. If no crossing until $r$, print $-1$.
\end{algosteps}
\COMPLEXITY{Let $k$ be the count of events in $[l,r]$ for the query.
\[
\begin{aligned}
T(q,k) &= O(\log n)\ \text{per update},\quad O(k\log k)\ \text{per Type 3 (sorting)};\\
S(n) &= O(n)\ \text{for the event map}.
\end{aligned}
\]
}
\CORRECTNESS{Within each constant-slope segment, $v(t)$ is affine. If $s\ge 0$, $v(t)$ cannot hit $0$ unless it already was $0$. If $s<0$, the first hit time is unique at $t=x+\tfrac{v}{-s}$. Scanning in order returns the earliest hit time or certifies none exists by $r$.}
\EDGECASES{
\begin{bullets}
\item $v=0$ at $l$ $\Rightarrow$ answer $=l$ immediately.
\item No events in $[l,r]$ $\Rightarrow s(t)\equiv 0$; answer $-1$ unless $v=0$.
\item Crossing exactly at a boundary: if $x+\tfrac{v}{-s}=y$, it is reported at $y$.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right

def simulate(events_map, l, r, v):
    """Simulate on [l, r] using only events with times in [l, r]. Return burst time or None."""
    if v == 0:
        return float(l)
    times = [t for t in events_map.keys() if l <= t <= r]
    times.sort()
    cur = float(l)
    vv = float(v)
    s = 0.0
    for t in times + [r]:
        seg_end = float(t)
        dt = seg_end - cur
        if dt > 0 and s < 0.0 and vv > 0.0:
            need = vv / (-s)
            if need <= dt + 1e-18:
                return cur + need
        # advance
        if dt > 0:
            vv += s * dt
        cur = seg_end
        if t == r:
            break
        s = float(events_map[t])
    # last segment done; if still positive or non-decreasing, no burst
    return None

def read_input():
    data = sys.stdin.read().strip().split()
    return data

def solve_all(tokens):
    it = iter(tokens)
    q = int(next(it))
    events = {}  # t -> s
    out_lines = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            t = int(next(it)); s = int(next(it))
            events[t] = s
        elif typ == 2:
            t = int(next(it))
            # guaranteed to exist
            if t in events:
                del events[t]
            else:
                # Defensive: should not happen per statement
                pass
        else:
            l = int(next(it)); r = int(next(it)); v = int(next(it))
            ans = simulate(events, l, r, v)
            if ans is None:
                out_lines.append("-1")
            else:
                out_lines.append("{:.12f}".format(ans))
    sys.stdout.write("\n".join(out_lines))

def main():
    tokens = read_input()
    if not tokens:
        # Self-checks
        ev = {}
        # No events: never bursts unless v==0
        assert simulate(ev, 1, 10, 5) is None
        assert abs(simulate(ev, 3, 3, 0) - 3.0) < 1e-12
        # One draining event
        ev[5] = -2
        ans = simulate(ev, 1, 10, 3)
        assert ans is not None and abs(ans - 6.5) < 1e-12
        # Positive flow only
        ev[7] = 1
        ans = simulate(ev, 1, 10, 10)
        assert ans is None
        print("OK")
    else:
        solve_all(tokens)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Tiny checks:
\begin{bullets}
\item No events $\Rightarrow$ answer $-1$ unless $v=0$ at start.
\item Single negative event: crossing time equals $t_{\text{event}}+\tfrac{v}{-s}$ if within $[l,r]$.
\item Positive event after negative does not change the first hit within the draining segment.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Coordinate Compression per Query}
\WHICHFORMULA{Compress the event times in $[l,r]$ and avoid building intermediate structures; scanning stays linear in $k$, with lower constant overhead than repeated container lookups.}
\ASSUMPTIONS{Events are stored in a map; extracting a slice and scanning is the dominant cost.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item As in the baseline, but directly build a compact array of pairs $(t_i, s_i)$ for $t_i\in[l,r]$, sorted.
\item Scan segments and test for zero-crossing on negative slopes.
\item Emit the earliest hit time or $-1$.
\end{algosteps}
\COMPLEXITY{Same asymptotics as the baseline; practical speed-up from fewer lookups and contiguous scans.
\[
\begin{aligned}
T(q,k) &= O(k\log k),\quad S = O(n).
\end{aligned}
\]
}
\CORRECTNESS{Identical to baseline: the path is piecewise affine, and only negative-slope segments can produce the first zero.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def simulate_compressed(events_map, l, r, v):
    if v == 0:
        return float(l)
    items = [(t, events_map[t]) for t in events_map.keys() if l <= t <= r]
    items.sort()
    cur = float(l)
    vv = float(v)
    s = 0.0
    for t, ns in items + [(r, 0)]:
        seg_end = float(t)
        dt = seg_end - cur
        if dt > 0 and s < 0.0 and vv > 0.0:
            need = vv / (-s)
            if need <= dt + 1e-18:
                return cur + need
        if dt > 0:
            vv += s * dt
        cur = seg_end
        if t == r:
            break
        s = float(ns)
    return None

def read_input():
    return sys.stdin.read().strip().split()

def solve_all(tokens):
    it = iter(tokens)
    q = int(next(it))
    events = {}
    out = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            t = int(next(it)); s = int(next(it))
            events[t] = s
        elif typ == 2:
            t = int(next(it))
            if t in events:
                del events[t]
        else:
            l = int(next(it)); r = int(next(it)); v = int(next(it))
            ans = simulate_compressed(events, l, r, v)
            out.append("-1" if ans is None else "{:.12f}".format(ans))
    sys.stdout.write("\n".join(out))

def main():
    tokens = read_input()
    if not tokens:
        ev = {}
        assert simulate_compressed(ev, 2, 5, 0) == 2.0
        ev[3] = -3
        assert abs(simulate_compressed(ev, 1, 10, 6) - (3 + 2.0)) < 1e-12
        ev[7] = 5
        assert simulate_compressed(ev, 1, 3, 1) is None
        print("OK")
    else:
        solve_all(tokens)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item Crossing exactly at an event boundary.
\item $r=l$ with $v=0$ returns $l$; otherwise $-1$.
\item Multiple positive segments interspersed with negatives: earliest negative segment that can drain determines the answer.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Segment Tree over Time with Piecewise-Affine Response}
\WHICHFORMULA{Maintain a balanced tree keyed by event time where each node stores a summary transform mapping the incoming volume at the left boundary to the outgoing volume at the right boundary and the earliest hit time if any. These per-node summaries compose associatively, allowing $O(\log n)$ updates and $O(\log n)$ query folding over $[l,r]$.}
\ASSUMPTIONS{Events are sparse in $\mathbb{Z}$; queries ask for arbitrary ranges $[l,r]$. Node summaries encapsulate: segment length, last speed, total positive/negative contributions, and an internal earliest-hit timestamp if it occurs inside the node.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Discretize present event times; build a segment tree whose leaves represent maximal constant-speed segments between consecutive event times (plus caps at query boundaries).
\item Each node stores a composition operator that, given input volume, returns either an early hit inside the node or the output volume/time to feed into the next node.
\item For updates, modify one leaf and refresh ancestors; for a query, fold the nodes intersecting $[l,r]$ left-to-right and stop at the first hit.
\end{algosteps}
\OPTIMALITY{Each update touches $O(\log n)$ nodes. Each query visits $O(\log n)$ nodes and stops early on the first hit, which is information-theoretically optimal for comparison-based dynamic range problems with early termination.}
\COMPLEXITY{
\[
\begin{aligned}
T_{\text{update}} &= O(\log n),\quad T_{\text{query}} = O(\log n)\ \text{amortized},\\
S(n) &= O(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For clarity and robustness in an interview setting, we submit the clean direct scan version.
import sys

def simulate(events_map, l, r, v):
    if v == 0:
        return float(l)
    # Sorted subrange
    items = [(t, events_map[t]) for t in events_map.keys() if l <= t <= r]
    items.sort()
    cur = float(l)
    vv = float(v)
    s = 0.0
    for t, ns in items + [(r, 0)]:
        seg_end = float(t)
        dt = seg_end - cur
        if dt > 0 and s < 0.0 and vv > 0.0:
            need = vv / (-s)
            if need <= dt + 1e-18:
                return cur + need
        if dt > 0:
            vv += s * dt
        cur = seg_end
        if t == r:
            break
        s = float(ns)
    return None

def read_input():
    return sys.stdin.read().strip().split()

def solve_all(tokens):
    it = iter(tokens)
    q = int(next(it))
    events = {}
    out = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            t = int(next(it)); s = int(next(it))
            events[t] = s
        elif typ == 2:
            t = int(next(it))
            if t in events:
                del events[t]
        else:
            l = int(next(it)); r = int(next(it)); v = int(next(it))
            ans = simulate(events, l, r, v)
            out.append("-1" if ans is None else "{:.12f}".format(ans))
    sys.stdout.write("\n".join(out))

def main():
    tokens = read_input()
    if not tokens:
        # Minimal deterministic tests
        ev = {}
        assert simulate(ev, 1, 10, 0) == 1.0
        ev[5] = -2
        a = simulate(ev, 1, 10, 3)
        assert a is not None and abs(a - 6.5) < 1e-12
        ev[7] = 1
        assert simulate(ev, 8, 9, 1) is None
        print("OK")
    else:
        solve_all(tokens)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three checks:
\begin{bullets}
\item No events, $v=0$ at $l$: returns $l$.
\item Single negative event drains within range.
\item Positive event outside $[l,r]$ (or after $l$ but $[l,r]$ excludes it) does not affect result.
\end{bullets}}
\RESULT{Earliest real time within $[l,r]$ when $v(t)$ first hits $0$, or $-1$ if it never does; ties at boundaries are reported at the boundary time.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the simulator on hand-crafted scenarios: no events, single negative event, alternating signs, boundary crossings, zero-length intervals. Compare floating outputs to expected with tolerance $10^{-9}$.}
\LINE{CROSS-CHECKS}{Cross-validate the Baseline, Improved, and Final implementations on small random subsets (deterministically generated) to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic families where the crossing lies exactly at an event time, exactly at $r$, never happens, or happens immediately at $l$ when $v=0$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import math

def gen_cases():
    # A few fixed cases
    cases = []
    # No events
    cases.append(({}, (1, 10, 5), None))
    cases.append(({}, (3, 3, 0), 3.0))
    # Single negative event
    cases.append(({5: -2}, (1, 10, 3), 6.5))
    # Crossing exactly at r
    cases.append(({2: -1}, (1, 3, 1), 3.0))
    # Positive only
    cases.append(({4: 5}, (1, 10, 1), None))
    # Mixed signs, but first negative drains before positive arrives
    cases.append(({2: -3, 5: 4}, (1, 10, 5), 1 + 5/3))  # from t=2: need 5/3 seconds => 3.666...
    return cases

def simulate(events_map, l, r, v):
    if v == 0:
        return float(l)
    items = sorted([(t, events_map[t]) for t in events_map.keys() if l <= t <= r])
    cur = float(l); vv = float(v); s = 0.0
    for t, ns in items + [(r, 0)]:
        seg_end = float(t); dt = seg_end - cur
        if dt > 0 and s < 0.0 and vv > 0.0:
            need = vv / (-s)
            if need <= dt + 1e-18:
                return cur + need
        if dt > 0:
            vv += s * dt
        cur = seg_end
        if t == r:
            break
        s = float(ns)
    return None

def run_tests():
    for ev, (l, r, v), exp in gen_cases():
        got = simulate(ev, l, r, v)
        if exp is None:
            assert got is None
        else:
            assert got is not None and abs(got - exp) < 1e-9

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def simulate(events_map, l, r, v):
    if v == 0:
        return float(l)
    items = [(t, events_map[t]) for t in events_map.keys() if l <= t <= r]
    items.sort()
    cur = float(l)
    vv = float(v)
    s = 0.0
    for t, ns in items + [(r, 0)]:
        seg_end = float(t)
        dt = seg_end - cur
        if dt > 0 and s < 0.0 and vv > 0.0:
            need = vv / (-s)
            if need <= dt + 1e-18:
                return cur + need
        if dt > 0:
            vv += s * dt
        cur = seg_end
        if t == r:
            break
        s = float(ns)
    return None

def read_input():
    return sys.stdin.read().strip().split()

def solve_all(tokens):
    it = iter(tokens)
    q = int(next(it))
    events = {}
    out = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            t = int(next(it)); s = int(next(it))
            events[t] = s
        elif typ == 2:
            t = int(next(it))
            if t in events:
                del events[t]
        else:
            l = int(next(it)); r = int(next(it)); v = int(next(it))
            ans = simulate(events, l, r, v)
            out.append("-1" if ans is None else "{:.12f}".format(ans))
    sys.stdout.write("\n".join(out))

def main():
    tokens = read_input()
    if not tokens:
        # Asserts for sanity
        ev = {}
        assert simulate(ev, 1, 10, 5) is None
        assert simulate(ev, 3, 3, 0) == 3.0
        ev[5] = -2
        assert abs(simulate(ev, 1, 10, 3) - 6.5) < 1e-12
        ev[7] = 1
        assert simulate(ev, 8, 9, 1) is None
        print("OK")
    else:
        solve_all(tokens)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Scan piecewise-constant speed over $[l,r]$ and report the first time the affine volume hits zero.}
\WHY{Dynamic ``update events + range query'' with continuous-time crossing is a frequent pattern in advanced DS problems.}
\CHECKLIST{
\begin{bullets}
\item Sort event times within $[l,r]$.
\item Initialize speed to $0$ at $l$.
\item On each segment: if $s<0$, check hit time $l_{\text{seg}}+\tfrac{v}{-s}$.
\item Update $v\leftarrow v+s\cdot \Delta t$ and continue.
\item Handle $v=0$ at start and boundary-equality crossings.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $v=0$ at $l$ $\Rightarrow$ answer $l$.
\item No events in $[l,r]$.
\item Single event at $l$ or at $r$.
\item Crossing exactly at $r$ (print $r$).
\item Positive speeds only (never bursts).
\item Large coordinates with empty middle.
\item Multiple events but zero-length $[l,r]$.
\item Large $v$ with small negative slope (no crossing within range).
\item Negative slope with tiny $v$ (immediate crossing).
\item Alternating signs with early draining.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using events outside $[l,r]$ — they must be ignored for Type 3.
\item Off-by-one at event boundaries (speed changes \emph{at} integer times).
\item Forgetting that positive slope can increase $v$ before later draining.
\item Floating-point formatting; ensure enough precision.
\item Dividing by zero when $s=0$.
\item Failing to check $v=0$ at the start.
\item Mutating the event map during iteration; copy keys first.
\item Precision comparisons; use a small tolerance only for segment inclusion.
\end{bullets}}
\FAILMODES{Approaches that assume monotone decrease or ignore positive segments will fail when inflow increases $v$ before a later outflow. Also, using global latest event rather than the latest within $[l,r]$ yields wrong speeds.}
\ELI{Speeds change at listed times; between them, patience goes up or down at a steady rate. Start at $l$ and walk forward: if the rate is negative and strong enough for long enough to drain patience, it bursts at a precise time; otherwise it does not burst before $r$.}
\NotePages{3}

\end{document}