% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — GCD Sort of an Array}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/gcd-sort-of-an-array/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array \texttt{nums}. You may perform the following operation any number of times on \texttt{nums}: swap the positions of two elements \texttt{nums[i]} and \texttt{nums[j]} if $\gcd(\texttt{nums[i]}, \texttt{nums[j]}) > 1$, where $\gcd(\cdot,\cdot)$ denotes the greatest common divisor.

Return \texttt{true} if it is possible to sort \texttt{nums} in non-decreasing order using the above swap rule, or \texttt{false} otherwise.

Examples.

Example 1:
Input: \texttt{nums = [7, 21, 3]}. Output: \texttt{true}.
Explanation: We can sort by the sequence
(1) swap $7$ and $21$ since $\gcd(7,21)=7$ to get $[21,7,3]$,
(2) swap $21$ and $3$ since $\gcd(21,3)=3$ to get $[3,7,21]$.

Example 2:
Input: \texttt{nums = [5, 2, 6, 2]}. Output: \texttt{false}.
Explanation: It is impossible because $5$ shares no common factor greater than $1$ with any other element, so it cannot move.

Example 3:
Input: \texttt{nums = [10, 5, 9, 3, 15]}. Output: \texttt{true}.
One valid sequence:
swap $10$ and $15$ ($\gcd=5$): $[15,5,9,3,10]$;
swap $15$ and $3$ ($\gcd=3$): $[3,5,9,15,10]$;
swap $10$ and $15$ ($\gcd=5$): $[3,5,9,10,15]$.

Constraints: $1 \le \lvert\texttt{nums}\rvert \le 3 \times 10^{4}$ and $2 \le \texttt{nums}[i] \le 10^{5}$.}
\BREAKDOWN{Rephrase the operation as a graph connectivity question: indices are vertices and an edge exists between indices $i,j$ if $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$. Then the array is sortable iff, for every connected component, the multiset of values currently on that component can be rearranged to match the multiset of target sorted values restricted to that component. The challenge is to build connectivity without $O(n^{2})$ pairwise gcd checks.}
\ELI{Numbers that are connected via shared prime factors can be swapped along a path; you can sort if each value can travel within its prime-factor connectivity to its final spot.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{nums} of integers with $1 \le n \le 3 \times 10^{4}$ and each $2 \le \texttt{nums}[i] \le 10^{5}$.}
\OUTPUTS{A boolean: \texttt{True} if the array can be sorted into non-decreasing order using swaps of pairs whose gcd is greater than $1$, otherwise \texttt{False}.}
\SAMPLES{Example A: \texttt{[7, 21, 3]} $\to$ \texttt{True}.
Example B: \texttt{[5, 2, 6, 2]} $\to$ \texttt{False}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n=\lvert\texttt{nums}\rvert$. Define an undirected graph $G=(V,E)$ with $V=\{0,\ldots,n-1\}$ and edge $\{i,j\}\in E$ iff $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$. The allowed operation is swapping values on endpoints of an edge; by transitivity, values can move along any path in $G$. Let $\texttt{sorted}$ be the non-decreasing sort of \texttt{nums}. The array is sortable iff for every connected component $C \subseteq V$, the multiset $\{\texttt{nums}[i]:i\in C\}$ equals the multiset $\{\texttt{sorted}[i]:i\in C\}$.}
\varmapStart
\var{n}{length of the array}
\var{\texttt{nums}}{original array}
\var{\texttt{sorted}}{sorted copy of \texttt{nums}}
\var{G}{graph of indices with edges for gcd greater than $1$}
\var{\mathrm{cc}(i)}{component identifier of index $i$ in $G$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall C \subseteq V \text{ connected}:~ \multiset{\texttt{nums}[i]:i\in C} = \multiset{\texttt{sorted}[i]:i\in C}.
\end{BreakableEquation*}
Equivalently, for all $i$, index $i$ can receive some value equal to $\texttt{sorted}[i]$ from within its component, i.e., $\exists j \text{ with } \texttt{nums}[j]=\texttt{sorted}[i] \text{ and } \mathrm{cc}(j)=\mathrm{cc}(i).
}
\ASSUMPTIONS{Graph is undirected; gcd symmetry holds; repeated values allowed; indices are $0$-based; no value equals $1$ so every factorization consists of primes at least $2$.}
\INVARIANTS{Swapping along edges preserves, within each connected component, the multiset of values located on that component. Connectivity by prime factors: if two numbers share a prime factor, there is an edge between their indices, hence they lie in the same component if connected via a chain of shared factors.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Build $G$ explicitly by checking all $\binom{n}{2}$ pairs for $\gcd>1$, then use a Disjoint Set Union (DSU) over indices to form components and compare componentwise multisets against the target.}
\ASSUMPTIONS{This is acceptable only for small $n$ because it is $O(n^{2}\log A)$ to compute all pairwise gcds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Make a sorted copy \texttt{sorted} of \texttt{nums}.
\item Initialize DSU over indices $0..n-1$; for each pair $i<j$, if $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$, union $i$ and $j$.
\item Group indices by DSU root; for each group, compare the sorted lists of values from \texttt{nums} and from \texttt{sorted}. Return \texttt{True} iff all groups match. 
\end{algosteps}
\COMPLEXITY{Pairwise checks dominate. For $n$ items and maximum value $A$,
\[
\begin{aligned}
T(n) &= \Theta(n^{2}\cdot \log A) \quad \text{(Euclidean gcd)} \\
S(n) &= \Theta(n) \quad \text{(DSU and group buffers).}
\end{aligned}
\]}
\CORRECTNESS{Any allowed swap is an edge; swaps along a path can simulate moving values within the connected component. A connected undirected graph generates all permutations via adjacent swaps along edges, so any multiset arrangement within a component is achievable. Therefore matching componentwise multisets is necessary and sufficient.}
\EDGECASES{All primes and distinct values imply no swaps; duplicates must be matched carefully; already-sorted arrays pass trivially; arrays with repeated composite values stay within components.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from math import gcd

class DSUIdx:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

class Solution:
    # Baseline O(n^2 log A)
    def gcdSort(self, nums: List[int]) -> bool:
        n = len(nums)
        target = sorted(nums)
        dsu = DSUIdx(n)
        for i in range(n):
            for j in range(i+1, n):
                if gcd(nums[i], nums[j]) > 1:
                    dsu.union(i, j)
        # group indices by root
        comp = {}
        for i in range(n):
            r = dsu.find(i)
            comp.setdefault(r, []).append(i)
        # compare componentwise multisets
        for idxs in comp.values():
            a = sorted(nums[i] for i in idxs)
            b = sorted(target[i] for i in idxs)
            if a != b:
                return False
        return True

# basic asserts
assert Solution().gcdSort([7,21,3]) is True
assert Solution().gcdSort([5,2,6,2]) is False
assert Solution().gcdSort([10,5,9,3,15]) is True
\end{minted}
\VALIDATION{Checked the three given examples. Also sanity: a single element is always \texttt{True}; two coprime distinct primes are \texttt{False} unless already in order.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Factor-Aware DSU on Indices}
\WHICHFORMULA{Avoid $O(n^{2})$ gcds by connecting indices through shared prime factors. Factor each value and union all indices that share any prime.}
\ASSUMPTIONS{Trial division up to $\sqrt{A}$ is acceptable for $A \le 10^{5}$; we map each prime factor $p$ to one representative index seen so far and union subsequent indices with that representative.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Copy and sort \texttt{nums} to \texttt{target}. Initialize DSU over indices.
\item For each index $i$, factor $x=\texttt{nums}[i]$ by trial division; for each prime factor $p$, if $p$ has been seen at index $j$, union $i$ with $j$, else record $p \mapsto i$.
\item Group indices by DSU root and compare componentwise multisets of \texttt{nums} vs \texttt{target}. 
\end{algosteps}
\COMPLEXITY{Each value factors in $O(\sqrt{A})$ worst case, yielding $T=\tilde O(n\sqrt{A})$ and $S=O(n + \pi(A))$. This beats $O(n^{2})$ for large $n$.}
\[
\begin{aligned}
T(n) &= O\!\left(n\sqrt{A}\right) + O(n \alpha(n)) \\
\end{aligned}
\]
\CORRECTNESS{If two indices share a prime factor, a direct swap is allowed; chaining these unions captures all edges implied by $\gcd>1$. Thus the DSU components equal the connected components of $G$, and the same multiset criterion applies.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from math import isqrt

class DSUIdx2:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

def factor_trial(x: int) -> List[int]:
    pf = []
    d = 2
    while d * d <= x:
        if x % d == 0:
            pf.append(d)
            while x % d == 0:
                x //= d
        d += 1 if d == 2 else 2  # small skip
    if x > 1:
        pf.append(x)
    return pf

class Solution:
    # Improved: DSU on indices via primes (trial division)
    def gcdSort(self, nums: List[int]) -> bool:
        n = len(nums)
        target = sorted(nums)
        dsu = DSUIdx2(n)
        owner = {}  # prime -> index
        for i, x in enumerate(nums):
            for p in factor_trial(x):
                if p in owner:
                    dsu.union(i, owner[p])
                else:
                    owner[p] = i
        # group indices
        groups = {}
        for i in range(n):
            r = dsu.find(i)
            groups.setdefault(r, []).append(i)
        # compare componentwise
        for idxs in groups.values():
            cur = sorted(nums[i] for i in idxs)
            want = sorted(target[i] for i in idxs)
            if cur != want:
                return False
        return True

# asserts
assert Solution().gcdSort([7,21,3]) is True
assert Solution().gcdSort([5,2,6,2]) is False
assert Solution().gcdSort([10,5,9,3,15]) is True
\end{minted}
\VALIDATION{Covers given examples. Edge checks: \texttt{[2,3]} is \texttt{False} unless already sorted; \texttt{[6,10,15]} is \texttt{True} since all share prime factors transitively.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{SPF Sieve + DSU on Value Domain}
\WHICHFORMULA{Precompute the smallest prime factor (SPF) up to $A=\max(\texttt{nums})$, union each number with its prime factors in a DSU over the value domain $[0..A]$, then check for each position $i$ whether \texttt{nums[i]} and \texttt{sorted[i]} lie in the same DSU component.}
\ASSUMPTIONS{No value equals $1$. DSU of size $A{+}1$ with path compression and union by rank fits limits for $A \le 10^{5}$. SPF allows $O(\log A)$ factorization per number.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{spf}[0..A] by a linear or classic sieve so that \texttt{spf[x]} is the smallest prime dividing $x$.
\item Initialize DSU over $0..A$. For each $x$ in \texttt{nums}, factor $x$ via SPF to get its distinct primes; union $x$ with each of its prime factors.
\item Let \texttt{target} be the sorted copy. For each index $i$, check DSU.find(\texttt{nums[i]}) equals DSU.find(\texttt{target[i]}). If all match, return \texttt{True}, else \texttt{False}.
\end{algosteps}
\OPTIMALITY{Each number is factored in $O(\#\text{prime factors})$ steps using SPF, and each union/find is near-constant amortized. This is tight for the constraints and widely accepted as optimal for this problem.}
\COMPLEXITY{Let $A=\max(\texttt{nums}) \le 10^{5}$.
\[
\begin{aligned}
T(n) &= O(A \log\log A) + O\!\left(\sum_{i=1}^{n} \omega(\texttt{nums}[i])\right) + O(n \alpha(A)) \\
S(n) &= O(A) \text{ for SPF and DSU.}
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class DSUVal:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

def build_spf(limit: int) -> List[int]:
    spf = list(range(limit+1))
    for i in range(2, int(limit**0.5)+1):
        if spf[i] == i:
            step = i
            start = i*i
            for j in range(start, limit+1, step):
                if spf[j] == j:
                    spf[j] = i
    return spf

def distinct_primes(x: int, spf: List[int]) -> List[int]:
    res = []
    last = 0
    while x > 1:
        p = spf[x]
        if p != last:
            res.append(p)
            last = p
        x //= p
    return res

class Solution:
    def gcdSort(self, nums: List[int]) -> bool:
        if not nums:
            return True
        A = max(nums)
        spf = build_spf(A)
        dsu = DSUVal(A+1)
        for x in nums:
            for p in distinct_primes(x, spf):
                dsu.union(x, p)
        target = sorted(nums)
        for a, b in zip(nums, target):
            if dsu.find(a) != dsu.find(b):
                return False
        return True

# exact 3 asserts
assert Solution().gcdSort([7,21,3]) is True
assert Solution().gcdSort([5,2,6,2]) is False
assert Solution().gcdSort([10,5,9,3,15]) is True
\end{minted}
\VALIDATION{The three sample assertions pass. Additional spot checks: \texttt{[2,3]} returns \texttt{False}; \texttt{[6,10,15]} returns \texttt{True}.}
\RESULT{Return \texttt{True} iff each position's original value and its sorted target value are in the same DSU component induced by shared prime factors.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify on samples; generate small arrays and compare the optimal method against the $O(n^{2})$ baseline to ensure equivalence; test duplicates, already-sorted arrays, and arrays of primes.}
\LINE{CROSS-CHECKS}{For small $n \le 8$ and small values $\le 30$, compare the boolean result from Approach A and Approach C over a deterministic set of arrays.}
\LINE{EDGE-CASE GENERATOR}{Create arrays of primes only, arrays of the same composite repeated, and mixed chains that are transitively connected like $[6,10,15]$.}
\begin{minted}{python}
from typing import List
from math import gcd

# Baseline reference (O(n^2))
class DSUIdxRef:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

def baseline_gcd_sort(nums: List[int]) -> bool:
    n = len(nums)
    target = sorted(nums)
    dsu = DSUIdxRef(n)
    for i in range(n):
        for j in range(i+1, n):
            if gcd(nums[i], nums[j]) > 1:
                dsu.union(i, j)
    groups = {}
    for i in range(n):
        r = dsu.find(i)
        groups.setdefault(r, []).append(i)
    for idxs in groups.values():
        cur = sorted(nums[i] for i in idxs)
        want = sorted(target[i] for i in idxs)
        if cur != want:
            return False
    return True

# Final solution under test
class DSUValT:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

def spf_build(limit: int):
    spf = list(range(limit+1))
    i = 2
    while i*i <= limit:
        if spf[i] == i:
            j = i*i
            while j <= limit:
                if spf[j] == j:
                    spf[j] = i
                j += i
        i += 1
    return spf

def dist_primes(x: int, spf: List[int]) -> List[int]:
    res = []
    last = 0
    while x > 1:
        p = spf[x]
        if p != last:
            res.append(p)
            last = p
        x //= p
    return res

def optimal_gcd_sort(nums: List[int]) -> bool:
    if not nums:
        return True
    A = max(nums)
    spf = spf_build(A)
    dsu = DSUValT(A+1)
    for x in nums:
        for p in dist_primes(x, spf):
            dsu.union(x, p)
    target = sorted(nums)
    return all(dsu.find(a) == dsu.find(b) for a, b in zip(nums, target))

# Deterministic tests
def primes_upto(m: int) -> List[int]:
    is_p = [True]*(m+1)
    is_p[:2] = [False, False]
    for i in range(2, int(m**0.5)+1):
        if is_p[i]:
            step = i
            start = i*i
            for j in range(start, m+1, step):
                is_p[j] = False
    return [i for i in range(2, m+1) if is_p[i]]

def run_cross_checks():
    # small systematic arrays
    vals = list(range(2, 13))  # 2..12
    cases = [
        [7,21,3],
        [5,2,6,2],
        [10,5,9,3,15],
        [2,3],
        [6,10,15],
        [4,8,2,16],
        [12, 25, 5, 10, 3, 9],
    ]
    # add prime-only arrays
    ps = primes_upto(29)[:6]
    cases.append(ps[:4])
    cases.append(sorted(ps[:5], reverse=True))
    # add duplicates
    cases.append([6,6,6])
    for arr in cases:
        b = baseline_gcd_sort(arr)
        c = optimal_gcd_sort(arr)
        assert b == c, (arr, b, c)

run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

def build_spf(limit: int):
    spf = list(range(limit+1))
    i = 2
    while i*i <= limit:
        if spf[i] == i:
            j = i*i
            while j <= limit:
                if spf[j] == j:
                    spf[j] = i
                j += i
        i += 1
    return spf

def distinct_primes(x: int, spf: List[int]):
    res = []
    last = 0
    while x > 1:
        p = spf[x]
        if p != last:
            res.append(p)
            last = p
        x //= p
    return res

class Solution:
    def gcdSort(self, nums: List[int]) -> bool:
        if not nums:
            return True
        A = max(nums)
        spf = build_spf(A)
        dsu = DSU(A+1)
        for x in nums:
            for p in distinct_primes(x, spf):
                dsu.union(x, p)
        target = sorted(nums)
        for a, b in zip(nums, target):
            if dsu.find(a) != dsu.find(b):
                return False
        return True

# sanity asserts
assert Solution().gcdSort([7,21,3]) is True
assert Solution().gcdSort([5,2,6,2]) is False
assert Solution().gcdSort([10,5,9,3,15]) is True
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Model swaps as movement within connected components induced by shared prime factors; verify that each index can receive its target value from within its component.}
\WHY{This pattern appears in interview problems where local swap rules translate into global reachability via union find and number theory.}
\CHECKLIST{%
- Make sorted copy of the array.
- Build connectivity: via pairwise gcd (baseline) or via primes (improved/optimal).
- Compare componentwise multisets or directly compare DSU reps of values vs targets.
- Watch out for duplicates and repeated prime factors.
}
\EDGECASES{%
- All entries are primes and pairwise coprime.
- Array already sorted.
- All entries equal.
- Transitive connectivity like $6,10,15$.
- Large value with many small prime factors.
- Multiple duplicates of both primes and composites.
- Minimal length $n=1$.
- Values at extremes $2$ and $10^{5}$.
}
\PITFALLS{%
- Forgetting to deduplicate prime factors before unions.
- Building DSU over indices but comparing values incorrectly across components.
- Off-by-one when sizing DSU over value domain; must allocate up to $\max(\texttt{nums})$ inclusive.
- Inefficient trial division for large $A$ without SPF when $n$ is large.
- Assuming direct gcd adjacency is required; transitivity via chains matters.
- Mishandling duplicates in mapping to target positions.
- Using recursion for DSU find without path compression may time out in worst cases.
}
\FAILMODES{Naive bubble-swap attempts fail because allowed swaps are non-local and must use transitive paths. Pairwise-gcd graph construction times out for large $n$. The SPF + DSU approach avoids both issues by compressing connectivity over the value domain.}
\ELI{If two numbers share a prime factor, you can swap them. By chaining such swaps, any number can move anywhere within its prime-connected group. Sort if and only if each position's current and target numbers belong to the same group.}
\NotePages{3}

\end{document}