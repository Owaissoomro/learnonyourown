% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Display The Number}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1295/A}}
\LINE{DIFFICULTY / RATING}{900}
\STATEMENT{You have a large electronic screen which can display up to $998{,}244{,}353$ decimal digits. The digits are displayed in the same way as on different electronic alarm clocks: each place for a digit consists of $7$ segments which can be turned on and off to compose different digits. The following picture describes how you can display all $10$ decimal digits.

As you can see, different digits may require different number of segments to be turned on. For example, if you want to display $1$, you have to turn on $2$ segments of the screen, and if you want to display $8$, all $7$ segments of some place to display a digit should be turned on.

You want to display a really large integer on the screen. Unfortunately, the screen is bugged: no more than $n$ segments can be turned on simultaneously. So now you wonder what is the greatest integer that can be displayed by turning on no more than $n$ segments.

Your program should be able to process $t$ different test cases.

Input:
The first line contains one integer $t$ ($1 \le t \le 100$) — the number of test cases in the input.

Then the test cases follow, each of them is represented by a separate line containing one integer $n$ ($2 \le n \le 10^5$) — the maximum number of segments that can be turned on in the corresponding testcase.

It is guaranteed that the sum of $n$ over all test cases in the input does not exceed $10^5$.

Output:
For each test case, print the greatest integer that can be displayed by turning on no more than $n$ segments of the screen. Note that the answer may not fit in the standard $32$-bit or $64$-bit integral data type.}
\BREAKDOWN{We must maximize the displayed integer subject to a segment budget. Since more digits make a larger integer when the leading digit is nonzero, we should maximize the number of digits and then make the number lexicographically largest by choosing the best possible leading digit pattern under the budget.}
\ELI{Use as many $1$'s as possible; if $n$ is odd, put a single leading $7$ then fill the rest with $1$'s.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer $t$ for the number of test cases. Then $t$ lines, each with an integer $n$ ($2 \le n \le 10^5$). The sum of all $n$ over test cases is at most $10^5$.}
\OUTPUTS{For each $n$, output the greatest integer (as a decimal string) that can be formed using at most $n$ segments on $7$-segment digits.}
\SAMPLES{Example 1: Input: $t=3$ with $n=2,3,4$. Output lines: 1, 7, 11.

Example 2: Input: $t=4$ with $n=5,6,7,8$. Output lines: 71, 111, 711, 1111.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $c(d)$ be the segment cost of digit $d\in\{0,\ldots,9\}$ on a $7$-segment display. The feasible set is all strings $x=x_1x_2\ldots x_k$ of digits with $\sum_{i=1}^k c(x_i)\le n$ and $x_1\ne 0$. Objective: maximize the integer value of $x$ (equivalently, maximize length $k$, then lexicographic order). Known costs: $c(0)=6$, $c(1)=2$, $c(2)=5$, $c(3)=5$, $c(4)=4$, $c(5)=5$, $c(6)=6$, $c(7)=3$, $c(8)=7$, $c(9)=6$.}
\varmapStart
\var{n}{segment budget}
\var{k}{number of digits in the answer}
\var{x_i}{the $i$-th digit of the answer (most significant first)}
\var{c(d)}{segment cost of digit $d$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{maximize}\quad (k,\ x_1,\ldots,x_k)\ \text{in lexicographic order} \\
&\text{subject to}\quad \sum_{i=1}^k c(x_i)\le n,\quad x_1\in\{1,\ldots,9\},\ x_i\in\{0,\ldots,9\}.
\end{aligned}
\]
}
\ASSUMPTIONS{No leading zeros; segments cannot be shared across digit positions; digits are independent except for the total budget.}
\INVARIANTS{Using more digits (with minimal per-digit cost $2$) dominates any attempt to use fewer digits with larger leading value. If $n$ is even, all digits can be $1$. If $n$ is odd, exactly one digit must have odd cost; the best such digit is $7$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic programming on the segment budget to maximize the tuple (length, lexicographic digits). This is conceptually straightforward and guarantees optimality, albeit overkill for constraints.}
\ASSUMPTIONS{We treat states by total segments used and store the best string in a compact comparator form.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DP over $0\ldots n$ with sentinel for infeasible; $dp[0]$ is empty string.
\item For each budget $s$ and each digit $d$, update $dp[s+c(d)]$ with the better string $dp[s]+d$ by comparing first length, then lexicographic order.
\item Take the best string among budgets $\le n$. For multiple test cases, rebuild or reuse up to the maximum $n$.
\end{algosteps}
\COMPLEXITY{DP is $O(n\cdot 10)$ per test in time and $O(n)$ in space, which is fine for $10^5$ but unnecessary here given a closed-form greedy exists.}
\[
\begin{aligned}
T(n) &= O(10n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{DP explores all concatenations whose total cost does not exceed $n$, and the comparison criterion exactly matches the objective: maximize length, then lexicographic order.}
\EDGECASES{$n=2$ yields ``1''; $n=3$ yields ``7''; odd budgets force exactly one odd-cost digit.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

COST = {0:6, 1:2, 2:5, 3:5, 4:4, 5:5, 6:6, 7:3, 8:7, 9:6}
DIGITS = list(range(10))

def better(a: str, b: str) -> str:
    # Return the better string by (length, then lexicographic) comparison.
    if len(a) != len(b):
        return a if len(a) > len(b) else b
    return a if a > b else b

def dp_best(n: int) -> str:
    # Baseline DP that allows budgets up to n and returns the maximum over s<=n.
    # We avoid building huge arrays for every test by just computing greedily here if needed,
    # but to honor baseline, we provide a trimmed DP that leverages only useful digits.
    useful = [1, 7, 4, 2, 3, 5, 0, 6, 9, 8]  # order roughly by attractiveness
    costs = [COST[d] for d in useful]
    max_s = n
    dp = [""] + [None] * max_s  # dp[s] best string with exact cost s, or None
    for s in range(max_s + 1):
        cur = dp[s]
        if cur is None:
            continue
        for d, cd in zip(useful, costs):
            ns = s + cd
            if ns > max_s:
                continue
            # Skip leading zero
            if cur == "" and d == 0:
                continue
            cand = cur + str(d)
            if dp[ns] is None:
                dp[ns] = cand
            else:
                dp[ns] = better(dp[ns], cand)
    ans = ""
    for s in range(max_s + 1):
        if dp[s] is not None:
            ans = better(ans, dp[s])
    return ans

def greedy_best(n: int) -> str:
    # Optimal greedy used for asserts comparison.
    if n % 2 == 0:
        return "1" * (n // 2)
    else:
        return "7" + ("1" * ((n - 3) // 2))

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return ns

def solve_case(n: int) -> str:
    # Use the baseline DP method; valid but heavier than necessary.
    return dp_best(n)

def solve_all(ns: List[int]) -> List[str]:
    return [solve_case(n) for n in ns]

def main() -> None:
    ns = read_input()
    if not ns:
        # Self-tests
        for n, expected in [(2, "1"), (3, "7"), (4, "11"), (5, "71"), (6, "111"), (7, "711"), (8, "1111")]:
            got = greedy_best(n)
            assert got == expected, (n, got, expected)
            # Baseline DP must match greedy
            assert dp_best(n) == expected, (n, dp_best(n), expected)
        # Random spot checks (small n)
        for n in range(2, 60):
            assert dp_best(n) == greedy_best(n)
        print("OK")
        return
    out = solve_all(ns)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Baseline DP matches the greedy on tiny and moderate $n$; asserts check both specific values and a range $n\in[2,59]$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the structural insight: maximize digit count with the cheapest digit ($1$ uses $2$ segments). If $n$ is odd, use one $7$ (cost $3$) to make the count even, then fill with $1$'s. This yields a closed-form construction in $O(n)$ time to emit the string.}
\ASSUMPTIONS{The lexicographic preference for the most significant position implies placing the single larger digit ($7$) first when needed; remaining digits should all be $1$ to maximize the count.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is even, print $n/2$ copies of digit $1$.
\item If $n$ is odd, print a leading $7$, then $(n-3)/2$ copies of digit $1$.
\item Repeat for all test cases.
\end{algosteps}
\COMPLEXITY{Linear in the output size, which is $\Theta(n)$.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=O(1)\ \text{excluding output buffer}.
\end{aligned}
\]
\CORRECTNESS{Among all digits, $1$ has the smallest cost $2$, hence maximizes count. With odd $n$, exactly one odd-cost digit is required; among odd-cost digits, $7$ is best to maximize the most significant digit (it is the largest odd-cost digit that does not reduce the remaining count beyond necessity).}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    return [int(next(it)) for _ in range(t)]

def best_number(n: int) -> str:
    if n % 2 == 0:
        return "1" * (n // 2)
    else:
        return "7" + ("1" * ((n - 3) // 2))

def solve_all(ns: List[int]) -> List[str]:
    return [best_number(n) for n in ns]

def main() -> None:
    ns = read_input()
    if not ns:
        # Edge and spot checks
        assert best_number(2) == "1"
        assert best_number(3) == "7"
        assert best_number(7) == "711"
        print("OK")
        return
    out = solve_all(ns)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers smallest even/odd and a larger odd; construction aligns with known CF samples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Greedy Construction}
\WHICHFORMULA{Greedy by parity: all $1$'s for even budgets; one leading $7$ then $1$'s for odd budgets.}
\ASSUMPTIONS{Digit costs are fixed and independent; objective is maximize length then lexicographic value.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is even, output a string of length $n/2$ composed entirely of digit $1$.
\item If $n$ is odd, output digit $7$ followed by $(n-3)/2$ copies of digit $1$.
\item Process all test cases independently.
\end{algosteps}
\OPTIMALITY{Lower bound: maximum possible digit count is $\left\lfloor n/2\right\rfloor$. This is achievable by using only $1$'s when $n$ is even, and by using one $7$ plus $1$'s when $n$ is odd, thus matching the bound. Any other choice with higher-cost digits reduces the count or worsens lexicographic order.}
\COMPLEXITY{$\Theta(n)$ to emit the output string; $O(1)$ extra memory.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return ns

def solve_case(n: int) -> str:
    if n % 2 == 0:
        return "1" * (n // 2)
    return "7" + ("1" * ((n - 3) // 2))

def solve_all(ns: List[int]) -> List[str]:
    return [solve_case(n) for n in ns]

def main() -> None:
    ns = read_input()
    if not ns:
        # Exactly 3 asserts
        assert solve_case(2) == "1"
        assert solve_case(5) == "71"
        assert solve_case(8) == "1111"
        print("OK")
        return
    out = solve_all(ns)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts: $n=2\mapsto 1$, $n=5\mapsto 71$, $n=8\mapsto 1111$.}
\RESULT{For each $n$, the output is the lexicographically largest decimal string with length $\left\lfloor n/2\right\rfloor$, using one leading $7$ when $n$ is odd and only $1$'s otherwise.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on minimal even/odd, cross-check DP vs greedy for small $n$, and random spot checks within limits. I/O tests with multiple cases ensure formatting correctness.}
\LINE{CROSS-CHECKS}{Compare baseline DP output with greedy for $n\in[2,200]$; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate all $n$ in a small range and verify parity handling and string length $\lfloor n/2\rfloor$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_small_ns(lo: int = 2, hi: int = 60):
    return list(range(lo, hi + 1))

def oracle(n: int) -> str:
    return ("1" * (n // 2)) if n % 2 == 0 else ("7" + "1" * ((n - 3) // 2))

def run_cross_checks():
    for n in gen_small_ns():
        assert oracle(n) == (("1" * (n // 2)) if n % 2 == 0 else ("7" + "1" * ((n - 3) // 2)))
    print("Cross-checks OK")

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    return [int(next(it)) for _ in range(t)]

def solve_case(n: int) -> str:
    if n % 2 == 0:
        return "1" * (n // 2)
    return "7" + ("1" * ((n - 3) // 2))

def solve_all(ns: List[int]) -> List[str]:
    return [solve_case(n) for n in ns]

def main() -> None:
    ns = read_input()
    if not ns:
        # Self-tests without interfering with CF I/O
        assert solve_case(2) == "1"
        assert solve_case(3) == "7"
        assert solve_case(7) == "711"
        print("OK")
        return
    out = solve_all(ns)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the number of digits using cost-$2$ digit $1$; if $n$ is odd, start with a $7$.}
\WHY{This pattern recurs in greedy DP problems where per-item costs and lexicographic objectives align; recognizing the parity trick is a common interview test.}
\CHECKLIST{%
\begin{bullets}
\item Compute parity of $n$.
\item If even: output $n/2$ ones.
\item If odd: output a single $7$ then $(n-3)/2$ ones.
\item Ensure no leading zeros; print per test on its own line.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=2\Rightarrow$ ``1''.
\item $n=3\Rightarrow$ ``7''.
\item $n=4\Rightarrow$ ``11''.
\item $n=5\Rightarrow$ ``71'' (not ``17'').
\item Large $n$ near $10^5$.
\item Multiple test cases with varying parity.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Printing an extra newline or missing newline per test case.
\item Using any digit other than $1$ and possibly a single leading $7$ reduces optimality.
\item Attempting to place $7$ not at the front hurts lexicographic order.
\item Building strings inefficiently inside tight loops without joining (minor in Python but be aware).
\item Misreading ``at most $n$'' as ``exactly $n$''; the construction uses exactly $n$ segments anyway.
\item Confusing costs of digits (ensure $c(1)=2$, $c(7)=3$).
\end{bullets}
}
\FAILMODES{Weaker approaches like naive greedy that place the largest possible digit first (e.g., many $9$'s) fail because they reduce digit count, which dominates value. The proposed method always reaches the maximum digit count and the best lexicographic arrangement.}
\ELI{Make the number as long as possible using the cheapest digit. If you have one extra segment left over (odd $n$), convert one pair of segments into a $7$ at the front.}
\NotePages{3}

\end{document}