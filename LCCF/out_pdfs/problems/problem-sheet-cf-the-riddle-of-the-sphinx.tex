% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Riddle of the Sphinx}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1466/I}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{This is an interactive problem. This problem does not support hacks.

Sphinx's duty is to guard the city of Thebes by making sure that no unworthy traveler crosses its gates. Only the ones who answer her riddle timely and correctly (or get an acc for short) are allowed to pass. As of those who fail, no one heard of them ever again\ldots

So you do not have a choice but to solve the riddle. Sphinx has an array $a_1, a_2, \ldots, a_n$ of nonnegative integers strictly smaller than $2^b$ and asked you to find the maximum value among its elements. Of course, she will not show you the array, but she will give you $n$ and $b$. As it is impossible to answer this riddle blindly, you can ask her some questions. For given $i, y$, she will answer you whether $a_i$ is bigger than $y$. As sphinxes are not very patient, you can ask at most $3\cdot(n+b)$ such questions.

Although cunning, sphinxes are honest. Even though the array can change between your queries, answers to the previously asked questions will remain valid.

Input:
The first line contains two integers $n$ and $b$ ($1 \le n, b \le 200$). The remaining parts of the input will be given throughout the interaction process.

Note:
In all examples, the sequence is fixed beforehand.

In the first example, the sequence is $2, 1, 4, 0, 6$.

In the second example, the sequence is $0, 0, 0, 0$.

In the third example, the sequence is $0$.

Note that if the interactor was adaptive, then the interaction in the first and the third example would not be sufficient to return the correct value of maximum.}
\BREAKDOWN{We must find $\max_i a_i$ using only queries of the form ``is $a_i > y$?'', with at most $3\cdot(n+b)$ queries, even if the array can change adversarially subject to past answers staying consistent.}
\ELI{Search increasing thresholds and keep a current ``witness'' index that beats them; because thresholds only rise, each index can say ``no'' at most once, yielding a total of $O(n+b)$ queries.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For this sheet we provide an offline simulator for testing:
\begin{bullets}
\item Integers $n, b$ on one line ($1 \le n, b \le 200$).
\item Then $n$ integers $a_1,\ldots,a_n$ with $0 \le a_i < 2^b$ (in any whitespace-separated layout).
\end{bullets}
In the real CF interactive problem, $a$ is hidden and you must interact via queries.}
\OUTPUTS{One integer: the maximum value $\max_i a_i$. Our offline harness also counts queries internally to verify the $3\cdot(n+b)$ budget, but only the maximum is printed.}
\SAMPLES{Examples for the offline simulator:
\begin{bullets}
\item Input: ``5 3'' and then ``2 1 4 0 6''. Output: ``6''.
\item Input: ``4 1'' and then ``0 0 0 0''. Output: ``0''.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Unknown vector $a\in\{0,\ldots,2^b-1\}^n$. Oracle answers predicates $Q(i,y)=\mathbf{1}[a_i>y]$. We must determine $\max_i a_i$ using at most $3\cdot(n+b)$ oracle calls. The oracle can change $a$ between queries but must keep per-index answers consistent over time.}
\varmapStart
\var{n}{array length}
\var{b}{bit limit; $a_i \in [0,2^b-1]$}
\var{a_i}{hidden nonnegative integers}
\var{Q(i,y)}{query: is $a_i>y$?}
\var{M}{true maximum $\max_i a_i$}
\var{y}{threshold to test}
\var{c}{current witness index with $a_c>y$}
\var{p}{scan pointer over indices}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Oracle monotonicity (per fixed $i$): }\quad y_1 \le y_2 \implies Q(i,y_2)=1 \Rightarrow Q(i,y_1)=1,\\
&\text{Goal: find } M \text{ with } M=\min\{y\in \mathbb{Z}_{\ge 0}:\ \neg\exists i,\ Q(i,y)\} \text{ and } \exists i,\ Q(i,M-1).
\end{aligned}
\]
}
\ASSUMPTIONS{We treat $y$ as any integer $\ge -1$. Answers are per-index consistent with some value $a_i$ at all times.}
\INVARIANTS{
\begin{bullets}
\item Thresholds $y$ we test are non-decreasing in the final method; once $Q(i,y)=0$, then $Q(i,y')=0$ for all $y'\ge y$.
\item The current witness $c$ always satisfies $Q(c,y)=1$ for the current threshold $y$, or we replace it by scanning.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{When $a$ is known (offline simulator), compute $\max_i a_i$ directly.}
\ASSUMPTIONS{Array is fully visible; no interaction.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n, b$ and the $n$ values.
\item Return the maximum of the $n$ values.
\end{algosteps}
\COMPLEXITY{Linear scan:
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(1).
\end{aligned}
\]
}
\CORRECTNESS{A single pass keeps the running maximum, which equals $\max_i a_i$ at the end.}
\EDGECASES{All zeros; single element; strictly increasing or decreasing arrays.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, int, List[int]]:
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n, b = it[0], it[1]
    arr = it[2:2 + n]
    return n, b, arr

def solve_case_offline_max(n: int, b: int, arr: List[int]) -> int:
    assert len(arr) == n
    # Direct baseline: just take max
    return max(arr) if arr else 0

def main() -> None:
    data = sys.stdin.read()
    if not data.strip():
        return
    n, b, arr = read_input(data)
    ans = solve_case_offline_max(n, b, arr)
    print(ans)

# Tiny asserts for baseline correctness
def _tests() -> None:
    assert solve_case_offline_max(5, 3, [2, 1, 4, 0, 6]) == 6
    assert solve_case_offline_max(4, 1, [0, 0, 0, 0]) == 0
    assert solve_case_offline_max(1, 1, [0]) == 0

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\VALIDATION{Checked on three tiny arrays (mixed, all zeros, single element).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-index binary search (interactive simulation)}
\WHICHFORMULA{For each index $i$, binary search $a_i$ using $Q(i,y)$ in $O(b)$ queries, then take max.}
\ASSUMPTIONS{Oracle available; per-index consistency holds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i=1..n$, binary search $a_i$ in $[0,2^b-1]$ using $Q(i,y)$.
\item Track and output the maximum found.
\end{algosteps}
\COMPLEXITY{Per index costs $O(b)$ queries; total $O(n b)$ queries and $O(1)$ extra space. This violates the $3\cdot(n+b)$ cap in the worst case.}
\[
\begin{aligned}
T_{\text{queries}}(n,b) &= n\cdot \lceil \log_2(2^b)\rceil = n\cdot b.
\end{aligned}
\]
\CORRECTNESS{Per-index binary search recovers exact $a_i$ due to monotonicity of $Q(i,y)$. Taking the maximum gives the correct answer.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class Interactor:
    def __init__(self, arr: List[int], b: int) -> None:
        self.arr = arr[:]  # fixed offline
        self.n = len(arr)
        self.b = b
        self.queries = 0
        self.limit = 3 * (self.n + self.b)

    def ask(self, i: int, y: int) -> bool:
        # i is 0-based
        self.queries += 1
        assert self.queries <= self.limit, "Query limit exceeded"
        return self.arr[i] > y

def read_input(data: str) -> Tuple[int, int, List[int]]:
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n, b = it[0], it[1]
    arr = it[2:2+n]
    return n, b, arr

def per_index_binary_search(inter: Interactor) -> int:
    n, b = inter.n, inter.b
    best = 0
    for i in range(n):
        lo, hi = -1, (1 << b) - 1
        # find largest y with a_i > y; answer will be y+1
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if inter.ask(i, mid):
                lo = mid
            else:
                hi = mid - 1
        val = lo + 1
        if val > best:
            best = val
    return best

def main() -> None:
    data = sys.stdin.read()
    if not data.strip():
        return
    n, b, arr = read_input(data)
    inter = Interactor(arr, b)
    ans = per_index_binary_search(inter)
    print(ans)

def _tests() -> None:
    inter = Interactor([2, 1, 4, 0, 6], 3)
    assert per_index_binary_search(inter) == 6
    inter = Interactor([0, 0, 0, 0], 1)
    assert per_index_binary_search(inter) == 0
    inter = Interactor([0], 1)
    assert per_index_binary_search(inter) == 0

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\VALIDATION{Works functionally but may exceed the interactive query budget when $n b > 3\cdot(n+b)$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Monotone threshold search with a witness index}
\WHICHFORMULA{Maintain a current witness index $c$ beating the current threshold $y$, and increase $y$ via binary lifting. For each tested threshold $y$ (monotone non-decreasing), first try $Q(c,y)$; if it fails, scan forward to find a new witness. Each index returns ``no'' at most once overall, so total queries are $O(n+b)$.}
\ASSUMPTIONS{Per-index consistency; $Q(i,y)$ can be asked with non-decreasing thresholds overall; offline simulator uses a fixed array.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $y=-1$, choose any $c$ with $Q(c,-1)=\text{true}$ (always true for nonnegative $a_c$). Set scan pointer $p=0$ (0-based indices). Mark all indices as ``alive''.
\item Define a helper exists$(y)$:
\begin{bullets}
\item If $c\neq -1$ and $Q(c,y)=\text{true}$, return true.
\item Else, advance $p$ while $p<n$ and $Q(p,y)=\text{false}$; mark each such index dead permanently.
\item If some $p<n$ satisfies $Q(p,y)=\text{true}$, set $c=p$ and return true; otherwise return false.
\end{bullets}
\item Binary-lift the largest $y$ with exists$(y)=\text{true}$ starting from $y=-1$ by trying $y':=y+2^k$ for $k=b-1,\ldots,0$ in decreasing order. If exists$(y')$ is true, set $y:=y'$.
\item Output $y+1$ as the maximum.
\end{algosteps}
\OPTIMALITY{Each threshold trial is monotone non-decreasing in $y$. Every time an index answers ``no'' to some $y$, it will answer ``no'' to all future (larger) thresholds and is never queried again. Across the $b$ threshold upgrades, at most $n$ distinct indices can die once, plus at most one query per threshold to the current witness. Hence total queries $\le n + b + 1 \le 3\cdot(n+b)$ for all $n,b\ge 1$.}
\COMPLEXITY{Time is linear in the number of oracle queries:
\[
\begin{aligned}
T_{\text{queries}} &\le n + b + O(1),\\
\text{Extra space} &= O(1) \text{ besides the array and a few pointers.}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class Interactor:
    def __init__(self, arr: List[int], b: int) -> None:
        self.arr = arr[:]  # fixed offline simulator
        self.n = len(arr)
        self.b = b
        self.queries = 0
        self.limit = 3 * (self.n + self.b)

    def ask(self, i: int, y: int) -> bool:
        # i is 0-based; allow y >= -1
        self.queries += 1
        assert self.queries <= self.limit, f"Query limit exceeded: {self.queries} > {self.limit}"
        return self.arr[i] > y

def read_input(data: str) -> Tuple[int, int, List[int]]:
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n, b = it[0], it[1]
    arr = it[2:2+n]
    return n, b, arr

def find_max_with_witness(arr: List[int], b: int) -> int:
    """
    Offline wrapper that constructs an Interactor and runs the optimal algorithm.
    """
    inter = Interactor(arr, b)
    n = inter.n
    if n == 0:
        return 0

    # Current witness index c (0-based), scan pointer p, and current y
    c = 0
    # One trivial query to certify nonnegativity; in the real interactor this is allowed and always true
    assert inter.ask(c, -1) is True
    p = 0
    dead = [False] * n  # tracked implicitly via p and 'no' answers; kept for clarity

    def exists(y: int) -> bool:
        nonlocal c, p
        # Try current witness
        if c != -1 and inter.ask(c, y):
            return True
        # Otherwise scan forward to find a new witness
        while p < n:
            if dead[p]:
                p += 1
                continue
            if inter.ask(p, y):
                c = p
                p += 1  # next scans start after this index
                return True
            else:
                dead[p] = True
                p += 1
        # No one beats this threshold
        return False

    y = -1
    # Binary lifting over thresholds y (monotone increasing)
    for k in range(b - 1, -1, -1):
        trial = y + (1 << k)
        if trial >= (1 << b):
            continue
        if exists(trial):
            y = trial

    # The maximum value is y + 1
    result = y + 1
    # Sanity: result must equal max(arr)
    assert result == max(arr), f"Offline mismatch: got {result}, expected {max(arr)}"
    # Sanity: query budget respected
    assert inter.queries <= inter.limit
    return result

def solve_all(data: str) -> str:
    n, b, arr = read_input(data)
    if n == 0:
        return ""
    return str(find_max_with_witness(arr, b))

def main() -> None:
    data = sys.stdin.read()
    if not data.strip():
        return
    out = solve_all(data)
    if out:
        print(out)

# Exactly 3 asserts (mini-tests)
def _tests() -> None:
    assert find_max_with_witness([2, 1, 4, 0, 6], 3) == 6
    assert find_max_with_witness([0, 0, 0, 0], 1) == 0
    assert find_max_with_witness([0], 1) == 0

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts on representative tiny arrays.}
\RESULT{Outputs the exact maximum value; ties are irrelevant since only the value is requested.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate on random arrays under the offline simulator; check correctness vs. direct max and verify query budget never exceeds $3\cdot(n+b)$.}
\LINE{CROSS-CHECKS}{Compare Baseline (direct max) vs. Optimal (witness-based) on many random arrays; they must agree.}
\LINE{EDGE-CASE GENERATOR}{Generate cases: $n=1$, all zeros, strictly increasing, strictly decreasing, many equal near $2^b-1$, and random seeds.}
\begin{minted}{python}
import random
from typing import List

def gen_cases() -> List[List[int]]:
    cases = []
    cases.append([0])
    cases.append([0, 0, 0, 0])
    cases.append([2, 1, 4, 0, 6])
    cases.append([7, 7, 7, 7, 7])
    cases.append(list(range(16)))
    cases.append(list(range(15, -1, -1)))
    random.seed(0)
    for _ in range(5):
        n = random.randint(1, 50)
        b = random.randint(1, 8)
        arr = [random.randint(0, (1 << b) - 1) for _ in range(n)]
        cases.append(arr)
    return cases

def reference_max(arr: List[int]) -> int:
    return max(arr) if arr else 0

def harness() -> None:
    from math import ceil
    # Import the solver from the final implementation block (assumed in same file when used)
    def run(arr: List[int]) -> int:
        # Pick a minimal b that can hold max(arr)
        maxv = reference_max(arr)
        b = max(1, maxv.bit_length())
        return find_max_with_witness(arr, b)
    for arr in gen_cases():
        got = run(arr)
        exp = reference_max(arr)
        assert got == exp, (arr, got, exp)

if __name__ == "__main__":
    harness()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class Interactor:
    def __init__(self, arr: List[int], b: int) -> None:
        self.arr = arr[:]
        self.n = len(arr)
        self.b = b
        self.queries = 0
        self.limit = 3 * (self.n + self.b)

    def ask(self, i: int, y: int) -> bool:
        self.queries += 1
        assert self.queries <= self.limit, f"Query limit exceeded: {self.queries} > {self.limit}"
        return self.arr[i] > y

def read_input(data: str) -> Tuple[int, int, List[int]]:
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n, b = it[0], it[1]
    arr = it[2:2+n]
    return n, b, arr

def find_max_with_witness(arr: List[int], b: int) -> int:
    inter = Interactor(arr, b)
    n = inter.n
    if n == 0:
        return 0
    c = 0
    assert inter.ask(c, -1)
    p = 0
    dead = [False] * n

    def exists(y: int) -> bool:
        nonlocal c, p
        if c != -1 and inter.ask(c, y):
            return True
        while p < n:
            if dead[p]:
                p += 1
                continue
            if inter.ask(p, y):
                c = p
                p += 1
                return True
            else:
                dead[p] = True
                p += 1
        return False

    y = -1
    for k in range(b - 1, -1, -1):
        trial = y + (1 << k)
        if trial >= (1 << b):
            continue
        if exists(trial):
            y = trial
    res = y + 1
    assert res == max(arr)
    assert inter.queries <= inter.limit
    return res

def solve_all(data: str) -> str:
    n, b, arr = read_input(data)
    if n == 0:
        return ""
    return str(find_max_with_witness(arr, b))

def main() -> None:
    data = sys.stdin.read()
    if not data.strip():
        return
    out = solve_all(data)
    if out:
        print(out)

def _tests() -> None:
    assert find_max_with_witness([2, 1, 4, 0, 6], 3) == 6
    assert find_max_with_witness([0, 0, 0, 0], 1) == 0
    assert find_max_with_witness([0], 1) == 0

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain a witness index while testing an increasing sequence of thresholds; each ``no'' kills an index forever, yielding $O(n+b)$ total queries.}
\WHY{Interactive threshold problems appear in high-rated interviews and contests; mastering witness/monotone strategies is essential.}
\CHECKLIST{
\begin{bullets}
\item Keep thresholds $y$ non-decreasing.
\item Always try the current witness first.
\item On failure, scan forward and permanently discard ``no'' indices.
\item Use binary lifting over $y$ to cap threshold trials at $b$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All zeros.
\item All equal nonzero values.
\item Maximum equals $2^b-1$.
\item Multiple indices share the maximum.
\item $b=1$ with tiny ranges.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Re-asking dead indices at higher thresholds (wastes queries).
\item Non-monotone threshold sequence causing repeated probes.
\item Forgetting to update the witness when it fails.
\item Off-by-one: the returned value is $y+1$ where $y$ is largest threshold with a ``yes''.
\item Allowing query budget to be exceeded in tests.
\item Mishandling pointer progression when a new witness is found.
\end{bullets}}
\FAILMODES{Naive per-index binary search uses $n b$ queries and can exceed the $3\cdot(n+b)$ limit. The witness method survives adversarial adaptations thanks to per-index monotonicity and one-time deaths.}
\ELI{Keep asking, ``Is there an element bigger than this bar?'' Starting from a very low bar and raising it cleverly, each element can only fail once. A single champion that keeps clearing the bar tells you how high the true maximum is.}
\NotePages{3}

\end{document}