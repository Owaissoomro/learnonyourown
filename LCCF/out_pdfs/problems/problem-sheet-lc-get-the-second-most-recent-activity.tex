% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Get the Second Most Recent Activity}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/get-the-second-most-recent-activity/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a relational table \texttt{Activities} recording user actions. We model it for clarity with the following schema: 
\begin{BreakableEquation*}
\text{\texttt{Activities}(user\_id INT, activity\_date DATE, activity\_type VARCHAR)}
\end{BreakableEquation*}
Each row denotes that user \texttt{user\_id} performed some \texttt{activity\_type} on the calendar day \texttt{activity\_date}. A user may perform multiple activities on the same day, and there may be multiple rows per day.

Write a query that, for every user present in \texttt{Activities}, returns the second most recent \emph{distinct} \texttt{activity\_date}. If a user has fewer than two distinct activity dates, report \texttt{NULL} for that user. The result should have the following columns:
\begin{BreakableEquation*}
(\texttt{user\_id},~\texttt{second\_activity\_date})
\end{BreakableEquation*}
Return one row per user and order the output by \texttt{user\_id} in ascending order.}
\BREAKDOWN{Group rows by user, consider distinct dates per user, identify the second largest date if it exists, else return \texttt{NULL}. This is a classic per-partition top-$k$ (here $k=2$) selection over distinct keys.}
\ELI{Per user, keep their top two unique dates by recency and output the second one, or \texttt{NULL} if it does not exist.}
\NotePages{3}

\section{IO Contract}
\INPUTS{For code simulation, we represent the table as a Python list of tuples: \texttt{List[Tuple[int, str, str]]} where each tuple is \texttt{(user\_id, activity\_date, activity\_type)} and \texttt{activity\_date} is an ISO string \texttt{"YYYY-MM-DD"}. Valid constraints: 
\begin{bullets}
\item \texttt{1 \le user\_id \le 10^9}
\item \texttt{activity\_date} is a valid date in range \texttt{"1900-01-01"} to \texttt{"2100-12-31"}.
\item Number of rows $n$: \texttt{0 \le n \le 2 \times 10^5}.
\end{bullets}}
\OUTPUTS{A list of \texttt{(user\_id, second\_activity\_date)} pairs sorted by \texttt{user\_id} ascending. \texttt{second\_activity\_date} is either an ISO date string or \texttt{None} if the user has fewer than two distinct dates.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input rows:
\[
\begin{aligned}
&(1,~\text{"2023-12-05"},~\text{"login"})\\
&(1,~\text{"2023-12-08"},~\text{"upload"})\\
&(1,~\text{"2023-12-05"},~\text{"logout"})\\
&(2,~\text{"2023-11-01"},~\text{"login"})
\end{aligned}
\]
\item Output: \texttt{[(1, "2023-12-05"), (2, None)]}
\end{itemize}
Example 2:
\begin{itemize}
\item Input rows:
\[
\begin{aligned}
&(3,~\text{"2023-10-09"},~\text{"login"})\\
&(3,~\text{"2023-10-10"},~\text{"logout"})\\
&(3,~\text{"2023-10-10"},~\text{"share"})
\end{aligned}
\]
\item Output: \texttt{[(3, "2023-10-09")]}
\end{itemize}}
\NotePages{3}

\section{Canonical Mathematical Model}
\MODEL{Let $U$ be the set of users appearing in the table. For each $u \in U$, let $D(u)$ be the set of distinct dates on which $u$ appeared. Define $\operatorname{second}(D(u))$ as the second largest element of $D(u)$ in chronological order if $|D(u)| \ge 2$, else $\operatorname{second}(D(u)) = \text{NULL}$. The output is the function $f(u) = \operatorname{second}(D(u))$.}
\varmapStart
\var{U}{set of user identifiers present in \texttt{Activities}}
\var{D(u)}{distinct activity dates for user $u$}
\var{f(u)}{second most recent date for $u$ or \text{NULL}}
\varmapEnd
\GOVERN{
\[
\forall u \in U:\quad
f(u) = 
\begin{cases}
\text{the 2nd element of } \operatorname{sorted}(D(u)) \text{ in descending order}, & \text{if } |D(u)| \ge 2,\\
\text{NULL}, & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Dates compare lexicographically equal to chronological order since they are ISO \texttt{YYYY-MM-DD}.
\item Each user with at least one row appears exactly once in the output.
\item Multiple rows on the same date for a user do not create multiple distinct dates.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item For each user $u$, $|D(u)| \ge 0$ and $D(u)$ contains no duplicates.
\item If $|D(u)| \ge 2$, then $\max D(u) \ne f(u)$ and $f(u)$ is well-defined.
\end{bullets}}
\NotePages{3}

\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Build $D(u)$ explicitly via grouping, sort each $D(u)$ in descending order, and read the second element if present.}
\ASSUMPTIONS{Sufficient memory to store all dates per user; sorting cost is acceptable for small to medium $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group rows by \texttt{user\_id}, collecting a Python set of distinct \texttt{activity\_date} per user.
\item For each user, sort the set in descending order.
\item Output the second element if it exists; otherwise output \texttt{None}.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of rows and $m$ be the number of distinct users. Building sets is $O(n)$ insertions; sorting per user costs $\sum_{u} O(d_u \log d_u)$ where $d_u = |D(u)|$. In the worst case, $O(n \log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &\le O(n) + \sum_{u \in U} O(d_u \log d_u) = O(n \log n) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{By construction, the set per user removes duplicates. Sorting in descending order makes the element at index 1 the second most recent. If there is no such element, returning \texttt{None} matches the specification.}
\EDGECASES{
\begin{bullets}
\item User with $0$ rows is absent; with $1$ distinct date returns \texttt{None}.
\item Duplicate rows on the same date do not affect the set.
\item All rows belong to a single user.
\item Very large range of dates; string comparison still valid due to ISO format.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Tuple, Optional

class Solution:
    def second_most_recent_activity(self, records: List[Tuple[int, str, str]]
                                   ) -> List[Tuple[int, Optional[str]]]:
        # Group by user -> distinct dates
        dates = defaultdict(set)
        for uid, adate, *_ in records:
            dates[uid].add(adate)
        # Build results
        ans = []
        for uid in dates:
            sorted_desc = sorted(dates[uid], reverse=True)
            second = sorted_desc[1] if len(sorted_desc) >= 2 else None
            ans.append((uid, second))
        ans.sort(key=lambda x: x[0])
        return ans

# Basic asserts (baseline)
if __name__ == "__main__":
    sol = Solution()
    recs = [
        (1, "2023-12-05", "login"),
        (1, "2023-12-08", "upload"),
        (1, "2023-12-05", "logout"),
        (2, "2023-11-01", "login"),
    ]
    assert sol.second_most_recent_activity(recs) == [(1, "2023-12-05"), (2, None)]

    recs2 = [
        (3, "2023-10-09", "login"),
        (3, "2023-10-10", "logout"),
        (3, "2023-10-10", "share"),
    ]
    assert sol.second_most_recent_activity(recs2) == [(3, "2023-10-09")]
\end{minted}
\VALIDATION{Sanity checks:
\begin{bullets}
\item Duplicate-date rows do not change the set cardinality.
\item Users appear exactly once in the output and are sorted by \texttt{user\_id}.
\end{bullets}}
\NotePages{3}

\section{Approach B — Improved}
\ApproachPage{B}{Maintain Top-2 Distinct Dates Without Sorting}
\WHICHFORMULA{Track only the top two distinct dates per user while scanning, avoiding full materialization and sorting.}
\ASSUMPTIONS{Dates compare lexicographically. We only need top-2, so we can maintain two variables per user.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a map \texttt{best[uid]} $\to$ pair \texttt{(max1, max2)} both \texttt{None}.
\item For each row, let \texttt{d} be \texttt{activity\_date}. Update the pair as:
\begin{bullets}
\item If \texttt{max1 is None} or \texttt{d > max1}: if \texttt{d != max1}, set \texttt{max2 = max1}, \texttt{max1 = d}.
\item Else if \texttt{d < max1} and (\texttt{max2 is None} or \texttt{d > max2}) and \texttt{d != max2}: set \texttt{max2 = d}.
\item Otherwise, do nothing (duplicate or not in top-2).
\end{bullets}
\item At the end, emit \texttt{(uid, max2)} for each user, sorted by \texttt{uid}.
\end{algosteps}
\COMPLEXITY{One pass with $O(1)$ amortized work per row and $O(1)$ state per user. This avoids the $\log$ factor from sorting.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(m) \quad \text{where } m = |U|
\end{aligned}
\]
\CORRECTNESS{The invariant is that \texttt{max1} and \texttt{max2} always store the largest and second-largest distinct dates seen so far for the user. Equality checks prevent counting duplicates as distinct. By the end of the scan, they are the desired values.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Optional, Dict

class Solution:
    def second_most_recent_activity(self, records: List[Tuple[int, str, str]]
                                   ) -> List[Tuple[int, Optional[str]]]:
        best: Dict[int, Tuple[Optional[str], Optional[str]]] = {}
        for uid, d, *_ in records:
            if uid not in best:
                best[uid] = (None, None)
            a, b = best[uid]  # a = max1 (most recent), b = max2
            if a is None or d > a:
                if d != a:
                    a, b = d, a
            elif d < a:
                if b is None or d > b:
                    if d != b:
                        b = d
            best[uid] = (a, b)
        ans = [(uid, best[uid][1]) for uid in best]
        ans.sort(key=lambda x: x[0])
        return ans

# Asserts (improved)
if __name__ == "__main__":
    sol = Solution()
    recs = [
        (1, "2023-12-05", "login"),
        (1, "2023-12-08", "upload"),
        (1, "2023-12-05", "logout"),
        (2, "2023-11-01", "login"),
    ]
    assert sol.second_most_recent_activity(recs) == [(1, "2023-12-05"), (2, None)]

    recs2 = [
        (3, "2023-10-09", "login"),
        (3, "2023-10-10", "logout"),
        (3, "2023-10-10", "share"),
    ]
    assert sol.second_most_recent_activity(recs2) == [(3, "2023-10-09")]
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item Repeated same-day rows never promote \texttt{max2}.
\item A late-arriving new maximum shifts the previous maximum to \texttt{max2}.
\end{bullets}}
\NotePages{3}

\section{Approach C — Optimal}
\ApproachPage{C}{Window Function Analogue / One-Pass Top-2 Distinct}
\WHICHFORMULA{In SQL, use \texttt{DENSE\_RANK() OVER (PARTITION BY user\_id ORDER BY activity\_date DESC)} and pick rank $=2$, then left-join to users to fill \texttt{NULL}. In Python, emulate this optimally with a one-pass top-2 tracker per user as in Approach B.}
\ASSUMPTIONS{Dates are ISO strings; duplicates must not be double-counted.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain per-user top-2 distinct dates \texttt{(a, b)} as most-recent and second-most-recent.
\item On each record with date \texttt{d}, update the pair with constant-time comparisons, ignoring duplicates.
\item Emit \texttt{(user\_id, b)} sorted by \texttt{user\_id}.
\end{algosteps}
\OPTIMALITY{Any comparison-based approach needs to inspect each input row at least once, so $O(n)$ time is optimal. The space of $O(m)$ is necessary to store per-user results.}
\COMPLEXITY{Same as Approach B, tight.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(m)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Optional, Dict

class Solution:
    def second_most_recent_activity(self, records: List[Tuple[int, str, str]]
                                   ) -> List[Tuple[int, Optional[str]]]:
        best: Dict[int, Tuple[Optional[str], Optional[str]]] = {}
        for uid, d, *_ in records:
            # Initialize per-user
            a, b = best.get(uid, (None, None))
            # Update only on distinct values; ignore duplicates
            if a is None or d > a:
                if d != a:
                    a, b = d, a
            elif d < a:
                if b is None or d > b:
                    if d != b:
                        b = d
            best[uid] = (a, b)
        # Build sorted answer
        ans = [(uid, b) for uid, (a, b) in best.items()]
        ans.sort(key=lambda x: x[0])
        return ans

# Exactly 3 asserts
if __name__ == "__main__":
    sol = Solution()
    # 1) Mixed duplicates and two users
    recs1 = [
        (1, "2023-12-05", "login"),
        (1, "2023-12-08", "upload"),
        (1, "2023-12-05", "logout"),
        (2, "2023-11-01", "login"),
    ]
    assert sol.second_most_recent_activity(recs1) == [(1, "2023-12-05"), (2, None)]
    # 2) Exactly two distinct dates with repeats
    recs2 = [
        (3, "2023-10-09", "login"),
        (3, "2023-10-10", "logout"),
        (3, "2023-10-10", "share"),
    ]
    assert sol.second_most_recent_activity(recs2) == [(3, "2023-10-09")]
    # 3) New maximum arrives later, previous maximum becomes second
    recs3 = [
        (4, "2023-01-01", "a"),
        (4, "2023-01-03", "b"),
        (4, "2023-01-02", "c"),
        (4, "2023-01-05", "d"),
    ]
    assert sol.second_most_recent_activity(recs3) == [(4, "2023-01-03")]
\end{minted}
\VALIDATION{The three asserts cover: duplicate-date suppression, exact two distinct dates, and promotion of a new maximum shifting the previous maximum to second.}
\RESULT{For each user, return the second most recent distinct date or \texttt{NULL}/\texttt{None} if no such date exists; one row per user, ordered by \texttt{user\_id}.}
\NotePages{3}

\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover:
\begin{bullets}
\item Users with 0, 1, 2, and $>2$ distinct dates.
\item Heavy duplicates on the same date.
\item Late-arriving maxima that reorder top-2.
\item Multiple users interleaved.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare outputs from Baseline (sort-then-pick) vs. Optimal (one-pass top-2) on randomized inputs for consistency.}
\LINE{EDGE-CASE GENERATOR}{Produce adversarial sequences like non-monotonic dates, repeated spikes of the current maximum, and many duplicates.}
\begin{minted}{python}
import random
from typing import List, Tuple

def gen_cases(seed: int = 0) -> List[Tuple[int, str, str]]:
    random.seed(seed)
    users = [1, 2, 3]
    dates = ["2023-01-%02d" % d for d in range(1, 10)]
    acts = ["a", "b", "c"]
    recs = []
    for _ in range(100):
        u = random.choice(users)
        d = random.choice(dates)
        t = random.choice(acts)
        recs.append((u, d, t))
    return recs

# Cross-check baseline vs. final on the same random set
from collections import defaultdict

class Baseline:
    def second_most_recent_activity(self, records):
        groups = defaultdict(set)
        for uid, d, *_ in records:
            groups[uid].add(d)
        ans = []
        for uid in groups:
            ds = sorted(groups[uid], reverse=True)
            ans.append((uid, ds[1] if len(ds) >= 2 else None))
        return sorted(ans)

class Final:
    def second_most_recent_activity(self, records):
        best = {}
        for uid, d, *_ in records:
            a, b = best.get(uid, (None, None))
            if a is None or d > a:
                if d != a:
                    a, b = d, a
            elif d < a:
                if b is None or d > b:
                    if d != b:
                        b = d
            best[uid] = (a, b)
        return sorted((uid, b) for uid, (a, b) in best.items())

if __name__ == "__main__":
    recs = gen_cases(7)
    assert Baseline().second_most_recent_activity(recs) == Final().second_most_recent_activity(recs)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple, Optional, Dict

class Solution:
    def second_most_recent_activity(self, records: List[Tuple[int, str, str]]
                                   ) -> List[Tuple[int, Optional[str]]]:
        best: Dict[int, Tuple[Optional[str], Optional[str]]] = {}
        for uid, d, *_ in records:
            a, b = best.get(uid, (None, None))
            if a is None or d > a:
                if d != a:
                    a, b = d, a
            elif d < a:
                if b is None or d > b:
                    if d != b:
                        b = d
            best[uid] = (a, b)
        ans = [(uid, b) for uid, (a, b) in best.items()]
        ans.sort(key=lambda x: x[0])
        return ans

if __name__ == "__main__":
    sol = Solution()
    # Smoke tests
    assert sol.second_most_recent_activity([]) == []
    assert sol.second_most_recent_activity([(1, "2023-01-01", "x")]) == [(1, None)]
    rows = [
        (1, "2023-01-01", "x"),
        (1, "2023-01-03", "y"),
        (1, "2023-01-02", "z"),
        (2, "2023-02-01", "x"),
        (2, "2023-02-01", "y"),
    ]
    assert sol.second_most_recent_activity(rows) == [(1, "2023-01-02"), (2, None)]
\end{minted}
\NotePages{3}

\section{Review \& Pitfalls}
\WHAT{Per user, return the second most recent distinct activity date or \texttt{NULL} if it does not exist.}
\WHY{Tests partitioned ranking logic and distinctness handling, common in analytics SQL and data engineering interviews.}
\CHECKLIST{
\begin{bullets}
\item Partition by user.
\item Deduplicate dates per partition.
\item Rank by date descending.
\item Select rank $=2$ or return \texttt{NULL} if missing.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Only one distinct date for a user.
\item Many duplicate rows for a single date.
\item Dates not in chronological input order.
\item Users with exactly two dates where the earlier appears first.
\item Interleaved users.
\item Very large number of rows for a single user.
\item All rows on the same date for a user.
\item Multiple users with disjoint date ranges.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Counting duplicate rows as distinct dates.
\item Using \texttt{ROW\_NUMBER()} instead of \texttt{DENSE\_RANK()} in SQL when days can repeat.
\item Comparing non-ISO date strings lexicographically.
\item Forgetting to order output by \texttt{user\_id}.
\item Off-by-one when indexing second element.
\item Not handling users with fewer than two dates.
\item Using unstable updates that let duplicates demote \texttt{max2}.
\item Sorting entire global dataset instead of per user.
\end{bullets}}
\FAILMODES{A naive pick of the second row per user without sorting or ranking fails when input is not ordered; counting duplicates inflates the rank; missing users with a single date if not emitting \texttt{NULL}. The one-pass top-2 approach and the SQL window version handle all.}
\ELI{Group activities by user, keep their two newest unique days, and print the second one. If there is only one day, output \texttt{NULL}. Window functions in SQL or a simple two-variable tracker per user both solve it cleanly.}
\NotePages{3}

\end{document}