% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Reindeer Games}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1615/H}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{There are $n$ reindeer at the North Pole, all battling for the highest spot on the ``Top Reindeer'' leaderboard on the front page of CodeNorses (a popular competitive reindeer gaming website). Interestingly, the ``Top Reindeer'' title is just a measure of upvotes and has nothing to do with their skill level in the reindeer games, but they still give it the utmost importance.

Currently, the $i$-th reindeer has a score of $a_i$. You would like to influence the leaderboard with some operations. In an operation, you can choose a reindeer, and either increase or decrease his score by $1$ unit. Negative scores are allowed.

You have $m$ requirements for the resulting scores. Each requirement is given by an ordered pair $(u, v)$, meaning that after all operations, the score of reindeer $u$ must be less than or equal to the score of reindeer $v$.

Your task is to perform the minimum number of operations so that all requirements will be satisfied.

Input: The first line contains two integers $n$ and $m$ ($2\le n\le 1000$; $1\le m\le 1000$) — the number of reindeer and requirements, respectively.

The second line contains $n$ integers $a_1,\ldots, a_n$ ($1\le a_i\le 10^9$), where $a_i$ is the current score of reindeer $i$.

The next $m$ lines describe the requirements.

The $i$-th of these lines contains two integers $u_i$ and $v_i$ ($1\le u_i, v_i\le n$; $u_i\ne v_i$) — the two reindeer of the $i$-th requirement.

Output: Print $n$ integers $b_1,\ldots, b_n$ ($-10^{15}\le b_i\le 10^{15}$), where $b_i$ is the score of the $i$-th reindeer after all operations.

If there are multiple solutions achieving the minimum number of operations, you may output any.

We can prove that there is always an optimal solution such that $|b_i|\le 10^{15}$ for all $i$.}
\BREAKDOWN{We must find $b\in\mathbb{Z}^n$ minimizing $\sum_i |b_i-a_i|$ subject to $b_u\le b_v$ for each directed edge $(u,v)$. This is the $L^1$ isotonic regression on a directed acyclic (possibly cyclic) precedence graph; feasible even with cycles since constraints are consistent via equalities along cycles.}
\ELI{Make scores nondecreasing along each requirement while moving each as little as possible in $L^1$ distance.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,m$ with $2\le n\le 1000$, $1\le m\le 1000$; array $a\in\mathbb{Z}^n$ with $1\le a_i\le 10^9$; $m$ directed pairs $(u_i,v_i)$ with $1\le u_i\ne v_i\le n$.}
\OUTPUTS{Any integer vector $b\in\mathbb{Z}^n$ minimizing $\sum_i |b_i-a_i|$ subject to $b_{u_i}\le b_{v_i}$ for all requirements. Space-separated on a single line.}
\SAMPLES{Example 1:
$n=2,m=1$, $a=[0,10]$, edge $(1,2)$. Output: $0~10$.

Example 2:
$n=2,m=1$, $a=[10,0]$, edge $(1,2)$. Output: $10~10$ (or $0~0$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a directed graph on $V=[n]$ with an edge $(u,v)$ meaning $b_u\le b_v$. Find $b\in\mathbb{Z}^n$ minimizing the $L^1$ deviation from $a$.}
\varmapStart
\var{a_i}{given initial score of node $i$}
\var{b_i}{final score of node $i$ to choose}
\var{E}{set of constraints $(u,v)$ requiring $b_u\le b_v$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{b\in\mathbb{Z}^n}\ \sum_{i=1}^n |b_i-a_i|\quad\text{s.t.}\quad b_u\le b_v\ \forall (u,v)\in E.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Feasible region is nonempty since taking all $b_i$ equal works. Optimal $b$ can be chosen with $b_i$ among the sorted unique values of $a$ (breakpoints of the convex objective).}
\INVARIANTS{For any threshold $t$, the superlevel set $\{i: b_i\ge t\}$ is an upper set: if $(u,v)\in E$ and $u$ is in the set, then $v$ must be in the set. The objective is separable and piecewise linear with breakpoints at $a_i$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Restrict candidate labels to the $K$ distinct values in $A=\{a_i\}$. Enumerate all assignments $b_i\in A$ satisfying $b_u\le b_v$, and take the minimum sum of absolute deviations.}
\ASSUMPTIONS{Feasible due to the optimality among observed values; exponential time only for tiny $n$ works as a checker.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract sorted unique values $S$ from $a$.
\item Enumerate all functions $x:[n]\to\{1,\ldots,K\}$ with constraint $x(u)\le x(v)$ for $(u,v)\in E$.
\item Evaluate $b_i=S_{x(i)}$ and track the minimum objective.
\end{algosteps}
\COMPLEXITY{Exponential in $n$; in the worst case $K^n$ assignments. Useful only for $n\le 10$ as a validator.}
\[
\begin{aligned}
T(n) &\le K^n \cdot (n+m),\quad K\le n,\\
S(n) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{Exhaustive search over a superset of optimal solutions (values restricted to $S$) yields the optimum.}
\EDGECASES{Cycles in $E$ force equal labels along the cycle; enumeration filters invalid ones. All $a_i$ equal reduces to unique solution $b=a$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from itertools import product

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    s = data.strip()
    if not s:
        return None
    it = iter(map(int, s.split()))
    n = next(it); m = next(it)
    a = [next(it) for _ in range(n)]
    edges = []
    for _ in range(m):
        u = next(it)-1; v = next(it)-1
        edges.append((u, v))
    return n, m, a, edges

def feasible_labeling(lbl, edges):
    for u, v in edges:
        if lbl[u] > lbl[v]:
            return False
    return True

def brute_solve(n, a, edges):
    S = sorted(set(a))
    K = len(S)
    best_cost = None
    best_b = None
    # Label indices 0..K-1
    for lbl in product(range(K), repeat=n):
        if not feasible_labeling(lbl, edges):
            continue
        b = [S[lbl[i]] for i in range(n)]
        cost = sum(abs(b[i]-a[i]) for i in range(n))
        if best_cost is None or cost < best_cost:
            best_cost = cost
            best_b = b
    # Fallback (should not happen unless n is too big): keep a respecting constraints by isotonic projection on chainless case
    if best_b is None:
        # trivial: set all to median of a, then push up along edges
        med = sorted(a)[len(a)//2]
        b = [med]*n
        # push along edges until constraints hold
        changed = True
        while changed:
            changed = False
            for u, v in edges:
                if b[u] > b[v]:
                    b[v] = b[u]
                    changed = True
        best_b = b
    return best_b

def solve_all():
    inp = read_input()
    if inp is None:
        # simple internal tests
        n, m = 2, 1
        a = [10, 0]
        edges = [(0, 1)]
        b = brute_solve(n, a, edges)
        assert b in ([10, 10], [0, 0])
        n, m = 3, 3
        a = [3, 1, 2]
        edges = [(0, 1), (1, 2), (0, 2)]
        b = brute_solve(n, a, edges)
        assert b[0] <= b[1] <= b[2]
        print("OK")
        return
    n, m, a, edges = inp
    b = brute_solve(n, a, edges)
    print(" ".join(str(x) for x in b))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Two asserts in code: a chain example and a simple two-node constraint, both verifying feasibility and expected optimality set.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Thresholded Max-Closure Integration}
\WHICHFORMULA{Characterize $L^1$ isotonic regression via threshold sets: for any $t$, $X_t=\{i: b_i\ge t\}$ is an upper set. For $t\in(S_k,S_{k+1})$, the optimal $X_t$ is the maximum-weight closed set with weights $w_i(t)=\mathbf{1}[a_i\ge t]-\mathbf{1}[a_i<t]\in\{-1,+1\}$. Integrate these sets to recover $b$.}
\ASSUMPTIONS{Optimal $b_i$ lie in $S=\text{unique}(a)$; thus it suffices to consider $K-1$ thresholds between consecutive values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $S_1<\cdots<S_K$ be sorted uniques of $a$. Initialize $b_i\gets S_1$.
\item For each $k=1,\ldots,K-1$, set $t\in(S_k,S_{k+1})$. Assign weights $w_i=+1$ if $a_i\ge S_{k+1}$ else $-1$.
\item Build a directed graph with original edges $(u,v)$ as infinite-capacity arcs $u\to v$. For node $i$, if $w_i>0$ add edge $s\to i$ with capacity $w_i$; else add $i\to t$ with capacity $-w_i$.
\item Compute a minimum $s$-$t$ cut; the $s$-side gives the maximum-weight closed set $X_t$. For all $i\in X_t$, increment $b_i$ by $(S_{k+1}-S_k)$.
\end{algosteps}
\COMPLEXITY{Dominated by $K-1\le n-1$ max-closure computations, each a single max-flow on a graph with $O(n+m)$ edges.
\begin{BreakableEquation*}
T(n)\approx O\big((K-1)\cdot \text{Flow}(n+m)\big),\quad S(n)=O(n+m).
\end{BreakableEquation*}
In practice with Dinic and $n,m\le 1000$, this is fast.}
\CORRECTNESS{For $L^1$ loss, $\sum_i |b_i-a_i|=\int \sum_i \big(\mathbf{1}[b_i\ge t]-\mathbf{1}[a_i\ge t]\big)\,dt$; minimizing per threshold is a maximum-closure problem over upper sets. Summing increments reconstructs $b$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

class Dinic:
    __slots__ = ("n","g","lev","it")
    def __init__(self, n):
        self.n = n
        self.g = [[] for _ in range(n)]
    def add_edge(self, u, v, c):
        self.g[u].append([v, c, len(self.g[v])])
        self.g[v].append([u, 0, len(self.g[u])-1])
    def bfs(self, s, t):
        self.lev = [-1]*self.n
        q = deque([s])
        self.lev[s] = 0
        while q:
            u = q.popleft()
            for v, c, _ in self.g[u]:
                if c > 0 and self.lev[v] < 0:
                    self.lev[v] = self.lev[u] + 1
                    q.append(v)
        return self.lev[t] >= 0
    def dfs(self, u, t, f):
        if u == t:
            return f
        for i in range(self.it[u], len(self.g[u])):
            self.it[u] = i
            v, c, r = self.g[u][i]
            if c > 0 and self.lev[v] == self.lev[u] + 1:
                ret = self.dfs(v, t, min(f, c))
                if ret:
                    self.g[u][i][1] -= ret
                    self.g[v][r][1] += ret
                    return ret
        return 0
    def maxflow(self, s, t):
        flow = 0
        INF = 10**18
        while self.bfs(s, t):
            self.it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF)
                if not pushed:
                    break
                flow += pushed
        return flow
    def reachable_from(self, s):
        vis = [False]*self.n
        q = deque([s])
        vis[s] = True
        while q:
            u = q.popleft()
            for v, c, _ in self.g[u]:
                if c > 0 and not vis[v]:
                    vis[v] = True
                    q.append(v)
        return vis

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    s = data.strip()
    if not s:
        return None
    it = iter(map(int, s.split()))
    n = next(it); m = next(it)
    a = [next(it) for _ in range(n)]
    edges = []
    for _ in range(m):
        u = next(it)-1; v = next(it)-1
        edges.append((u, v))
    return n, m, a, edges

def isotonic_L1(a, edges):
    n = len(a)
    S = sorted(set(a))
    K = len(S)
    b = [S[0]]*n
    if K == 1:
        return b
    for k in range(K-1):
        threshold = S[k+1]
        N = n + 2
        SRC = n
        SNK = n + 1
        din = Dinic(N)
        INF = n + 5  # > total positive weight (<= n)
        # node weights
        for i in range(n):
            w = 1 if a[i] >= threshold else -1
            if w >= 0:
                din.add_edge(SRC, i, w)
            else:
                din.add_edge(i, SNK, -w)
        # precedence edges enforce upper set
        for u, v in edges:
            din.add_edge(u, v, INF)
        _ = din.maxflow(SRC, SNK)
        reach = din.reachable_from(SRC)
        diff = S[k+1] - S[k]
        for i in range(n):
            if reach[i]:
                b[i] += diff
    return b

def solve_all():
    inp = read_input()
    if inp is None:
        # internal checks
        # 1) simple increasing already
        n, m, a, E = 2, 1, [0, 10], [(0, 1)]
        b = isotonic_L1(a, E)
        assert b == [0, 10]
        # 2) must tie or flip
        n, m, a, E = 2, 1, [10, 0], [(0, 1)]
        b = isotonic_L1(a, E)
        assert b in ([10, 10], [0, 0])
        # 3) random small brute compare
        a = [3, 1, 2]
        E = [(0, 1), (1, 2)]
        b = isotonic_L1(a, E)
        assert b[0] <= b[1] <= b[2]
        print("OK")
        return
    n, m, a, edges = inp
    b = isotonic_L1(a, edges)
    print(" ".join(str(x) for x in b))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Asserts cross-check feasibility and basic optimal patterns; more exhaustive tests appear later.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Parametric Max-Closure Integration (L1 Isotonic Regression on DAG)}
\WHICHFORMULA{Use the integral representation of $L^1$ loss via superlevel sets and compute $K-1$ maximum-closure sets by a single $s$-$t$ min-cut each. Integrate increments $(S_{k+1}-S_k)$ over thresholds to form $b$.}
\ASSUMPTIONS{Applies to any directed graph; upper sets are enforced by infinite-capacity arcs along $(u,v)$. The optimal solution is among $S$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S=\text{sorted unique}(a)$. Initialize $b\gets S_1\cdot\mathbf{1}$.
\item For each adjacent pair $(S_k,S_{k+1})$:
  \begin{bullets}
  \item Set node weight $w_i=+1$ if $a_i\ge S_{k+1}$ else $-1$.
  \item Build flow network: $s\to i$ with capacity $w_i$ if $w_i>0$, $i\to t$ with capacity $-w_i$ if $w_i<0$, and $u\to v$ with capacity $\infty$ for each constraint $(u,v)$.
  \item Min-cut yields the maximum-weight closed (upper) set $X$ as the $s$-reachable nodes.
  \item Add $(S_{k+1}-S_k)$ to $b_i$ for $i\in X$.
  \end{bullets}
\item Output $b$.
\end{algosteps}
\OPTIMALITY{This is the classical reduction of separable $L^1$ isotonic regression to a sequence of maximum-closure problems; each closure is solved exactly via a single min-cut. Summing threshold contributions reconstructs the unique minimal $L^1$ objective (ties yield any optimal $b$ in $S$).}
\COMPLEXITY{With $K\le n$, we perform at most $n-1$ flows on $O(n+m)$-edge graphs.
\begin{BreakableEquation*}
T(n)=O\big((n-1)\cdot \text{Dinic}(n+m)\big),\quad S(n)=O(n+m).
\end{BreakableEquation*}
In practice $n,m\le 1000$ runs easily.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

class Dinic:
    __slots__ = ("n","g","lev","it")
    def __init__(self, n:int):
        self.n = n
        self.g = [[] for _ in range(n)]
    def add_edge(self, u:int, v:int, c:int):
        self.g[u].append([v, c, len(self.g[v])])
        self.g[v].append([u, 0, len(self.g[u])-1])
    def bfs(self, s:int, t:int)->bool:
        self.lev = [-1]*self.n
        dq = deque([s])
        self.lev[s] = 0
        while dq:
            u = dq.popleft()
            for v, c, _ in self.g[u]:
                if c > 0 and self.lev[v] < 0:
                    self.lev[v] = self.lev[u] + 1
                    dq.append(v)
        return self.lev[t] >= 0
    def dfs(self, u:int, t:int, f:int)->int:
        if u == t:
            return f
        for i in range(self.it[u], len(self.g[u])):
            self.it[u] = i
            v, c, r = self.g[u][i]
            if c > 0 and self.lev[v] == self.lev[u] + 1:
                ret = self.dfs(v, t, min(f, c))
                if ret:
                    self.g[u][i][1] -= ret
                    self.g[v][r][1] += ret
                    return ret
        return 0
    def maxflow(self, s:int, t:int)->int:
        flow = 0
        INF = 10**18
        while self.bfs(s, t):
            self.it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF)
                if not pushed:
                    break
                flow += pushed
        return flow
    def reachable_from(self, s:int):
        vis = [False]*self.n
        dq = deque([s])
        vis[s] = True
        while dq:
            u = dq.popleft()
            for v, c, _ in self.g[u]:
                if c > 0 and not vis[v]:
                    vis[v] = True
                    dq.append(v)
        return vis

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    s = data.strip()
    if not s:
        return None
    it = iter(map(int, s.split()))
    n = next(it); m = next(it)
    a = [next(it) for _ in range(n)]
    edges = []
    for _ in range(m):
        u = next(it)-1; v = next(it)-1
        edges.append((u, v))
    return n, m, a, edges

def isotonic_L1_b_solution(n:int, a:list, edges:list)->list:
    S = sorted(set(a))
    K = len(S)
    b = [S[0]]*n
    if K == 1:
        return b
    for k in range(K-1):
        thr = S[k+1]
        SRC = n
        SNK = n+1
        din = Dinic(n+2)
        INF = n + 5
        for i in range(n):
            w = 1 if a[i] >= thr else -1
            if w >= 0:
                din.add_edge(SRC, i, w)
            else:
                din.add_edge(i, SNK, -w)
        for u, v in edges:
            din.add_edge(u, v, INF)
        _ = din.maxflow(SRC, SNK)
        reach = din.reachable_from(SRC)
        inc = S[k+1] - S[k]
        for i in range(n):
            if reach[i]:
                b[i] += inc
    return b

def solve_all():
    inp = read_input()
    if inp is None:
        # exactly 3 asserts
        # 1) trivial: no edges
        a = [5, 1, 9]
        b = isotonic_L1_b_solution(3, a, [])
        assert b == a
        # 2) chain forces nondecreasing
        n, m, a, E = 3, 2, [3, 1, 2], [(0, 1), (1, 2)]
        b = isotonic_L1_b_solution(n, a, E)
        assert b[0] <= b[1] <= b[2]
        # 3) two-node constraint inversion
        n, m, a, E = 2, 1, [10, 0], [(0, 1)]
        b = isotonic_L1_b_solution(n, a, E)
        assert b in ([10, 10], [0, 0])
        print("OK")
        return
    n, m, a, edges = inp
    b = isotonic_L1_b_solution(n, a, edges)
    print(" ".join(str(x) for x in b))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts included: identity with no edges, monotone chain, and a 2-node inversion requiring tie.}
\RESULT{Outputs any optimal integer vector $b$ (values lie in $S$) that minimizes $\sum_i |b_i-a_i|$ while satisfying all $b_u\le b_v$. Ties across multiple optimal $b$ are allowed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for feasibility and small instances with brute-force verification; property checks for threshold integration; random DAGs with $n\le 7$ cross-validated.}
\LINE{CROSS-CHECKS}{Compare Approach A (brute) vs Approach C on small $n$ and random graphs to ensure identical objective values and feasibility.}
\LINE{EDGE-CASE GENERATOR}{Generates graphs with cycles, disjoint components, all-equal $a$, strictly increasing/decreasing $a$, and single-threshold cases ($K=2$).}
\begin{minted}{python}
import sys
import random
from itertools import product

# Deterministic generators for boundaries, degenerates, adversarials
def brute_check(n, a, edges):
    S = sorted(set(a))
    K = len(S)
    best = None
    bestb = None
    for lbl in product(range(K), repeat=n):
        ok = True
        for u, v in edges:
            if lbl[u] > lbl[v]:
                ok = False
                break
        if not ok:
            continue
        b = [S[lbl[i]] for i in range(n)]
        val = sum(abs(b[i]-a[i]) for i in range(n))
        if best is None or val < best:
            best = val
            bestb = b
    return best, bestb

def iso_L1(n, a, edges):
    # mirror of final implementation (short form)
    S = sorted(set(a))
    K = len(S)
    b = [S[0]]*n
    if K == 1:
        return b
    from collections import deque
    class Dinic:
        def __init__(self, n): self.n=n; self.g=[[] for _ in range(n)]
        def add(self,u,v,c): self.g[u].append([v,c,len(self.g[v])]); self.g[v].append([u,0,len(self.g[u])-1])
        def bfs(self,s,t):
            self.lv=[-1]*self.n; dq=deque([s]); self.lv[s]=0
            while dq:
                u=dq.popleft()
                for v,c,_ in self.g[u]:
                    if c>0 and self.lv[v]<0:
                        self.lv[v]=self.lv[u]+1; dq.append(v)
            return self.lv[t]>=0
        def dfs(self,u,t,f):
            if u==t: return f
            for i in range(self.it[u], len(self.g[u])):
                self.it[u]=i
                v,c,r=self.g[u][i]
                if c>0 and self.lv[v]==self.lv[u]+1:
                    ret=self.dfs(v,t,min(f,c))
                    if ret:
                        self.g[u][i][1]-=ret; self.g[v][r][1]+=ret; return ret
            return 0
        def flow(self,s,t):
            res=0; INF=10**18
            while self.bfs(s,t):
                self.it=[0]*self.n
                while True:
                    p=self.dfs(s,t,INF)
                    if not p: break
                    res+=p
            return res
        def reach(self,s):
            vis=[False]*self.n; dq=deque([s]); vis[s]=True
            while dq:
                u=dq.popleft()
                for v,c,_ in self.g[u]:
                    if c>0 and not vis[v]: vis[v]=True; dq.append(v)
            return vis
    for k in range(K-1):
        N=n+2; SRC=n; SNK=n+1; din=Dinic(N); INF=n+5
        thr=S[k+1]
        for i in range(n):
            w=1 if a[i]>=thr else -1
            if w>=0: din.add(SRC,i,w)
            else: din.add(i,SNK,-w)
        for u,v in edges: din.add(u,v,INF)
        din.flow(SRC,SNK); reach=din.reach(SRC); inc=S[k+1]-S[k]
        for i in range(n):
            if reach[i]: b[i]+=inc
    return b

def main():
    random.seed(0)
    # small exhaustive tests
    for n in range(1, 7):
        for _ in range(50):
            a = [random.randint(0, 5) for _ in range(n)]
            m = random.randint(0, min(6, n*(n-1)))
            edges = set()
            for _ in range(m):
                u = random.randrange(n); v = random.randrange(n)
                if u != v:
                    edges.add((u, v))
            edges = list(edges)
            b = iso_L1(n, a, edges)
            # feasibility
            for u, v in edges:
                assert b[u] <= b[v]
            # optimality vs brute (only when state space small)
            if len(set(a))**n <= 20000:
                best, bestb = brute_check(n, a, edges)
                val = sum(abs(b[i]-a[i]) for i in range(n))
                assert val == best
    print("ALL TESTS PASSED")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

class Dinic:
    __slots__ = ("n","g","lev","it")
    def __init__(self, n:int):
        self.n = n
        self.g = [[] for _ in range(n)]
    def add_edge(self, u:int, v:int, c:int):
        self.g[u].append([v, c, len(self.g[v])])
        self.g[v].append([u, 0, len(self.g[u])-1])
    def bfs(self, s:int, t:int)->bool:
        self.lev = [-1]*self.n
        dq = deque([s])
        self.lev[s] = 0
        while dq:
            u = dq.popleft()
            for v, c, _ in self.g[u]:
                if c > 0 and self.lev[v] < 0:
                    self.lev[v] = self.lev[u] + 1
                    dq.append(v)
        return self.lev[t] >= 0
    def dfs(self, u:int, t:int, f:int)->int:
        if u == t:
            return f
        for i in range(self.it[u], len(self.g[u])):
            self.it[u] = i
            v, c, r = self.g[u][i]
            if c > 0 and self.lev[v] == self.lev[u] + 1:
                ret = self.dfs(v, t, min(f, c))
                if ret:
                    self.g[u][i][1] -= ret
                    self.g[v][r][1] += ret
                    return ret
        return 0
    def maxflow(self, s:int, t:int)->int:
        flow = 0
        INF = 10**18
        while self.bfs(s, t):
            self.it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF)
                if not pushed:
                    break
                flow += pushed
        return flow
    def reachable_from(self, s:int):
        vis = [False]*self.n
        dq = deque([s])
        vis[s] = True
        while dq:
            u = dq.popleft()
            for v, c, _ in self.g[u]:
                if c > 0 and not vis[v]:
                    vis[v] = True
                    dq.append(v)
        return vis

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    s = data.strip()
    if not s:
        return None
    it = iter(map(int, s.split()))
    n = next(it); m = next(it)
    a = [next(it) for _ in range(n)]
    edges = []
    for _ in range(m):
        u = next(it)-1; v = next(it)-1
        edges.append((u, v))
    return n, m, a, edges

def solve_case(n:int, m:int, a:list, edges:list)->list:
    S = sorted(set(a))
    K = len(S)
    b = [S[0]]*n
    if K == 1:
        return b
    SRC = n; SNK = n+1
    for k in range(K-1):
        thr = S[k+1]
        din = Dinic(n+2)
        INF = n + 5
        for i in range(n):
            w = 1 if a[i] >= thr else -1
            if w >= 0:
                din.add_edge(SRC, i, w)
            else:
                din.add_edge(i, SNK, -w)
        for u, v in edges:
            din.add_edge(u, v, INF)
        _ = din.maxflow(SRC, SNK)
        reach = din.reachable_from(SRC)
        inc = S[k+1] - S[k]
        for i in range(n):
            if reach[i]:
                b[i] += inc
    return b

def solve_all():
    inp = read_input()
    if inp is None:
        # run a few deterministic checks
        n, m, a, E = 2, 1, [0, 10], [(0, 1)]
        assert solve_case(n, m, a, E) == [0, 10]
        n, m, a, E = 2, 1, [10, 0], [(0, 1)]
        assert solve_case(n, m, a, E) in ([10, 10], [0, 0])
        n, m, a, E = 3, 3, [3, 1, 2], [(0, 1), (1, 2), (0, 2)]
        b = solve_case(n, m, a, E)
        assert b[0] <= b[1] <= b[2]
        print("OK")
        return
    n, m, a, edges = inp
    b = solve_case(n, m, a, edges)
    print(" ".join(str(x) for x in b))

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize total $L^1$ change to fit monotonicity constraints: $L^1$ isotonic regression on a directed graph.}
\WHY{Shows up in regression with order constraints, precedence scheduling, and as a classic reduction to max-closure/min-cut.}
\CHECKLIST{
\begin{bullets}
\item Extract sorted uniques $S$.
\item For each gap $(S_k,S_{k+1})$, build max-closure with weights $\pm 1$.
\item Add infinite-capacity arcs along $(u,v)$.
\item Min-cut $\Rightarrow$ $s$-reachable nodes give upper set; add increment.
\item Output $b$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All $a_i$ equal $\Rightarrow b=a$.
\item No edges $\Rightarrow b=a$.
\item Strongly connected components enforce equality across components.
\item Single threshold ($K=2$) reduces to one max-closure.
\item Negative $b_i$ allowed, but optimal stays in $[\min a,\max a]$.
\item Dense cycles: ensure arcs are directed correctly ($u\to v$).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using insufficient ``infinite'' capacity; choose $>n$ since total positive weight $\le n$.
\item Mixing lower vs upper sets; for $b_u\le b_v$, superlevel sets are upper sets: add arcs $u\to v$.
\item Forgetting to add increments $(S_{k+1}-S_k)$ (values may be non-unit spaced).
\item Mishandling $K=1$ case.
\item Integer overflow if using too small types for capacities.
\item Reusing flow graph across thresholds without resetting residuals.
\end{bullets}
}
\FAILMODES{Greedy local adjustments can get stuck or violate transitive constraints; simple averaging/median along edges does not respect global constraints. The closure-based method is globally optimal and robust to cycles.}
\ELI{Decide, for each height band between consecutive observed scores, which reindeer are at least that tall while respecting all ``must not be taller than'' arrows. This decision is a single min-cut. Stack the chosen bands to get the final heights.}
\NotePages{3}

\end{document}