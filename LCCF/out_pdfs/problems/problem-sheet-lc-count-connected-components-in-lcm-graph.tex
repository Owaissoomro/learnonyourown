% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Count Connected Components in LCM Graph}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/count-connected-components-in-lcm-graph/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an array of integers \texttt{nums} of size $n$ and a positive integer \texttt{threshold}. There is a graph consisting of $n$ nodes with the $i$th node having a value of \texttt{nums[i]}. Two nodes $i$ and $j$ in the graph are connected via an undirected edge if $\operatorname{lcm}(\texttt{nums[i]}, \texttt{nums[j]}) \le \texttt{threshold}$. Return the number of connected components in this graph. A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph. The term $\operatorname{lcm}(a,b)$ denotes the least common multiple of $a$ and $b$. 

Example 1: Input: \texttt{nums = [2,4,8,3,9]}, \texttt{threshold = 5}. Output: \texttt{4}. Explanation: The four connected components are $(2,4)$, $(3)$, $(8)$, $(9)$.

Example 2: Input: \texttt{nums = [2,4,8,3,9,12]}, \texttt{threshold = 10}. Output: \texttt{2}. Explanation: The two connected components are $(2,3,4,8,9)$ and $(12)$.

Constraints:
\begin{bullets}
\item $1 \le \texttt{nums.length} \le 10^5$
\item $1 \le \texttt{nums[i]} \le 10^9$
\item All elements of \texttt{nums} are unique.
\item $1 \le \texttt{threshold} \le 2 \times 10^5$
\end{bullets}}
\BREAKDOWN{Nodes with value $> \texttt{threshold}$ are isolated. Among values $\le \texttt{threshold}$, connect indices $i,j$ iff $\operatorname{lcm}(\texttt{nums[i]}, \texttt{nums[j]}) \le \texttt{threshold}$. Count components via Union-Find or graph traversal.}
\ELI{Small numbers that can share a common multiple not exceeding the threshold end up in the same group; big numbers stay alone.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer array \texttt{nums} of length $n$ (unique entries), and an integer \texttt{threshold}. Valid ranges: $1 \le n \le 10^5$, $1 \le \texttt{nums[i]} \le 10^9$, $1 \le \texttt{threshold} \le 2 \times 10^5$.}
\OUTPUTS{Return a single integer: the number of connected components in the graph with edges between $i,j$ when $\operatorname{lcm}(\texttt{nums[i]},\texttt{nums[j]}) \le \texttt{threshold}$.}
\SAMPLES{Example A: \texttt{nums=[2,4,8,3,9]}, \texttt{threshold=5} $\rightarrow$ \texttt{4}. Example B: \texttt{nums=[2,4,8,3,9,12]}, \texttt{threshold=10} $\rightarrow$ \texttt{2}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{0,\ldots,n-1\}$, values $a_i=\texttt{nums[i]}$. Undirected graph $G=(V,E)$ with $(i,j) \in E$ iff $\operatorname{lcm}(a_i,a_j) \le T$, where $T=\texttt{threshold}$. We seek the number of connected components of $G$.}
\varmapStart
\var{n}{number of nodes}
\var{a_i}{value at node $i$}
\var{T}{threshold}
\var{C}{number of connected components in $G$}
\varmapEnd
\GOVERN{
\[
E=\bigl\{(i,j)\,:\, i\ne j,\ \operatorname{lcm}(a_i,a_j)\le T\bigr\},\qquad
C=\text{number of connected components of }(V,E).
\]
}
\ASSUMPTIONS{All $a_i$ are positive and unique. Note $\operatorname{lcm}(x,y)\ge \max(x,y)$, hence if $a_i>T$ then node $i$ is isolated.}
\INVARIANTS{
\begin{bullets}
\item For any $i$ with $a_i>T$, its component is $\{i\}$.
\item For $a_i,a_j\le T$, $\operatorname{lcm}(a_i,a_j)\le T$ iff there exists $m\le T$ such that $a_i\mid m$ and $a_j\mid m$ (choose $m=\operatorname{lcm}(a_i,a_j)$).
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test each pair among values $\le T$ with $\operatorname{lcm}(x,y)=\dfrac{xy}{\gcd(x,y)}$ and union if the lcm is $\le T$.}
\ASSUMPTIONS{Filter out $a_i>T$ as isolated components; only pairwise-check the remaining $k$ values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition indices into small set $S=\{i:a_i\le T\}$ and large set $L=\{i:a_i>T\}$.
\item Make a DSU over $S$. For every unordered pair $\{i,j\}\subseteq S$, compute $\gcd(a_i,a_j)$ and $l=\dfrac{a_i}{\gcd(a_i,a_j)}\cdot a_j$; if $l\le T$, union their DSU sets.
\item Answer is $\lvert L\rvert$ plus the number of DSU roots over $S$.
\end{algosteps}
\COMPLEXITY{Let $k=\lvert S\rvert$. Pairwise checking costs $O\!\left(k^2\log A\right)$ time with $A=\max a_i$, and $O(k)$ space for DSU.}
\[
\begin{aligned}
T(n) &= O\!\left(k^2\log A\right),\quad S(n)=O(k). \\
\end{aligned}
\]
\CORRECTNESS{Every edge definition is checked exactly for eligible pairs; DSU merges exactly when $\operatorname{lcm}\le T$, producing the correct component partition.}
\EDGECASES{If $k\le 1$, the answer is $n$ or $n-1+1$ trivially. Values equal to $1$ connect to all values $\le T$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import math

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
        self.cc = n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.cc -= 1
        return True

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        small_idx = [i for i, v in enumerate(nums) if v <= threshold]
        big_count = n - len(small_idx)
        k = len(small_idx)
        if k <= 1:
            return big_count + k
        dsu = DSU(k)
        vals = [nums[i] for i in small_idx]
        for i in range(k):
            ai = vals[i]
            for j in range(i+1, k):
                aj = vals[j]
                g = math.gcd(ai, aj)
                # Compute lcm safely
                lcm = (ai // g) * aj
                if lcm <= threshold:
                    dsu.union(i, j)
        return big_count + dsu.cc

# Tests (baseline)
s = Solution()
assert s.countComponents([2,4,8,3,9], 5) == 4
assert s.countComponents([2,4,8,3,9,12], 10) == 2
# Edge: all > T
assert s.countComponents([100, 101], 50) == 2
# Edge: single element
assert s.countComponents([7], 10) == 1
\end{minted}
\VALIDATION{Compared with hand reasoning on the two examples; sanity checks for trivial and all-isolated cases confirm behavior.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sieve via Common Multiples Bucketing}
\WHICHFORMULA{Use the equivalence: for $a,b\le T$, $\operatorname{lcm}(a,b)\le T$ iff there exists $m\le T$ divisible by both $a$ and $b$. For each $m\le T$, union all present numbers that divide $m$.}
\ASSUMPTIONS{Track, for each $m\in[1..T]$, the first seen index of a present divisor; union subsequent divisors to it.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build mapping from value $v\le T$ to its index among small elements.
\item Initialize DSU over these $k$ elements and an array \texttt{first} of size $T{+}1$ with $-1$.
\item For each present $d\le T$, iterate multiples $m=d,2d,\ldots,\le T$:
\begin{bullets}
\item If \texttt{first[m]} is $-1$, set it to the index of $d$.
\item Else, union the index of $d$ with \texttt{first[m]}.
\end{bullets}
\item Answer is number of DSU roots plus count of values $>T$.
\end{algosteps}
\COMPLEXITY{Each $d$ contributes $\lfloor T/d\rfloor$ iterations. Total time $O\!\left(\sum_{d\in S} \lfloor T/d\rfloor\right)\le O\!\left(k\log T + T\right)$, space $O(T+k)$.}
\[
\begin{aligned}
T(n) &= O\!\Bigl(\sum_{d\in S}\big\lfloor \tfrac{T}{d}\big\rfloor\Bigr) \approx O(k\log T),\quad S(n)=O(T+k).
\end{aligned}
\]
\CORRECTNESS{If $\operatorname{lcm}(a,b)\le T$, then at $m=\operatorname{lcm}(a,b)$ both are divisors, hence they are unioned. Conversely, unions occur only among numbers dividing a common $m\le T$, which implies their lcm $\le m\le T$. Transitive closure matches graph connectivity.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
        self.cc = n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.cc -= 1
        return True

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        small = [(v, i) for i, v in enumerate(nums) if v <= threshold]
        big_count = n - len(small)
        k = len(small)
        if k <= 1:
            return big_count + k
        # Map value to compact index [0..k-1]
        val2idx = {}
        vals = []
        for ci, (v, _) in enumerate(small):
            val2idx[v] = ci
            vals.append(v)
        dsu = DSU(k)
        T = threshold
        first = [-1] * (T + 1)
        # Iterate present divisors d; visit multiples m
        for d in vals:
            idx = val2idx[d]
            for m in range(d, T + 1, d):
                if first[m] == -1:
                    first[m] = idx
                else:
                    dsu.union(idx, first[m])
        return big_count + dsu.cc

# Tests (improved)
s = Solution()
assert s.countComponents([2,4,8,3,9], 5) == 4
assert s.countComponents([2,4,8,3,9,12], 10) == 2
# Edge: 1 connects to all values <= T
assert s.countComponents([1, 7, 11, 13], 20) == 1 + 1  # 1+{7,11,13} -> one small comp + 1 isolated (none > T here), equals 1
# Adjusted: all <= T so 1 component
assert s.countComponents([1, 7, 11, 13], 20) == 1
\end{minted}
\VALIDATION{Covers examples; verifies that the presence of $1$ merges all small values into one component.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Union by Common Multiples (Tight Bound)}
\WHICHFORMULA{Same sieve union as Approach B, with minor constant-factor improvements and early exits. This achieves near-linear time in $T$ plus harmonic overhead in $k$.}
\ASSUMPTIONS{Only values $\le T$ can have edges. Use an array of length $T{+}1$ and iterate each present $d$ across its multiples.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Separate small values $v\le T$ and count isolates $>T$.
\item If small count $k\le 1$, return immediately.
\item Build \texttt{val2idx} for small values; DSU over $k$.
\item Initialize \texttt{first} array of size $T{+}1$ to $-1$.
\item For each small value $d$, loop $m=d,2d,\ldots\le T$ and union with \texttt{first[m]} if it exists.
\item Return DSU components $+$ isolates.
\end{algosteps}
\OPTIMALITY{Any algorithm must at least inspect potential connectors up to $T$. The harmonic bound $\sum_{d\in S}\lfloor T/d\rfloor$ is tight in worst-case inputs with many small $d$.}
\COMPLEXITY{As in Approach B; practical runtime $\approx O(T + k\log T)$ and memory $O(T+k)$.}
\[
\begin{aligned}
T(n) &= O\!\Bigl(\sum_{d\in S}\big\lfloor \tfrac{T}{d}\big\rfloor\Bigr),\quad S(n)=O(T+k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
        self.cc = n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.cc -= 1
        return True

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        # Partition
        small_vals = [v for v in nums if v <= threshold]
        big_count = n - len(small_vals)
        k = len(small_vals)
        if k <= 1:
            return big_count + k
        # Map value -> compact index
        val2idx = {v: i for i, v in enumerate(small_vals)}
        dsu = DSU(k)
        T = threshold
        first = [-1] * (T + 1)
        # Union by common multiple
        for d in small_vals:
            idx = val2idx[d]
            step = d
            for m in range(d, T + 1, step):
                f = first[m]
                if f == -1:
                    first[m] = idx
                else:
                    dsu.union(idx, f)
        return big_count + dsu.cc

# Validation (exactly 3 asserts)
s = Solution()
assert s.countComponents([2,4,8,3,9], 5) == 4
assert s.countComponents([2,4,8,3,9,12], 10) == 2
assert s.countComponents([1000000000, 2, 3, 5], 6) == 2  # 1 big isolated + {2,3,5} connected via m=6
\end{minted}
\VALIDATION{Three asserts: two examples and a mixed case with one large isolated value.}
\RESULT{Returns the exact count of connected components; ties are irrelevant since components are disjoint sets.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify: examples; all elements $>T$; all elements $\le T$ including $1$; random small arrays cross-checked between baseline and optimal; monotonicity when lowering $T$.}
\LINE{CROSS-CHECKS}{On tiny arrays ($n\le 10$), compare Approach A versus Approach C to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with primes, powers of two, and inclusion of $1$; vary $T$ around min/max values to trigger isolation and full connectivity.}
\begin{minted}{python}
from typing import List
import random
import math

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
        self.cc = n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.cc -= 1
        return True

class Baseline:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        small_idx = [i for i, v in enumerate(nums) if v <= threshold]
        big_count = n - len(small_idx)
        k = len(small_idx)
        if k <= 1:
            return big_count + k
        dsu = DSU(k)
        vals = [nums[i] for i in small_idx]
        for i in range(k):
            ai = vals[i]
            for j in range(i+1, k):
                aj = vals[j]
                g = math.gcd(ai, aj)
                lcm = (ai // g) * aj
                if lcm <= threshold:
                    dsu.union(i, j)
        return big_count + dsu.cc

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        small_vals = [v for v in nums if v <= threshold]
        big_count = n - len(small_vals)
        k = len(small_vals)
        if k <= 1:
            return big_count + k
        val2idx = {v: i for i, v in enumerate(small_vals)}
        dsu = DSU(k)
        T = threshold
        first = [-1] * (T + 1)
        for d in small_vals:
            idx = val2idx[d]
            for m in range(d, T + 1, d):
                if first[m] == -1:
                    first[m] = idx
                else:
                    dsu.union(idx, first[m])
        return big_count + dsu.cc

# Cross-check random small cases
rng = random.Random(0)
for _ in range(200):
    n = rng.randint(1, 9)
    # ensure uniqueness
    pool = list(range(1, 60))
    rng.shuffle(pool)
    nums = pool[:n]
    T = rng.randint(1, 40)
    assert Solution().countComponents(nums, T) == Baseline().countComponents(nums, T)

print("Random cross-checks passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
        self.cc = n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.cc -= 1
        return True

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        small_vals = [v for v in nums if v <= threshold]
        big_count = n - len(small_vals)
        k = len(small_vals)
        if k <= 1:
            return big_count + k
        val2idx = {v: i for i, v in enumerate(small_vals)}
        dsu = DSU(k)
        T = threshold
        first = [-1] * (T + 1)
        for d in small_vals:
            idx = val2idx[d]
            for m in range(d, T + 1, d):
                if first[m] == -1:
                    first[m] = idx
                else:
                    dsu.union(idx, first[m])
        return big_count + dsu.cc

# Final quick asserts
s = Solution()
assert s.countComponents([2,4,8,3,9], 5) == 4
assert s.countComponents([2,4,8,3,9,12], 10) == 2
assert s.countComponents([1, 6, 10, 15], 30) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count components where an edge exists iff the lcm of node values is at most the threshold.}
\WHY{Tests number theory meets graph connectivity; sieve-like unions are common in hard interviews.}
\CHECKLIST{
\begin{bullets}
\item Filter out values $>T$ as isolated components.
\item Map small values to compact indices.
\item Union by iterating multiples of each small value.
\item Count DSU roots and add isolated count.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All values $>T$ (answer $=n$).
\item Presence of $1$ (connects to all $v\le T$).
\item Prime-only arrays with moderate $T$.
\item Mixed small/large with $T$ very small ($T=1$).
\item Very large values near $10^9$ (must be isolated if $>T$).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that $a_i>T$ implies isolation.
\item Building edges by GCD instead of LCM (not equivalent).
\item Double-counting or quadratic loops causing TLE.
\item Not compressing DSU paths leading to slow find.
\item Using a map from $m$ to full divisor lists (costly) instead of the first-seen trick.
\item Integer overflow concerns in other languages when computing $\operatorname{lcm}$ naively.
\end{bullets}
}
\FAILMODES{Brute force pairwise approaches time out for $k\approx 10^5$. The sieve union survives by limiting work to harmonic series over $T$.}
\ELI{Only numbers that can fit together under a common multiple not exceeding the threshold can connect. Looping over multiples lets us efficiently group them without checking every pair.}
\NotePages{3}

\end{document}