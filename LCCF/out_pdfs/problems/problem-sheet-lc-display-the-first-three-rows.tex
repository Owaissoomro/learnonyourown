% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Display the First Three Rows}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/display-the-first-three-rows/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given a DataFrame \texttt{employees} with the following schema:
\begin{center}
\begin{tabular}{llll}
\toprule
\textbf{Column Name} & \textbf{Type} & & \\
\midrule
\texttt{employee\_id} & int & & \\
\texttt{name} & object & & \\
\texttt{department} & object & & \\
\texttt{salary} & int & & \\
\bottomrule
\end{tabular}
\end{center}
Write a solution to display the first 3 rows of this DataFrame, preserving the original row order and column order.

Example:
\begin{center}
\begin{tabular}{llll}
\toprule
\multicolumn{4}{c}{Input: DataFrame \texttt{employees}}\\
\midrule
\texttt{employee\_id} & \texttt{name} & \texttt{department} & \texttt{salary} \\
\midrule
3 & Bob & Operations & 48675 \\
90 & Alice & Sales & 11096 \\
9 & Tatiana & Engineering & 33805 \\
60 & Annabelle & InformationTechnology & 37678 \\
49 & Jonathan & HumanResources & 23793 \\
43 & Khaled & Administration & 40454 \\
\midrule
\multicolumn{4}{c}{Output (first 3 rows)}\\
\midrule
3 & Bob & Operations & 48675 \\
90 & Alice & Sales & 11096 \\
9 & Tatiana & Engineering & 33805 \\
\bottomrule
\end{tabular}
\end{center}
Return the resulting DataFrame.}
\BREAKDOWN{Identify the correct DataFrame operation to select the top $k=3$ rows without reordering or filtering by content. Ensure that edge cases with fewer than 3 rows are handled gracefully.}
\ELI{Use the DataFrame's built-in method to take the first three rows.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single pandas DataFrame \texttt{employees} with columns \{\texttt{employee\_id} (int), \texttt{name} (object), \texttt{department} (object), \texttt{salary} (int)\}. The row order is the natural order in the given DataFrame.}
\OUTPUTS{A DataFrame containing the first 3 rows of \texttt{employees}. If \texttt{employees} has fewer than 3 rows, return all available rows. Preserve the original column order and row order.}
\SAMPLES{Example A: If \texttt{employees} has rows with \texttt{employee\_id} 3, 90, 9, 60, \ldots, then output has rows with \texttt{employee\_id} 3, 90, 9 in that order.

Example B: If \texttt{employees} has only two rows, return exactly those two rows.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the table be an ordered sequence of rows $R = (r_1,r_2,\ldots,r_n)$, where each $r_i$ is a tuple over fixed columns. The task is to return the prefix subsequence $R[1..k]$ with $k=3$, or $R$ itself if $n<k$.}
\varmapStart
\var{n}{number of rows in the input DataFrame}
\var{k}{requested prefix length; here $k=3$}
\var{R}{ordered sequence of rows}
\var{C}{ordered list of columns; must be preserved}
\varmapEnd
\GOVERN{
\[
\text{Output}(R,k) =
\begin{cases}
(r_1,r_2,\ldots,r_k), & \text{if } n \ge k,\\
(r_1,r_2,\ldots,r_n), & \text{if } n < k.
\end{cases}
\]
}
\ASSUMPTIONS{Row order is meaningful and must not be changed. Columns are fixed and ordered. No deduplication or sorting is required.}
\INVARIANTS{The output contains at most 3 rows; if the input has fewer than 3 rows, the output size equals the input size. The column order in the output equals the input column order.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the DataFrame method \texttt{head(3)} to obtain the first three rows. It directly implements the prefix semantics.}
\ASSUMPTIONS{The DataFrame API provides \texttt{head}. If \texttt{head} is unavailable, we can slice the underlying row sequence.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Receive DataFrame \texttt{employees}.
\item Return \texttt{employees.head(3)}.
\item Done.
\end{algosteps}
\COMPLEXITY{The operation constructs a view/copy of up to 3 rows: $T(n)=\mathcal{O}(\min(n,3))$ and $S(n)=\mathcal{O}(\min(n,3))$.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(\min(n,3)) \\
S(n) &= \mathcal{O}(\min(n,3)).
\end{aligned}
\]
\CORRECTNESS{By definition, \texttt{head(3)} returns the first three rows in order and does not alter columns.}
\EDGECASES{Empty DataFrame; one/two rows; exactly three rows; more than three rows.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode (Pandas) - Display the First Three Rows
# Self-contained: if pandas is unavailable, provide a minimal shim so tests run with stdlib only.

from typing import Any, List, Tuple

try:
    import pandas as pd  # type: ignore
    HAVE_PANDAS = True
except Exception:
    HAVE_PANDAS = False

    class _SimpleDF:
        def __init__(self, records: List[dict]):
            self._rows = list(records)
            self.columns = list(records[0].keys()) if records else []

        def head(self, n: int = 5) -> "_SimpleDF":
            return _SimpleDF(self._rows[:n])

        # helpers for testing parity
        def to_records(self) -> List[Tuple[Any, ...]]:
            return [tuple(row.get(c) for c in self.columns) for row in self._rows]

        def __repr__(self) -> str:
            return f"_SimpleDF(rows={self._rows!r})"

    class pd:  # minimal namespace shim
        DataFrame = _SimpleDF  # type: ignore

def _df_from_records(records: List[dict]):
    if HAVE_PANDAS:
        return pd.DataFrame(records)
    else:
        return pd.DataFrame(records)  # our shim

def _df_records(df) -> List[Tuple[Any, ...]]:
    if HAVE_PANDAS:
        # Preserve column order and return tuples of row values
        return list(map(tuple, df.itertuples(index=False, name=None)))
    else:
        return df.to_records()  # our shim

# LC-style function signature
def selectFirstRows(employees: "pd.DataFrame") -> "pd.DataFrame":
    return employees.head(3)

# Also expose a class Solution wrapper per the contract
class Solution:
    def selectFirstRows(self, employees: "pd.DataFrame") -> "pd.DataFrame":
        return selectFirstRows(employees)

# --- Tests (deterministic, stdlib only) ---
def _make_sample():
    return [
        {"employee_id": 3, "name": "Bob", "department": "Operations", "salary": 48675},
        {"employee_id": 90, "name": "Alice", "department": "Sales", "salary": 11096},
        {"employee_id": 9, "name": "Tatiana", "department": "Engineering", "salary": 33805},
        {"employee_id": 60, "name": "Annabelle", "department": "InformationTechnology", "salary": 37678},
    ]

def _run_tests():
    sol = Solution()

    # 1) Typical 4-row case
    df = _df_from_records(_make_sample())
    out = sol.selectFirstRows(df)
    exp = _df_from_records(_make_sample()[:3])
    assert _df_records(out) == _df_records(exp)

    # 2) Fewer than 3 rows
    df2 = _df_from_records(_make_sample()[:2])
    out2 = selectFirstRows(df2)
    exp2 = _df_from_records(_make_sample()[:2])
    assert _df_records(out2) == _df_records(exp2)

    # 3) Empty DataFrame
    df3 = _df_from_records([])
    out3 = selectFirstRows(df3)
    exp3 = _df_from_records([])
    assert _df_records(out3) == _df_records(exp3)

_run_tests()
\end{minted}
\VALIDATION{Checked typical input, fewer than 3 rows, and empty input.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use position-based slicing. In pandas, \texttt{employees.iloc[:3]} returns the first three rows efficiently. Fall back to \texttt{head(3)} if \texttt{iloc} is not available (shim).}
\ASSUMPTIONS{The DataFrame supports zero-based positional slicing via \texttt{.iloc}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If the DataFrame has attribute \texttt{iloc}, return \texttt{employees.iloc[:3]}.
\item Otherwise, return \texttt{employees.head(3)}.
\item Done.
\end{algosteps}
\COMPLEXITY{Same as baseline: $T(n)=\mathcal{O}(\min(n,3))$, $S(n)=\mathcal{O}(\min(n,3))$.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(\min(n,3)).
\end{aligned}
\]
\CORRECTNESS{Slicing from the start by three positions yields exactly the first three rows and preserves ordering and columns.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import Any, List, Tuple

try:
    import pandas as pd  # type: ignore
    HAVE_PANDAS = True
except Exception:
    HAVE_PANDAS = False
    class _SimpleDF:
        def __init__(self, records: List[dict]):
            self._rows = list(records)
            self.columns = list(records[0].keys()) if records else []
        def head(self, n: int = 5) -> "_SimpleDF":
            return _SimpleDF(self._rows[:n])
        def to_records(self):
            return [tuple(row.get(c) for c in self.columns) for row in self._rows]
    class pd:
        DataFrame = _SimpleDF  # type: ignore

def _df_from_records(records: List[dict]):
    return pd.DataFrame(records)

def _df_records(df) -> List[Tuple[Any, ...]]:
    if hasattr(df, "itertuples"):  # pandas
        return list(map(tuple, df.itertuples(index=False, name=None)))
    else:  # shim
        return df.to_records()

def selectFirstRows(employees: "pd.DataFrame") -> "pd.DataFrame":
    if hasattr(employees, "iloc"):
        return employees.iloc[:3]  # pandas path
    return employees.head(3)       # shim path

class Solution:
    def selectFirstRows(self, employees: "pd.DataFrame") -> "pd.DataFrame":
        return selectFirstRows(employees)

def _make_sample():
    return [
        {"employee_id": 3, "name": "Bob", "department": "Operations", "salary": 48675},
        {"employee_id": 90, "name": "Alice", "department": "Sales", "salary": 11096},
        {"employee_id": 9, "name": "Tatiana", "department": "Engineering", "salary": 33805},
        {"employee_id": 60, "name": "Annabelle", "department": "InformationTechnology", "salary": 37678},
    ]

def _run_tests():
    df = _df_from_records(_make_sample())
    out = selectFirstRows(df)
    exp = _df_from_records(_make_sample()[:3])
    assert _df_records(out) == _df_records(exp)

    df2 = _df_from_records(_make_sample()[:1])
    out2 = Solution().selectFirstRows(df2)
    exp2 = _df_from_records(_make_sample()[:1])
    assert _df_records(out2) == _df_records(exp2)

    df3 = _df_from_records([])
    out3 = selectFirstRows(df3)
    exp3 = _df_from_records([])
    assert _df_records(out3) == _df_records(exp3)

_run_tests()
\end{minted}
\VALIDATION{Verified behavior for 3+ rows, exactly 1 row, and empty input.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the canonical API \texttt{head(3)}. It is idiomatic, clear, and directly expresses the prefix constraint.}
\ASSUMPTIONS{The DataFrame API conforms to pandas semantics.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Return \texttt{employees.head(3)}.
\item Nothing else is needed.
\item Done.
\end{algosteps}
\OPTIMALITY{No method can asymptotically improve on copying at most three rows. \texttt{head(3)} is idiomatic and minimal.}
\COMPLEXITY{$T(n)=\mathcal{O}(\min(n,3))$, $S(n)=\mathcal{O}(\min(n,3))$.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(\min(n,3)).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import Any, List, Tuple

try:
    import pandas as pd  # type: ignore
    HAVE_PANDAS = True
except Exception:
    HAVE_PANDAS = False
    class _SimpleDF:
        def __init__(self, records: List[dict]):
            self._rows = list(records)
            self.columns = list(records[0].keys()) if records else []
        def head(self, n: int = 5) -> "_SimpleDF":
            return _SimpleDF(self._rows[:n])
        def to_records(self):
            return [tuple(row.get(c) for c in self.columns) for row in self._rows]
    class pd:
        DataFrame = _SimpleDF  # type: ignore

def selectFirstRows(employees: "pd.DataFrame") -> "pd.DataFrame":
    return employees.head(3)

class Solution:
    def selectFirstRows(self, employees: "pd.DataFrame") -> "pd.DataFrame":
        return selectFirstRows(employees)

# Exactly 3 asserts
def _df_from_records(records: List[dict]):
    return pd.DataFrame(records)

def _df_records(df) -> List[Tuple[Any, ...]]:
    if hasattr(df, "itertuples"):
        return list(map(tuple, df.itertuples(index=False, name=None)))
    return df.to_records()

def _make_sample():
    return [
        {"employee_id": 3, "name": "Bob", "department": "Operations", "salary": 48675},
        {"employee_id": 90, "name": "Alice", "department": "Sales", "salary": 11096},
        {"employee_id": 9, "name": "Tatiana", "department": "Engineering", "salary": 33805},
        {"employee_id": 60, "name": "Annabelle", "department": "InformationTechnology", "salary": 37678},
    ]

# 3 asserts
_df = _df_from_records(_make_sample())
_out = Solution().selectFirstRows(_df)
_exp = _df_from_records(_make_sample()[:3])
assert _df_records(_out) == _df_records(_exp)

_df2 = _df_from_records(_make_sample()[:2])
assert _df_records(selectFirstRows(_df2)) == _df_records(_df2)

_df3 = _df_from_records([])
assert _df_records(selectFirstRows(_df3)) == _df_records(_df3)
\end{minted}
\VALIDATION{Three asserts: typical case, fewer-than-3 case, and empty case.}
\RESULT{Return the first three rows of \texttt{employees} without reordering rows or columns.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the function on datasets with size 0, 1, 2, 3, and 4+. Verify that the first three rows are returned unchanged and column order is preserved.}
\LINE{CROSS-CHECKS}{Compare outputs from \texttt{head(3)} and \texttt{iloc[:3]} on identical inputs. They must match for all tested cases.}
\LINE{EDGE-CASE GENERATOR}{Construct deterministic arrays of dictionaries to simulate DataFrame rows of varying sizes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Dict

def gen_rows(n: int) -> List[Dict[str, int]]:
    rows = []
    for i in range(n):
        rows.append({
            "employee_id": i + 1,
            "name": f"Name{i+1}",
            "department": "Dept",
            "salary": 1000 + i
        })
    return rows

# Quick property checks against both strategies when pandas is present.
try:
    import pandas as pd  # type: ignore
    HAVE_PANDAS = True
except Exception:
    HAVE_PANDAS = False
    class _SimpleDF:
        def __init__(self, records):
            self._rows = list(records)
            self.columns = list(records[0].keys()) if records else []
        def head(self, n: int = 5):
            return _SimpleDF(self._rows[:n])
        def to_records(self):
            return [tuple(row.get(c) for c in self.columns) for row in self._rows]
    class pd:
        DataFrame = _SimpleDF  # type: ignore

def df_from(records):
    return pd.DataFrame(records)

def recs(df):
    if hasattr(df, "itertuples"):
        return list(map(tuple, df.itertuples(index=False, name=None)))
    return df.to_records()

def first3_head(df):
    return df.head(3)

def first3_slice(df):
    if hasattr(df, "iloc"):
        return df.iloc[:3]
    return df.head(3)

for n in [0, 1, 2, 3, 4, 10]:
    df = df_from(gen_rows(n))
    assert recs(first3_head(df)) == recs(first3_slice(df))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution for LC Pandas: Display the First Three Rows
from typing import Any, List, Tuple

try:
    import pandas as pd  # type: ignore
except Exception:
    class _SimpleDF:
        def __init__(self, records: List[dict]):
            self._rows = list(records)
            self.columns = list(records[0].keys()) if records else []
        def head(self, n: int = 5) -> "_SimpleDF":
            return _SimpleDF(self._rows[:n])
        def to_records(self) -> List[Tuple[Any, ...]]:
            return [tuple(row.get(c) for c in self.columns) for row in self._rows]
    class pd:
        DataFrame = _SimpleDF  # type: ignore

def selectFirstRows(employees: "pd.DataFrame") -> "pd.DataFrame":
    return employees.head(3)

class Solution:
    def selectFirstRows(self, employees: "pd.DataFrame") -> "pd.DataFrame":
        return selectFirstRows(employees)

# Minimal asserts
def _df_from_records(records: List[dict]):
    return pd.DataFrame(records)

def _df_records(df) -> List[Tuple[Any, ...]]:
    if hasattr(df, "itertuples"):
        return list(map(tuple, df.itertuples(index=False, name=None)))
    return df.to_records()

_rows = [
    {"employee_id": 3, "name": "Bob", "department": "Operations", "salary": 48675},
    {"employee_id": 90, "name": "Alice", "department": "Sales", "salary": 11096},
    {"employee_id": 9, "name": "Tatiana", "department": "Engineering", "salary": 33805},
    {"employee_id": 60, "name": "Annabelle", "department": "InformationTechnology", "salary": 37678},
]

_df = _df_from_records(_rows)
_exp = _df_from_records(_rows[:3])
assert _df_records(Solution().selectFirstRows(_df)) == _df_records(_exp)
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Return the first three rows of a DataFrame using a prefix operation.}
\WHY{Common warm-up in DataFrame/pandas interviews to verify familiarity with basic selection operations.}
\CHECKLIST{Use \texttt{head(3)} or \texttt{iloc[:3]}; preserve row and column order; handle $n<3$ by returning all rows.}
\EDGECASES{Empty DataFrame; one row; two rows; exactly three rows; non-contiguous index in pandas; presence of additional unused columns.}
\PITFALLS{Accidentally sorting or reordering; selecting columns instead of rows; off-by-one errors like \texttt{head(2)} or \texttt{iloc[:2]}; using random sampling; dropping the index unintentionally in non-required contexts.}
\FAILMODES{Approaches that filter by content rather than by position will fail on arbitrary data. The prefix methods are position-based and robust.}
\ELI{Just take the top three rows of the table and return them as-is. If there are fewer than three, return whatever is there.}
\NotePages{3}

\end{document}