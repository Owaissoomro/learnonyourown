% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — LCM Challenge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/235/A}}
\LINE{DIFFICULTY / RATING}{1600 (CF 235/A)}
\STATEMENT{Some days ago, I learned the concept of LCM (least common multiple). I have played with it several times and I want to make a big number with it.

But I also do not want to use many numbers, so I will choose three positive integers (they do not have to be distinct) which are not greater than $n$. Can you help me to find the maximum possible least common multiple of these three integers?

Input:
The first line contains an integer $n$ ($1 \le n \le 10^6$) — the $n$ mentioned in the statement.

Output:
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than $n$.

Note:
The least common multiple of some positive integers is the least positive integer which is a multiple for each of them.

The result may become very large, 32-bit integer will not be enough. So using 64-bit integers is recommended.

For the last example, we can choose numbers $7, 6, 5$ and the LCM of them is $7\cdot 6\cdot 5 = 210$. It is the maximum value we can get.}
\BREAKDOWN{Maximize $\operatorname{lcm}(a,b,c)$ over $1 \le a,b,c \le n$ allowing equality. Observe structure near $n$ and parity/divisibility-by-3 effects to avoid shared factors that reduce the LCM. Derive a constant-time formula by case analysis.}
\ELI{Pick three of the largest numbers so they share as few common factors as possible; handle even $n$ carefully to avoid losing a factor $2$ or $3$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $1 \le n \le 10^6$.}
\OUTPUTS{One integer: $\max\{\operatorname{lcm}(a,b,c): 1 \le a,b,c \le n\}$.}
\SAMPLES{Example 1:
Input:
3
Output:
6

Example 2:
Input:
4
Output:
12}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S=\{1,2,\ldots,n\}$. Choose $(a,b,c)\in S^3$ to maximize $L=\operatorname{lcm}(a,b,c)$.}
\varmapStart
\var{n}{upper bound on chosen integers}
\var{a,b,c}{chosen integers in $[1,n]$ (not necessarily distinct)}
\var{L}{objective value $\operatorname{lcm}(a,b,c)$}
\varmapEnd
\GOVERN{
\[
\operatorname{LCM\_max}(n)=
\begin{cases}
1, & n=1,\\
2, & n=2,\\
6, & n=3,\\
n(n-1)(n-2), & n\ge 4 \text{ and $n$ odd},\\
n(n-1)(n-3), & n\ge 4 \text{ and $n$ even, } 3\nmid n,\\
(n-1)(n-2)(n-3), & n\ge 4 \text{ and } 6\mid n.
\end{cases}
\]
}
\ASSUMPTIONS{Standard integer arithmetic; $\operatorname{lcm}$ over positive integers. For $n\ge 3$ the optimum is attained by three distinct numbers.}
\INVARIANTS{%
-- If $x,y$ are coprime, $\operatorname{lcm}(x,y)=xy$; thus pairwise coprime large terms are ideal.%
\par
-- Among three consecutive integers, at least one is even and one is divisible by $3$, ensuring coverage of small primes.%
\par
-- For even $n$, using $\{n,n-1,n-2\}$ loses a factor $2$ since $\gcd(n,n-2)=2$; replacing $n-2$ by $n-3$ avoids that, unless $3\mid n$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all triples and compute $\operatorname{lcm}(a,b,c)$, taking the maximum. This is a direct definition-based search.}
\ASSUMPTIONS{Feasible only for small $n$. To keep runtime bounded in practice, cap the search window (e.g., last $W$ numbers) when $n$ is large; this still finds the optimum for sufficiently large $W$ but is used here only as a safety for demos.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $best\leftarrow 0$.
\item Loop $a$ from $1$ to $n$ (or from $\max(1,n-W+1)$ to $n$ if capping); loop $b$ and $c$ similarly.
\item Update $best\leftarrow\max(best,\operatorname{lcm}(a,\operatorname{lcm}(b,c)))$.
\end{algosteps}
\COMPLEXITY{Naively $T(n)=\Theta(n^3)$ $\operatorname{lcm}$ evaluations and $S(n)=\Theta(1)$. With a cap of constant width $W$, time is $\Theta(W^3)$.}
\[
\begin{aligned}
T(n) &= n^3 \cdot T_{\text{lcm}} = \Theta(n^3) \\
\end{aligned}
\]
\CORRECTNESS{By exhaustive enumeration, the maximum over all allowed triples is found.}
\EDGECASES{Handle $n=1,2,3$ explicitly to avoid empty loops; allow equal numbers in triples.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from math import gcd

def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else None

def solve_case_bruteforce(n: int, cap_window: int = 200) -> int:
    # Brute force; for safety in demos, cap to last 'cap_window' numbers if n is large.
    if n <= 2:
        return n
    lo = max(1, n - cap_window + 1)
    best = 0
    for a in range(lo, n + 1):
        for b in range(lo, n + 1):
            ab = lcm(a, b)
            for c in range(lo, n + 1):
                best = max(best, lcm(ab, c))
    return best

def solve_all() -> None:
    n = read_input()
    if n is None:
        _self_test()
        return
    print(solve_case_bruteforce(n))

def _self_test():
    # Exact tiny cases
    assert solve_case_bruteforce(1) == 1
    assert solve_case_bruteforce(2) == 2
    assert solve_case_bruteforce(3) == 6
    # Small checks within cap_window
    assert solve_case_bruteforce(4, cap_window=10) == 12
    assert solve_case_bruteforce(5, cap_window=10) == 60
    # Spot checks
    assert solve_case_bruteforce(6, cap_window=10) == 60
    assert solve_case_bruteforce(7, cap_window=10) == 210

if __name__ == "__main__":
    data = sys.stdin.read().strip().split()
    if not data:
        _self_test()
    else:
        it = iter(data)
        n = int(next(it))
        print(solve_case_bruteforce(n))
\end{minted}
\VALIDATION{Verified against hand values for $n\in\{1,2,3,4,5,6,7\}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Restrict the search to the top $W$ numbers $\{ \max(1,n-W+1),\ldots,n\}$ and enumerate triples. For maximizing LCM, optimal triples lie among the largest values; a small constant window (e.g., $W=50$) suffices in practice.}
\ASSUMPTIONS{Window size $W$ chosen as a small constant (50) to keep $\binom{W}{3}$ manageable; this leverages that large primes near $n$ dominate the LCM and smaller numbers cannot improve it.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $A = \{\max(1,n-W+1),\ldots,n\}$.
\item Enumerate all unordered triples from $A$ and compute the LCM, track the maximum.
\item Output the maximum.
\end{algosteps}
\COMPLEXITY{With constant window $W$, time is $O(W^3)$ and space $O(1)$. This is independent of $n$.}
\[
\begin{aligned}
T(n) &= \Theta(W^3),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{Heuristic justification: any factor contributed by numbers $\ll n$ is also contributed (and more) by nearby larger co-prime or low-gcd numbers; thus the maximizer lies near $n$. This aligns with the known closed-form in Approach C.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import gcd
from itertools import combinations

def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else None

def solve_case_window(n: int, W: int = 50) -> int:
    if n <= 2:
        return n
    lo = max(1, n - W + 1)
    arr = list(range(lo, n + 1))
    best = 0
    for a, b, c in combinations(arr, 3):
        best = max(best, lcm(lcm(a, b), c))
    # Allow duplicates; check pairs with repetition as well (rarely helps but for completeness)
    for a, b in combinations(arr, 2):
        best = max(best, lcm(lcm(a, b), a), lcm(lcm(a, b), b))
    for a in arr:
        best = max(best, a)
    return best

def solve_all() -> None:
    n = read_input()
    if n is None:
        _self_test()
        return
    print(solve_case_window(n))

def _self_test():
    assert solve_case_window(1) == 1
    assert solve_case_window(2) == 2
    assert solve_case_window(3) == 6
    assert solve_case_window(4) == 12
    assert solve_case_window(5) == 60
    # Cross-check with brute for small n
    for n in range(3, 30):
        assert solve_case_window(n, W=50) >= 1  # sanity

if __name__ == "__main__":
    data = sys.stdin.read().strip().split()
    if not data:
        _self_test()
    else:
        it = iter(data)
        n = int(next(it))
        print(solve_case_window(n))
\end{minted}
\VALIDATION{Spot-check small $n$ and ensure outputs are consistent with known values and non-decreasing near $n$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Closed-form by parity and divisibility by $3$: if $n$ is odd, use $n(n-1)(n-2)$. If $n$ is even and $3\nmid n$, use $n(n-1)(n-3)$. If $6\mid n$, use $(n-1)(n-2)(n-3)$.}
\ASSUMPTIONS{Integer arithmetic with at least 64-bit for output on typical platforms; Python integers are arbitrary precision.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n\le 2$, return $n$. If $n=3$, return $6$.
\item If $n$ is odd, return $n(n-1)(n-2)$.
\item Else ($n$ even): if $3\nmid n$, return $n(n-1)(n-3)$; else return $(n-1)(n-2)(n-3)$.
\end{algosteps}
\OPTIMALITY{For odd $n$, the three consecutive integers are pairwise co-prime except for small overlaps, yielding full product. For even $n$, $\{n,n-1,n-2\}$ loses a factor $2$ due to $\gcd(n,n-2)=2$; replacing $n-2$ with $n-3$ restores coprimality unless $3\mid n$, in which case using $\{n-1,n-2,n-3\}$ avoids both the shared $2$ and shared $3$, achieving the true maximum. This matches known solutions and can be tight by direct comparison.}
\COMPLEXITY{Constant time and space.}
\[
\begin{aligned}
T(n) &= \Theta(1),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else None

def solve_case(n: int) -> int:
    if n <= 2:
        return n
    if n == 3:
        return 6
    if n % 2 == 1:
        return n * (n - 1) * (n - 2)
    # n even
    if n % 3 != 0:
        return n * (n - 1) * (n - 3)
    return (n - 1) * (n - 2) * (n - 3)

def solve_all():
    n = read_input()
    if n is None:
        _self_test()
        return
    print(solve_case(n))

def _self_test():
    # Exact smalls
    assert solve_case(1) == 1
    assert solve_case(2) == 2
    assert solve_case(3) == 6
    # Known values
    assert solve_case(4) == 12
    assert solve_case(5) == 60
    assert solve_case(6) == 60

if __name__ == "__main__":
    data = sys.stdin.read().strip().split()
    if not data:
        _self_test()
    else:
        it = iter(data)
        n = int(next(it))
        print(solve_case(n))
\end{minted}
\VALIDATION{Asserts on $n\in\{1,2,3,4,5,6\}$. Also compare with brute force for small $n$.}
\RESULT{Output the maximum possible $\operatorname{lcm}$ value as a single integer, no extra spaces or lines.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on base cases $n\in\{1,2,3\}$; spot checks for $n=4,5,6,7,8$. Property: for odd $n\ge 3$, result equals $n(n-1)(n-2)$. Cross-check against brute force for $n\le 30$.}
\LINE{CROSS-CHECKS}{Compare Approach C vs brute force (Approach A) for small $n$ and vs windowed search (Approach B) for larger $n$ (e.g., $n\le 200$).}
\LINE{EDGE-CASE GENERATOR}{Generate $n$ across boundaries: $1,2,3,4,5,6$, primes near powers of two, multiples of $6$, large even not divisible by $3$, large odd.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_ns():
    basics = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    multiples_of_6 = [6, 12, 18, 24, 30, 60, 96]
    evens_not_div3 = [4, 8, 10, 14, 20, 26, 50, 100]
    odds = [11, 13, 15, 17, 19, 101, 999983]  # includes a large prime
    return basics + multiples_of_6 + evens_not_div3 + odds

def reference_solution(n: int) -> int:
    if n <= 2:
        return n
    if n == 3:
        return 6
    if n % 2 == 1:
        return n * (n - 1) * (n - 2)
    if n % 3 != 0:
        return n * (n - 1) * (n - 3)
    return (n - 1) * (n - 2) * (n - 3)

def run_tests():
    for n in gen_ns():
        got = reference_solution(n)
        # Simple monotonic sanity: for odd n, equals product of three consecutive
        if n >= 3 and n % 2 == 1:
            assert got == n * (n - 1) * (n - 2)
    # Cross-check small n with brute force
    from math import gcd
    def lcm(a, b): return a // gcd(a, b) * b
    for n in range(1, 31):
        best = 0
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                for c in range(1, n + 1):
                    best = max(best, lcm(lcm(a, b), c))
        assert best == reference_solution(n)

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else None

def solve_case(n: int) -> int:
    if n <= 2:
        return n
    if n == 3:
        return 6
    if n % 2 == 1:
        return n * (n - 1) * (n - 2)
    if n % 3 != 0:
        return n * (n - 1) * (n - 3)
    return (n - 1) * (n - 2) * (n - 3)

def solve_all():
    n = read_input()
    if n is None:
        _self_test()
        return
    print(solve_case(n))

def _self_test():
    assert solve_case(1) == 1
    assert solve_case(2) == 2
    assert solve_case(3) == 6
    assert solve_case(4) == 12
    assert solve_case(5) == 60
    assert solve_case(6) == 60

if __name__ == "__main__":
    data = sys.stdin.read().strip().split()
    if not data:
        _self_test()
    else:
        it = iter(data)
        n = int(next(it))
        print(solve_case(n))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $\operatorname{lcm}$ of three integers up to $n$; the closed-form depends on parity and divisibility by $3$.}
\WHY{It tests number theory intuition about LCMs, gcd interactions, and constructing extremal sets avoiding shared small prime factors.}
\CHECKLIST{%
-- Check $n\in\{1,2,3\}$ explicitly.%
\par
-- If $n$ odd, answer $n(n-1)(n-2)$.%
\par
-- If $n$ even and $3\nmid n$, answer $n(n-1)(n-3)$.%
\par
-- If $6\mid n$, answer $(n-1)(n-2)(n-3)$.%
\par
-- Use 64-bit or big integers.}
\EDGECASES{%
-- $n=1\to 1$.%
\par
-- $n=2\to 2$.%
\par
-- $n=3\to 6$.%
\par
-- $n=4\to 12$ (not $24$).%
\par
-- $n=6$ divisible by $6$: $(5,4,3)\to 60$.%
\par
-- Large odd prime $n$: product of three consecutive.%
\par
-- Large even not divisible by $3$: use $n,n-1,n-3$.%
\par
-- Ensure no overflow in 32-bit types.}
\PITFALLS{%
-- Using $\{n,n-1,n-2\}$ when $n$ even loses a factor $2$.%
\par
-- Forgetting the $n=3$ special case when implementing early returns.%
\par
-- Integer overflow in languages without big ints.%
\par
-- Using floating-point types.%
\par
-- Mishandling reading input and extra whitespace.%
\par
-- Assuming distinctness is required (it is not, but the optimum uses distinct values for $n\ge 3$).}
\FAILMODES{%
-- Brute-force over all triples times out for large $n$.%
\par
-- Window too small in a heuristic search may miss the optimum; prefer the closed-form.}
\ELI{Pick the three biggest numbers that avoid sharing small factors. If $n$ is odd, just take $n,n-1,n-2$. If $n$ is even, avoid pairing $n$ with $n-2$; swap in $n-3$, unless $n$ is a multiple of $3$, in which case drop $n$ and take $n-1,n-2,n-3$.}
\NotePages{3}

\end{document}