% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Longest Line of Consecutive One in Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/}}
\LINE{DIFFICULTY / RATING}{Medium}
\STATEMENT{Given a binary matrix $M$ of size $m \times n$ (each entry is either $0$ or $1$), return the length of the longest line of consecutive $1$'s in the matrix. A line can be:
\begin{bullets}
\item horizontal (left to right in the same row),
\item vertical (top to bottom in the same column),
\item diagonal (top-left to bottom-right),
\item anti-diagonal (top-right to bottom-left).
\end{bullets}
The line must consist of adjacent cells in one of the four directions above. If the matrix contains no $1$'s, return $0$. The matrix is rectangular and may be empty.}
\BREAKDOWN{We need to scan the grid and track, for each cell, how long a consecutive run of $1$'s reaches that cell in each of the four directions, and maintain the global maximum.}
\ELI{Count the longest streak of $1$'s in any straight line direction across the grid.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function input: a list of lists $M$ representing an $m \times n$ binary matrix with entries in $\{0,1\}$. The matrix is rectangular; $m,n \ge 0$.}
\OUTPUTS{Return a single integer equal to the maximum length of a straight line of consecutive $1$'s in any of the four directions. If no $1$ exists, return $0$.}
\SAMPLES{
Example 1:\quad $M=\begin{bmatrix}1&1&0&0\\0&1&1&1\\0&0&1&0\end{bmatrix}$ \ $\to$ result $=3$ (both a horizontal run and a diagonal of length $3$).\\
Example 2:\quad $M=\begin{bmatrix}0&1&1&0\\0&1&1&0\\0&0&0&1\end{bmatrix}$ \ $\to$ result $=2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M \in \{0,1\}^{m \times n}$. For each cell $(i,j)$ with $0 \le i < m$, $0 \le j < n$, define four quantities:
\begin{BreakableEquation*}
H_{i,j}, V_{i,j}, D_{i,j}, A_{i,j}
\end{BreakableEquation*}
representing the lengths of the longest runs of $1$'s ending at $(i,j)$ in the horizontal, vertical, diagonal, and anti-diagonal directions, respectively. The answer is $\max_{i,j}\max\{H_{i,j},V_{i,j},D_{i,j},A_{i,j}\}$.}
\varmapStart
\var{m,n}{numbers of rows and columns}
\var{M}{binary matrix}
\var{H_{i,j}}{horizontal run length ending at $(i,j)$}
\var{V_{i,j}}{vertical run length ending at $(i,j)$}
\var{D_{i,j}}{diagonal run length ending at $(i,j)$}
\var{A_{i,j}}{anti-diagonal run length ending at $(i,j)$}
\var{ans}{global maximum over all directions and cells}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
H_{i,j} &= \begin{cases}
0, & M_{i,j}=0,\\
1 + \mathbf{1}_{j>0}\,H_{i,j-1}, & M_{i,j}=1,
\end{cases}\\
V_{i,j} &= \begin{cases}
0, & M_{i,j}=0,\\
1 + \mathbf{1}_{i>0}\,V_{i-1,j}, & M_{i,j}=1,
\end{cases}\\
D_{i,j} &= \begin{cases}
0, & M_{i,j}=0,\\
1 + \mathbf{1}_{i>0,j>0}\,D_{i-1,j-1}, & M_{i,j}=1,
\end{cases}\\
A_{i,j} &= \begin{cases}
0, & M_{i,j}=0,\\
1 + \mathbf{1}_{i>0,j+1<n}\,A_{i-1,j+1}, & M_{i,j}=1.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Matrix is rectangular; indices are zero-based; neighboring cells for diagonal relations exist only when within bounds.}
\INVARIANTS{
\begin{bullets}
\item At any cell $(i,j)$ with $M_{i,j}=0$, all four directional values are $0$.
\item For $M_{i,j}=1$, each directional value depends only on prior row and/or column entries, enabling a single pass.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly count from every $1$-cell outwards in each of the four directions until a $0$ or boundary is encountered; keep the maximum.}
\ASSUMPTIONS{Bounds checking at each step; early stop on first $0$ or boundary in the current direction.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell $(i,j)$ with $M_{i,j}=1$, iterate in each of the four directions and count consecutive $1$'s.
\item Update a running maximum with the largest count found.
\item Return the maximum after examining all cells and directions.
\end{algosteps}
\COMPLEXITY{For each cell we may scan up to $O(\max\{m,n\})$ in each of four directions, yielding worst-case $T(m,n)=O(mn(m+n))$ and $S(m,n)=O(1)$ extra space.}
\[
\begin{aligned}
T(m,n) &\le 4 \sum_{i=0}^{m-1}\sum_{j=0}^{n-1} \max\{m,n\} \\
       &= O\!\left(mn(m+n)\right).
\end{aligned}
\]
\CORRECTNESS{Every possible line has some starting cell; counting outward from every $1$-cell in every direction guarantees encountering the full length of that line, thus the maximum is captured.}
\EDGECASES{Empty matrix; single row or column; all zeros; all ones; isolated ones; runs touching boundaries.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestLine(self, mat: List[List[int]]) -> int:
        # Brute-force: for every 1-cell, expand in 4 directions
        if not mat or not mat[0]:
            return 0
        m, n = len(mat), len(mat[0])
        ans = 0

        def count_dir(i: int, j: int, di: int, dj: int) -> int:
            cnt = 0
            x, y = i, j
            while 0 <= x < m and 0 <= y < n and mat[x][y] == 1:
                cnt += 1
                x += di
                y += dj
            return cnt

        dirs = [(0, 1), (1, 0), (1, 1), (1, -1)]  # H, V, D, A
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 1:
                    for di, dj in dirs:
                        ans = max(ans, count_dir(i, j, di, dj))
        return ans

# Basic asserts
sol = Solution()
assert sol.longestLine([]) == 0
assert sol.longestLine([[1,1,1,1]]) == 4
assert sol.longestLine([[1,1,0,0],[0,1,1,1],[0,0,1,0]]) == 3
assert sol.longestLine([[0,1,1,0],[0,1,1,0],[0,0,0,1]]) == 2
\end{minted}
\VALIDATION{Verified against tiny cases: empty, single row of ones, mixed matrix with diagonal length $3$, and a case whose maximum is $2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Dynamic Programming with 4 directional tables}
\WHICHFORMULA{Use the recurrences for $H,V,D,A$ so each directional length at $(i,j)$ is computed from previously computed neighbors in $O(1)$ time.}
\ASSUMPTIONS{Four 2D DP arrays or a single 3D array of size $m \times n \times 4$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize four $m \times n$ arrays for horizontal, vertical, diagonal, and anti-diagonal lengths with zeros.
\item For each cell in row-major order, if $M_{i,j}=1$ update:
$H_{i,j}=1+\mathbf{1}_{j>0}H_{i,j-1}$, $V_{i,j}=1+\mathbf{1}_{i>0}V_{i-1,j}$, $D_{i,j}=1+\mathbf{1}_{i>0,j>0}D_{i-1,j-1}$, $A_{i,j}=1+\mathbf{1}_{i>0,j+1<n}A_{i-1,j+1}$.
\item Maintain a running maximum over these four values.
\end{algosteps}
\COMPLEXITY{Each cell is processed once with $O(1)$ work, so $T(m,n)=O(mn)$. Space is $O(mn)$ for the four tables.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn),\quad S(m,n)=\Theta(mn).
\end{aligned}
\]
\CORRECTNESS{By induction on row-major order, each DP entry correctly equals the length of the longest run ending at $(i,j)$ in its direction, since it extends the prior cell if and only if that prior exists and equals $1$. Taking the max over all four directions and all cells yields the answer.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestLine(self, mat: List[List[int]]) -> int:
        if not mat or not mat[0]:
            return 0
        m, n = len(mat), len(mat[0])
        H = [[0]*n for _ in range(m)]
        V = [[0]*n for _ in range(m)]
        D = [[0]*n for _ in range(m)]
        A = [[0]*n for _ in range(m)]
        ans = 0
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 1:
                    H[i][j] = 1 + (H[i][j-1] if j > 0 else 0)
                    V[i][j] = 1 + (V[i-1][j] if i > 0 else 0)
                    D[i][j] = 1 + (D[i-1][j-1] if i > 0 and j > 0 else 0)
                    A[i][j] = 1 + (A[i-1][j+1] if i > 0 and j+1 < n else 0)
                    ans = max(ans, H[i][j], V[i][j], D[i][j], A[i][j])
                # else all zeros remain zero
        return ans

# Checks
sol = Solution()
assert sol.longestLine([]) == 0
assert sol.longestLine([[0]]) == 0
assert sol.longestLine([[1,1,0,0],[0,1,1,1],[0,0,1,0]]) == 3
assert sol.longestLine([[0,1,1,0],[0,1,1,0],[0,0,0,1]]) == 2
\end{minted}
\VALIDATION{Edge checks include empty matrix, single zero, and mixed cases hitting each direction.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single-Pass DP with $O(n)$ memory}
\WHICHFORMULA{Row-scan with rolling arrays: keep vertical lengths per column, plus previous-row diagonals and anti-diagonals to compute current-row values in $O(1)$ each.}
\ASSUMPTIONS{We maintain:
\begin{bullets}
\item vertical: size $n$,
\item diagPrev: size $n$ storing $D_{i-1,\cdot}$,
\item antiPrev: size $n$ storing $A_{i-1,\cdot}$,
\item horizontal accumulator for current row.
\end{bullets}}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize arrays vertical, diagPrev, antiPrev to zeros; ans to $0$.
\item For each row $i$, reset horizontal to $0$ and allocate newDiag, newAnti as zeros.
\item For each column $j$:
\begin{bullets}
\item If $M_{i,j}=1$: update horizontal, vertical[j], diag = $1+(j>0?\,\text{diagPrev}[j-1]:0)$, anti = $1+(j+1<n?\,\text{antiPrev}[j+1]:0)$; write diag, anti into newDiag[j], newAnti[j]; update ans with all four.
\item Else: set horizontal to $0$ and vertical[j] to $0$; newDiag[j]=newAnti[j]=0.
\end{bullets}
\item After finishing row $i$, assign diagPrev = newDiag and antiPrev = newAnti.
\item Return ans after all rows.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect all entries, giving a lower bound $\Omega(mn)$. This method achieves $O(mn)$ time and $O(n)$ extra space, which is optimal up to constant factors for the RAM model when $m \ge 1$.}
\COMPLEXITY{Each cell does $O(1)$ work; memory is three arrays of length $n$ and a scalar.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn),\quad S(m,n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestLine(self, mat: List[List[int]]) -> int:
        if not mat or not mat[0]:
            return 0
        m, n = len(mat), len(mat[0])
        vertical = [0] * n
        diagPrev = [0] * n      # corresponds to D of previous row
        antiPrev = [0] * n      # corresponds to A of previous row
        ans = 0

        for i in range(m):
            horizontal = 0
            newDiag = [0] * n
            newAnti = [0] * n
            for j in range(n):
                if mat[i][j] == 1:
                    horizontal += 1
                    vertical[j] += 1
                    d = 1 + (diagPrev[j-1] if j > 0 else 0)
                    a = 1 + (antiPrev[j+1] if j+1 < n else 0)
                    newDiag[j] = d
                    newAnti[j] = a
                    ans = max(ans, horizontal, vertical[j], d, a)
                else:
                    horizontal = 0
                    vertical[j] = 0
                    newDiag[j] = 0
                    newAnti[j] = 0
            diagPrev = newDiag
            antiPrev = newAnti
        return ans

# Exactly 3 asserts
sol = Solution()
assert sol.longestLine([[1,1,0,0],[0,1,1,1],[0,0,1,0]]) == 3
assert sol.longestLine([[0,1,1,0],[0,1,1,0],[0,0,0,1]]) == 2
assert sol.longestLine([]) == 0
\end{minted}
\VALIDATION{Tests cover: diagonal/horizontal maximum $3$; mixed case with maximum $2$; and empty matrix returning $0$.}
\RESULT{Returns the maximum count of consecutive $1$'s along any horizontal, vertical, diagonal, or anti-diagonal line.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests should include: empty matrix; all zeros; all ones in a line; random small matrices; stress with one long anti-diagonal and sparse ones elsewhere; borders-only runs; single row/column.}
\LINE{CROSS-CHECKS}{On small matrices (e.g., $m,n \le 5$), compare outputs of Approach A, B, and C to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Produce cases like: $1 \times n$, $m \times 1$, checkerboards (no runs longer than $1$), and matrices with a single long diagonal or anti-diagonal.}
\begin{minted}{python}
from typing import List
import random

def brute_force(mat: List[List[int]]) -> int:
    if not mat or not mat[0]:
        return 0
    m, n = len(mat), len(mat[0])
    ans = 0
    dirs = [(0,1),(1,0),(1,1),(1,-1)]
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1:
                for di,dj in dirs:
                    x,y=i,j
                    cnt=0
                    while 0<=x<m and 0<=y<n and mat[x][y]==1:
                        cnt+=1;x+=di;y+=dj
                    ans=max(ans,cnt)
    return ans

class Solution:
    def longestLine(self, mat: List[List[int]]) -> int:
        if not mat or not mat[0]:
            return 0
        m, n = len(mat), len(mat[0])
        vertical = [0] * n
        diagPrev = [0] * n
        antiPrev = [0] * n
        ans = 0
        for i in range(m):
            horizontal = 0
            newDiag = [0] * n
            newAnti = [0] * n
            for j in range(n):
                if mat[i][j] == 1:
                    horizontal += 1
                    vertical[j] += 1
                    d = 1 + (diagPrev[j-1] if j > 0 else 0)
                    a = 1 + (antiPrev[j+1] if j+1 < n else 0)
                    newDiag[j] = d
                    newAnti[j] = a
                    if horizontal > ans: ans = horizontal
                    if vertical[j] > ans: ans = vertical[j]
                    if d > ans: ans = d
                    if a > ans: ans = a
                else:
                    horizontal = 0
                    vertical[j] = 0
                    newDiag[j] = 0
                    newAnti[j] = 0
            diagPrev = newDiag
            antiPrev = newAnti
        return ans

# Cross-check A vs C on random small cases
rng = random.Random(0)
for m in range(1,6):
    for n in range(1,6):
        for _ in range(50):
            mat = [[rng.randint(0,1) for _ in range(n)] for _ in range(m)]
            assert Solution().longestLine(mat) == brute_force(mat)

# Edge-case generator checks
assert Solution().longestLine([[1]*7]) == 7
assert Solution().longestLine([[1],[1],[1],[1]]) == 4
assert Solution().longestLine([[0,1,0],[1,0,1],[0,1,0]]) == 1
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestLine(self, mat: List[List[int]]) -> int:
        # O(mn) time, O(n) extra space
        if not mat or not mat[0]:
            return 0
        m, n = len(mat), len(mat[0])
        vertical = [0] * n
        diagPrev = [0] * n
        antiPrev = [0] * n
        ans = 0
        for i in range(m):
            horizontal = 0
            newDiag = [0] * n
            newAnti = [0] * n
            for j in range(n):
                if mat[i][j] == 1:
                    horizontal += 1
                    vertical[j] += 1
                    d = 1 + (diagPrev[j-1] if j > 0 else 0)
                    a = 1 + (antiPrev[j+1] if j+1 < n else 0)
                    newDiag[j] = d
                    newAnti[j] = a
                    if horizontal > ans: ans = horizontal
                    if vertical[j] > ans: ans = vertical[j]
                    if d > ans: ans = d
                    if a > ans: ans = a
                else:
                    horizontal = 0
                    vertical[j] = 0
                    newDiag[j] = 0
                    newAnti[j] = 0
            diagPrev = newDiag
            antiPrev = newAnti
        return ans

# Sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestLine([]) == 0
    assert sol.longestLine([[1,1,1,1]]) == 4
    assert sol.longestLine([[1,1,0,0],[0,1,1,1],[0,0,1,0]]) == 3
    assert sol.longestLine([[0,1,1,0],[0,1,1,0],[0,0,0,1]]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the longest consecutive $1$'s in any straight-line direction in a binary matrix.}
\WHY{A classic DP-on-grids pattern that tests directional dependencies, boundary handling, and space optimization.}
\CHECKLIST{
\begin{bullets}
\item Define four directions precisely.
\item Decide traversal order (row-major works).
\item Maintain per-direction state and update max.
\item Handle boundaries for $j-1$, $i-1$, and $j+1$ carefully.
\item Consider empty matrix early return.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Empty matrix or empty rows $\to 0$.
\item Single cell $0$ or $1$.
\item Single row / single column.
\item All zeros vs. all ones.
\item Lines that end on edges or start at corners.
\item Multiple equal-length maximum lines.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Mixing up diagonal vs. anti-diagonal neighbor indices.
\item Overwriting 1D DP arrays before reading needed previous-row values.
\item Forgetting to reset horizontal to $0$ on a zero cell.
\item Not zeroing vertical[j] when encountering a zero.
\item Off-by-one when checking $j>0$ and $j+1<n$.
\item Not updating the global maximum with all four directions.
\item Assuming non-rectangular input; LC matrices are rectangular.
\item Missing early return on empty input.
\end{bullets}}
\FAILMODES{Brute force times out on large dense matrices. Incorrect DP indexing yields overcounted diagonals or missed anti-diagonals; rolling-array approach avoids full $O(mn)$ memory while preserving correctness.}
\ELI{Walk the grid once, remembering how long your current streak of ones is in each direction that could end at the current cell. Reset on zeros, extend on ones, and keep the best seen value.}
\NotePages{3}

\end{document}