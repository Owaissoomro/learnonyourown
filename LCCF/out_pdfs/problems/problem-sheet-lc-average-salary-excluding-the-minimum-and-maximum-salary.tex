% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Average Salary Excluding the Minimum and Maximum Salary}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an array of \textbf{unique} integers \texttt{salary} where \texttt{salary[i]} is the salary of the $i$th employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within $10^{-5}$ of the actual answer will be accepted.

\textbf{Example 1:}

Input: \texttt{salary = [4000,3000,1000,2000]} \\
Output: \texttt{2500.00000} \\
Explanation: Minimum salary and maximum salary are $1000$ and $4000$ respectively. Average salary excluding minimum and maximum salary is $(2000 + 3000) / 2 = 2500$.

\textbf{Example 2:}

Input: \texttt{salary = [1000,2000,3000]} \\
Output: \texttt{2000.00000} \\
Explanation: Minimum salary and maximum salary are $1000$ and $3000$ respectively. Average salary excluding minimum and maximum salary is $(2000) / 1 = 2000$.

\textbf{Constraints:}
\begin{bullets}
\item $3 \le n \le 100$, where $n = \lvert \texttt{salary} \rvert$.
\item $1{,}000 \le \texttt{salary}[i] \le 10^6$ for all valid $i$.
\item All the integers of \texttt{salary} are \textbf{unique}.
\end{bullets}}
\BREAKDOWN{Compute the sum, minimum, and maximum over the array, then remove the extremes from the sum and divide by the count $n-2$. Sorting also works but is unnecessary.}
\ELI{Add up all salaries, subtract the biggest and smallest, then divide by how many are left.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{salary} of distinct integers with length $n$ where $3 \le n \le 100$ and each value is in $[1{,}000, 10^6]$.}
\OUTPUTS{A floating-point number equal to the average of all entries of \texttt{salary} except its single minimum and single maximum element. Any answer within absolute error $10^{-5}$ is accepted.}
\SAMPLES{\textbf{Sample A}

Input: \texttt{[4000,3000,1000,2000]} \\
Output: \texttt{2500.00000}

\textbf{Sample B}

Input: \texttt{[1000,2000,3000]} \\
Output: \texttt{2000.00000}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S = \{s_1,\ldots,s_n\}$ with all $s_i$ distinct. Define
\begin{BreakableEquation*}
\operatorname{avg\_excl}(S) \triangleq \frac{\sum_{i=1}^{n} s_i - \min(S) - \max(S)}{n-2}.
\end{BreakableEquation*}
Compute $\operatorname{avg\_excl}(S)$ for the given multiset (here set) of salaries.}
\varmapStart
\var{n}{number of employees, $n = \lvert S \rvert = \lvert \texttt{salary} \rvert$}
\var{s_i}{salary of employee $i$}
\var{m_{\min}}{minimum element in $S$}
\var{m_{\max}}{maximum element in $S$}
\var{\Sigma}{sum $\sum_{i=1}^{n} s_i$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\operatorname{avg\_excl}(S) = \frac{\Sigma - m_{\min} - m_{\max}}{n-2},\quad n \ge 3.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All $s_i$ are integers and pairwise distinct; $n \ge 3$. Division by $n-2$ is safe.}
\INVARIANTS{
\begin{bullets}
\item $\min(S) \le s_i \le \max(S)$ for all $i$.
\item $\sum_{i=1}^{n} s_i - \min(S) - \max(S)$ equals the sum of the $n-2$ middle elements under any ordering.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sort the array, drop the first and last elements, and average the remaining $n-2$ numbers. This directly implements the definition while leveraging sorting to identify extremes.}
\ASSUMPTIONS{Sorting cost $O(n \log n)$ is acceptable for small $n$, and elements are distinct so the first and last are unique extremes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \texttt{salary} in nondecreasing order to get $a_1 \le \cdots \le a_n$.
\item Compute $t = \sum_{i=2}^{n-1} a_i$.
\item Return $t / (n-2)$ as a float.
\end{algosteps}
\COMPLEXITY{Sorting dominates time. Space due to sorted copy (or in-place).}
\[
\begin{aligned}
T(n) &= O(n \log n) \\
S(n) &= O(1)\ \text{(in-place)}\ \text{or}\ O(n)\ \text{(with copy)}.
\end{aligned}
\]
\CORRECTNESS{After sorting, the smallest and largest are at positions $1$ and $n$. Summing indices $2$ to $n-1$ includes exactly the $n-2$ non-extreme elements.}
\EDGECASES{Minimum $n=3$ leaves exactly one middle element; the sum of indices $2$ to $2$ works and division by $1$ is valid.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def average(self, salary: List[int]) -> float:
        # Sort, drop extremes, average the rest
        arr = sorted(salary)
        middle_sum = sum(arr[1:-1])
        return middle_sum / (len(arr) - 2)

# Asserts
s = Solution()
assert abs(s.average([4000, 3000, 1000, 2000]) - 2500.0) < 1e-9
assert abs(s.average([1000, 2000, 3000]) - 2000.0) < 1e-9
# Random-order sanity
assert abs(s.average([6000, 1000, 2000, 4000, 3000, 5000]) - 3500.0) < 1e-9
\end{minted}
\VALIDATION{Sorting-based answer should equal one-pass method on random permutations; examples above cover $n=3$ and a larger $n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{We do not need sorting. A single pass keeps $\Sigma$, $m_{\min}$, and $m_{\max}$, then computes $(\Sigma - m_{\min} - m_{\max})/(n-2)$.}
\ASSUMPTIONS{At least three elements and all are distinct, so there is a unique min and max.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $\Sigma \leftarrow 0$, $m_{\min} \leftarrow +\infty$, $m_{\max} \leftarrow -\infty$.
\item For each $x$ in \texttt{salary}: update $\Sigma \mathrel{+}= x$, $m_{\min} \leftarrow \min(m_{\min}, x)$, $m_{\max} \leftarrow \max(m_{\max}, x)$.
\item Return $(\Sigma - m_{\min} - m_{\max}) / (n-2)$.
\end{algosteps}
\COMPLEXITY{Linear time and constant extra space, which beats sorting.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{By invariant maintenance, after the pass $\Sigma$ equals the total sum and $m_{\min}, m_{\max}$ are the true extremes. Subtracting them removes exactly the two excluded elements.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def average(self, salary: List[int]) -> float:
        total = 0
        mn = float('inf')
        mx = float('-inf')
        for x in salary:
            total += x
            if x < mn:
                mn = x
            if x > mx:
                mx = x
        return (total - mn - mx) / (len(salary) - 2)

# Asserts
s = Solution()
assert abs(s.average([4000, 3000, 1000, 2000]) - 2500.0) < 1e-9
assert abs(s.average([1000, 2000, 3000]) - 2000.0) < 1e-9
# Adversarial order (min at end, max at start)
assert abs(s.average([5000, 2000, 3000, 4000, 1000]) - 3000.0) < 1e-9
\end{minted}
\VALIDATION{Edge layout with min/max at extremes of iteration order; confirm numerically with examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single pass tracking sum, min, and max is optimal in the comparison model: one must at least read all elements.}
\ASSUMPTIONS{Distinct elements; numeric range fits within Python integers (unbounded). In fixed-width types, ensure no overflow when summing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize accumulators: total, current min, current max.
\item Scan each value once, updating these three variables.
\item Compute and return $(\text{total} - \text{min} - \text{max})/(n-2)$.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect all $n$ inputs to know the min and max, giving a lower bound $\Omega(n)$. This method matches the lower bound and uses $O(1)$ extra space.}
\COMPLEXITY{Linear time with constant space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \qquad S(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def average(self, salary: List[int]) -> float:
        total = 0
        lo = float('inf')
        hi = float('-inf')
        for v in salary:
            total += v
            if v < lo:
                lo = v
            if v > hi:
                hi = v
        return (total - lo - hi) / (len(salary) - 2)

# Exactly 3 asserts
_s = Solution()
assert abs(_s.average([4000, 3000, 1000, 2000]) - 2500.0) < 1e-9
assert abs(_s.average([1000, 2000, 3000]) - 2000.0) < 1e-9
assert abs(_s.average([8000, 1000, 6000, 7000, 9000, 2000]) - 7000.0) < 1e-9
\end{minted}
\VALIDATION{Three asserts cover minimal $n=3$, a general case, and a larger shuffled case.}
\RESULT{Return a Python \texttt{float} equal to the arithmetic mean of all salaries except the single minimum and single maximum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on:
\begin{bullets}
\item Minimal size $n=3$ across varied values and orders.
\item Random permutations verifying equivalence of sort-based and one-pass methods.
\item Cases with tightly clustered middle values and far-apart extremes.
\end{bullets}}
\LINE{CROSS-CHECKS}{For small arrays, compare the one-pass result to sorting-based computation on the same inputs. They must match within a tiny tolerance.}
\LINE{EDGE-CASE GENERATOR}{Generate random arrays with distinct integers, then force-insert unique min and max outside the middle range to stress updates when min/max appear anywhere.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_case(n: int, seed: int = 0) -> List[int]:
    random.seed(seed)
    # Middle values
    mids = random.sample(range(1500, 8500), n - 2)
    lo = 1000
    hi = 10000
    arr = mids + [lo, hi]
    random.shuffle(arr)
    return arr

def avg_sort(a: List[int]) -> float:
    b = sorted(a)
    return sum(b[1:-1]) / (len(b) - 2)

def avg_onepass(a: List[int]) -> float:
    total = 0
    mn = float('inf')
    mx = float('-inf')
    for x in a:
        total += x
        if x < mn: mn = x
        if x > mx: mx = x
    return (total - mn - mx) / (len(a) - 2)

# Cross-check a few seeds and sizes
for seed in range(5):
    for n in (3, 5, 10):
        arr = gen_case(n, seed)
        x = avg_sort(arr)
        y = avg_onepass(arr)
        assert abs(x - y) < 1e-9
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def average(self, salary: List[int]) -> float:
        total = 0
        mn = float('inf')
        mx = float('-inf')
        for s in salary:
            total += s
            if s < mn:
                mn = s
            if s > mx:
                mx = s
        return (total - mn - mx) / (len(salary) - 2)

# Basic submission-time sanity checks
if __name__ == "__main__":
    sol = Solution()
    assert abs(sol.average([4000, 3000, 1000, 2000]) - 2500.0) < 1e-9
    assert abs(sol.average([1000, 2000, 3000]) - 2000.0) < 1e-9
    # Mixed order, min/max internal positions in iteration
    assert abs(sol.average([7000, 5000, 1000, 6000, 4000, 3000, 8000]) - 5250.0) < 1e-9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Average all but the smallest and largest salaries: $(\sum - \min - \max)/(n-2)$.}
\WHY{A frequent warm-up that tests recognition of removing outliers without resorting to unnecessary sorting.}
\CHECKLIST{
\begin{bullets}
\item Read $n$ and confirm $n \ge 3$.
\item Single pass: update sum, min, max.
\item Compute numerator = sum $-$ min $-$ max.
\item Divide by $n-2$ as float and return.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=3$ (only one middle element).
\item Min at the end of the array.
\item Max at the beginning of the array.
\item Nearly equal middle values with far-away extremes.
\item Large magnitudes up to $10^6$.
\item Random orderings of the same set.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Accidentally dividing by $n$ instead of $n-2$.
\item Forgetting to remove both extremes (subtracting only one).
\item Using integer division in languages where \texttt{/} truncates.
\item Overflow in fixed-width integer languages when summing; use wider type.
\item Sorting unnecessarily, increasing time complexity.
\item Misreading constraints where values might not be distinct (here they are).
\end{bullets}}
\FAILMODES{Brute-force averaging without excluding extremes yields wrong answers. Sorting-based methods are correct but slower; they still survive constraints here but are not optimal.}
\ELI{Look at the biggest and smallest numbers, throw them out, add up what is left, and divide by how many remain. One quick pass through the list is enough.}
\NotePages{3}

\end{document}