% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Treeland Tour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/490/F}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{The ``Road Accident'' band is planning an unprecedented tour around Treeland. The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have.

Treeland consists of $n$ cities, some pairs of cities are connected by bidirectional roads. Overall the country has $n - 1$ roads. We know that it is possible to get to any city from any other one. The cities are numbered by integers from $1$ to $n$. For every city we know its value $r_i$ — the number of people in it.

We know that the band will travel along some path, having concerts in some cities along the path. The band's path will not pass one city twice, each time they move to the city that hasn't been previously visited. Thus, the musicians will travel along some path (without visiting any city twice) and in some (not necessarily all) cities along the way they will have concerts.

The band plans to gather all the big stadiums and concert halls during the tour, so every time they will perform in a city which population is larger than the population of the previously visited with concert city. In other words, the sequence of population in the cities where the concerts will be held is strictly increasing.

In a recent interview with the leader of the ``road accident'' band promised to the fans that the band will give concert in the largest possible number of cities! Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities, so that the population number will increase, and the number of concerts will be the largest possible.

The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland. Looks like they can't manage without some help from a real programmer! Help the fans find the sought number of concerts.

Input:
The first line of the input contains integer $n$ ($2 \le n \le 6000$) — the number of cities in Treeland. The next line contains $n$ integers $r_1, r_2, \ldots, r_n$ ($1 \le r_i \le 10^6$), where $r_i$ is the population of the $i$-th city. The next $n - 1$ lines contain the descriptions of the roads, one road per line. Each road is defined by a pair of integers $a_j, b_j$ ($1 \le a_j, b_j \le n$) — the pair of the numbers of the cities that are connected by the $j$-th road. All numbers in the lines are separated by spaces.

Output:
Print the number of cities where the ``Road Accident'' band will have concerts.}
\BREAKDOWN{We have a tree with vertex weights. We can choose any simple path and then choose a strictly increasing subsequence of the weights along that path. Maximize the subsequence length over all paths.}
\ELI{Among all simple paths in the tree, pick the one whose node values contain the longest strictly increasing subsequence; return its length.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test case.\\
-- $n$: integer, $2 \le n \le 6000$.\\
-- $r_1,\ldots,r_n$: integers, $1 \le r_i \le 10^6$.\\
-- $n-1$ undirected edges $(a_j,b_j)$ forming a tree.}
\OUTPUTS{A single integer: the maximum possible number of concerts, i.e., the maximum length of a strictly increasing subsequence along some simple path.}
\SAMPLES{Example 1:\\
Input:
\begin{minipage}[t]{0.9\linewidth}
\begin{minted}{python}
5
1 3 2 4 5
1 2
2 3
3 4
4 5
\end{minted}
\end{minipage}
Output:
\begin{minted}{python}
4
\end{minted}
Explanation: Path 1-2-3-4-5 has values [1,3,2,4,5] with LIS length 4 (e.g., [1,2,4,5]).\\[6pt]
Example 2:\\
Input:
\begin{minipage}[t]{0.9\linewidth}
\begin{minted}{python}
4
7 7 7 7
1 2
2 3
3 4
\end{minted}
\end{minipage}
Output:
\begin{minted}{python}
1
\end{minted}
Explanation: All values equal; the best increasing subsequence along any path has length 1.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree on $|V|=n$ with vertex weights $r:V\to\mathbb{Z}_{>0}$. For any simple path $P=(v_0,v_1,\ldots,v_k)$, define the sequence $(r(v_0),r(v_1),\ldots,r(v_k))$. Let $\operatorname{LIS}(P)$ be the length of the longest strictly increasing subsequence of this sequence. The objective is to compute
\[
\max_{P \text{ simple path in } T} \operatorname{LIS}(P).
\] }
\varmapStart
\var{n}{number of nodes}
\var{r_i}{population (weight) of node $i$}
\var{P}{a simple path in the tree, i.e., vertices with no repeats}
\var{\operatorname{LIS}(P)}{length of longest strictly increasing subsequence along $P$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer}=\max_{u\in V}\ \max_{v\in V}\ \operatorname{LIS}\big(\text{weights along the unique path } u\!\leadsto\! v\big).
\end{BreakableEquation*}
}
\ASSUMPTIONS{The graph is a connected tree (acyclic, $n-1$ edges). Paths are simple by definition. Subsequences are strictly increasing: if we pick indices $i_1<i_2<\cdots<i_t$, then $r(v_{i_1})<r(v_{i_2})<\cdots<r(v_{i_t})$.}
\INVARIANTS{On any fixed path, the standard patience sorting tails array maintains: (i) its length equals the LIS length so far; (ii) replacing a tail value by a smaller one at the same length never decreases the achievable LIS.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all unordered pairs $(u,v)$, extract the unique path $u\!\leadsto\! v$, and compute the LIS length of its weights by the classic $O(m\log m)$ patience algorithm for sequence length $m$.}
\ASSUMPTIONS{Tree shortest path equals unique simple path. Using BFS/parent recovery per pair is acceptable for a conceptual baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pair $(u,v)$ with $u\le v$, recover the path $u\!\leadsto\! v$ (e.g., via BFS or LCA).
\item Gather the sequence of weights along the path in order.
\item Compute the strictly increasing LIS length via patience sorting (\texttt{bisect\_left}).
\item Track the maximum over all pairs.
\end{algosteps}
\COMPLEXITY{Let $m$ be path length. Path recovery in $O(n)$, LIS in $O(m\log m)\le O(n\log n)$. Over $\Theta(n^2)$ pairs:
\[
\begin{aligned}
T(n) &\in \Theta\big(n^2\cdot (n + n\log n)\big)=\Theta(n^3\log n),\\
S(n) &\in O(n).
\end{aligned}
\]}
\CORRECTNESS{Every candidate path is examined; LIS is computed correctly per path by a standard algorithm. The maximum over all paths is thus correct.}
\EDGECASES{All equal values; strictly decreasing chains; stars; single edge; duplicate values interleaved.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    r = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    adj = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        edges.append((a, b))
        adj[a].append(b); adj[b].append(a)
    return n, r, edges

def lis_length_strict(seq):
    # patience sorting for strictly increasing
    from bisect import bisect_left
    tails = []
    for x in seq:
        i = bisect_left(tails, x)
        if i == len(tails):
            tails.append(x)
        else:
            tails[i] = x
    return len(tails)

def shortest_path_in_tree(u, v, adj):
    # BFS from u to v in a tree, return list of vertices along the path
    n = len(adj) - 1
    parent = [-1] * (n + 1)
    q = deque([u])
    parent[u] = 0
    while q:
        x = q.popleft()
        if x == v:
            break
        for y in adj[x]:
            if parent[y] == -1:
                parent[y] = x
                q.append(y)
    path = []
    cur = v
    while cur != 0:
        path.append(cur)
        cur = parent[cur]
    path.reverse()
    return path

def solve_case_bruteforce(n, r, edges):
    adj = [[] for _ in range(n + 1)]
    for a, b in edges:
        adj[a].append(b); adj[b].append(a)
    best = 1
    for u in range(1, n + 1):
        for v in range(u, n + 1):
            path = shortest_path_in_tree(u, v, adj)
            vals = [r[x] for x in path]
            cur = lis_length_strict(vals)
            if cur > best:
                best = cur
    return best

def main():
    parsed = read_input()
    if parsed is None:
        # Self-tests for baseline
        # 1) Path line with increasing values
        n = 4
        r = [0, 1, 2, 3, 4]
        edges = [(1,2),(2,3),(3,4)]
        assert solve_case_bruteforce(n, r, edges) == 4
        # 2) All equal
        n = 4
        r = [0, 7, 7, 7, 7]
        edges = [(1,2),(2,3),(3,4)]
        assert solve_case_bruteforce(n, r, edges) == 1
        # 3) Star with center bridging increase
        n = 5
        r = [0, 2, 1, 3, 4, 5]
        edges = [(1,2),(1,3),(1,4),(1,5)]
        assert solve_case_bruteforce(n, r, edges) == 3
        return
    n, r, edges = parsed
    print(solve_case_bruteforce(n, r, edges))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Manually crafted tiny tests: line graphs, stars, and all-equal arrays ensure LIS behavior is correct.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DFS With Rollback LIS From Each Start}
\WHICHFORMULA{Fix a start node $s$. DFS outward without revisits (tree parent guard), maintaining the patience-sorting tails of weights along the current $s\!\leadsto\!u$ path. The tails length equals the LIS along that path. Roll back changes on backtrack. Take the max over all starts $s$.}
\ASSUMPTIONS{Tree structure guarantees a unique path from $s$ to any visited node; binary search on tails is $O(\log n)$; rollback is $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each start $s$, clear a global \texttt{tails} array.
\item DFS$(u, p)$: insert $r[u]$ into \texttt{tails} via \texttt{bisect\_left}; record position and previous value; update the global answer by $\lvert\texttt{tails}\rvert$.
\item Recurse to neighbors $v\ne p$. After returning, roll back the \texttt{tails} modification (pop or restore previous).
\item Repeat for all starts $s$; output the maximum.
\end{algosteps}
\COMPLEXITY{For each start, each node is visited once, each visit costs one binary search in a \texttt{tails} of size at most depth $\le n$:
\begin{BreakableEquation*}
T(n) \in \Theta(n \cdot n\log n)=\Theta(n^2\log n),\quad S(n)\in O(n).
\end{BreakableEquation*}
This is a major improvement over the cubic baseline and fits $n\le 6000$ with a fast language; it remains acceptable as a pedagogical Python reference.}
\CORRECTNESS{For any fixed start $s$ and current node $u$, the visited sequence equals the weights along the unique path $s\!\leadsto\!u$. The patience algorithm invariant ensures the tails length equals the LIS length on that path. Enumerating all starts covers all simple paths (every simple path has an endpoint $s$).}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    r = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    adj = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        edges.append((a, b))
        adj[a].append(b); adj[b].append(a)
    return n, r, edges

def solve_case_dfs_lis(n, r, edges):
    sys.setrecursionlimit(10000000)
    from bisect import bisect_left
    adj = [[] for _ in range(n + 1)]
    for a, b in edges:
        adj[a].append(b); adj[b].append(a)
    best = 1
    tails = []

    def dfs(u, p):
        nonlocal best
        x = r[u]
        i = bisect_left(tails, x)
        extended = (i == len(tails))
        if extended:
            tails.append(x)
        else:
            prev = tails[i]
            tails[i] = x
        if len(tails) > best:
            best = len(tails)
        for v in adj[u]:
            if v == p:
                continue
            dfs(v, u)
        # rollback
        if extended:
            tails.pop()
        else:
            tails[i] = prev

    for s in range(1, n + 1):
        tails.clear()
        dfs(s, 0)
    return best

def main():
    parsed = read_input()
    if parsed is None:
        # Self-tests for improved approach
        n = 4
        r = [0, 1, 3, 2, 4]
        edges = [(1,2),(2,3),(3,4)]
        assert solve_case_dfs_lis(n, r, edges) == 3  # e.g., [1,2,4]
        n = 4
        r = [0, 4, 3, 2, 1]
        edges = [(1,2),(2,3),(3,4)]
        assert solve_case_dfs_lis(n, r, edges) == 1
        n = 5
        r = [0, 2, 1, 3, 4, 5]
        edges = [(1,2),(1,3),(1,4),(1,5)]
        assert solve_case_dfs_lis(n, r, edges) == 3  # 2-1-3 or 2-1-4, LIS 1-3-4 length 3
        return
    n, r, edges = parsed
    print(solve_case_dfs_lis(n, r, edges))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on lines, stars, and mixed-increasing paths; duplicates handled via \texttt{bisect\_left} (strictness).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Endpoint Enumeration + DFS LIS With Rollback}
\WHICHFORMULA{Provably optimal for this task: the maximum over all simple paths equals the maximum over all paths starting at an endpoint $s$. Enumerating $s\in V$ and running a single DFS with rollback-LIS per $s$ explores all such paths exactly once.}
\ASSUMPTIONS{Tree of size $n\le 6000$. Python implementation is clear and correct; in compiled languages it passes time easily.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency.
\item For each $s\in\{1,\ldots,n\}$: clear \texttt{tails}, run DFS with rollback as in Approach B.
\item Track and output the maximum length encountered.
\end{algosteps}
\OPTIMALITY{Every simple path has two endpoints; picking one as start $s$ yields a unique $s\!\leadsto\!u$ traversal at some DFS node $u$. The patience algorithm yields the exact LIS length for that path. Thus scanning all $s$ covers all candidate paths; no path is missed or overcounted for the max.}
\COMPLEXITY{Let $d(u)$ be depth in the DFS tree when starting at $s$. Each node update is a binary search on \texttt{tails} of size $\le d(u) \le n$. Over all $n$ starts:
\begin{BreakableEquation*}
T(n) \in \Theta(n^2\log n),\quad S(n)\in O(n).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from bisect import bisect_left

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    r = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        edges.append((a, b))
    return n, r, edges

def solve_all(n, r, edges):
    sys.setrecursionlimit(10000000)
    adj = [[] for _ in range(n + 1)]
    for a, b in edges:
        adj[a].append(b); adj[b].append(a)

    best = 1
    tails = []

    def dfs(u, p):
        nonlocal best
        x = r[u]
        i = bisect_left(tails, x)
        extended = (i == len(tails))
        if extended:
            tails.append(x)
        else:
            prev = tails[i]
            tails[i] = x
        if len(tails) > best:
            best = len(tails)
        for v in adj[u]:
            if v == p:
                continue
            dfs(v, u)
        if extended:
            tails.pop()
        else:
            tails[i] = prev

    for s in range(1, n + 1):
        tails.clear()
        dfs(s, 0)
    return best

def main():
    parsed = read_input()
    if parsed is None:
        # Exactly 3 asserts (no I/O)
        n = 5
        r = [0, 1, 3, 2, 4, 5]
        edges = [(1,2),(2,3),(3,4),(4,5)]
        assert solve_all(n, r, edges) == 4
        n = 4
        r = [0, 7, 7, 7, 7]
        edges = [(1,2),(2,3),(3,4)]
        assert solve_all(n, r, edges) == 1
        n = 5
        r = [0, 2, 1, 3, 4, 0]
        edges = [(1,2),(1,3),(3,4),(4,5)]
        # Best path: 2-1-3-4 with values [2,1,3,4] -> LIS 1,3,4 length 3
        assert solve_all(n, r, edges) == 3
        return
    n, r, edges = parsed
    print(solve_all(n, r, edges))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three targeted asserts: increasing line, all-equal line, and a branched case with duplicates.}
\RESULT{The printed integer is the maximum number of concerts achievable under strictly increasing populations along some simple path.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test LIS behavior on sequences derived from small trees; verify duplicates do not extend the LIS; test both chain and star structures; cross-check baseline vs improved vs final on tiny instances.}
\LINE{CROSS-CHECKS}{On $n\le 9$, generate random trees and random weights; compare outputs of brute force (Approach A) and final (Approach C).}
\LINE{EDGE-CASE GENERATOR}{Covers: all equal; strictly increasing along a diameter; strictly decreasing; mixed duplicates; stars; brooms.}
\begin{minted}{python}
import random

def gen_tree(n, rng):
    parents = list(range(1, n + 1))
    edges = []
    for v in range(2, n + 1):
        u = rng.randint(1, v - 1)
        edges.append((u, v))
    return edges

def brute_vs_final_trial():
    # tiny randomized cross-check
    from collections import deque
    def lis_length(seq):
        from bisect import bisect_left
        tails = []
        for x in seq:
            i = bisect_left(tails, x)
            if i == len(tails):
                tails.append(x)
            else:
                tails[i] = x
        return len(tails)

    def path(u, v, adj):
        n = len(adj) - 1
        parent = [-1] * (n + 1)
        q = deque([u])
        parent[u] = 0
        while q:
            x = q.popleft()
            if x == v:
                break
            for y in adj[x]:
                if parent[y] == -1:
                    parent[y] = x
                    q.append(y)
        res = []
        cur = v
        while cur != 0:
            res.append(cur)
            cur = parent[cur]
        return list(reversed(res))

    def brute(n, r, edges):
        adj = [[] for _ in range(n + 1)]
        for a, b in edges:
            adj[a].append(b); adj[b].append(a)
        best = 1
        for u in range(1, n + 1):
            for v in range(u, n + 1):
                p = path(u, v, adj)
                best = max(best, lis_length([r[x] for x in p]))
        return best

    def final(n, r, edges):
        from bisect import bisect_left
        adj = [[] for _ in range(n + 1)]
        for a, b in edges:
            adj[a].append(b); adj[b].append(a)
        best = 1
        tails = []
        sys.setrecursionlimit(1000000)
        def dfs(u, p):
            nonlocal best
            x = r[u]
            i = bisect_left(tails, x)
            extended = (i == len(tails))
            if extended:
                tails.append(x)
            else:
                prev = tails[i]
                tails[i] = x
            best = max(best, len(tails))
            for v in adj[u]:
                if v == p: continue
                dfs(v, u)
            if extended:
                tails.pop()
            else:
                tails[i] = prev
        for s in range(1, n + 1):
            tails.clear()
            dfs(s, 0)
        return best

    rng = random.Random(0)
    for _ in range(50):
        n = rng.randint(2, 9)
        r = [0] + [rng.randint(1, 10) for _ in range(n)]
        edges = gen_tree(n, rng)
        assert brute(n, r, edges) == final(n, r, edges)

if __name__ == "__main__":
    # Run cross-check when this block is executed standalone.
    brute_vs_final_trial()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from bisect import bisect_left

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    r = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        edges.append((a, b))
    return n, r, edges

def solve_all(n, r, edges):
    sys.setrecursionlimit(10000000)
    adj = [[] for _ in range(n + 1)]
    for a, b in edges:
        adj[a].append(b); adj[b].append(a)

    best = 1
    tails = []

    def dfs(u, p):
        nonlocal best
        x = r[u]
        i = bisect_left(tails, x)
        extended = (i == len(tails))
        if extended:
            tails.append(x)
        else:
            prev = tails[i]
            tails[i] = x
        if len(tails) > best:
            best = len(tails)
        for v in adj[u]:
            if v == p:
                continue
            dfs(v, u)
        if extended:
            tails.pop()
        else:
            tails[i] = prev

    for s in range(1, n + 1):
        tails.clear()
        dfs(s, 0)
    return best

def main():
    parsed = read_input()
    if parsed is None:
        # quick smoke tests
        n = 4; r = [0, 1, 2, 3, 4]; edges = [(1,2),(2,3),(3,4)]
        assert solve_all(n, r, edges) == 4
        n = 4; r = [0, 4, 3, 2, 1]; edges = [(1,2),(2,3),(3,4)]
        assert solve_all(n, r, edges) == 1
        n = 5; r = [0, 2, 1, 3, 4, 5]; edges = [(1,2),(1,3),(1,4),(1,5)]
        assert solve_all(n, r, edges) == 3
        return
    n, r, edges = parsed
    print(solve_all(n, r, edges))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the LIS length of node weights along any simple path in a tree.}
\WHY{Tests mastery of LIS invariants, rollback techniques, and exhaustive path coverage in trees under tight constraints.}
\CHECKLIST{%
\begin{bullets}
\item Confirm tree input and read correctly.
\item Use strictly increasing LIS via \texttt{bisect\_left}.
\item DFS from every start; maintain and roll back tails.
\item Update global answer at every DFS visit.
\item Increase recursion limit safely.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item All weights equal $\Rightarrow$ answer $1$.
\item Strictly decreasing along a diameter.
\item Star graphs where best path goes leaf-center-leaf.
\item Duplicate-heavy sequences with sparse increases.
\item Small $n=2$ trivial edge.
\item Long chains with alternating ups and downs.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Using \texttt{bisect\_right} by mistake (would compute non-decreasing).
\item Forgetting to roll back the replaced tail value.
\item Not clearing \texttt{tails} between different starts.
\item Off-by-one in 1-indexed node arrays.
\item Recursion depth too small for long chains.
\item Mutating shared structures across recursion without care.
\end{bullets}}
\FAILMODES{Brute force per pair with naive path recovery is $\Theta(n^3\log n)$ and times out on $n=6000$. The DFS+rollback method avoids recomputing LIS from scratch per path and keeps state size linear in depth.}
\ELI{Walk from each possible starting city, keep the best strictly increasing concert plan along the current road you are following, and undo changes when you backtrack. Track the biggest plan size you ever see.}
\NotePages{3}

\end{document}