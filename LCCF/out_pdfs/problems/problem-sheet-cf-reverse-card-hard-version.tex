% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Reverse Card (Hard Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1967/B2}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{The two versions are different problems. You may want to read both versions. You can make hacks only if both versions are solved.

You are given two positive integers $n$, $m$.

Calculate the number of ordered pairs $(a, b)$ satisfying the following conditions:
\begin{bullets}
\item $1\le a\le n$, $1\le b\le m$;
\item $b \cdot \gcd(a,b)$ is a multiple of $a+b$.
\end{bullets}

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1\le t\le 10^4$). The description of the test cases follows.

The first line of each test case contains two integers $n$, $m$ ($1\le n,m\le 2 \cdot 10^6$).

It is guaranteed that neither the sum of $n$ nor the sum of $m$ over all test cases exceeds $2 \cdot 10^6$.

Output: For each test case, print a single integer: the number of valid pairs.

Note: In the first test case, no pair satisfies the conditions.

In the fourth test case, $(2,2),(3,6),(4,4),(6,3),(6,6),(8,8)$ satisfy the conditions.}
\BREAKDOWN{Normalize by $g=\gcd(a,b)$, letting $a=gx$, $b=gy$ with $\gcd(x,y)=1$. The condition becomes $(x+y)\mid g$, so $g=k(x+y)$. Count coprime pairs $(x,y)$ and scale $k$ under bounds $a\le n$, $b\le m$. Reindex via $s=x+y$ and use inclusion--exclusion or M\"obius to count valid $x$ in ranges.}
\ELI{Write $a=gx$, $b=gy$ with $\gcd(x,y)=1$; the rule forces $x+y$ to divide $g$, so solutions are scaled copies of coprime splits of a sum, clipped by $n,m$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. Integer $t$; then $t$ lines each with $n,m$ where $1\le n,m\le 2\cdot 10^6$. The total $\sum n\le 2\cdot 10^6$, $\sum m\le 2\cdot 10^6$.}
\OUTPUTS{For each test case, one integer: the count of ordered pairs $(a,b)$ with $1\le a\le n$, $1\le b\le m$ and $(a+b)\mid b\cdot \gcd(a,b)$.}
\SAMPLES{Example mini-cases:
\begin{bullets}
\item $n=1$, $m=1$ $\to 0$.
\item $n=2$, $m=2$ $\to 1$ (only $(2,2)$).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $g=\gcd(a,b)$, write $a=gx$, $b=gy$ with $\gcd(x,y)=1$, $x,y\in\mathbb{Z}_{\ge 1}$. The condition $a+b\mid b\cdot g$ becomes $(x+y)\mid g$. So $g=k(x+y)$ for some $k\in\mathbb{Z}_{\ge 1}$ and
\begin{BreakableEquation*}
a=k(x+y)x,\quad b=k(x+y)y,\quad \gcd(x,y)=1.
\end{BreakableEquation*}
Bounds give $k\le \min\!\big(\lfloor n/(x(x+y))\rfloor,\ \lfloor m/(y(x+y))\rfloor\big)$.
Equivalently,
\begin{BreakableEquation*}
\text{Ans}(n,m)=\sum_{\substack{x,y\ge 1\\ \gcd(x,y)=1}} \left\lfloor \frac{\min\!\left(\left\lfloor \dfrac{n}{x}\right\rfloor,\ \left\lfloor \dfrac{m}{y}\right\rfloor\right)}{x+y}\right\rfloor.
\end{BreakableEquation*}%
}
\varmapStart
\var{n,m}{rectangle bounds for $a,b$}
\var{g}{$\gcd(a,b)$}
\var{x,y}{coprime normalized coordinates, $a=gx$, $b=gy$}
\var{k}{positive scale with $g=k(x+y)$}
\var{s}{sum $s=x+y$}
\var{t}{multiple $t=ks$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\gcd(x,y)=1,\quad a=k(x+y)x\le n,\quad b=k(x+y)y\le m,\\
&\text{count}=\sum_{s\ge 2}\ \sum_{k\ge 1}\ \#\left\{x\in[1,s-1]:\ \gcd(x,s)=1,\ x\le \left\lfloor\frac{n}{ks}\right\rfloor,\ s-x\le \left\lfloor\frac{m}{ks}\right\rfloor \right\}.
\end{aligned}
\]
}
\ASSUMPTIONS{All variables are integers. Standard arithmetic with floors. Coprimality via prime decomposition.}
\INVARIANTS{
\begin{bullets}
\item $\gcd(x,s)=1 \iff \gcd(x,s-x)=1$ ensures uniqueness for fixed $s$.
\item If $x\le A$, $s-x\le B$, then $s-1\le A+B$; otherwise no valid $x$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Test all pairs $(a,b)$; check $1\le a\le n$, $1\le b\le m$ and $(a+b)\mid b\cdot \gcd(a,b)$.}
\ASSUMPTIONS{Intended only for very small $n,m$ to validate logic and unit test the optimized methods.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize counter $ans=0$.
\item For $a=1..n$, for $b=1..m$, compute $g=\gcd(a,b)$ and test $(b\cdot g)\bmod(a+b)=0$; if true, increment $ans$.
\item Output $ans$.
\end{algosteps}
\COMPLEXITY{Quadratic in the rectangle size.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm\log\min(n,m)) \text{ (for gcd)},\\
S(n,m) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Directly implements the definition; no missed cases.}
\EDGECASES{$n=1$ or $m=1$; pairs with $a=b$; co-prime and non co-prime cases.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF Baseline: brute-force validator for tiny inputs

import sys
import math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    tests = []
    for _ in range(t):
        n = next(it); m = next(it)
        tests.append((n, m))
    return tests

def solve_case_bruteforce(n, m):
    ans = 0
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            g = math.gcd(a, b)
            if (b * g) % (a + b) == 0:
                ans += 1
    return ans

def solve_all():
    tests = read_input()
    out_lines = []
    for (n, m) in tests:
        out_lines.append(str(solve_case_bruteforce(n, m)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny self-checks
    assert solve_case_bruteforce(1, 1) == 0
    assert solve_case_bruteforce(2, 2) == 1
    assert solve_case_bruteforce(3, 3) >= 0  # sanity non-negative
    # If input is provided, run solver
    if sys.stdin.isatty():
        pass
    else:
        # Warning: brute is only for very small inputs
        # solve_all()
        # Disabled by default to avoid TLE on large cases.
        pass
\end{minted}
\VALIDATION{Brute results for $(n,m)\in\{(1,1),(2,2),(3,3)\}$ check non-negativity and a known exact value.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Normalize by $\gcd$ and count via M\"obius over a fixed sum}
\WHICHFORMULA{Let $a=gx$, $b=gy$, $\gcd(x,y)=1$, $g=k(x+y)$. For a fixed $s=x+y$ and $t=ks$, count $x$ in $[L,R]=\big[s-\lfloor m/t\rfloor,\, \lfloor n/t\rfloor\big]\cap[1,s-1]$ such that $\gcd(x,s)=1$. Use
\begin{BreakableEquation*}
\#\{1\le x\le X:\ \gcd(x,s)=1\}=\sum_{d\mid s}\mu(d)\left\lfloor\frac{X}{d}\right\rfloor.
\end{BreakableEquation*}%
}
\ASSUMPTIONS{We iterate $s$ up to $\max(n,m)$; for each $t$ multiple of $s$ with $\lfloor n/t\rfloor+\lfloor m/t\rfloor>0$, sum over divisors of $s$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute smallest prime factor (SPF) up to $N_{\max}$ and M\"obius $\mu$.
\item For each test: for each $s\ge 2$, iterate $t\in\{s,2s,3s,\ldots\}$ while $\lfloor n/t\rfloor+\lfloor m/t\rfloor>0$.
\item Let $R=\min(s-1,\lfloor n/t\rfloor)$, $L=\max(1,s-\lfloor m/t\rfloor)$. If $R\ge L$, count coprimes in $[L,R]$ by inclusion--exclusion: $\sum_{d\mid s}\mu(d)\big(\lfloor R/d\rfloor-\lfloor (L-1)/d\rfloor\big)$.
\end{algosteps}
\COMPLEXITY{Beats brute but still too slow in Python at the upper bound; practical for moderate sizes or as a validator.}
\[
\begin{aligned}
T &\approx \sum_{s\le N}\tau(s)\cdot \frac{N}{s} = N\sum_{s\le N}\frac{\tau(s)}{s} = \tilde O(N\log^2 N),\\
S &= O(N).
\end{aligned}
\]
\CORRECTNESS{Directly counts valid $x$ per $(s,t)$ using standard coprime counting by M\"obius inversion.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF Improved: gcd-normalized + inclusion-exclusion per (s,t).
# Suitable as a cross-check for moderate limits.

import sys

def sieve_spf_mu(N):
    spf = list(range(N + 1))
    primes = []
    mu = [1] * (N + 1)
    for i in range(2, N + 1):
        if spf[i] == i:
            primes.append(i)
            mu[i] = -1
        for p in primes:
            v = i * p
            if v > N:
                break
            spf[v] = p
            if i % p == 0:
                mu[v] = 0
                break
            else:
                mu[v] = -mu[i]
    return spf, mu

def divisors_from_spf(x, spf):
    # returns all divisors of x
    divs = [1]
    while x > 1:
        p = spf[x]; cnt = 0
        while x % p == 0:
            x //= p; cnt += 1
        base = p
        size0 = len(divs)
        for _ in range(cnt):
            for i in range(size0):
                divs.append(divs[i] * base)
            base *= p
    return divs

def coprime_count_in_range(s, L, R, spf, mu):
    # count x in [L,R] with gcd(x,s)=1 using inclusion-exclusion
    if L > R:
        return 0
    res = 0
    for d in divisors_from_spf(s, spf):
        md = mu[d]
        if md == 0:
            continue
        res += md * (R // d - (L - 1) // d)
    return res

def solve_case_improved(n, m, spf, mu):
    W = max(n, m)
    ans = 0
    for s in range(2, W + 1):
        t = s
        while True:
            A = n // t
            B = m // t
            if A == 0 and B == 0:
                break
            R = min(s - 1, A)
            L = max(1, s - B)
            if L <= R:
                ans += coprime_count_in_range(s, L, R, spf, mu)
            t += s
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    tests = []
    for _ in range(t):
        n = next(it); m = next(it)
        tests.append((n, m))
    return tests

def solve_all():
    tests = read_input()
    if not tests:
        return
    Nmax = max(max(n, m) for n, m in tests)
    spf, mu = sieve_spf_mu(Nmax)
    out = []
    for n, m in tests:
        out.append(str(solve_case_improved(n, m, spf, mu)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # sanity asserts (compare to small brute)
    import math
    def brute(n, m):
        c = 0
        for a in range(1, n + 1):
            for b in range(1, m + 1):
                g = math.gcd(a, b)
                if (b * g) % (a + b) == 0:
                    c += 1
        return c
    spf_t, mu_t = sieve_spf_mu(64)
    assert solve_case_improved(1, 1, spf_t, mu_t) == brute(1, 1)
    assert solve_case_improved(2, 2, spf_t, mu_t) == brute(2, 2)
    assert solve_case_improved(6, 6, spf_t, mu_t) == brute(6, 6)
    # Disabled I/O by default
    # solve_all()
\end{minted}
\VALIDATION{Validated against brute for several small squares (up to $6\times 6$) and boundary cases $(1,1)$, $(2,2)$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Square-free filtered divisor reindexing with SPF pruning}
\WHICHFORMULA{With $a=gx$, $b=gy$, $\gcd(x,y)=1$, the constraint becomes $(x+y)\mid g$. Let $t=ks$. Reindex by $w=t$. For each $w$, we need the number of $x$ with $\gcd(x,s)=1$ in the interval $[s-\lfloor m/w\rfloor,\, \lfloor n/w\rfloor]\cap[1,s-1]$, summed over $s$ such that $w/s$ is square-free. If $w=\prod p_i^{e_i}$, the allowed $s$ are $s = \left(\prod p_i^{e_i-1}\right)\cdot t$, where $t$ runs over divisors of $\prod p_i$ (each prime at most once). This yields:
\begin{BreakableEquation*}
\text{Ans}(n,m)=\sum_{w=1}^{\max(n,m)}\ \sum_{t\mid \mathrm{rad}(w)} f\!\left(s=\mathrm{core}(w)\cdot t,\ A=\left\lfloor\frac{n}{w}\right\rfloor,\ B=\left\lfloor\frac{m}{w}\right\rfloor\right),
\end{BreakableEquation*}
with $f(s,A,B)=\max\big(0,\ \min(s-1,A)-\max(0,s-1-B)\big)$, and we prune by $s-1\le A+B$.}
\ASSUMPTIONS{Use SPF sieve up to $N_{\max}=\max(n,m)$ across all tests. For each $w$, factor once by SPF to get distinct primes and the square-core $\prod p^{e-1}$, then DFS enumerate $t$ divisors of $\mathrm{rad}(w)$ bounded by $(A+B+1)/\mathrm{core}(w)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute SPF up to global $N_{\max}$ from input.
\item For each test and for $w=1..W=\max(n,m)$:
\begin{bullets}
\item $A=n//w$, $B=m//w$; if $A=B=0$, break.
\item Factor $w$ using SPF to get distinct primes $p_i$ and $\mathrm{core}(w)=\prod p_i^{e_i-1}$.
\item Let $T_{\max}=\left\lfloor (A+B+1)/\mathrm{core}(w)\right\rfloor$. DFS over subset products $t$ of $\{p_i\}$ with $t\le T_{\max}$; for each, set $s=\mathrm{core}(w)\cdot t$, add $f(s,A,B)$ to the answer.
\end{bullets}
\item Output the sum.
\end{algosteps}
\OPTIMALITY{The reindexing collapses the inner M\"obius sum to a square-free filter and enumerates only $2^{\omega(w)}$ candidates per $w$, further pruned by $s\le A+B+1$. Amortized over all $w\le N$, this runs in about $O(N \log N)$ operations with very light inner arithmetic, fitting the problem bounds in a fast language; with careful pruning and SPF factorization it is still practical in Python under the given total-sum constraints.}
\COMPLEXITY{Let $W=\max(n,m)$.}
\[
\begin{aligned}
T &\approx \sum_{w\le W}\big(\omega(w) + \#\{t\mid \mathrm{rad}(w): t\le (A+B+1)/\mathrm{core}(w)\}\big) \\
  &\lesssim W\log\log W + \sum_{w\le W} 2^{\omega(w)} = O(W\log W)\ \text{on average with pruning},\\
S &= O(W) \text{ for SPF plus $O(1)$ per loop}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF Final: Reverse Card (Hard Version) — optimized SPF + square-free filtered divisor enumeration.

import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    tests = []
    for _ in range(t):
        n = next(it); m = next(it)
        tests.append((n, m))
    return tests

def sieve_spf(N):
    spf = list(range(N + 1))
    primes = []
    for i in range(2, N + 1):
        if spf[i] == i:
            primes.append(i)
        for p in primes:
            v = i * p
            if v > N:
                break
            spf[v] = p
            if i % p == 0:
                break
    if N >= 1:
        spf[1] = 1
    return spf

def factor_distinct_and_core(x, spf):
    # returns (distinct_primes_list, core = product p^(e-1))
    primes = []
    core = 1
    while x > 1:
        p = spf[x]
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1
        primes.append(p)
        if cnt > 1:
            # multiply by p^(cnt-1)
            core *= pow(p, cnt - 1)
    return primes, core

def solve_case(n, m, spf):
    W = max(n, m)
    ans = 0
    for w in range(1, W + 1):
        A = n // w
        B = m // w
        if A == 0 and B == 0:
            break
        primes, core = factor_distinct_and_core(w, spf)
        T_max = (A + B + 1) // core
        if T_max <= 0:
            continue
        # DFS enumerate t divisors of rad(w) bounded by T_max
        res = 0
        # iterative stack to avoid recursion overhead
        k = len(primes)
        stack = [(0, 1)]
        while stack:
            i, prod = stack.pop()
            if prod > T_max:
                continue
            if i == k:
                s = core * prod
                X = s - 1
                if X <= A:
                    res += X if X <= B else B
                else:
                    if X <= B:
                        res += A
                    else:
                        # X <= A + B by construction; add the remainder
                        add = A + B - X
                        if add > 0:
                            res += add
                continue
            # exclude primes[i]
            stack.append((i + 1, prod))
            # include primes[i] (once, square-free factor)
            np = prod * primes[i]
            if np <= T_max:
                stack.append((i + 1, np))
        ans += res
    return ans

def solve_all():
    tests = read_input()
    if not tests:
        return
    Nmax = 1
    for n, m in tests:
        if n > Nmax: Nmax = n
        if m > Nmax: Nmax = m
    spf = sieve_spf(Nmax)
    out_lines = []
    for n, m in tests:
        out_lines.append(str(solve_case(n, m, spf)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Self-checks with brute for small sizes
    import math
    def brute(n, m):
        c = 0
        for a in range(1, n + 1):
            for b in range(1, m + 1):
                g = math.gcd(a, b)
                if (b * g) % (a + b) == 0:
                    c += 1
        return c
    spf_test = sieve_spf(128)
    assert solve_case(1, 1, spf_test) == 0
    assert solve_case(2, 2, spf_test) == 1
    # Random small: compare to brute
    assert solve_case(8, 8, spf_test) == brute(8, 8)
    # Now run if input provided
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts:
\begin{bullets}
\item $(n,m)=(1,1)\Rightarrow 0$.
\item $(n,m)=(2,2)\Rightarrow 1$.
\item $(n,m)=(8,8)$ vs brute agree (noting the statement lists 6 valid pairs for this case).
\end{bullets}}
\RESULT{For each test case, outputs the count of ordered pairs $(a,b)$ with $1\le a\le n$, $1\le b\le m$ and $(a+b)\mid b\cdot \gcd(a,b)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-validate Approach C against brute for many random small rectangles (e.g., up to $20\times 20$) offline. Boundary tests $n=1$ or $m=1$; symmetric cases $n=m$; asymmetric $n\ll m$ and $m\ll n$.}
\LINE{CROSS-CHECKS}{Compare Approach B (inclusion--exclusion per $(s,t)$) to Approach C for medium sizes (e.g., $n,m\le 2000$).}
\LINE{EDGE-CASE GENERATOR}{Generate $(n,m)$ with:
\begin{bullets}
\item $n=1$ or $m=1$ (degenerate).
\item Powers of a prime (to exercise square parts).
\item Highly composite numbers (many prime factors).
\end{bullets}}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

def gen_cases_small(limit=20):
    cases = []
    for n in range(1, limit + 1):
        cases.append((n, 1))
        cases.append((1, n))
        cases.append((n, n))
    return cases

def gen_prime_powers(p=2, kmax=10):
    cases = []
    x = 1
    for _ in range(kmax):
        x *= p
        cases.append((x, x))
        cases.append((x, 2 * x))
        cases.append((2 * x, x))
    return cases

def gen_highly_composite(limit=200):
    # simple deterministic list of numbers with many divisors
    nums = [1, 2, 3, 4, 6, 8, 12, 16, 18, 24, 30, 36, 48, 60, 72, 84, 96, 108, 120]
    cases = []
    for a in nums:
        for b in nums:
            if a <= limit and b <= limit:
                cases.append((a, b))
    return cases
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference: same as Approach C, packaged for submission.

import sys

def sieve_spf(N):
    spf = list(range(N + 1))
    primes = []
    for i in range(2, N + 1):
        if spf[i] == i:
            primes.append(i)
        for p in primes:
            v = i * p
            if v > N:
                break
            spf[v] = p
            if i % p == 0:
                break
    if N >= 1:
        spf[1] = 1
    return spf

def factor_distinct_and_core(x, spf):
    primes = []
    core = 1
    while x > 1:
        p = spf[x]
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1
        primes.append(p)
        if cnt > 1:
            core *= pow(p, cnt - 1)
    return primes, core

def solve_case(n, m, spf):
    W = max(n, m)
    ans = 0
    for w in range(1, W + 1):
        A = n // w
        B = m // w
        if A == 0 and B == 0:
            break
        primes, core = factor_distinct_and_core(w, spf)
        T_max = (A + B + 1) // core
        if T_max <= 0:
            continue
        res = 0
        k = len(primes)
        stack = [(0, 1)]
        while stack:
            i, prod = stack.pop()
            if prod > T_max:
                continue
            if i == k:
                s = core * prod
                X = s - 1
                if X <= A:
                    res += X if X <= B else B
                else:
                    if X <= B:
                        res += A
                    else:
                        add = A + B - X
                        if add > 0:
                            res += add
                continue
            stack.append((i + 1, prod))
            np = prod * primes[i]
            if np <= T_max:
                stack.append((i + 1, np))
        ans += res
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    tests = []
    for _ in range(t):
        n = next(it); m = next(it)
        tests.append((n, m))
    return tests

def solve_all():
    tests = read_input()
    if not tests:
        return
    Nmax = 1
    for n, m in tests:
        if n > Nmax: Nmax = n
        if m > Nmax: Nmax = m
    spf = sieve_spf(Nmax)
    out = []
    for n, m in tests:
        out.append(str(solve_case(n, m, spf)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Minimal asserts on tiny inputs
    import math
    def brute(n, m):
        c = 0
        for a in range(1, n + 1):
            for b in range(1, m + 1):
                g = math.gcd(a, b)
                if (b * g) % (a + b) == 0:
                    c += 1
        return c
    spf_test = sieve_spf(64)
    assert solve_case(1, 1, spf_test) == 0
    assert solve_case(2, 2, spf_test) == 1
    assert solve_case(8, 8, spf_test) == brute(8, 8)
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Normalize $(a,b)$ by $g=\gcd(a,b)$, set $a=gx$, $b=gy$, force $(x+y)\mid g$, then count scaled coprime splits under bounds.}
\WHY{Combines number theory (M\"obius, square-free structure) and floor-division grouping, a common pattern in advanced CF problems.}
\CHECKLIST{
\begin{bullets}
\item Normalize by $\gcd$ and prove $(x+y)\mid g$.
\item Reindex by $w=t$ and filter $s$ with $w/s$ square-free.
\item Compute $f(s,A,B)=\max(0,\min(s-1,A)-\max(0,s-1-B))$.
\item Prune by $s-1\le A+B$.
\item SPF for fast factorization and distinct primes.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ or $m=1$.
\item Very unbalanced $n\ll m$ or $m\ll n$.
\item $w$ a large prime power: ensure core $=p^{e-1}$.
\item $A=0$ or $B=0$ early termination.
\item Bounds where $s=2$ (smallest sum).
\item Floors near transitions: $w$ at divisors of $n$ or $m$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to cap $x$ to $[1,s-1]$.
\item Missing the square-free restriction on $w/s$ (double-count).
\item Not pruning by $s-1\le A+B$ causing negative counts.
\item Inefficient factorization; use SPF not trial division.
\item Recursion overhead; prefer iterative stack for DFS.
\item Off-by-one in $L=s-\lfloor m/w\rfloor$ vs $L-1$.
\end{bullets}}
\FAILMODES{Brute and naive inclusion--exclusion per $(s,t)$ time out at upper bounds. The final approach avoids summing over all $k$ and over all divisors by compressing via square-free structure and pruning by $A+B$.}
\ELI{Each valid pair is a scaled version of a coprime split of a sum $s=x+y$. The scale must be a multiple of $s$, so we index by $w$ and only certain divisors $s$ are allowed. Then we clip by $n,m$; the remaining count per $s$ has a simple closed form, and we add them up fast using prime factorization.}
\NotePages{3}

\end{document}