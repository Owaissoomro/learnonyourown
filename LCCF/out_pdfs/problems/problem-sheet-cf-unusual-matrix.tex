% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Unusual Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1475/F}}
\LINE{DIFFICULTY / RATING}{CF 1475F — Rating 1900}
\STATEMENT{You are given two binary square matrices $a$ and $b$ of size $n \times n$. A matrix is called binary if each of its elements is equal to $0$ or $1$. You can do the following operations on the matrix $a$ an arbitrary number of times (0 or more):
\begin{bullets}
\item vertical xor. Choose a column index $j$ ($1 \le j \le n$) and for all rows $i$ ($1 \le i \le n$) do: $a_{i,j} := a_{i,j} \oplus 1$ (here $\oplus$ is xor, exclusive or).
\item horizontal xor. Choose a row index $i$ ($1 \le i \le n$) and for all columns $j$ ($1 \le j \le n$) do: $a_{i,j} := a_{i,j} \oplus 1$.
\end{bullets}
Note that the elements of $a$ change after each operation.

For example, if $n=3$ and the matrix $a$ is
\[
\begin{pmatrix}
1 & 1 & 0\\
0 & 0 & 1\\
1 & 1 & 0
\end{pmatrix}
\]
then the following sequence of operations yields:
\begin{bullets}
\item vertical xor, $j=1$:
\[
a=
\begin{pmatrix}
0 & 1 & 0\\
1 & 0 & 1\\
0 & 1 & 0
\end{pmatrix}
\]
\item horizontal xor, $i=2$:
\[
a=
\begin{pmatrix}
0 & 1 & 0\\
0 & 1 & 0\\
0 & 1 & 0
\end{pmatrix}
\]
\item vertical xor, $j=2$:
\[
a=
\begin{pmatrix}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0
\end{pmatrix}
\]
\end{bullets}
Check if there is a sequence of operations such that the matrix $a$ becomes equal to the matrix $b$.

Input: The first line contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases. Then $t$ test cases follow.

The first line of each test case contains one integer $n$ ($1 \le n \le 1000$) — the size of the matrices.

The following $n$ lines contain strings of length $n$, consisting of the characters `0' and `1' — the description of the matrix $a$.

An empty line follows.

The following $n$ lines contain strings of length $n$, consisting of the characters `0' and `1' — the description of the matrix $b$.

It is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.

Output: For each test case, output on a separate line:
\begin{bullets}
\item ``YES'' if there is a sequence of operations that transforms $a$ into $b$;
\item ``NO'' otherwise.
\end{bullets}
You can output ``YES'' and ``NO'' in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).}
\BREAKDOWN{Reduce the problem to whether there exist row flips and column flips (over $\mathbb{F}_2$) that reconcile differences between $a$ and $b$. Let $d_{ij}=a_{ij}\oplus b_{ij}$. Determine whether there exist vectors $r$ and $c$ such that $d_{ij}=r_i\oplus c_j$ for all $i,j$.}
\ELI{Think of toggling whole rows and columns; we only need to match the pattern of differences so that each row is either the same as the first row of $d$ or exactly its bitwise opposite.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item $n$ (integer), $1 \le n \le 1000$.
\item $n$ lines: binary strings of length $n$ for matrix $a$.
\item Optional empty line (may or may not be present).
\item $n$ lines: binary strings of length $n$ for matrix $b$.
\end{bullets}
Total $\sum n \le 1000$ over all test cases.}
\OUTPUTS{For each test case, print ``YES'' if $a$ can be transformed to $b$ using any number of row/column xors; otherwise print ``NO''. One line per test case.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
2
3
110
001
110

000
000
000
2
00
00

01
11
\end{verbatim}
Output
\begin{verbatim}
YES
NO
\end{verbatim}
\end{tcolorbox}
Example 2:
\begin{tcolorbox}
Input
\begin{verbatim}
2
1
1

0
3
010
111
000

110
001
101
\end{verbatim}
Output
\begin{verbatim}
YES
YES
\end{verbatim}
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a,b \in \{0,1\}^{n \times n}$. Define the difference matrix $d$ by $d_{ij}=a_{ij}\oplus b_{ij}$. We seek vectors $r \in \{0,1\}^n$ and $c \in \{0,1\}^n$ such that for all $i,j$,
\[
a_{ij}\oplus r_i \oplus c_j=b_{ij}
\quad\Longleftrightarrow\quad
d_{ij}=r_i\oplus c_j.
\]
This is a rank-1 over $\mathbb{F}_2$ decomposition of $d$ in the sense of xor-sum of a row vector and a column vector.}
\varmapStart
\var{a_{ij}}{bit at row $i$, column $j$ of $a$}
\var{b_{ij}}{bit at row $i$, column $j$ of $b$}
\var{d_{ij}}{xor-difference $a_{ij}\oplus b_{ij}$}
\var{r_i}{whether row $i$ is flipped}
\var{c_j}{whether column $j$ is flipped}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i,j:\quad d_{ij}=r_i\oplus c_j.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are 1-based in the description; we implement with 0-based arrays. Every row/column flip is idempotent modulo 2. Feasibility must hold for all entries simultaneously.}
\INVARIANTS{
\begin{bullets}
\item If a solution exists, there is one with $r_1=0$ (shift $r\gets r\oplus r_1$, $c\gets c\oplus r_1$).
\item For any rows $i,k$, the vector $d_{i,\cdot}\oplus d_{k,\cdot}$ is constant across columns (all 0 or all 1).
\item Equivalently, each row of $d$ equals either the first row of $d$ or its bitwise complement.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Fix $r_1=0$ without loss of generality. Then $c_j=d_{1j}$ and $r_i=d_{i1}$. Verify $\forall i,j$, $r_i\oplus c_j=d_{ij}$.}
\ASSUMPTIONS{We rely on the ability to choose a canonical representative of the solution class by fixing $r_1=0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read matrices $a$ and $b$ and compute $d_{ij}=a_{ij}\oplus b_{ij}$.
\item Define $c_j:=d_{1j}$ for all $j$ and $r_i:=d_{i1}$ for all $i$.
\item Check whether $r_i\oplus c_j=d_{ij}$ for all $(i,j)$. If all match, answer YES; else NO.
\end{algosteps}
\COMPLEXITY{We scan $O(n^2)$ entries a constant number of times.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\\
S(n) &= \Theta(1) \text{ extra, aside from input storage.}
\end{aligned}
\]
\CORRECTNESS{If a solution $(r,c)$ exists, shifting by $r_1$ yields an equivalent solution with $r_1=0$. Then the only consistent choices are $c_j=d_{1j}$ and $r_i=d_{i1}$. The final verification enforces $d_{ij}=r_i\oplus c_j$ for all entries, which is both necessary and sufficient.}
\EDGECASES{Single cell $n=1$; all-zero/all-one matrices; presence/absence of the optional blank line between $a$ and $b$ in input.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def can_transform(a, b):
    n = len(a)
    # d[i][j] = a[i][j] xor b[i][j]
    d = [[(a[i][j] ^ b[i][j]) for j in range(n)] for i in range(n)]
    # Fix r1 = 0; then c[j] = d[0][j], r[i] = d[i][0]
    c = d[0][:]
    r = [d[i][0] for i in range(n)]
    for i in range(n):
        ri = r[i]
        row = d[i]
        for j in range(n):
            if (ri ^ c[j]) != row[j]:
                return False
    return True

def read_input(data_tokens=None):
    if data_tokens is None:
        data_tokens = sys.stdin.read().split()
    it = iter(data_tokens)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = []
        for _ in range(n):
            s = next(it)
            a.append([1 if ch == '1' else 0 for ch in s])
        b = []
        for _ in range(n):
            s = next(it)
            b.append([1 if ch == '1' else 0 for ch in s])
        cases.append((n, a, b))
    return cases

def solve_case(n, a, b):
    return "YES" if can_transform(a, b) else "NO"

def solve_all(cases):
    out = []
    for (n, a, b) in cases:
        out.append(solve_case(n, a, b))
    return "\n".join(out)

def main():
    data = sys.stdin.read().split()
    if data:
        # Robust to optional empty lines because we split by whitespace
        cases = read_input(data)
        print(solve_all(cases))
    else:
        # Self-tests when no input is provided
        # Example 1: YES
        a = [[1,1,0],[0,0,1],[1,1,0]]
        b = [[0,0,0],[0,0,0],[0,0,0]]
        assert can_transform(a, b) is True
        # Example 2: NO
        a = [[0,0],[0,0]]
        b = [[0,1],[1,1]]
        assert can_transform(a, b) is False
        # Example 3: YES
        a = [[0,1,0],[1,1,1],[0,0,0]]
        b = [[1,1,0],[0,0,1],[1,0,1]]
        assert can_transform(a, b) in (True, False)  # determinism check, replaced below
        # Replace last assert with actual check
        # Compute expected by verifying condition directly
        d = [[a[i][j]^b[i][j] for j in range(3)] for i in range(3)]
        ok = True
        c = d[0][:]
        r = [d[i][0] for i in range(3)]
        for i in range(3):
            for j in range(3):
                ok &= ((r[i]^c[j]) == d[i][j])
        assert can_transform(a, b) == ok
        print("ALL SELF-TESTS PASSED")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Manually check: rows of $d$ must match the first row or its complement; the code enforces the global constraint consistently. The tests include a YES case, a NO case, and a consistency check.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Row-Pattern Characterization}
\WHICHFORMULA{A necessary and sufficient condition: every row of $d=a\oplus b$ equals either the first row $d_{1,\cdot}$ or its bitwise complement. This avoids explicitly building $r$ and $c$ vectors.}
\ASSUMPTIONS{Relies on the identity $d_{ij}=r_i\oplus c_j$. Fix $r_1=0$, so $d_{1j}=c_j$. Then for any row $i$, either $r_i=0$ and $d_{ij}=d_{1j}$ for all $j$, or $r_i=1$ and $d_{ij}=\overline{d_{1j}}$ for all $j$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $d_{ij}=a_{ij}\oplus b_{ij}$.
\item Store the first row $p=d_{1,\cdot}$ and its bitwise complement $\bar p$.
\item For each row $i$, check whether $d_{i,\cdot}$ equals $p$ or $\bar p$. If any row fails, return NO; otherwise YES.
\end{algosteps}
\COMPLEXITY{Still linear in the matrix size, but with fewer xor operations during checking.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{Directly encodes the row-wise consequence of $d_{ij}=r_i\oplus c_j$ with $r_1=0$. If the condition holds, set $r_i$ by whether row $i$ equals $p$ ($r_i=0$) or $\bar p$ ($r_i=1$), and $c=p$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def can_transform_by_row_pattern(a, b):
    n = len(a)
    d = [[(a[i][j] ^ b[i][j]) for j in range(n)] for i in range(n)]
    p = d[0]
    comp = [1 - x for x in p]
    for i in range(n):
        row = d[i]
        if not (row == p or row == comp):
            return False
    return True

def read_input(data_tokens=None):
    if data_tokens is None:
        data_tokens = sys.stdin.read().split()
    it = iter(data_tokens)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = []
        for _ in range(n):
            s = next(it)
            a.append([1 if ch == '1' else 0 for ch in s])
        b = []
        for _ in range(n):
            s = next(it)
            b.append([1 if ch == '1' else 0 for ch in s])
        cases.append((n, a, b))
    return cases

def solve_case(n, a, b):
    return "YES" if can_transform_by_row_pattern(a, b) else "NO"

def solve_all(cases):
    return "\n".join(solve_case(n, a, b) for (n, a, b) in cases)

def main():
    data = sys.stdin.read().split()
    if data:
        cases = read_input(data)
        print(solve_all(cases))
    else:
        # Self-tests
        a = [[1,1,0],[0,0,1],[1,1,0]]
        b = [[0,0,0],[0,0,0],[0,0,0]]
        assert can_transform_by_row_pattern(a, b) is True
        a = [[0,0],[0,0]]
        b = [[0,1],[1,1]]
        assert can_transform_by_row_pattern(a, b) is False
        # Cross-check with the direct method
        def direct(a, b):
            n = len(a)
            d = [[a[i][j]^b[i][j] for j in range(n)] for i in range(n)]
            c = d[0][:]
            r = [d[i][0] for i in range(n)]
            for i in range(n):
                for j in range(n):
                    if (r[i]^c[j]) != d[i][j]:
                        return False
            return True
        import random
        random.seed(0)
        for n in range(1,5):
            for _ in range(50):
                a = [[random.randint(0,1) for _ in range(n)] for _ in range(n)]
                b = [[random.randint(0,1) for _ in range(n)] for _ in range(n)]
                assert can_transform_by_row_pattern(a, b) == direct(a, b)
        print("ALL SELF-TESTS PASSED")
if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-check improved method against the direct verification on many random small cases; include explicit YES/NO examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Canonical $r/c$ Reconstruction and Global Check}
\WHICHFORMULA{Use the canonical choice $r_1=0$, $c=d_{1,\cdot}$, $r_i=d_{i1}$. Verify $r_i\oplus c_j=d_{ij}$ for all $i,j$.}
\ASSUMPTIONS{Over $\mathbb{F}_2$, flipping all rows and all columns toggles $r$ and $c$ by the same constant and preserves $d_{ij}=r_i\oplus c_j$, allowing $r_1$ to be normalized to $0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $d=a\oplus b$.
\item Set $c=d_{1,\cdot}$ and $r$ from the first column of $d$.
\item Verify the identity across the entire matrix.
\end{algosteps}
\OPTIMALITY{Runs in $\Theta(n^2)$ time, which is optimal up to constants as every input bit may affect the answer. Requires only $O(1)$ extra space beyond the input.}
\COMPLEXITY{Single pass plus verification is linear in number of cells.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def can_transform(a, b):
    n = len(a)
    d = [[(a[i][j] ^ b[i][j]) for j in range(n)] for i in range(n)]
    c = d[0][:]
    r = [d[i][0] for i in range(n)]
    for i in range(n):
        ri = r[i]
        row = d[i]
        for j in range(n):
            if (ri ^ c[j]) != row[j]:
                return False
    return True

def read_input(tokens=None):
    if tokens is None:
        tokens = sys.stdin.read().split()
    it = iter(tokens)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = []
        for _ in range(n):
            s = next(it)
            a.append([1 if ch == '1' else 0 for ch in s])
        b = []
        for _ in range(n):
            s = next(it)
            b.append([1 if ch == '1' else 0 for ch in s])
        cases.append((n, a, b))
    return cases

def solve_case(n, a, b):
    return "YES" if can_transform(a, b) else "NO"

def solve_all(cases):
    return "\n".join(solve_case(n, a, b) for (n, a, b) in cases)

def main():
    data = sys.stdin.read().split()
    if data:
        cases = read_input(data)
        print(solve_all(cases))
    else:
        # Exactly 3 asserts / mini-tests
        # 1) YES: sample-like
        a = [[1,1,0],[0,0,1],[1,1,0]]
        b = [[0,0,0],[0,0,0],[0,0,0]]
        assert can_transform(a, b) is True
        # 2) NO: inconsistent row pattern
        a = [[0,0],[0,0]]
        b = [[0,1],[1,1]]
        assert can_transform(a, b) is False
        # 3) YES: trivial 1x1
        a = [[1]]
        b = [[0]]
        assert can_transform(a, b) is True
        print("ALL SELF-TESTS PASSED")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: a 3x3 YES case; a 2x2 NO case; a $1\times 1$ YES case.}
\RESULT{Print ``YES'' if there exist row/column flips transforming $a$ to $b$; otherwise print ``NO''. Any capitalization is accepted by the judge, but we output uppercase.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: handcrafted YES/NO; boundary $n=1$; randomized cross-check against the row-pattern characterization. I/O scenarios: multiple test cases; presence/absence of blank lines between matrices.}
\LINE{CROSS-CHECKS}{Verify equivalence of the canonical $(r,c)$ check and the row-pattern method on many small random matrices.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial $d$ where one row differs from both the first row and its complement to ensure NO, and cases where all rows are consistent to ensure YES.}
\begin{minted}{python}
import random

def gen_yes_case(n):
    # Choose random r, c then define b = a xor r xor c to guarantee YES
    a = [[random.randint(0,1) for _ in range(n)] for _ in range(n)]
    r = [random.randint(0,1) for _ in range(n)]
    c = [random.randint(0,1) for _ in range(n)]
    b = [[a[i][j] ^ r[i] ^ c[j] for j in range(n)] for i in range(n)]
    return a, b

def gen_no_case(n):
    # Create d with row 0 = p, row 1 = not p, and row 2 = p with one bit flipped -> NO
    p = [random.randint(0,1) for _ in range(n)]
    d = []
    d.append(p[:])
    d.append([1-x for x in p])
    bad = p[:]
    bad[random.randrange(n)] ^= 1
    d.append(bad)
    # Fill remaining rows with consistent choices
    for _ in range(3, n):
        d.append(p[:] if random.randint(0,1)==0 else [1-x for x in p])
    # Recover (a,b) from d by picking arbitrary a (zeros) and defining b=a xor d
    a = [[0]*n for _ in range(n)]
    b = [row[:] for row in d]
    return a, b

def reference_can_transform(a, b):
    n = len(a)
    d = [[a[i][j]^b[i][j] for j in range(n)] for i in range(n)]
    c = d[0][:]
    r = [d[i][0] for i in range(n)]
    for i in range(n):
        for j in range(n):
            if (r[i]^c[j]) != d[i][j]:
                return False
    return True

def run_tests():
    random.seed(1)
    # YES cases
    for n in range(1,8):
        for _ in range(50):
            a,b = gen_yes_case(n)
            assert reference_can_transform(a,b) is True
    # NO cases (n>=3 to build inconsistent row)
    for n in range(3,8):
        for _ in range(50):
            a,b = gen_no_case(n)
            assert reference_can_transform(a,b) is False
    print("Generator tests passed")

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def can_transform(a, b):
    n = len(a)
    d = [[(a[i][j] ^ b[i][j]) for j in range(n)] for i in range(n)]
    c = d[0][:]
    r = [d[i][0] for i in range(n)]
    for i in range(n):
        ri = r[i]
        row = d[i]
        for j in range(n):
            if (ri ^ c[j]) != row[j]:
                return False
    return True

def read_input(tokens=None):
    if tokens is None:
        tokens = sys.stdin.read().split()
    it = iter(tokens)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = []
        for _ in range(n):
            s = next(it)
            a.append([1 if ch == '1' else 0 for ch in s])
        b = []
        for _ in range(n):
            s = next(it)
            b.append([1 if ch == '1' else 0 for ch in s])
        cases.append((n, a, b))
    return cases

def solve_case(n, a, b):
    return "YES" if can_transform(a, b) else "NO"

def solve_all(cases):
    return "\n".join(solve_case(n, a, b) for (n, a, b) in cases)

def main():
    data = sys.stdin.read().split()
    if data:
        cases = read_input(data)
        print(solve_all(cases))
    else:
        # Basic asserts
        a = [[1,1,0],[0,0,1],[1,1,0]]
        b = [[0,0,0],[0,0,0],[0,0,0]]
        assert can_transform(a, b) is True
        a = [[0,0],[0,0]]
        b = [[0,1],[1,1]]
        assert can_transform(a, b) is False
        a = [[1]]
        b = [[1]]
        assert can_transform(a, b) is True
        print("ALL SELF-TESTS PASSED")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transformability reduces to whether $d=a\oplus b$ can be written as $r\oplus c$ entrywise: $d_{ij}=r_i\oplus c_j$.}
\WHY{Common in grid-flip interview problems; recognizing the xor-separable structure and fixing one degree of freedom unlocks an $O(n^2)$ solution.}
\CHECKLIST{
\begin{bullets}
\item Build $d=a\oplus b$.
\item Fix $r_1=0$ and set $c=d_{1,\cdot}$.
\item Set $r$ from the first column of $d$.
\item Verify $r_i\oplus c_j=d_{ij}$ for all $i,j$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All-zeros or all-ones matrices.
\item Rows identical to first row.
\item Rows identical to complement of first row.
\item Inconsistent row differing at exactly one column.
\item Optional blank line in input between $a$ and $b$.
\item Multiple test cases back-to-back.
\item Non-square inputs are invalid (guaranteed square here).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to normalize $r_1=0$ and double-counting possibilities.
\item Building $b$ by applying operations to $a$ in simulation (too slow).
\item Misparsing input due to optional blank line; use tokenized reading.
\item Using strings instead of ints for xor.
\item Off-by-one with indices when comparing rows/columns.
\item Assuming columns must match first column or its complement instead of rows; either works but be consistent.
\item Mixing ``and''/``or'' with bitwise operators in Python.
\item Printing extra spaces or missing newlines between test case outputs.
\end{bullets}}
\FAILMODES{A naive backtracking or BFS over operations explodes exponentially. The rank-1 xor structure avoids search entirely and handles worst-case sizes.}
\ELI{We only need to decide if we can toggle whole rows and columns to fix all mismatches. Record the mismatches in a matrix $d$. If every row of $d$ looks like the first row or its opposite, we can pick the right combination of row and column toggles to fix everything; otherwise, it's impossible.}
\NotePages{3}

\end{document}