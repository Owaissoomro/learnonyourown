% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Shuffle Hashing}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1278/A}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{Polycarp has built his own web service. Being a modern web service it includes login feature. And that always implies password security problems.

Polycarp decided to store the hash of the password, generated by the following algorithm:

1. take the password $p$, consisting of lowercase Latin letters, and shuffle the letters randomly in it to obtain $p'$ ($p'$ can still be equal to $p$);
2. generate two random strings, consisting of lowercase Latin letters, $s_1$ and $s_2$ (any of these strings can be empty);
3. the resulting hash $h = s_1 + p' + s_2$, where addition is string concatenation.

For example, let the password $p =$ ``abacaba''. Then $p'$ can be equal to ``aabcaab''. Random strings $s_1 =$ ``zyx'' and $s_2 =$ ``kjh''. Then $h =$ ``zyxaabcaabkjh''.

Note that no letters could be deleted or added to $p$ to obtain $p'$, only the order could be changed.

Now Polycarp asks you to help him to implement the password check module. Given the password $p$ and the hash $h$, check that $h$ can be the hash for the password $p$.

Your program should answer $t$ independent test cases.

Input:
The first line contains one integer $t$ ($1 \le t \le 100$) — the number of test cases.

The first line of each test case contains a non-empty string $p$, consisting of lowercase Latin letters. The length of $p$ does not exceed $100$.

The second line of each test case contains a non-empty string $h$, consisting of lowercase Latin letters. The length of $h$ does not exceed $100$.

Output:
For each test case print the answer to it — ``YES'' if the given hash $h$ could be obtained from the given password $p$ or ``NO'' otherwise.

Note:
The first test case is explained in the statement.

In the second test case both $s_1$ and $s_2$ are empty and $p'=$ ``threetwoone'' is $p$ shuffled.

In the third test case the hash could not be obtained from the password.

In the fourth test case $s_1=$ ``n'', $s_2$ is empty and $p'=$ ``one'' is $p$ shuffled (even though it stayed the same).

In the fifth test case the hash could not be obtained from the password.}
\BREAKDOWN{We need to determine if some permutation of $p$ appears as a contiguous substring of $h$. This reduces to checking, for any window of length $\lvert p\rvert$ in $h$, whether its multiset of characters equals that of $p$.}
\ELI{Check if $h$ contains the letters of $p$ in some order, stuck together without gaps.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: a string $p$ with $1 \le \lvert p\rvert \le 100$ and a string $h$ with $1 \le \lvert h\rvert \le 100$, both lowercase Latin letters.}
\OUTPUTS{For each test case print ``YES'' if some permutation of $p$ is a contiguous substring of $h$, otherwise print ``NO''. Each answer on its own line.}
\SAMPLES{Example 1:
Input
3
abacaba
zzzaabcaabyyy
abc
defgh
one
none

Output
YES
NO
YES

Example 2:
Input
2
aa
a
ab
eidbaooo

Output
NO
YES}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{a,\ldots,z\}$. Define $\operatorname{cnt}_x:\Sigma\to\mathbb{N}$ as the character-count function for string $x$. The question is whether there exists an index $i$ with $0\le i\le \lvert h\rvert-\lvert p\rvert$ such that $\operatorname{cnt}_{h[i:i+\lvert p\rvert]}=\operatorname{cnt}_p$.}
\varmapStart
\var{p}{password string}
\var{h}{hash string}
\var{n}{length $\lvert p\rvert$}
\var{m}{length $\lvert h\rvert$}
\var{\operatorname{cnt}_x(c)}{number of occurrences of character $c$ in $x$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\exists i\in\{0,\ldots,m-n\}\ \ \forall c\in\Sigma:\ \operatorname{cnt}_{h[i:i+n]}(c)=\operatorname{cnt}_p(c).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Strings are over lowercase Latin letters; $1\le n\le 100$, $1\le m\le 100$. If $n>m$ then the answer is immediately ``NO''.}
\INVARIANTS{For a sliding window approach of width $n$, maintain an array $\Delta[c]=\operatorname{cnt}_{\text{window}}(c)-\operatorname{cnt}_p(c)$. The invariant is that updating the window by one character adjusts exactly two entries of $\Delta$ by $\pm1$. The window matches iff all $\Delta[c]=0$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sort-and-compare: precompute $p_{\text{sorted}}$, then for every window of length $n$ in $h$, sort it and compare equality.}
\ASSUMPTIONS{Alphabet is small but ignored here; this baseline is simple and sufficient for small bounds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n>m$, return ``NO''.
\item Compute $p_s=\operatorname{sort}(p)$.
\item For each $i=0$ to $m-n$: compute $w=\operatorname{sort}(h[i:i+n])$ and if $w=p_s$, return ``YES''.
\item After the loop, return ``NO''.
\end{algosteps}
\COMPLEXITY{Sorting each length-$n$ window costs $O(n\log n)$ and there are $m-n+1$ windows. Space is $O(n)$ for temporary buffers.}
\[
\begin{aligned}
T(n,m) &= (m-n+1)\cdot O(n\log n) \\
       &= O\big(m\,n\log n\big),\quad S(n,m)=O(n).
\end{aligned}
\]
\CORRECTNESS{Every window considered corresponds to a candidate $p'$; equality after sorting means the multisets of characters match, which is equivalent to being a permutation. Exhausting all windows guarantees coverage.}
\EDGECASES{If $n=m$, compare just once. If $n>m$, impossible. Repeated characters are handled by sorting.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        p = next(it)
        h = next(it)
        cases.append((p, h))
    return t, cases

def can_hash_bruteforce(p: str, h: str) -> bool:
    n, m = len(p), len(h)
    if n > m:
        return False
    ps = "".join(sorted(p))
    for i in range(m - n + 1):
        if "".join(sorted(h[i:i+n])) == ps:
            return True
    return False

def solve_case(p: str, h: str) -> str:
    return "YES" if can_hash_bruteforce(p, h) else "NO"

def solve_all(cases):
    out = []
    for p, h in cases:
        out.append(solve_case(p, h))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    sys.stdout.write(solve_all(cases))

# --- tests (run with: python script.py --test) ---
def _run_tests():
    assert can_hash_bruteforce("abacaba", "zzzaabcaabyyy") is True
    assert can_hash_bruteforce("abc", "defgh") is False
    assert can_hash_bruteforce("one", "none") is True
    # boundaries
    assert can_hash_bruteforce("a", "a") is True
    assert can_hash_bruteforce("aa", "a") is False

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        _run_tests()
    else:
        main()
\end{minted}
\VALIDATION{Quick checks: identical strings; $n>m$; presence/absence of a permuted window; repeated letters.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use frequency counting over the fixed alphabet and a sliding window to update counts in $O(1)$ per shift, avoiding per-window sorting.}
\ASSUMPTIONS{Alphabet $\Sigma$ has size $26$, so an array of size $26$ suffices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build count array $cp[26]$ for $p$.
\item Initialize window count $cw[26]$ from $h[0:n)$; if $cw=cp$, return ``YES''.
\item Slide window $i=1$ to $m-n$: decrement count of $h[i-1]$, increment count of $h[i+n-1]$; if $cw=cp$, return ``YES''.
\item If no match, return ``NO''.
\end{algosteps}
\COMPLEXITY{Initialization is $O(n+26)$; each of the $m-n$ slides costs $O(1)$ updates plus $O(26)$ for equality or maintain a mismatch counter to get $O(1)$ amortized per slide. Overall $O(m+26)$ time and $O(26)$ space.}
\[
\begin{aligned}
T(n,m) &= O(n + m + 26),\quad S(n,m)=O(26)=O(1).
\end{aligned}
\]
\CORRECTNESS{Counts match if and only if the window is a permutation of $p$. Sliding updates preserve correctness since only one character exits and one enters per shift.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        p = next(it)
        h = next(it)
        cases.append((p, h))
    return t, cases

def can_hash_counts(p: str, h: str) -> bool:
    n, m = len(p), len(h)
    if n > m:
        return False
    cp = [0]*26
    for ch in p:
        cp[ord(ch)-97] += 1
    cw = [0]*26
    for ch in h[:n]:
        cw[ord(ch)-97] += 1
    if cw == cp:
        return True
    for i in range(n, m):
        cw[ord(h[i-n])-97] -= 1
        cw[ord(h[i])-97] += 1
        if cw == cp:
            return True
    return False

def solve_case(p: str, h: str) -> str:
    return "YES" if can_hash_counts(p, h) else "NO"

def solve_all(cases):
    return "\n".join(solve_case(p, h) for p, h in cases)

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    sys.stdout.write(solve_all(cases))

# --- tests (run with: python script.py --test) ---
def _run_tests():
    assert can_hash_counts("abacaba", "zzzaabcaabyyy") is True
    assert can_hash_counts("abc", "defgh") is False
    assert can_hash_counts("one", "none") is True
    # more
    assert can_hash_counts("aa", "bbaaa") is True
    assert can_hash_counts("abc", "ccccbbbbaaa") is True  # window "cba"

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        _run_tests()
    else:
        main()
\end{minted}
\VALIDATION{Verify on mixed repeats, minimal and maximal sizes, and negative cases where letters are scattered non-contiguously in $h$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Sliding window with a mismatch counter $\delta=\sum_{c\in\Sigma} [cw[c]\ne cp[c]]$ to test equality in $O(1)$ per slide.}
\ASSUMPTIONS{Fixed small alphabet enables maintaining $\delta$ efficiently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $cp[26]$. Initialize $cw[26]$ for the first window and compute $\delta$ as the number of indices with $cw[c]\ne cp[c]$.
\item If $\delta=0$, return ``YES''.
\item For each slide, update the two affected characters; for each, adjust $\delta$ before/after the count change appropriately. If $\delta=0$, return ``YES''.
\item If all slides fail, return ``NO''.
\end{algosteps}
\OPTIMALITY{Any solution must examine at least the characters of $h$ once: $\Omega(m)$. This method runs in $O(m+26)$ and $O(1)$ space, which is asymptotically optimal.}
\COMPLEXITY{Linear time and constant space in the alphabet size.}
\[
\begin{aligned}
T(n,m) &= O(m+26),\quad S(n,m)=O(26).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        p = next(it)
        h = next(it)
        cases.append((p, h))
    return t, cases

def can_hash_optimal(p: str, h: str) -> bool:
    n, m = len(p), len(h)
    if n > m:
        return False
    cp = [0]*26
    for ch in p:
        cp[ord(ch)-97] += 1
    cw = [0]*26
    for ch in h[:n]:
        cw[ord(ch)-97] += 1
    delta = 0
    for i in range(26):
        if cw[i] != cp[i]:
            delta += 1
    if delta == 0:
        return True
    for i in range(n, m):
        out_idx = ord(h[i-n]) - 97
        in_idx  = ord(h[i]) - 97
        # update out_idx
        before = cw[out_idx] == cp[out_idx]
        cw[out_idx] -= 1
        after = cw[out_idx] == cp[out_idx]
        if before and not after:
            delta += 1
        elif not before and after:
            delta -= 1
        # update in_idx
        before = cw[in_idx] == cp[in_idx]
        cw[in_idx] += 1
        after = cw[in_idx] == cp[in_idx]
        if before and not after:
            delta += 1
        elif not before and after:
            delta -= 1
        if delta == 0:
            return True
    return False

def solve_case(p: str, h: str) -> str:
    return "YES" if can_hash_optimal(p, h) else "NO"

def solve_all(cases):
    return "\n".join(solve_case(p, h) for p, h in cases)

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    sys.stdout.write(solve_all(cases))

# --- tests (run with: python script.py --test) ---
def _run_tests():
    assert can_hash_optimal("abacaba", "zzzaabcaabyyy") is True
    assert can_hash_optimal("abc", "defgh") is False
    assert can_hash_optimal("one", "none") is True

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        _run_tests()
    else:
        main()
\end{minted}
\VALIDATION{Exactly three asserts above cover a positive with repeats, a negative, and a simple positive with a single-character prefix.}
\RESULT{For each test case, output ``YES'' iff some contiguous substring of $h$ is a permutation of $p$; otherwise output ``NO''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on: trivial sizes ($n=1$), $n>m$, repeated letters (e.g., ``aab''), disjoint alphabets, and windows at start/middle/end.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Optimal on random small strings to ensure identical answers.}
\LINE{EDGE-CASE GENERATOR}{Generate random $p$ and $h$ with controlled $n,m\le 8$; brute force via sort-and-compare to validate the optimized method.}
\begin{minted}{python}
import random
import string

def gen_case(n_max=8, m_max=8, trials=1000, seed=0):
    random.seed(seed)
    for _ in range(trials):
        n = random.randint(1, n_max)
        m = random.randint(1, m_max)
        p = "".join(random.choice(string.ascii_lowercase) for _ in range(n))
        h = "".join(random.choice(string.ascii_lowercase) for _ in range(m))
        yield p, h

def brute(p, h):
    ps = "".join(sorted(p))
    n, m = len(p), len(h)
    if n > m: return False
    for i in range(m-n+1):
        if "".join(sorted(h[i:i+n])) == ps:
            return True
    return False

def optimal(p, h):
    cp = [0]*26
    for ch in p: cp[ord(ch)-97]+=1
    n, m = len(p), len(h)
    if n > m: return False
    cw = [0]*26
    for ch in h[:n]: cw[ord(ch)-97]+=1
    delta = sum(1 for i in range(26) if cp[i]!=cw[i])
    if delta==0: return True
    for i in range(n, m):
        oi = ord(h[i-n])-97
        ii = ord(h[i])-97
        b = cw[oi]==cp[oi]; cw[oi]-=1; a = cw[oi]==cp[oi]
        if b and not a: delta+=1
        elif not b and a: delta-=1
        b = cw[ii]==cp[ii]; cw[ii]+=1; a = cw[ii]==cp[ii]
        if b and not a: delta+=1
        elif not b and a: delta-=1
        if delta==0: return True
    return False

def cross_check():
    for p, h in gen_case():
        assert brute(p, h) == optimal(p, h)
    return True

if __name__ == "__main__":
    assert cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        p = next(it)
        h = next(it)
        cases.append((p, h))
    return t, cases

def can_hash_optimal(p: str, h: str) -> bool:
    n, m = len(p), len(h)
    if n > m:
        return False
    cp = [0]*26
    for ch in p:
        cp[ord(ch)-97] += 1
    cw = [0]*26
    for ch in h[:n]:
        cw[ord(ch)-97] += 1
    delta = 0
    for i in range(26):
        if cw[i] != cp[i]:
            delta += 1
    if delta == 0:
        return True
    for i in range(n, m):
        out_idx = ord(h[i-n]) - 97
        in_idx  = ord(h[i]) - 97
        before = cw[out_idx] == cp[out_idx]
        cw[out_idx] -= 1
        after = cw[out_idx] == cp[out_idx]
        if before and not after: delta += 1
        elif not before and after: delta -= 1
        before = cw[in_idx] == cp[in_idx]
        cw[in_idx] += 1
        after = cw[in_idx] == cp[in_idx]
        if before and not after: delta += 1
        elif not before and after: delta -= 1
        if delta == 0:
            return True
    return False

def solve_case(p: str, h: str) -> str:
    return "YES" if can_hash_optimal(p, h) else "NO"

def solve_all(cases):
    return "\n".join(solve_case(p, h) for p, h in cases)

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    sys.stdout.write(solve_all(cases))

# Tests (only run with explicit flag)
def _run_tests():
    assert can_hash_optimal("abacaba", "zzzaabcaabyyy") is True
    assert can_hash_optimal("abc", "defgh") is False
    assert can_hash_optimal("one", "none") is True

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        _run_tests()
    else:
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Detect if any substring of $h$ of length $\lvert p\rvert$ is an anagram of $p$ using sliding window counts.}
\WHY{This pattern appears widely: permutation-in-string, anagram-substring, frequency-window checks—common in interviews to test mastery of sliding windows.}
\CHECKLIST{%
\begin{bullets}
\item Compute count of $p$.
\item Initialize window of size $\lvert p\rvert$ in $h$.
\item Compare counts (or track mismatch counter).
\item Slide by one: remove left char, add right char.
\item Early exit on match; handle $n>m$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n>m$ immediately ``NO''.
\item $n=1$ single-character match.
\item All identical letters in $p$ (e.g., ``aaaaa'').
\item Letters present in $h$ but not contiguously.
\item Match at the very start or very end of $h$.
\item Mixed high/low frequency causing off-by-one on slides.
\item Minimal input $t=1$.
\item Max lengths $n,m=100$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to update both outgoing and incoming characters on slide.
\item Comparing counts incorrectly (indexing by wrong offset).
\item Not handling $n=m$ correctly (should check initial window).
\item Using dynamic structures causing extra overhead instead of fixed arrays.
\item Mutating shared arrays across test cases without reinit.
\item Incorrect delta maintenance (adjusting before/after states wrongly).
\item Off-by-one in loop bounds for window slides.
\item Reading input with stray whitespace handling errors.
\end{bullets}
}
\FAILMODES{Brute force sorting per window may time out on larger constraints, though here it still passes. Solutions that search scattered characters without enforcing contiguity yield false positives; the sliding window avoids this by construction.}
\ELI{Count the letters in $p$, then slide a window of the same size over $h$, updating letter counts as you go. If the counts ever match exactly, you found the shuffled password inside $h$.}
\NotePages{3}

\end{document}