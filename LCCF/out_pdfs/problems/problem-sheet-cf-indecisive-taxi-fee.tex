% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Indecisive Taxi Fee}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1163/F}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{In the city of Capypaland where Kuro and Shiro reside, there are $n$ towns numbered from $1$ to $n$ and there are $m$ bidirectional roads numbered from $1$ to $m$ connecting them. The $i$-th road connects towns $u_i$ and $v_i$. Since traveling between the towns is quite difficult, the taxi industry is really popular here. To survive the harsh competition, each taxi company has to find a distinctive trait for their customers.

Kuro is the owner of a taxi company. He has decided to introduce a new fee model for his taxi brand, where the fee for each ride is not calculated based on the trip length, but on the sum of the prices of the roads traveled. The price for each of the $m$ roads has been decided by Kuro himself.

As of now, the price for the road $i$ is $w_i$ and hence the fee for a taxi ride traveling through roads $e_1, e_2, \ldots, e_k$ is $\sum_{i=1}^k w_{e_i}$.

However, Kuro himself is an indecisive person, so he has drafted $q$ plans to change the road price. Each of the plans will be based on the original prices $w_i$, except for a single road $t_j$, the price of which is changed to $x_j$. Note, that the plans are independent of each other.

Shiro is a regular customer of Kuro's taxi brand since she uses the taxi to travel from town $1$ to town $n$ every day. Since she is such a regular customer, Kuro decided to show her all his $q$ plans before publishing them to the public. Now, Shiro wants to know the lowest fee she must pay to travel from town $1$ to town $n$ for each of Kuro's plans.

Input: The first line contains three integers $n$, $m$ and $q$ ($2 \le n \le 2 \cdot 10^5$, $1 \le m, q \le 2 \cdot 10^5$) — the number of towns, the number of roads, and the number of plans that Kuro has drafted respectively.

The $i$-th of the next $m$ lines contains three integers $u_i$, $v_i$ and $w_i$ ($1 \le u_i, v_i \le n$, $1 \le w_i \le 10^9$, $u_i \ne v_i$) — two endpoints and the original price of the $i$-th road. It is guaranteed that there is at least one way to travel from town $1$ to town $n$ using these $m$ bidirectional roads.

Each of the next $q$ lines contains two integers $t_j$ and $x_j$ ($1 \le t_j \le m$, $1 \le x_j \le 10^9$) — the index of the road Kuro has planned to change and its new price respectively.

Output: Print $q$ integers — the lowest fee Shiro must pay to get from town $1$ to town $n$ in each of those $q$ plans.}
\BREAKDOWN{Precompute the original shortest distance from $1$ and to $n$. For each query changing one edge, the best path either avoids that edge (precomputable per edge) or uses it once with the new weight. Compute per-edge replacement distances along a chosen shortest path via a DAG compression and interval minima.}
\ELI{Changing one road weight only affects paths that use it; precompute the best path that avoids each road on the main shortest path, and combine with the cost of using the changed road.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m, q$. Then $m$ lines of edges $u_i, v_i, w_i$. Then $q$ lines of updates $t_j, x_j$. All inputs satisfy $2 \le n \le 2\cdot 10^5$, $1 \le m, q \le 2\cdot 10^5$, $1 \le u_i, v_i \le n$, $1 \le w_i \le 10^9$, $u_i \ne v_i$, $1 \le t_j \le m$, $1 \le x_j \le 10^9$.}
\OUTPUTS{Print $q$ lines, each a single integer: the minimum possible fee from $1$ to $n$ when only edge $t_j$ has weight $x_j$ and all other edges keep their original weights.}
\SAMPLES{Example-style mini-case:
- $n=3, m=3, q=3$; edges: $(1,2,3)$, $(2,3,3)$, $(1,3,10)$. Queries: $(3,1)$, $(3,5)$, $(1,1)$.
- Answers: $1+0+? \to$ For $(3,1)$, path $1\to 3$ uses edge $3$ with $x=1$: cost $1$. For $(3,5)$, either $1\to 2\to 3$ with cost $6$ or $1\to 3$ with $5$, so $5$. For $(1,1)$, either $1\to 2\to 3$ with cost $1+3=4$ or $1\to 3$ with $10$, so $4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given undirected graph $G=(V,E)$ with positive weights $w:E\to \mathbb{R}_{>0}$. Let $s=1$, $t=n$. For each query updating one edge $e=(a,b)$ to weight $x$, compute $\operatorname{dist}_x(s,t)$, the shortest $s$-$t$ path length under weights $w'$ where $w'(e)=x$ and $w'(e')=w(e')$ for $e'\ne e$.}
\varmapStart
\var{d_1(v)}{shortest distance from $s$ to $v$ under original weights}
\var{d_n(v)}{shortest distance from $v$ to $t$ under original weights}
\var{D}{original shortest distance $D=d_1(t)$}
\var{P}{a fixed shortest path from $s$ to $t$ in the shortest-path DAG}
\var{\mathrm{pos}(v)}{index of $v$ on $P$ if $v\in P$, else $-1$}
\var{L(v),R(v)}{min/max indices on $P$ that reach $v$/are reachable from $v$ within the DAG}
\var{\mathrm{alt}(e)}{$\min\{d_1(a)+w(e)+d_n(b),\, d_1(b)+w(e)+d_n(a)\}$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\operatorname{Ans}(e,x)=\min\left(\ \underbrace{\text{Best path avoiding }e}_{A(e)}\ ,\ \underbrace{\min\{d_1(a)+x+d_n(b),\ d_1(b)+x+d_n(a)\}}_{B(e,x)}\ \right).
\end{BreakableEquation*}
}
\ASSUMPTIONS{All edge weights positive. The shortest-path subgraph oriented by increasing $d_1$ is a DAG. A fixed shortest path $P$ exists and is chosen deterministically.}
\INVARIANTS{
- Along any oriented shortest-path edge $u\to v$, $d_1(v)=d_1(u)+w(u,v)$ and $d_1(u)+w(u,v)+d_n(v)=D$.
- Any simple $s$-$t$ path avoiding a specific edge of $P$ can be represented as: prefix along the DAG, one arbitrary edge, then suffix along the DAG; hence one off-DAG edge suffices for optimality.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Recompute Dijkstra from scratch for each query with the single edge weight changed.}
\ASSUMPTIONS{Use a standard binary-heap Dijkstra since weights are positive.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read graph. For each query $(t,x)$, temporarily set $w_t\leftarrow x$.
\item Run Dijkstra from $1$ to get $d[\,]$ and report $d[n]$.
\item Restore $w_t$ and proceed to the next query.
\end{algosteps}
\COMPLEXITY{This is too slow for $q$ up to $2\cdot 10^5$.}
\[
\begin{aligned}
T(n) &= q\cdot O\big((n+m)\log n\big) \\
     &\approx O\big(2\cdot 10^5 \cdot (2\cdot 10^5)\log n\big)\quad\text{(TLE)} \\
S(n) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{Direct recomputation always yields the correct shortest path.}
\EDGECASES{Disconnected updates never occur by statement; weights remain positive.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LC TEMPLATE not applicable; CF-style helpers included but not intended for submission due to TLE.
import sys, heapq

def dijkstra(n, adj):
    INF = 10**30
    dist = [INF]*(n+1)
    dist[1] = 0
    pq = [(0,1)]
    while pq:
        d,u = heapq.heappop(pq)
        if d!=dist[u]: continue
        if u==n: break
        for v,w,_ in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq,(nd,v))
    return dist

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); q = int(next(it))
    U=[0]*(m+1); V=[0]*(m+1); W=[0]*(m+1)
    adj=[[] for _ in range(n+1)]
    for i in range(1,m+1):
        u=int(next(it)); v=int(next(it)); w=int(next(it))
        U[i]=u; V[i]=v; W[i]=w
        adj[u].append((v,w,i)); adj[v].append((u,w,i))
    queries=[]
    for _ in range(q):
        t=int(next(it)); x=int(next(it))
        queries.append((t,x))
    return n,m,q,U,V,W,adj,queries

def solve_all_baseline(n,m,q,U,V,W,adj,queries):
    out=[]
    for t,x in queries:
        # modify edge t
        u,v = U[t], V[t]
        # update adj weights for t temporarily
        # Build modified adjacency on the fly (copy small but TLE in general)
        adj2=[lst[:] for lst in adj]
        # Replace both directions
        for idx,(to,w,id_) in enumerate(adj2[u]):
            if id_==t:
                adj2[u][idx]=(to,x,id_)
        for idx,(to,w,id_) in enumerate(adj2[v]):
            if id_==t:
                adj2[v][idx]=(to,x,id_)
        d = dijkstra(n, adj2)
        out.append(str(d[n]))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Tiny self-check
        n,m,q,U,V,W,adj,queries = read_input("3 3 3\n1 2 3\n2 3 3\n1 3 10\n3 1\n3 5\n1 1\n")
        print(solve_all_baseline(n,m,q,U,V,W,adj,queries))
    else:
        n,m,q,U,V,W,adj,queries = read_input(data)
        print(solve_all_baseline(n,m,q,U,V,W,adj,queries))

if __name__=="__main__":
    main()
\end{minted}
\VALIDATION{The embedded tiny test prints answers for a toy case; correctness is guaranteed but performance is inadequate.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Use Precomputed $d_1$ and $d_n$ and Per-Query Reweight}
\WHICHFORMULA{Observe any path using the updated edge $e=(a,b)$ has cost $\min\{d_1(a)+x+d_n(b), d_1(b)+x+d_n(a)\}$. For paths that avoid $e$, their cost is unchanged. Hence answer is the min of these two classes.}
\ASSUMPTIONS{Only one edge changes per query; all weights remain positive.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run Dijkstra twice on the original graph to get $d_1[\,]$ and $d_n[\,]$, and let $D=d_1[n]$.
\item For each query $(t,x)$, compute $B(t,x)=\min\{d_1(u_t)+x+d_n(v_t), d_1(v_t)+x+d_n(u_t)\}$.
\item Let $A(t)$ be the best path that avoids $t$ under original weights. If $t$ is not on any original shortest path, then $A(t)=D$; otherwise it may be larger. Without precomputation, this is unknown.
\end{algosteps}
\COMPLEXITY{Per query is $O(1)$ once $A(t)$ is known. The missing piece is to precompute $A(t)$ for all $t$.}
\[
\begin{aligned}
T(n) &= O\big((n+m)\log n\big) + O(q) \\
S(n) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{Splits possibilities by whether the changed edge is used or not.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Sketch-only; see Optimal approach for full implementation.
\end{minted}
\VALIDATION{See Optimal approach tests.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Shortest-Path DAG Compression + Interval Minima}
\WHICHFORMULA{Precompute $A(e)$ for all edges $e$ via a fixed shortest path $P$ and interval covering by all edges. Then answer each query as $\min\{A(e), B(e,x)\}$.}
\ASSUMPTIONS{Positive weights imply an acyclic orientation of the shortest-path subgraph by increasing $d_1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Dijkstra from $1$ and from $n$ to get $d_1$, $d_n$, and $D=d_1[n]$.
\item Build the shortest-path DAG: for each edge $(u,v,w)$, if $d_1[u]+w+d_n[v]=D$ and $d_1[u]+w=d_1[v]$, add $u\to v$; likewise $v\to u$ if symmetric.
\item Choose a deterministic shortest path $P$ from $1$ to $n$ in the DAG by greedily following, at each node, the outgoing neighbor with minimum $d_n[\cdot]$. Record node positions $\mathrm{pos}[\cdot]$ along $P$ and the edge id used between successive nodes.
\item Compute $L(\cdot)$ and $R(\cdot)$ over the DAG: initialize $L(v)=R(v)=\mathrm{pos}(v)$ for $v\in P$, else $L=+\infty$, $R=-\infty$. Propagate $L$ forward in topological ($d_1$-ascending) order; propagate $R$ backward in reverse order.
\item Let $K=|P|-1$ be the number of edges on $P$. Build a segment tree on indices $[0,K-1]$ initialized to $+\infty$, supporting range operation “take min with $x$”.
\item For every original edge $(a,b,w)$, orient so that $d_1[a]\le d_1[b]$. Let $\ell=R(a)$ and $r=L(b)$. If both are defined and $\ell<r$, then this edge yields an alternative path that bypasses all $P$-edges with indices in $[\ell,r-1]$ at cost $\text{alt}=d_1[a]+w+d_n[b]$. Apply range-update $[\ell,r-1]\gets\min(\cdot,\text{alt})$.
\item After all updates, the leaf value at index $i$ is $A(\text{edge on }P\text{ at }i)$. For edges not on $P$, $A(e)=D$.
\item Answer each query $(t,x)$ by $\min\big(A(t), \min\{d_1(u_t)+x+d_n(v_t), d_1(v_t)+x+d_n(u_t)\}\big)$.
\end{algosteps}
\OPTIMALITY{Any replacement path that avoids a specific shortest-path edge can be decomposed into a DAG-prefix, one arbitrary edge, and a DAG-suffix, hence at most one non-DAG edge suffices. Covering all intervals $[\ell,r-1]$ collects the best detour for each path edge, proving tightness.}
\COMPLEXITY{Two Dijkstras and linear DAG passes; one segment-tree with $O(m\log n)$ updates.}
\[
\begin{aligned}
T(n) &= O\big((n+m)\log n\big) + O(m\log n) + O(q) \\
S(n) &= O(n+m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_all(), main()+guard + asserts
import sys, heapq, random

INF = 10**30

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); q = int(next(it))
    U=[0]*(m+1); V=[0]*(m+1); W=[0]*(m+1)
    adj=[[] for _ in range(n+1)]
    for i in range(1,m+1):
        u=int(next(it)); v=int(next(it)); w=int(next(it))
        U[i]=u; V[i]=v; W[i]=w
        adj[u].append((v,w,i)); adj[v].append((u,w,i))
    queries=[]
    for _ in range(q):
        t=int(next(it)); x=int(next(it))
        queries.append((t,x))
    return n,m,q,U,V,W,adj,queries

def dijkstra(n, adj, src):
    dist = [INF]*(n+1)
    dist[src]=0
    pq=[(0,src)]
    while pq:
        d,u = heapq.heappop(pq)
        if d!=dist[u]: continue
        for v,w,_ in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq,(nd,v))
    return dist

def build_shortest_dag(n, m, U, V, W, d1, dn, D):
    # For each original edge, determine directed arcs in shortest-path DAG.
    dag = [[] for _ in range(n+1)]
    rdag = [[] for _ in range(n+1)]
    on_dag = [False]*(m+1)
    for i in range(1,m+1):
        u,v,w = U[i],V[i],W[i]
        # mark if on some shortest path (undirected check)
        if d1[u] + w + dn[v] == D or d1[v] + w + dn[u] == D:
            on_dag[i] = True
        # orient arcs
        if d1[u] + w == d1[v] and d1[u] + w + dn[v] == D:
            dag[u].append((v,i))
            rdag[v].append((u,i))
        if d1[v] + w == d1[u] and d1[v] + w + dn[u] == D:
            dag[v].append((u,i))
            rdag[u].append((v,i))
    return dag, rdag, on_dag

def choose_path(n, dag, dn):
    # Greedily from 1 follow outgoing neighbor with minimal dn until reaching n.
    pos=[-1]*(n+1)
    path_nodes=[1]
    used_edge_ids=[]
    u=1
    idx=0
    pos[1]=0
    while u!=n:
        if not dag[u]:
            break  # should not happen if graph guarantees path
        # pick v minimizing dn[v]
        best_v=None; best_dn=INF; best_eid=None
        for v,eid in dag[u]:
            if dn[v] < best_dn:
                best_dn = dn[v]; best_v = v; best_eid = eid
        u = best_v
        idx += 1
        path_nodes.append(u)
        pos[u]=idx
        used_edge_ids.append(best_eid)
    return path_nodes, pos, used_edge_ids

class SegTreeMinAssign:
    # Range "min-assign": node.tag stores min applied to this segment.
    def __init__(self, n):
        self.n=n
        self.tag=[INF]*(4*max(1,n))
    def _upd(self, p, L, R, l, r, val):
        if r<L or R<l: return
        if l<=L and R<=r:
            if val < self.tag[p]:
                self.tag[p]=val
            return
        mid=(L+R)//2
        self._upd(p*2,L,mid,l,r,val)
        self._upd(p*2+1,mid+1,R,l,r,val)
    def update(self, l, r, val):
        if l>r or self.n==0: return
        self._upd(1,0,self.n-1,l,r,val)
    def _gather(self, p, L, R, carry, out):
        carry = min(carry, self.tag[p])
        if L==R:
            out[L]=carry
            return
        mid=(L+R)//2
        self._gather(p*2, L, mid, carry, out)
        self._gather(p*2+1, mid+1, R, carry, out)
    def gather(self):
        if self.n==0: return []
        out=[INF]*self.n
        self._gather(1,0,self.n-1,INF,out)
        return out

def solve_all(n,m,q,U,V,W,adj,queries):
    d1 = dijkstra(n, adj, 1)
    dn = dijkstra(n, adj, n)
    D = d1[n]
    dag, rdag, on_dag = build_shortest_dag(n,m,U,V,W,d1,dn,D)
    # Choose a specific shortest path P and map path edges to indices
    path_nodes, pos, used_edge_ids = choose_path(n, dag, dn)
    K = max(0, len(path_nodes)-1)
    path_edge_index = {}  # edge id -> index on path
    for i,eid in enumerate(used_edge_ids):
        path_edge_index[eid]=i
    # Compute topological order by sorting nodes by d1 (strictly increasing along dag arcs)
    order = list(range(1,n+1))
    order.sort(key=lambda x: d1[x])
    inv_order = order[::-1]
    INF_POS = 10**9
    L = [INF_POS]*(n+1)
    R = [-1]*(n+1)
    for v in path_nodes:
        L[v]=pos[v]; R[v]=pos[v]
    # propagate L forward
    for u in order:
        if L[u]==INF_POS: continue
        for v,_ in dag[u]:
            if L[v] > L[u]:
                L[v] = L[u]
    # propagate R backward
    for u in inv_order:
        for v,_ in dag[u]:
            if R[u] < R[v]:
                R[u] = R[v]
    # Segment tree over K path edges
    seg = SegTreeMinAssign(K)
    # For each original edge, compute interval cover and alternative cost
    for i in range(1,m+1):
        a,b,w = U[i],V[i],W[i]
        # orient by d1
        if d1[a] > d1[b]:
            a,b = b,a
        left = R[a]
        right = L[b]
        if left!=-1 and right!=INF_POS and left < right:
            alt = d1[a] + w + dn[b]
            seg.update(left, right-1, alt)
    best_without_on_path = seg.gather()  # size K
    # For any edge not on path, best path avoiding it is D
    A = [D]*(m+1)
    for eid, idx in path_edge_index.items():
        A[eid] = best_without_on_path[idx]
    # Answer queries
    out_lines=[]
    for t,x in queries:
        u,v,w = U[t],V[t],W[t]
        cand_use = min(d1[u] + x + dn[v], d1[v] + x + dn[u])
        ans = min(A[t], cand_use)
        out_lines.append(str(ans))
    return "\n".join(out_lines)

# --- Testing helpers (small, deterministic) ---
def brute_answer(n,m,U,V,W,adj,queries):
    def dijkstra_mod(mod_e=None, new_w=None):
        dist=[INF]*(n+1); dist[1]=0
        pq=[(0,1)]
        while pq:
            d,u = heapq.heappop(pq)
            if d!=dist[u]: continue
            if u==n: break
            for v,w,id_ in adj[u]:
                if mod_e is not None and id_==mod_e:
                    w = new_w
                nd=d+w
                if nd<dist[v]:
                    dist[v]=nd
                    heapq.heappush(pq,(nd,v))
        return dist[n]
    out=[]
    for t,x in queries:
        out.append(str(dijkstra_mod(t,x)))
    return "\n".join(out)

def self_check():
    # Random small graphs
    for seed in range(5):
        random.seed(1234+seed)
        n=6; m=10
        U=[0]*(m+1); V=[0]*(m+1); W=[0]*(m+1)
        adj=[[] for _ in range(n+1)]
        edges=set()
        eid=1
        while eid<=m:
            u=random.randint(1,n)
            v=random.randint(1,n)
            if u==v: continue
            if (u,v) in edges or (v,u) in edges: continue
            edges.add((u,v))
            w=random.randint(1,20)
            U[eid]=u; V[eid]=v; W[eid]=w
            adj[u].append((v,w,eid)); adj[v].append((u,w,eid))
            eid+=1
        # ensure connectivity by adding a simple chain if needed would complicate; retry if unreachable
        d = dijkstra(n, adj, 1)
        if d[n] >= INF: continue
        q=8
        queries=[]
        for _ in range(q):
            t=random.randint(1,m); x=random.randint(1,20)
            queries.append((t,x))
        out1 = solve_all(n,m,q,U,V,W,adj,queries)
        out2 = brute_answer(n,m,U,V,W,adj,queries)
        assert out1==out2, f"Mismatch:\n{out1}\nvs\n{out2}"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Run self-checks and a tiny sample
        self_check()
        sample = "3 3 3\n1 2 3\n2 3 3\n1 3 10\n3 1\n3 5\n1 1\n"
        n,m,q,U,V,W,adj,queries = read_input(sample)
        print(solve_all(n,m,q,U,V,W,adj,queries))
    else:
        n,m,q,U,V,W,adj,queries = read_input(data)
        print(solve_all(n,m,q,U,V,W,adj,queries))

if __name__=="__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts or I/O mini-tests are included:
- Self-check with random small graphs comparing to brute force.
- A tiny hand-crafted sample scenario in main when no input is provided.
- Internal assertions in self-check will raise on mismatch.}
\RESULT{For each query, output the minimal $1\to n$ fee after changing only edge $t$ to weight $x$: the minimum of using that edge with the new weight or avoiding it via the precomputed best detour.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use randomized small graphs to cross-check the optimal method against a brute-force Dijkstra per query. Include a tiny deterministic sample.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach C and a brute-force solver for the same inputs across multiple seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate small connected graphs with positive weights, random queries, and ensure reachability $1\to n$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_chain(n):
    # chain 1-2-...-n with weight 1
    m = n-1
    U=[0]*(m+1); V=[0]*(m+1); W=[0]*(m+1)
    adj=[[] for _ in range(n+1)]
    for i in range(1,n):
        U[i]=i; V[i]=i+1; W[i]=1
        adj[i].append((i+1,1,i)); adj[i+1].append((i,1,i))
    return n,m,U,V,W,adj
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# The "Code (Final Submission)" block in Section 6 is the reference solution.
# Copy that block as-is for submission; it meets the CF API contract.
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer per query is min(best path avoiding the changed edge, best path using it once with new weight).}
\WHY{This pattern appears in problems with single-edge perturbations over shortest paths. Precomputing replacement paths across a chosen shortest path enables $O(1)$ queries.}
\CHECKLIST{
- Run Dijkstra from source and target once.
- Build shortest-path DAG and pick a deterministic path $P$.
- Compute $L,R$ ranges by DAG DP.
- Apply range-min updates from all edges to cover $P$ segments.
- For each query, compute the two candidates and print the minimum.}
\EDGECASES{
- Multiple shortest paths exist: DAG handles this; interval covering finds equal-$D$ alternatives.
- Edge not on any shortest path: $A(e)=D$.
- Parallel edges or multi-edges: handled by per-edge processing.
- Large weights: use 64-bit (Python int is unbounded).
- Zero path edges $K=0$ cannot occur since $1\ne n$, but guard anyway.}
\PITFALLS{
- Forgetting to direct only edges satisfying both $d_1$ increment and total $D$ equality.
- Building $P$ without recording exact edge ids between its nodes.
- Off-by-one on interval $[\ell, r-1]$ when updating segment tree.
- Not initializing $L$/$R$ only for $P$ nodes before propagation.
- Using lazy-prop for “min-assign” incorrectly; prefer tag-only with gather pass.}
\FAILMODES{Brute-force per query times out. Partial solutions that only consider using the changed edge miss cases where avoiding the edge is necessary due to increases. The DAG + intervals approach survives all such cases.}
\ELI{We first learn distances from both ends. Then we pick one shortest route and find for each of its edges the cheapest way to detour around it using any other single road. With that in hand, updating one road is easy: either we use it with its new cost or we take the best detour that avoids it.}
\NotePages{3}

\end{document}