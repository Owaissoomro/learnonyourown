% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Words on Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1657/F}}
\LINE{DIFFICULTY / RATING}{2600}
\STATEMENT{You are given a tree consisting of $n$ vertices, and $q$ triples $(x_i, y_i, s_i)$, where $x_i$ and $y_i$ are integers from $1$ to $n$, and $s_i$ is a string with length equal to the number of vertices on the simple path from $x_i$ to $y_i$.

You want to write a lowercase Latin letter on each vertex in such a way that, for each of $q$ given triples, at least one of the following conditions holds:
\begin{bullets}
\item if you write out the letters on the vertices on the simple path from $x_i$ to $y_i$ in the order they appear on this path, you get the string $s_i$;
\item if you write out the letters on the vertices on the simple path from $y_i$ to $x_i$ in the order they appear on this path, you get the string $s_i$.
\end{bullets}
Find any possible way to write a letter on each vertex to meet these constraints, or report that it is impossible.

Input: The first line contains two integers $n$ and $q$ ($2 \le n \le 4 \cdot 10^5$; $1 \le q \le 4 \cdot 10^5$) — the number of vertices in the tree and the number of triples, respectively.

Then $n - 1$ lines follow; the $i$-th of them contains two integers $u_i$ and $v_i$ ($1 \le u_i, v_i \le n$; $1 \ne v_i$) — the endpoints of the $i$-th edge. These edges form a tree.

Then $q$ lines follow; the $j$-th of them contains two integers $x_j$ and $y_j$, and a string $s_j$ consisting of lowercase Latin letters. The length of $s_j$ is equal to the number of vertices on the simple path between $x_j$ and $y_j$.

Additional constraint on the input: $\sum \limits_{j=1}^{q} |s_j| \le 4 \cdot 10^5$.

Output: If there is no way to meet the conditions on all triples, print NO. Otherwise, print YES in the first line, and a string of $n$ lowercase Latin letters in the second line; the $i$-th character of the string should be the letter you write on the $i$-th vertex. If there are multiple answers, print any of them.}
\BREAKDOWN{Model each query path by pairing symmetric positions along the path. For each pair of endpoints on the path, their letters must be exactly the unordered pair of the endpoint letters of $s$ at symmetric positions. Reduce to constraints of the form: either both equal a fixed letter, or two vertices must take opposite letters from a 2-letter set. Then propagate forced letters and 2-color the remaining constraint graph.}
\ELI{Every symmetric pair of positions on each path must be filled with a multiset of two letters matching the ends of the query string, so vertices are either forced to a letter or must alternate between two letters; check consistency by propagation and bipartite coloring.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,q$ with $2 \le n \le 4 \cdot 10^5$, $1 \le q \le 4 \cdot 10^5$; tree edges $(u_i,v_i)$ forming a tree on $[1..n]$; queries $(x_j,y_j,s_j)$ with $\lvert s_j\rvert =$ number of vertices on the simple path from $x_j$ to $y_j$ and $\sum \lvert s_j\rvert \le 4 \cdot 10^5$.}
\OUTPUTS{If impossible, print NO. Otherwise, print YES and then a string of length $n$; the $i$-th character is the letter placed at vertex $i$.}
\SAMPLES{Example 1: $n=2$, edges $(1,2)$; $q=1$ with $(1,2,\texttt{ab})$. Valid outputs include YES with string \texttt{ab} or \texttt{ba}. Example 2: $n=3$, edges $(1,2),(2,3)$; $q=1$ with $(1,3,\texttt{aba})$. Output YES with string \texttt{aba}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a tree on $n$ vertices. Variables: for each $v \in V$ choose a letter $\ell(v) \in \Sigma$ where $\Sigma=\{a,\ldots,z\}$. For each query $(x,y,s)$, let the simple path be $P=(v_0=x,\ldots,v_{L-1}=y)$ and $s=s_0 s_1 \ldots s_{L-1}$. The constraint is: either $\ell(v_i)=s_i$ for all $i$, or $\ell(v_i)=s_{L-1-i}$ for all $i$. Equivalently, for all $i$, the unordered pair $\{\ell(v_i),\ell(v_{L-1-i})\}=\{s_i,s_{L-1-i}\}$.}
\varmapStart
\var{G}{input tree}
\var{(x,y,s)}{a query path and its string}
\var{\ell(v)}{letter assigned to vertex $v$}
\var{L}{path length, i.e., number of vertices on the path}
\var{S(v)}{domain of letters allowed at $v$ after filtering}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall \text{ queries }(x,y,s):\ \forall i\in[0,\lfloor\tfrac{L-1}{2}\rfloor],\ \{\ell(v_i),\ell(v_{L-1-i})\}=\{s_i,s_{L-1-i}\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Tree is connected and acyclic; paths are unique. All strings are lowercase Latin and lengths match path lengths.}
\INVARIANTS{Symmetric pair constraint: each symmetric pair on a path must match the multiset of endpoint letters of $s$ at those positions. Domain monotonicity: intersecting per-constraint letter sets only shrinks domains. If a node is forced to a letter, all neighbors connected by a pair constraint are forced to the complementary letter when the pair letters are distinct.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all orientations per query and check consistency by accumulating forced equalities per vertex. Exponential in $q$, only for tiny inputs.}
\ASSUMPTIONS{Use the fact $\sum \lvert s_j\rvert$ can be small in micro-tests; do not target full constraints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute path vertex sequences for all queries.
\item Backtrack over orientations of queries; maintain current letter assignment per vertex; prune on conflicts.
\item On success, output the assignment.
\end{algosteps}
\COMPLEXITY{Exponential in $q$ in the worst case; only for sanity checks.}
\[
\begin{aligned}
T(q) &= O(2^q \cdot \sum |s_j|) \\
S(q) &= O(n + q)
\end{aligned}
\]
\CORRECTNESS{Enumerates all combinations of forward/backward choices; if any is feasible, finds it; otherwise correctly reports NO.}
\EDGECASES{Odd-length paths with fixed center; repeated vertices across queries; conflicting forced letters.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        edges[u].append(v); edges[v].append(u)
    queries = []
    for _ in range(q):
        x = int(next(it)); y = int(next(it)); s = next(it)
        queries.append((x, y, s))
    return n, edges, queries

def build_parents(n: int, edges: List[List[int]]):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    # iterative DFS from 1
    st = [1]
    parent[1] = 1; depth[1] = 0
    order = []
    while st:
        u = st.pop()
        order.append(u)
        for v in edges[u]:
            if v == parent[u]:
                continue
            parent[v] = u
            depth[v] = depth[u] + 1
            st.append(v)
    up[0] = parent[:]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    def lca(a: int, b: int) -> int:
        if depth[a] < depth[b]:
            a, b = b, a
        da = depth[a] - depth[b]
        k = 0
        while da:
            if da & 1:
                a = up[k][a]
            da >>= 1; k += 1
        if a == b: return a
        for k in range(LOG-1, -1, -1):
            if up[k][a] != up[k][b]:
                a = up[k][a]; b = up[k][b]
        return up[0][a]
    def get_path(a: int, b: int) -> List[int]:
        w = lca(a, b)
        left = []
        while a != w:
            left.append(a)
            a = up[0][a]
        left.append(w)
        right = []
        while b != w:
            right.append(b)
            b = up[0][b]
        right.reverse()
        return left + right
    return get_path

def solve_all():
    n, edges, queries = read_input()
    if n == 0:
        return
    get_path = build_parents(n, edges)
    paths = []
    for (x, y, s) in queries:
        p = get_path(x, y)
        if len(p) != len(s):
            print("NO")
            return
        paths.append(p)
    # Backtracking
    assign = ['?'] * (n+1)
    q = len(queries)
    sys.setrecursionlimit(10000000)
    def dfs(i: int) -> bool:
        if i == q:
            return True
        x, y, s = queries[i]
        p = paths[i]
        # try forward
        saved = []
        ok = True
        for v, ch in zip(p, s):
            if assign[v] == '?' or assign[v] == ch:
                if assign[v] == '?':
                    assign[v] = ch; saved.append(v)
            else:
                ok = False; break
        if ok and dfs(i+1):
            return True
        # rollback
        for v in saved: assign[v] = '?'
        # try backward
        saved = []
        ok = True
        for v, ch in zip(p, reversed(s)):
            if assign[v] == '?' or assign[v] == ch:
                if assign[v] == '?':
                    assign[v] = ch; saved.append(v)
            else:
                ok = False; break
        if ok and dfs(i+1):
            return True
        for v in saved: assign[v] = '?'
        return False
    if dfs(0):
        print("YES")
        for i in range(1, n+1):
            if assign[i] == '?':
                assign[i] = 'a'
        print("".join(assign[1:]))
    else:
        print("NO")

def main():
    if sys.stdin.isatty():
        # tiny self-checks
        inp = "2 1\n1 2\n1 2 ab\n"
        print(run_io(inp).strip())
    else:
        solve_all()

def run_io(data: str) -> str:
    from io import StringIO
    backup_stdin = sys.stdin
    backup_stdout = sys.stdout
    sys.stdin = StringIO(data)
    sys.stdout = StringIO()
    try:
        solve_all()
        out = sys.stdout.getvalue()
    finally:
        sys.stdin = backup_stdin
        sys.stdout = backup_stdout
    return out

# Basic asserts for baseline on tiny cases
if __name__ == "__main__":
    # Case: 2 nodes, "ab"
    out = run_io("2 1\n1 2\n1 2 ab\n")
    assert out.splitlines()[0] == "YES"
    s = out.splitlines()[1].strip()
    assert len(s) == 2 and (s == "ab" or s == "ba")
    # Case: 3 nodes path "aba"
    out = run_io("3 1\n1 2\n2 3\n1 3 aba\n")
    assert out.splitlines()[0] == "YES"
    s = out.splitlines()[1].strip()
    assert s[0] == 'a' and s[2] == 'a' and s[1] == 'b'
    # Case: impossible triangle-like constraints
    data = "3 3\n1 2\n2 3\n1 2 ab\n2 3 ab\n1 3 abb\n"
    out = run_io(data)
    assert out.splitlines()[0] == "NO"
\end{minted}
\VALIDATION{Baseline validates a few tiny inputs with asserts; not suitable for $n,q$ up to $4\cdot 10^5$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Domain Filtering + Forced Propagation}
\WHICHFORMULA{Convert each symmetric pair $(v_i,v_{L-1-i})$ with letters $(a,b)$ into per-vertex domain intersections $S(v)\gets S(v)\cap\{a,b\}$. If $a=b$, immediately force both vertices to $a$. Then propagate forced assignments along constraints; contradictions detected early.}
\ASSUMPTIONS{Maintain a constraint graph whose edges are labeled by unordered letter-pairs; breadth-first propagate singletons.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build all paths explicitly; for each symmetric pair on a path, intersect domains and add a labeled edge $\{a,b\}$ if $a\ne b$; if $a=b$, force both endpoints to $a$.
\item Initialize a queue with all vertices forced to a single letter and propagate along edges: if $u$ is $a$ on edge $\{a,b\}$, force neighbor to $b$.
\item Detect contradictions if a forced letter conflicts with existing assignment or with an edge label.
\end{algosteps}
\COMPLEXITY{Linear in total path length for building, plus near-linear in number of pair constraints for propagation.}
\[
\begin{aligned}
T &\approx O\!\left(n + \sum |s_j|\right),\quad S \approx O(n + \sum |s_j|).
\end{aligned}
\]
\CORRECTNESS{Propagation enforces all implications from forced letters due to pair constraints $\{a,b\}$ and detects immediate conflicts. Residual ambiguity remains only on vertices with two-letter domains.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple, Deque
from collections import deque
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        edges[u].append(v); edges[v].append(u)
    queries = []
    for _ in range(q):
        x = int(next(it)); y = int(next(it)); s = next(it)
        queries.append((x, y, s))
    return n, edges, queries

def build_path_getter(n:int, g:List[List[int]]):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    parent[1] = 1; depth[1] = 0
    st = [1]
    while st:
        u = st.pop()
        for v in g[u]:
            if v == parent[u]: continue
            parent[v] = u; depth[v] = depth[u] + 1; st.append(v)
    up[0] = parent[:]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    def lca(a:int,b:int)->int:
        if depth[a] < depth[b]:
            a,b = b,a
        d = depth[a]-depth[b]; k=0
        while d:
            if d&1: a = up[k][a]
            d>>=1; k+=1
        if a==b: return a
        for k in range(LOG-1,-1,-1):
            if up[k][a] != up[k][b]:
                a = up[k][a]; b = up[k][b]
        return up[0][a]
    def get_path(a:int,b:int)->List[int]:
        w = lca(a,b)
        left = []
        while a != w:
            left.append(a); a = up[0][a]
        left.append(w)
        right = []
        while b != w:
            right.append(b); b = up[0][b]
        right.reverse()
        return left + right
    return get_path

def solve_all():
    n, g, queries = read_input()
    if n == 0:
        return
    get_path = build_path_getter(n, g)
    # domains: 26-bit mask
    FULL = (1<<26)-1
    dom = [FULL]*(n+1)
    assigned = [-1]*(n+1)
    # constraint edges: for each u -> list of (v, a, b) as indices 0..25
    adj = [[] for _ in range(n+1)]
    def bit(c:str)->int:
        return 1<<(ord(c)-97)
    def idx(c:str)->int:
        return ord(c)-97
    # Build constraints
    for (x,y,s) in queries:
        p = get_path(x,y)
        if len(p) != len(s):
            print("NO"); return
        L = len(p)
        for i in range((L+1)//2):
            j = L-1-i
            u = p[i]; v = p[j]
            a = s[i]; b = s[j]
            if i == j:
                dom[u] &= bit(a)
            else:
                if a == b:
                    dom[u] &= bit(a)
                    dom[v] &= bit(a)
                else:
                    mask = bit(a) | bit(b)
                    dom[u] &= mask
                    dom[v] &= mask
                    ai = idx(a); bi = idx(b)
                    adj[u].append((v, ai, bi))
                    adj[v].append((u, ai, bi))
    # Initialize queue with singletons
    qd: Deque[int] = deque()
    for v in range(1, n+1):
        if dom[v] == 0:
            print("NO"); return
        if dom[v] & (dom[v]-1) == 0:
            # single
            val = (dom[v].bit_length()-1)
            assigned[v] = val
            qd.append(v)
    # BFS propagate
    while qd:
        u = qd.popleft()
        lu = assigned[u]
        if lu == -1:
            continue
        if (dom[u] >> lu) & 1 == 0:
            print("NO"); return
        for (v, a, b) in adj[u]:
            if a == b:
                need = a
            else:
                if lu == a:
                    need = b
                elif lu == b:
                    need = a
                else:
                    print("NO"); return
            if ((dom[v] >> need) & 1) == 0:
                print("NO"); return
            if assigned[v] == -1:
                assigned[v] = need
                dom[v] = (1<<need)
                qd.append(v)
            elif assigned[v] != need:
                print("NO"); return
    # residual nodes: still unassigned
    # Build bipartite graph among dom-size-2 nodes with edges requiring inequality on same {a,b}
    # Map node -> two letters (lo, hi)
    two = {}
    for v in range(1, n+1):
        if assigned[v] == -1:
            if dom[v] == 0:
                print("NO"); return
            if dom[v] & (dom[v]-1) == 0:
                assigned[v] = (dom[v].bit_length()-1)
            else:
                # ensure exactly 2 bits or more (should be 2 if constrained; if FULL, leave for default)
                if dom[v] != ((dom[v] & -dom[v]) | (dom[v] ^ (dom[v] & -dom[v])) & -(dom[v] ^ (dom[v] & -dom[v]))):
                    # dom size not equal 2; if equals FULL, skip for now
                    if dom[v] == ((1<<26)-1):
                        continue
                    # If size > 2 but not FULL, impossible (overlap of multiple constraints would have reduced)
                    # However, safely fail to be conservative.
                    cnt = dom[v].bit_count()
                    if cnt > 2:
                        print("NO"); return
                bits = [i for i in range(26) if (dom[v]>>i)&1]
                if len(bits) == 2:
                    two[v] = (min(bits), max(bits))
                elif len(bits) == 1:
                    assigned[v] = bits[0]
                else:
                    # unconstrained node, will assign 'a' later
                    pass
    # build diff-edges
    gdiff = {}
    for u in range(1, n+1):
        for (v, a, b) in adj[u]:
            if u < v:
                if a == b:
                    # would have been propagated; ensure both are set to a, else handle later
                    continue
                setmask = (1<<a)|(1<<b)
                # both endpoints must have exactly this set to be in two-letter graph
                if u in two and v in two:
                    if setmask == ((1<<two[u][0])|(1<<two[u][1])) and setmask == ((1<<two[v][0])|(1<<two[v][1])):
                        gdiff.setdefault(u, []).append(v)
                        gdiff.setdefault(v, []).append(u)
                # else, constraints should already be satisfied or contradicted by propagation
    # color components
    color = {}
    for s in gdiff.keys():
        if s in color: continue
        color[s] = 0
        dq = deque([s])
        while dq:
            u = dq.popleft()
            for v in gdiff.get(u, []):
                if v in color:
                    if color[v] == color[u]:
                        print("NO"); return
                else:
                    color[v] = 1 - color[u]
                    dq.append(v)
    # assign 2-letter nodes according to color
    for v, pair in two.items():
        c0, c1 = pair
        if v in color:
            assigned[v] = c0 if color[v] == 0 else c1
        else:
            # isolated; choose lexicographically smaller for determinism
            assigned[v] = c0
    # any remaining unassigned are unconstrained; set to 'a'
    for v in range(1, n+1):
        if assigned[v] == -1:
            assigned[v] = 0  # 'a'
    # Output
    print("YES")
    out = "".join(chr(97 + assigned[i]) for i in range(1, n+1))
    print(out)

def main():
    if sys.stdin.isatty():
        # tiny asserts for improved method
        def run_io(data: str) -> str:
            from io import StringIO
            backup_stdin, backup_stdout = sys.stdin, sys.stdout
            sys.stdin = StringIO(data); sys.stdout = StringIO()
            try:
                solve_all()
                return sys.stdout.getvalue()
            finally:
                sys.stdin, sys.stdout = backup_stdin, backup_stdout
        # 2 nodes, "ab"
        out = run_io("2 1\n1 2\n1 2 ab\n")
        assert out.splitlines()[0] == "YES"
        s = out.splitlines()[1].strip()
        assert s in ("ab","ba")
        # 3 nodes, "aba"
        out = run_io("3 1\n1 2\n2 3\n1 3 aba\n")
        assert out.splitlines()[0] == "YES"
        s = out.splitlines()[1].strip()
        assert s[0] == 'a' and s[1] == 'b' and s[2] == 'a'
        # impossible case
        out = run_io("3 3\n1 2\n2 3\n1 2 ab\n2 3 ab\n1 3 abb\n")
        assert out.splitlines()[0] == "NO"
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks identical to baseline on tiny cases; propagation prunes aggressively and finds contradictions early.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Symmetric-Pair Reduction + Propagation + Bipartite Coloring}
\WHICHFORMULA{Key reduction: For each query path $P=(v_0,\ldots,v_{L-1})$ and string $s=s_0\ldots s_{L-1}$, the condition ``forward or backward equals $s$'' is equivalent to $\{\ell(v_i),\ell(v_{L-1-i})\}=\{s_i,s_{L-1-i}\}$ for all $i$. Thus every constraint is local to unordered symmetric pairs.}
\ASSUMPTIONS{Total path length over all queries is $O(4\cdot 10^5)$, so explicitly materializing paths and pairs is feasible. After domain filtering, remaining ambiguous vertices have exactly two letters, and edges between them require inequality, yielding a bipartite 2-coloring problem.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute LCA and extract every query path as a list of vertices in order. For each symmetric pair:
\begin{bullets}
\item If $a=b$, force both endpoints to $a$.
\item Else intersect both endpoints' domains with $\{a,b\}$ and add an undirected edge labeled by $\{a,b\}$.
\end{bullets}
\item Initialize a queue with all vertices forced to a single letter and propagate: on edge $\{a,b\}$, if one endpoint is $a$, force the other to $b$ (and vice versa). Detect contradictions.
\item Remaining ambiguous vertices all have domains of size 2. Build a graph over them, adding edges that require inequality (both endpoints must be different among the same two-letter set). Check bipartiteness and 2-color; map colors to the two letters.
\item Assign unconstrained vertices arbitrarily (e.g., 'a') and output.
\end{algosteps}
\OPTIMALITY{The reduction yields linear-time processing in the total input size: materializing paths is linear in $\sum |s_j|$, propagation visits each pair at most twice, and bipartite checking is linear in the number of remaining edges.}
\COMPLEXITY{Let $M=\sum |s_j|$.}
\[
\begin{aligned}
T(n,M) &= O(n + M) \\
S(n,M) &= O(n + M)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple, Deque
from collections import deque
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        edges[u].append(v); edges[v].append(u)
    queries = []
    for _ in range(q):
        x = int(next(it)); y = int(next(it)); s = next(it)
        queries.append((x, y, s))
    return n, edges, queries

def build_path_getter(n:int, g:List[List[int]]):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    parent[1] = 1; depth[1] = 0
    st = [1]
    while st:
        u = st.pop()
        for v in g[u]:
            if v == parent[u]: continue
            parent[v] = u; depth[v] = depth[u] + 1; st.append(v)
    up[0] = parent[:]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    def lca(a:int,b:int)->int:
        if depth[a] < depth[b]:
            a,b = b,a
        d = depth[a]-depth[b]; k=0
        while d:
            if d&1: a = up[k][a]
            d>>=1; k+=1
        if a==b: return a
        for k in range(LOG-1,-1,-1):
            if up[k][a] != up[k][b]:
                a = up[k][a]; b = up[k][b]
        return up[0][a]
    def get_path(a:int,b:int)->List[int]:
        w = lca(a,b)
        left = []
        while a != w:
            left.append(a); a = up[0][a]
        left.append(w)
        right = []
        while b != w:
            right.append(b); b = up[0][b]
        right.reverse()
        return left + right
    return get_path

def solve_all():
    n, g, queries = read_input()
    if n == 0:
        return
    get_path = build_path_getter(n, g)
    FULL = (1<<26)-1
    dom = [FULL]*(n+1)
    assigned = [-1]*(n+1)
    adj = [[] for _ in range(n+1)]  # edges u: list of (v,a,b)
    def bit(c:str)->int: return 1<<(ord(c)-97)
    def idx(c:str)->int: return ord(c)-97
    # Build constraints
    for (x,y,s) in queries:
        p = get_path(x,y)
        if len(p) != len(s):
            print("NO"); return
        L = len(p)
        for i in range((L+1)//2):
            j = L-1-i
            u = p[i]; v = p[j]
            a = s[i]; b = s[j]
            if i == j:
                dom[u] &= bit(a)
            else:
                if a == b:
                    dom[u] &= bit(a); dom[v] &= bit(a)
                else:
                    mask = bit(a)|bit(b)
                    dom[u] &= mask; dom[v] &= mask
                    ai, bi = idx(a), idx(b)
                    adj[u].append((v, ai, bi))
                    adj[v].append((u, ai, bi))
    # Early failure if any domain empty
    for v in range(1, n+1):
        if dom[v] == 0:
            print("NO"); return
    # Initialize queue with singletons
    qd: Deque[int] = deque()
    for v in range(1, n+1):
        if dom[v] & (dom[v]-1) == 0:  # singleton
            assigned[v] = dom[v].bit_length()-1
            qd.append(v)
    # Propagate
    while qd:
        u = qd.popleft()
        lu = assigned[u]
        if lu == -1: continue
        if ((dom[u]>>lu) & 1) == 0:
            print("NO"); return
        for (v, a, b) in adj[u]:
            if a == b:
                need = a
            else:
                if lu == a:
                    need = b
                elif lu == b:
                    need = a
                else:
                    print("NO"); return
            if ((dom[v]>>need) & 1) == 0:
                print("NO"); return
            if assigned[v] == -1:
                assigned[v] = need
                dom[v] = (1<<need)
                qd.append(v)
            elif assigned[v] != need:
                print("NO"); return
    # Prepare two-letter nodes
    two = {}
    for v in range(1, n+1):
        if assigned[v] == -1:
            cnt = dom[v].bit_count()
            if cnt == 0:
                print("NO"); return
            if cnt == 1:
                assigned[v] = dom[v].bit_length()-1
            elif dom[v] == FULL:
                # unconstrained; leave unassigned
                pass
            else:
                bits = [i for i in range(26) if (dom[v]>>i)&1]
                if len(bits) != 2:
                    print("NO"); return
                two[v] = (min(bits), max(bits))
    # Build inequality graph among two-letter nodes
    gdiff = {}
    for u in range(1, n+1):
        for (v, a, b) in adj[u]:
            if u < v and a != b:
                setmask = (1<<a)|(1<<b)
                if u in two and v in two:
                    if setmask == ((1<<two[u][0])|(1<<two[u][1])) and setmask == ((1<<two[v][0])|(1<<two[v][1])):
                        gdiff.setdefault(u, []).append(v)
                        gdiff.setdefault(v, []).append(u)
    # Bipartite coloring
    color = {}
    for s in gdiff.keys():
        if s in color: continue
        color[s] = 0
        dq = deque([s])
        while dq:
            u = dq.popleft()
            for v in gdiff.get(u, []):
                if v in color:
                    if color[v] == color[u]:
                        print("NO"); return
                else:
                    color[v] = 1 - color[u]
                    dq.append(v)
    # Assign remaining
    for v, pair in two.items():
        if assigned[v] != -1: continue
        c0, c1 = pair
        if v in color:
            assigned[v] = c0 if color[v] == 0 else c1
        else:
            assigned[v] = c0
    for v in range(1, n+1):
        if assigned[v] == -1:
            assigned[v] = 0  # 'a'
    print("YES")
    print("".join(chr(97 + assigned[i]) for i in range(1, n+1)))

def main():
    if sys.stdin.isatty():
        # Run deterministic asserts
        def run_io(data: str) -> str:
            from io import StringIO
            backup_stdin, backup_stdout = sys.stdin, sys.stdout
            sys.stdin = StringIO(data); sys.stdout = StringIO()
            try:
                solve_all()
                return sys.stdout.getvalue()
            finally:
                sys.stdin, sys.stdout = backup_stdin, backup_stdout
        # 1) Two nodes, "ab": either "ab" or "ba"
        out = run_io("2 1\n1 2\n1 2 ab\n")
        assert out.splitlines()[0] == "YES"
        s = out.splitlines()[1].strip()
        assert s in ("ab","ba")
        # 2) Three nodes, "aba": fixed
        out = run_io("3 1\n1 2\n2 3\n1 3 aba\n")
        assert out.splitlines()[0] == "YES"
        s = out.splitlines()[1].strip()
        assert s == "aba"
        # 3) Impossible constraints
        out = run_io("3 3\n1 2\n2 3\n1 2 ab\n2 3 ab\n1 3 abb\n")
        assert out.splitlines()[0] == "NO"
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: two feasible cases and one impossible case exercising contradiction detection and bipartite check.}
\RESULT{Either NO, or YES and a valid assignment of letters to vertices. When multiple answers exist, any valid one is acceptable; this method produces a deterministic choice on isolated two-letter components (lexicographically smaller letter for color 0) and 'a' for unconstrained vertices.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-level tests on tiny trees; property: for each query, the produced labeling matches $s$ either forward or backward along the path. Negative test with contradictory constraints that form an odd cycle in the inequality graph.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Final on micro cases; both should agree on feasibility and on a valid labeling (not necessarily identical strings).}
\LINE{EDGE-CASE GENERATOR}{Generate star, path, and random trees with micro $n$ and random queries whose total lengths are small; verify forward/backward condition by brute force for cross-checking.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_path_tree(n: int):
    edges = []
    for i in range(1, n):
        edges.append((i, i+1))
    return edges

def check_solution(n, edges, queries, lab):
    # Verify each query is satisfied forward or backward
    g = [[] for _ in range(n+1)]
    for u,v in edges:
        g[u].append(v); g[v].append(u)
    # Build parent for LCA-like path extraction (simple parent stepping here due to tiny n)
    from collections import deque
    parent = [0]*(n+1); depth = [0]*(n+1)
    def bfs(root=1):
        parent[root] = root; depth[root]=0
        q = deque([root])
        while q:
            u = q.popleft()
            for v in g[u]:
                if v == parent[u]: continue
                parent[v]=u; depth[v]=depth[u]+1; q.append(v)
    bfs(1)
    def path(a,b):
        pa=[]; pb=[]
        aa=a; bb=b
        while aa!=bb:
            if depth[aa]>=depth[bb]:
                pa.append(aa); aa = parent[aa]
            else:
                pb.append(bb); bb = parent[bb]
        pa.append(aa); pb.reverse()
        return pa+pb
    for (x,y,s) in queries:
        p = path(x,y)
        t1 = "".join(lab[v-1] for v in p)
        t2 = t1[::-1]
        if not (t1 == s or t2 == s):
            return False
    return True

def adversarial_odd_cycle():
    n = 3
    edges = [(1,2),(2,3)]
    queries = [(1,2,"ab"), (2,3,"ab"), (1,3,"abb")]
    return n, edges, queries
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List
from collections import deque
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    edges = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it))
        edges[u].append(v); edges[v].append(u)
    queries = []
    for _ in range(q):
        x = int(next(it)); y = int(next(it)); s = next(it)
        queries.append((x, y, s))
    return n, edges, queries

def build_path_getter(n:int, g:List[List[int]]):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    parent[1] = 1; depth[1] = 0
    st = [1]
    while st:
        u = st.pop()
        for v in g[u]:
            if v == parent[u]: continue
            parent[v] = u; depth[v] = depth[u] + 1; st.append(v)
    up[0] = parent[:]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    def lca(a:int,b:int)->int:
        if depth[a] < depth[b]:
            a,b = b,a
        d = depth[a]-depth[b]; k=0
        while d:
            if d&1: a = up[k][a]
            d>>=1; k+=1
        if a==b: return a
        for k in range(LOG-1,-1,-1):
            if up[k][a] != up[k][b]:
                a = up[k][a]; b = up[k][b]
        return up[0][a]
    def get_path(a:int,b:int)->List[int]:
        w = lca(a,b)
        left = []
        while a != w:
            left.append(a); a = up[0][a]
        left.append(w)
        right = []
        while b != w:
            right.append(b); b = up[0][b]
        right.reverse()
        return left + right
    return get_path

def solve_all():
    n, g, queries = read_input()
    if n == 0:
        return
    get_path = build_path_getter(n, g)
    FULL = (1<<26)-1
    dom = [FULL]*(n+1)
    assigned = [-1]*(n+1)
    adj = [[] for _ in range(n+1)]  # edges u: list of (v,a,b)
    def bit(c:str)->int: return 1<<(ord(c)-97)
    def idx(c:str)->int: return ord(c)-97
    # Build constraints
    for (x,y,s) in queries:
        p = get_path(x,y)
        if len(p) != len(s):
            print("NO"); return
        L = len(p)
        for i in range((L+1)//2):
            j = L-1-i
            u = p[i]; v = p[j]
            a = s[i]; b = s[j]
            if i == j:
                dom[u] &= bit(a)
            else:
                if a == b:
                    dom[u] &= bit(a); dom[v] &= bit(a)
                else:
                    mask = bit(a)|bit(b)
                    dom[u] &= mask; dom[v] &= mask
                    ai, bi = idx(a), idx(b)
                    adj[u].append((v, ai, bi))
                    adj[v].append((u, ai, bi))
    for v in range(1, n+1):
        if dom[v] == 0:
            print("NO"); return
    # Initialize queue with singletons
    qd = deque()
    for v in range(1, n+1):
        if dom[v] & (dom[v]-1) == 0:
            assigned[v] = dom[v].bit_length()-1
            qd.append(v)
    # Propagate
    while qd:
        u = qd.popleft()
        lu = assigned[u]
        if lu == -1: continue
        if ((dom[u]>>lu) & 1) == 0:
            print("NO"); return
        for (v, a, b) in adj[u]:
            if a == b:
                need = a
            else:
                if lu == a:
                    need = b
                elif lu == b:
                    need = a
                else:
                    print("NO"); return
            if ((dom[v]>>need) & 1) == 0:
                print("NO"); return
            if assigned[v] == -1:
                assigned[v] = need
                dom[v] = (1<<need)
                qd.append(v)
            elif assigned[v] != need:
                print("NO"); return
    # Two-letter nodes
    two = {}
    for v in range(1, n+1):
        if assigned[v] == -1:
            cnt = dom[v].bit_count()
            if cnt == 0:
                print("NO"); return
            if cnt == 1:
                assigned[v] = dom[v].bit_length()-1
            elif dom[v] == FULL:
                pass
            else:
                bits = [i for i in range(26) if (dom[v]>>i)&1]
                if len(bits) != 2:
                    print("NO"); return
                two[v] = (min(bits), max(bits))
    # Inequality graph
    gdiff = {}
    for u in range(1, n+1):
        for (v, a, b) in adj[u]:
            if u < v and a != b:
                setmask = (1<<a)|(1<<b)
                if u in two and v in two:
                    if setmask == ((1<<two[u][0])|(1<<two[u][1])) and setmask == ((1<<two[v][0])|(1<<two[v][1])):
                        gdiff.setdefault(u, []).append(v)
                        gdiff.setdefault(v, []).append(u)
    # Bipartite coloring
    color = {}
    for s in gdiff.keys():
        if s in color: continue
        color[s] = 0
        dq = deque([s])
        while dq:
            u = dq.popleft()
            for v in gdiff.get(u, []):
                if v in color:
                    if color[v] == color[u]:
                        print("NO"); return
                else:
                    color[v] = 1 - color[u]
                    dq.append(v)
    # Assign remaining
    for v, pair in two.items():
        if assigned[v] != -1: continue
        c0, c1 = pair
        if v in color:
            assigned[v] = c0 if color[v] == 0 else c1
        else:
            assigned[v] = c0
    for v in range(1, n+1):
        if assigned[v] == -1:
            assigned[v] = 0
    print("YES")
    print("".join(chr(97 + assigned[i]) for i in range(1, n+1)))

def main():
    if sys.stdin.isatty():
        # Exactly 3 asserts / mini-tests
        def run_io(data: str) -> str:
            from io import StringIO
            backup_stdin, backup_stdout = sys.stdin, sys.stdout
            sys.stdin = StringIO(data); sys.stdout = StringIO()
            try:
                solve_all()
                return sys.stdout.getvalue()
            finally:
                sys.stdin, sys.stdout = backup_stdin, backup_stdout
        out = run_io("2 1\n1 2\n1 2 ab\n")
        assert out.splitlines()[0] == "YES"
        s = out.splitlines()[1].strip()
        assert s in ("ab","ba")
        out = run_io("3 1\n1 2\n2 3\n1 3 aba\n")
        assert out.splitlines()[0] == "YES"
        assert out.splitlines()[1].strip() == "aba"
        out = run_io("3 3\n1 2\n2 3\n1 2 ab\n2 3 ab\n1 3 abb\n")
        assert out.splitlines()[0] == "NO"
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce each query to symmetric-pair constraints, propagate forced letters, and 2-color the remaining inequality graph.}
\WHY{This pattern of turning global path string constraints into local pairwise constraints appears in advanced string-on-graph problems; the symmetric-pair trick is the key insight.}
\CHECKLIST{
\begin{bullets}
\item Extract paths; pair symmetric positions.
\item Intersect domains; force centers and equal-letter pairs.
\item Propagate singletons along $\{a,b\}$ edges.
\item Build inequality graph on remaining two-letter vertices and 2-color.
\item Assign defaults for unconstrained vertices; output.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Odd-length paths: center is fixed to $s_{\lfloor L/2\rfloor}$.
\item Equal endpoints $a=b$: both vertices forced to $a$.
\item Repeated constraints on the same pair with different letter-sets: should contradict.
\item Vertices appearing in many queries: domains shrink to $0/1/2$ letters only.
\item Unconstrained vertices: assign arbitrary letter (e.g., 'a').
\item Disconnected inequality components: color each independently.
\item Duplicate pair constraints: harmless; do not change feasibility.
\item Paths of length $1$: trivial single-letter force.
\item Sum of lengths within limit: building all paths is safe.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to handle $a=b$ as equality (not inequality).
\item Not intersecting domains before propagation can cause missed contradictions.
\item Building the inequality graph with mismatched letter-sets leads to false positives.
\item Off-by-one when forming symmetric pairs.
\item Incorrect LCA/path construction causing length mismatch with $s$.
\item Not guarding domain $=0$ early leads to late crashes.
\item Multiple identical edges: ensure coloring tolerates duplicates.
\item Using recursion for DFS risks recursion limit; use iterative DFS.
\end{bullets}
}
\FAILMODES{Odd cycle in the inequality graph of two-letter nodes makes the instance impossible; the algorithm detects this via bipartite check. Conflicting forced letters detected during propagation.}
\ELI{Each symmetric pair along a path must contain the two endpoint letters from the string at those positions. This either fixes both vertices to the same letter or forces them to be different among two letters. Push all forced choices, then 2-color what is left. If a contradiction appears, answer is NO; otherwise, we can write out a valid labeling.}
\NotePages{3}

\end{document}