% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Display Table of Food Orders in a Restaurant}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given the array \texttt{orders}, which represents the orders that customers have done in a restaurant. More specifically, \texttt{orders[i] = [customerNamei, tableNumberi, foodItemi]} where \texttt{customerNamei} is the name of the customer, \texttt{tableNumberi} is the table the customer sits at, and \texttt{foodItemi} is the item the customer orders.

Return the restaurant's ``display table''. The ``display table'' is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is \texttt{"Table"}, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order of table number.

Examples:

1) Input: \texttt{orders = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]}
Output: \texttt{[["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]]}

2) Input: \texttt{orders = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],["Brianna","1","Canadian Waffles"]]}
Output: \texttt{[["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]]}

3) Input: \texttt{orders = [["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]}
Output: \texttt{[["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]}.

Constraints:
- $1 \le \texttt{orders.length} \le 5 \times 10^4$.
- $\texttt{orders[i].length} = 3$.
- $1 \le \texttt{customerNamei.length}, \texttt{foodItemi.length} \le 20$.
- \texttt{customerNamei} and \texttt{foodItemi} consist of lowercase and uppercase English letters and the space character.
- \texttt{tableNumberi} is a valid integer between $1$ and $500$.}
\BREAKDOWN{Collect the set of all food items; count per table the occurrences of each food; sort food names lexicographically and table numbers numerically; format result as strings with header.}
\ELI{Make a spreadsheet: columns are foods ordered alphabetically; rows are tables in increasing order; each cell shows how many times that table ordered that food.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single parameter \texttt{orders}: a list of lists of strings \texttt{[customerName, tableNumber, foodItem]}. Table numbers are given as strings representing positive integers. Valid ranges: $1 \le \lvert \texttt{orders} \rvert \le 5 \times 10^4$, table numbers in $[1,500]$, name and food lengths in $[1,20]$.}
\OUTPUTS{A list of lists of strings representing the display table. The first row is the header: \texttt{["Table"] + sorted(foodNames)}. Each subsequent row corresponds to a table in increasing numeric order: first the table number as a string, followed by counts for each food as strings.}
\SAMPLES{Example A:
Input: \texttt{[["A","2","Tea"],["B","2","Tea"],["C","1","Cake"]]}
Output: \texttt{[["Table","Cake","Tea"],["1","1","0"],["2","0","2"]]}.

Example B:
Input: \texttt{[["X","10","Soup"]]}
Output: \texttt{[["Table","Soup"],["10","1"]]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $O$ be the multiset of orders, where each order is a pair $(t,f)$ with table $t \in \mathbb{N}$ and food $f \in \mathcal{F}$. Let $T \subset \mathbb{N}$ be the set of tables present in $O$ and $\mathcal{F}$ the set of foods present in $O$. Define the count matrix $C \in \mathbb{N}_0^{\lvert T \rvert \times \lvert \mathcal{F} \rvert}$ with entries $C_{t,f}$ counting orders of food $f$ at table $t$.}
\varmapStart
\var{T}{set of tables present}
\var{\mathcal{F}}{set of food items present}
\var{C_{t,f}}{nonnegative integer count of orders of $f$ at table $t$}
\var{O}{multiset of orders $(t,f)$}
\var{h}{header row: \texttt{["Table"]} then foods in alphabetical order}
\var{R_t}{row for table $t$: table number then stringified counts per food}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
C_{t,f} = \left\lvert \left\{ (t',f') \in O \;:\; t'=t,\; f'=f \right\} \right\rvert
\end{BreakableEquation*}
}
\ASSUMPTIONS{Table numbers are positive integers but provided as strings in input/output. Foods are compared lexicographically using standard string order. Rows are sorted by numeric value of table number.}
\INVARIANTS{
- For any $t$, $\sum_{f \in \mathcal{F}} C_{t,f}$ equals the total number of orders placed by table $t$.
- For any $f$, $\sum_{t \in T} C_{t,f}$ equals the total number of orders of food $f$ across all tables.
- $C_{t,f} \ge 0$ for all $t,f$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $C_{t,f}$ via repeated scans: for each table and each food, count by iterating all orders.}
\ASSUMPTIONS{We can materialize sorted unique tables and foods; counts are recomputed by scanning the full \texttt{orders} each time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract sorted list of unique foods (lexicographic) and unique tables (numeric).
\item For each table $t$ and each food $f$, compute $C_{t,f}$ as the number of matching orders by scanning all \texttt{orders}.
\item Build the header and rows, converting counts to strings.
\end{algosteps}
\COMPLEXITY{Let $N=\lvert \texttt{orders} \rvert$, $F=\lvert \mathcal{F} \rvert$, $T=\lvert T \rvert$. Time is $O(N + T\log T + F\log F + TFN)$ due to recomputation; space is $O(F+T)$ for the collected uniques and output, excluding output storage itself.}
\[
\begin{aligned}
T(N,F,T) &= O\big(N\big) + O\big(T\log T + F\log F\big) + \sum_{t\in T}\sum_{f\in \mathcal{F}} O(N) \\
&= O\big(N + T\log T + F\log F + TFN\big).
\end{aligned}
\]
\CORRECTNESS{Every order contributes to exactly one pair $(t,f)$, and the brute-force counts consider all orders for each pair, hence produce correct counts. Sorting ensures required ordering of columns and rows.}
\EDGECASES{Single order; multiple foods with spaces; multiple tables with same food; no duplication; large table numbers as strings; ensure numeric sort for tables, lexicographic for foods.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        # Collect unique foods and tables
        foods_set = set()
        tables_set = set()
        for _, t, f in orders:
            foods_set.add(f)
            tables_set.add(int(t))
        foods = sorted(foods_set)
        tables = sorted(tables_set)
        # Header
        result: List[List[str]] = []
        header = ["Table"] + foods
        result.append(header)
        # Brute-force counting: for each (table, food), scan all orders
        for t in tables:
            row = [str(t)]
            for food in foods:
                cnt = 0
                for _, tt, ff in orders:
                    if int(tt) == t and ff == food:
                        cnt += 1
                row.append(str(cnt))
            result.append(row)
        return result

# --- asserts (examples) ---
sol = Solution()
orders1 = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
exp1 = [["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]]
assert sol.displayTable(orders1) == exp1

orders2 = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],["Brianna","1","Canadian Waffles"]]
exp2 = [["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]]
assert sol.displayTable(orders2) == exp2

orders3 = [["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]
exp3 = [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
assert sol.displayTable(orders3) == exp3
\end{minted}
\VALIDATION{The asserts cover distinct foods, multiple counts per table, and numeric sorting of table numbers.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single-Pass Aggregation with Counter}
\WHICHFORMULA{Aggregate counts in a dictionary-of-counters in one pass, then format output once with sorted keys.}
\ASSUMPTIONS{Use \texttt{defaultdict(Counter)} or nested dict; ensure conversion of table numbers to integers for sorting but keep strings in output.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate orders once, collecting the food universe and updating per-table food counts.
\item Sort foods lexicographically and tables numerically.
\item Build the header and transform counts to strings in the prescribed order.
\end{algosteps}
\COMPLEXITY{One pass aggregation yields $O(N)$ counting plus $O(F\log F + T\log T)$ sorting and $O(TF)$ output formatting. This improves on the brute-force $O(TFN)$.}
\[
\begin{aligned}
T(N,F,T) &= O\big(N + F\log F + T\log T + TF\big).
\end{aligned}
\]
\CORRECTNESS{Each order increments exactly one cell $(t,f)$. Sorting and fixed iteration orders produce the required output ordering.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict
from collections import defaultdict, Counter

class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        foods_set = set()
        table_counts: Dict[int, Counter] = defaultdict(Counter)
        for _, t_str, food in orders:
            t = int(t_str)
            foods_set.add(food)
            table_counts[t][food] += 1
        foods = sorted(foods_set)
        tables = sorted(table_counts.keys())
        res: List[List[str]] = []
        res.append(["Table"] + foods)
        for t in tables:
            row = [str(t)]
            cnts = table_counts[t]
            for food in foods:
                row.append(str(cnts.get(food, 0)))
            res.append(row)
        return res

# --- asserts (examples) ---
sol = Solution()
orders1 = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
exp1 = [["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]]
assert sol.displayTable(orders1) == exp1

orders2 = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],["Brianna","1","Canadian Waffles"]]
exp2 = [["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]]
assert sol.displayTable(orders2) == exp2

orders3 = [["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]
exp3 = [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
assert sol.displayTable(orders3) == exp3
\end{minted}
\VALIDATION{Covers multi-count increments, lexicographic food ordering, numeric table ordering.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Index Mapping to Dense Arrays}
\WHICHFORMULA{Map foods to contiguous indices after sorting, and store per-table counts in fixed-size arrays for fast updates and output.}
\ASSUMPTIONS{Foods and tables are enumerable from data; using arrays reduces Python dict overhead in the innermost loop.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item First pass: collect foods and tables.
\item Sort foods and tables; build \texttt{food\_to\_idx} map of food name to column index.
\item Allocate a map from table number to a list of zeros of length $F$.
\item Second pass: for each order, increment the appropriate array cell using the food index.
\item Build header and rows by reading off arrays; stringify counts.
\end{algosteps}
\OPTIMALITY{Given arbitrary input order, sorting foods and tables is necessary to meet output ordering; the remaining work is a single linear pass plus $O(TF)$ output. This is optimal up to lower-order factors.}
\COMPLEXITY{Time $O(N + F\log F + T\log T + TF)$; space $O(F + T + TF)$ for the dense table of counts and name maps.}
\[
\begin{aligned}
T(N,F,T) &= O(N) + O(F\log F + T\log T) + O(TF).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        # Collect universes
        foods_set = set()
        tables_set = set()
        for _, t_str, food in orders:
            foods_set.add(food)
            tables_set.add(int(t_str))
        foods = sorted(foods_set)
        tables = sorted(tables_set)
        # Map food to index
        food_to_idx: Dict[str, int] = {f: i for i, f in enumerate(foods)}
        F = len(foods)
        # Allocate arrays per table
        table_counts: Dict[int, List[int]] = {t: [0] * F for t in tables}
        # Fill counts
        for _, t_str, food in orders:
            t = int(t_str)
            j = food_to_idx[food]
            table_counts[t][j] += 1
        # Build result
        res: List[List[str]] = []
        res.append(["Table"] + foods)
        for t in tables:
            row = [str(t)] + [str(c) for c in table_counts[t]]
            res.append(row)
        return res

# --- Exactly 3 asserts (I/O mini-tests) ---
sol = Solution()
assert sol.displayTable([["X","10","Soup"]]) == [["Table","Soup"],["10","1"]]
assert sol.displayTable([["A","2","Tea"],["B","2","Tea"],["C","1","Cake"]]) == [["Table","Cake","Tea"],["1","1","0"],["2","0","2"]]
assert sol.displayTable([["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]) == [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
\end{minted}
\VALIDATION{The three asserts exercise singleton input, multiple orders on same table/food, and multiple foods at one table.}
\RESULT{A list-of-lists of strings forming the display table; header is \texttt{["Table"] + foods} with foods in alphabetical order; data rows are for tables in increasing numeric order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate with the three official-style samples; fuzz small random cases to ensure consistency and invariants: column sums equal total per food; row sums equal total per table; compare against a simple baseline implementation.}
\LINE{CROSS-CHECKS}{For random small inputs, compare outputs produced by Approach B and Approach C; they must match exactly. Also verify that the header matches the sorted unique foods.}
\LINE{EDGE-CASE GENERATOR}{Generate tables in non-sorted order, foods with spaces, repeated names, and multiple identical orders; ensure strings are preserved and numeric sorting is applied to tables.}
\begin{minted}{python}
from typing import List, Dict, Tuple
import random

def gen_orders(n: int, seed: int = 7) -> List[List[str]]:
    random.seed(seed)
    foods = ["A", "B", "C", "D E", "Fried Chicken", "Soda"]
    tables = [str(t) for t in range(1, 8)]
    names = ["Ann", "Bob", "Cara", "Dan", "Eve"]
    res: List[List[str]] = []
    for _ in range(n):
        res.append([random.choice(names), random.choice(tables), random.choice(foods)])
    return res

class Baseline:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        foods_set = set()
        tables_set = set()
        for _, t, f in orders:
            foods_set.add(f)
            tables_set.add(int(t))
        foods = sorted(foods_set)
        tables = sorted(tables_set)
        out: List[List[str]] = [["Table"] + foods]
        for t in tables:
            row = [str(t)]
            for food in foods:
                cnt = sum(1 for _, tt, ff in orders if int(tt) == t and ff == food)
                row.append(str(cnt))
            out.append(row)
        return out

class Reference:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        foods_set = set()
        tables_set = set()
        for _, t_str, food in orders:
            foods_set.add(food)
            tables_set.add(int(t_str))
        foods = sorted(foods_set)
        tables = sorted(tables_set)
        idx = {f: i for i, f in enumerate(foods)}
        F = len(foods)
        counts: Dict[int, List[int]] = {t: [0]*F for t in tables}
        for _, t_str, food in orders:
            counts[int(t_str)][idx[food]] += 1
        res: List[List[str]] = [["Table"] + foods]
        for t in tables:
            res.append([str(t)] + [str(c) for c in counts[t]])
        return res

# Cross-check on random small instances
base = Baseline()
ref = Reference()
for n in range(0, 30):
    orders = gen_orders(n, seed=11 + n)
    assert base.displayTable(orders) == ref.displayTable(orders)

# Edge: same table, multiple foods with spaces
orders_edge = [["X","12","Fried Chicken"],["Y","12","D E"],["Z","12","D E"]]
exp_edge = [["Table","D E","Fried Chicken"],["12","2","1"]]
assert ref.displayTable(orders_edge) == exp_edge
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        foods_set = set()
        tables_set = set()
        for _, t_str, food in orders:
            foods_set.add(food)
            tables_set.add(int(t_str))
        foods = sorted(foods_set)
        tables = sorted(tables_set)
        food_to_idx: Dict[str, int] = {f: i for i, f in enumerate(foods)}
        counts: Dict[int, List[int]] = {t: [0]*len(foods) for t in tables}
        for _, t_str, food in orders:
            counts[int(t_str)][food_to_idx[food]] += 1
        result: List[List[str]] = [["Table"] + foods]
        for t in tables:
            result.append([str(t)] + [str(x) for x in counts[t]])
        return result

# Minimal sanity tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.displayTable([["X","10","Soup"]]) == [["Table","Soup"],["10","1"]]
    assert sol.displayTable([["A","2","Tea"],["B","2","Tea"],["C","1","Cake"]]) == [["Table","Cake","Tea"],["1","1","0"],["2","0","2"]]
    assert sol.displayTable([["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]) == [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Aggregate per-table counts of foods, sort foods lexicographically and tables numerically, and format as strings.}
\WHY{Tests alphabetical vs numeric ordering, map-of-maps aggregation, and careful formatting, all common in interviews.}
\CHECKLIST{
- Gather unique foods and tables.
- Sort foods lexicographically; sort tables numerically.
- Count orders per $(\text{table}, \text{food})$.
- Build header and stringify counts.
- Validate with sample cases.}
\EDGECASES{
- Single order; single table.
- Multiple identical orders for same table and food.
- Food names containing spaces.
- Non-consecutive table numbers.
- Large table number strings requiring numeric sort.
- No overlapping foods across tables.}
\PITFALLS{
- Sorting table numbers lexicographically as strings instead of numerically.
- Forgetting to convert counts to strings in output.
- Missing a food column if it appears only once or at a single table.
- Building header out of order relative to columns used for counts.
- Mutating shared lists when constructing rows.
- Using an unordered iteration over dict keys without sorting.}
\FAILMODES{Brute-force approaches can be too slow if implemented as triple loops with repeated scans; using dict aggregation avoids $TFN$ behavior. Sorting by string for tables yields wrong order (e.g., "10" before "2"); ensure numeric sort.}
\ELI{Make a list of all foods, sort them; make a list of all tables, sort by number; count how many times each table ordered each food; write it all down as strings.}
\NotePages{3}

\end{document}